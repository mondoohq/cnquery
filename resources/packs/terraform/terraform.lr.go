// Code generated by resources. DO NOT EDIT.
package terraform

import (
	"errors"
	"fmt"
	"time"

	"go.mondoo.com/cnquery/resources"
	"github.com/rs/zerolog/log"
)

// Init all resources into the registry
func Init(registry *resources.Registry) {
	registry.AddFactory("terraform", newTerraform)
	registry.AddFactory("terraform.file", newTerraformFile)
	registry.AddFactory("terraform.fileposition", newTerraformFileposition)
	registry.AddFactory("terraform.block", newTerraformBlock)
	registry.AddFactory("terraform.module", newTerraformModule)
	registry.AddFactory("terraform.settings", newTerraformSettings)
	registry.AddFactory("terraform.state", newTerraformState)
	registry.AddFactory("terraform.state.output", newTerraformStateOutput)
	registry.AddFactory("terraform.state.module", newTerraformStateModule)
	registry.AddFactory("terraform.state.resource", newTerraformStateResource)
	registry.AddFactory("terraform.plan", newTerraformPlan)
	registry.AddFactory("terraform.plan.resourceChange", newTerraformPlanResourceChange)
	registry.AddFactory("terraform.plan.proposedChange", newTerraformPlanProposedChange)
}

// Terraform resource interface
type Terraform interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Files() ([]interface{}, error)
	Tfvars() (interface{}, error)
	Modules() ([]interface{}, error)
	Blocks() ([]interface{}, error)
	Providers() ([]interface{}, error)
	Datasources() ([]interface{}, error)
	Resources() ([]interface{}, error)
	Variables() ([]interface{}, error)
	Outputs() ([]interface{}, error)
}

// mqlTerraform for the terraform resource
type mqlTerraform struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraform) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform resource
func newTerraform(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraform{runtime.NewResource("terraform")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "tfvars":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"tfvars\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "modules":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"modules\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "blocks":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"blocks\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "providers":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"providers\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "datasources":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"datasources\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "resources":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"resources\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "variables":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"variables\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "outputs":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"outputs\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraform) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraform) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform].Register")
	switch name {
	case "files":
		return nil
	case "tfvars":
		return nil
	case "modules":
		return nil
	case "blocks":
		return nil
	case "providers":
		return nil
	case "datasources":
		return nil
	case "resources":
		return nil
	case "variables":
		return nil
	case "outputs":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraform) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform].Field")
	switch name {
	case "files":
		return s.Files()
	case "tfvars":
		return s.Tfvars()
	case "modules":
		return s.Modules()
	case "blocks":
		return s.Blocks()
	case "providers":
		return s.Providers()
	case "datasources":
		return s.Datasources()
	case "resources":
		return s.Resources()
	case "variables":
		return s.Variables()
	case "outputs":
		return s.Outputs()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform\" resource")
	}
}

// Files accessor autogenerated
func (s *mqlTerraform) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Tfvars accessor autogenerated
func (s *mqlTerraform) Tfvars() (interface{}, error) {
	res, ok := s.Cache.Load("tfvars")
	if !ok || !res.Valid {
		if err := s.ComputeTfvars(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("tfvars")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"tfvars\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "tfvars")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"tfvars\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Modules accessor autogenerated
func (s *mqlTerraform) Modules() ([]interface{}, error) {
	res, ok := s.Cache.Load("modules")
	if !ok || !res.Valid {
		if err := s.ComputeModules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("modules")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"modules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "modules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"modules\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Blocks accessor autogenerated
func (s *mqlTerraform) Blocks() ([]interface{}, error) {
	res, ok := s.Cache.Load("blocks")
	if !ok || !res.Valid {
		if err := s.ComputeBlocks(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("blocks")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"blocks\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "blocks")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"blocks\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Providers accessor autogenerated
func (s *mqlTerraform) Providers() ([]interface{}, error) {
	res, ok := s.Cache.Load("providers")
	if !ok || !res.Valid {
		if err := s.ComputeProviders(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("providers")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"providers\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "providers")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"providers\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Datasources accessor autogenerated
func (s *mqlTerraform) Datasources() ([]interface{}, error) {
	res, ok := s.Cache.Load("datasources")
	if !ok || !res.Valid {
		if err := s.ComputeDatasources(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("datasources")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"datasources\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "datasources")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"datasources\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Resources accessor autogenerated
func (s *mqlTerraform) Resources() ([]interface{}, error) {
	res, ok := s.Cache.Load("resources")
	if !ok || !res.Valid {
		if err := s.ComputeResources(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("resources")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"resources\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "resources")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"resources\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Variables accessor autogenerated
func (s *mqlTerraform) Variables() ([]interface{}, error) {
	res, ok := s.Cache.Load("variables")
	if !ok || !res.Valid {
		if err := s.ComputeVariables(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("variables")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"variables\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "variables")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"variables\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Outputs accessor autogenerated
func (s *mqlTerraform) Outputs() ([]interface{}, error) {
	res, ok := s.Cache.Load("outputs")
	if !ok || !res.Valid {
		if err := s.ComputeOutputs(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("outputs")
		if !ok {
			return nil, errors.New("\"terraform\" calculated \"outputs\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "outputs")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform\" failed to cast field \"outputs\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraform) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform].Compute")
	switch name {
	case "files":
		return s.ComputeFiles()
	case "tfvars":
		return s.ComputeTfvars()
	case "modules":
		return s.ComputeModules()
	case "blocks":
		return s.ComputeBlocks()
	case "providers":
		return s.ComputeProviders()
	case "datasources":
		return s.ComputeDatasources()
	case "resources":
		return s.ComputeResources()
	case "variables":
		return s.ComputeVariables()
	case "outputs":
		return s.ComputeOutputs()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform\" resource")
	}
}

// ComputeFiles computer autogenerated
func (s *mqlTerraform) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeTfvars computer autogenerated
func (s *mqlTerraform) ComputeTfvars() error {
	var err error
	if _, ok := s.Cache.Load("tfvars"); ok {
		return nil
	}
	vres, err := s.GetTfvars()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("tfvars", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeModules computer autogenerated
func (s *mqlTerraform) ComputeModules() error {
	var err error
	if _, ok := s.Cache.Load("modules"); ok {
		return nil
	}
	vres, err := s.GetModules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("modules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeBlocks computer autogenerated
func (s *mqlTerraform) ComputeBlocks() error {
	var err error
	if _, ok := s.Cache.Load("blocks"); ok {
		return nil
	}
	vres, err := s.GetBlocks()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("blocks", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeProviders computer autogenerated
func (s *mqlTerraform) ComputeProviders() error {
	var err error
	if _, ok := s.Cache.Load("providers"); ok {
		return nil
	}
	vres, err := s.GetProviders()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("providers", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDatasources computer autogenerated
func (s *mqlTerraform) ComputeDatasources() error {
	var err error
	if _, ok := s.Cache.Load("datasources"); ok {
		return nil
	}
	vres, err := s.GetDatasources()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("datasources", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeResources computer autogenerated
func (s *mqlTerraform) ComputeResources() error {
	var err error
	if _, ok := s.Cache.Load("resources"); ok {
		return nil
	}
	vres, err := s.GetResources()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("resources", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVariables computer autogenerated
func (s *mqlTerraform) ComputeVariables() error {
	var err error
	if _, ok := s.Cache.Load("variables"); ok {
		return nil
	}
	vres, err := s.GetVariables()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("variables", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOutputs computer autogenerated
func (s *mqlTerraform) ComputeOutputs() error {
	var err error
	if _, ok := s.Cache.Load("outputs"); ok {
		return nil
	}
	vres, err := s.GetOutputs()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("outputs", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformFile resource interface
type TerraformFile interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Blocks() ([]interface{}, error)
}

// mqlTerraformFile for the terraform.file resource
type mqlTerraformFile struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformFile) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.file resource
func newTerraformFile(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformFile{runtime.NewResource("terraform.file")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.file\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "blocks":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.file\", its \"blocks\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.file\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.file with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformFile) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"terraform.file\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformFile) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.file].Register")
	switch name {
	case "path":
		return nil
	case "blocks":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.file\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformFile) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.file].Field")
	switch name {
	case "path":
		return s.Path()
	case "blocks":
		return s.Blocks()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.file\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlTerraformFile) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.file\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.file\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Blocks accessor autogenerated
func (s *mqlTerraformFile) Blocks() ([]interface{}, error) {
	res, ok := s.Cache.Load("blocks")
	if !ok || !res.Valid {
		if err := s.ComputeBlocks(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("blocks")
		if !ok {
			return nil, errors.New("\"terraform.file\" calculated \"blocks\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "blocks")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.file\" failed to cast field \"blocks\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformFile) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.file].Compute")
	switch name {
	case "path":
		return nil
	case "blocks":
		return s.ComputeBlocks()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.file\" resource")
	}
}

// ComputeBlocks computer autogenerated
func (s *mqlTerraformFile) ComputeBlocks() error {
	var err error
	if _, ok := s.Cache.Load("blocks"); ok {
		return nil
	}
	vres, err := s.GetBlocks()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("blocks", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformFileposition resource interface
type TerraformFileposition interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Line() (int64, error)
	Column() (int64, error)
	Byte() (int64, error)
}

// mqlTerraformFileposition for the terraform.fileposition resource
type mqlTerraformFileposition struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformFileposition) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.fileposition resource
func newTerraformFileposition(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformFileposition{runtime.NewResource("terraform.fileposition")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.fileposition\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "line":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"terraform.fileposition\", its \"line\" argument has the wrong type (expected type \"int64\")")
			}
		case "column":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"terraform.fileposition\", its \"column\" argument has the wrong type (expected type \"int64\")")
			}
		case "byte":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"terraform.fileposition\", its \"byte\" argument has the wrong type (expected type \"int64\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.fileposition\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.fileposition with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformFileposition) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"terraform.fileposition\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("line"); !ok {
		return errors.New("Initialized \"terraform.fileposition\" resource without a \"line\". This field is required.")
	}
	if _, ok := s.Cache.Load("column"); !ok {
		return errors.New("Initialized \"terraform.fileposition\" resource without a \"column\". This field is required.")
	}
	if _, ok := s.Cache.Load("byte"); !ok {
		return errors.New("Initialized \"terraform.fileposition\" resource without a \"byte\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformFileposition) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.fileposition].Register")
	switch name {
	case "path":
		return nil
	case "line":
		return nil
	case "column":
		return nil
	case "byte":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.fileposition\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformFileposition) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.fileposition].Field")
	switch name {
	case "path":
		return s.Path()
	case "line":
		return s.Line()
	case "column":
		return s.Column()
	case "byte":
		return s.Byte()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.fileposition\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlTerraformFileposition) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.fileposition\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.fileposition\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Line accessor autogenerated
func (s *mqlTerraformFileposition) Line() (int64, error) {
	res, ok := s.Cache.Load("line")
	if !ok || !res.Valid {
		return 0, errors.New("\"terraform.fileposition\" failed: no value provided for static field \"line\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"terraform.fileposition\" failed to cast field \"line\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Column accessor autogenerated
func (s *mqlTerraformFileposition) Column() (int64, error) {
	res, ok := s.Cache.Load("column")
	if !ok || !res.Valid {
		return 0, errors.New("\"terraform.fileposition\" failed: no value provided for static field \"column\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"terraform.fileposition\" failed to cast field \"column\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Byte accessor autogenerated
func (s *mqlTerraformFileposition) Byte() (int64, error) {
	res, ok := s.Cache.Load("byte")
	if !ok || !res.Valid {
		return 0, errors.New("\"terraform.fileposition\" failed: no value provided for static field \"byte\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"terraform.fileposition\" failed to cast field \"byte\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformFileposition) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.fileposition].Compute")
	switch name {
	case "path":
		return nil
	case "line":
		return nil
	case "column":
		return nil
	case "byte":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.fileposition\" resource")
	}
}

// TerraformBlock resource interface
type TerraformBlock interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Type() (string, error)
	NameLabel() (string, error)
	Labels() ([]interface{}, error)
	Start() (TerraformFileposition, error)
	End() (TerraformFileposition, error)
	Arguments() (interface{}, error)
	Attributes() (interface{}, error)
	Blocks() ([]interface{}, error)
	Snippet() (string, error)
}

// mqlTerraformBlock for the terraform.block resource
type mqlTerraformBlock struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformBlock) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.block resource
func newTerraformBlock(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformBlock{runtime.NewResource("terraform.block")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "nameLabel":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"nameLabel\" argument has the wrong type (expected type \"string\")")
			}
		case "labels":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"labels\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "start":
			if _, ok := val.(TerraformFileposition); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"start\" argument has the wrong type (expected type \"TerraformFileposition\")")
			}
		case "end":
			if _, ok := val.(TerraformFileposition); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"end\" argument has the wrong type (expected type \"TerraformFileposition\")")
			}
		case "arguments":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"arguments\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "attributes":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"attributes\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "blocks":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"blocks\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "snippet":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"snippet\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.block\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.block with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformBlock) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"terraform.block\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"terraform.block\" resource without a \"labels\". This field is required.")
	}
	if _, ok := s.Cache.Load("start"); !ok {
		return errors.New("Initialized \"terraform.block\" resource without a \"start\". This field is required.")
	}
	if _, ok := s.Cache.Load("end"); !ok {
		return errors.New("Initialized \"terraform.block\" resource without a \"end\". This field is required.")
	}
	if _, ok := s.Cache.Load("snippet"); !ok {
		return errors.New("Initialized \"terraform.block\" resource without a \"snippet\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformBlock) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.block].Register")
	switch name {
	case "type":
		return nil
	case "nameLabel":
		return nil
	case "labels":
		return nil
	case "start":
		return nil
	case "end":
		return nil
	case "arguments":
		return nil
	case "attributes":
		return nil
	case "blocks":
		return nil
	case "snippet":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.block\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformBlock) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.block].Field")
	switch name {
	case "type":
		return s.Type()
	case "nameLabel":
		return s.NameLabel()
	case "labels":
		return s.Labels()
	case "start":
		return s.Start()
	case "end":
		return s.End()
	case "arguments":
		return s.Arguments()
	case "attributes":
		return s.Attributes()
	case "blocks":
		return s.Blocks()
	case "snippet":
		return s.Snippet()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.block\" resource")
	}
}

// Type accessor autogenerated
func (s *mqlTerraformBlock) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.block\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.block\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// NameLabel accessor autogenerated
func (s *mqlTerraformBlock) NameLabel() (string, error) {
	res, ok := s.Cache.Load("nameLabel")
	if !ok || !res.Valid {
		if err := s.ComputeNameLabel(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("nameLabel")
		if !ok {
			return "", errors.New("\"terraform.block\" calculated \"nameLabel\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "nameLabel")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.block\" failed to cast field \"nameLabel\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlTerraformBlock) Labels() ([]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.block\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"labels\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Start accessor autogenerated
func (s *mqlTerraformBlock) Start() (TerraformFileposition, error) {
	res, ok := s.Cache.Load("start")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.block\" failed: no value provided for static field \"start\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformFileposition)
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"start\" to the right type (TerraformFileposition): %#v", res)
	}
	return tres, nil
}

// End accessor autogenerated
func (s *mqlTerraformBlock) End() (TerraformFileposition, error) {
	res, ok := s.Cache.Load("end")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.block\" failed: no value provided for static field \"end\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformFileposition)
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"end\" to the right type (TerraformFileposition): %#v", res)
	}
	return tres, nil
}

// Arguments accessor autogenerated
func (s *mqlTerraformBlock) Arguments() (interface{}, error) {
	res, ok := s.Cache.Load("arguments")
	if !ok || !res.Valid {
		if err := s.ComputeArguments(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("arguments")
		if !ok {
			return nil, errors.New("\"terraform.block\" calculated \"arguments\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "arguments")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"arguments\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Attributes accessor autogenerated
func (s *mqlTerraformBlock) Attributes() (interface{}, error) {
	res, ok := s.Cache.Load("attributes")
	if !ok || !res.Valid {
		if err := s.ComputeAttributes(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("attributes")
		if !ok {
			return nil, errors.New("\"terraform.block\" calculated \"attributes\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "attributes")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"attributes\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Blocks accessor autogenerated
func (s *mqlTerraformBlock) Blocks() ([]interface{}, error) {
	res, ok := s.Cache.Load("blocks")
	if !ok || !res.Valid {
		if err := s.ComputeBlocks(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("blocks")
		if !ok {
			return nil, errors.New("\"terraform.block\" calculated \"blocks\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "blocks")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.block\" failed to cast field \"blocks\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Snippet accessor autogenerated
func (s *mqlTerraformBlock) Snippet() (string, error) {
	res, ok := s.Cache.Load("snippet")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.block\" failed: no value provided for static field \"snippet\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.block\" failed to cast field \"snippet\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformBlock) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.block].Compute")
	switch name {
	case "type":
		return nil
	case "nameLabel":
		return s.ComputeNameLabel()
	case "labels":
		return nil
	case "start":
		return nil
	case "end":
		return nil
	case "arguments":
		return s.ComputeArguments()
	case "attributes":
		return s.ComputeAttributes()
	case "blocks":
		return s.ComputeBlocks()
	case "snippet":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.block\" resource")
	}
}

// ComputeNameLabel computer autogenerated
func (s *mqlTerraformBlock) ComputeNameLabel() error {
	var err error
	if _, ok := s.Cache.Load("nameLabel"); ok {
		return nil
	}
	vres, err := s.GetNameLabel()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("nameLabel", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeArguments computer autogenerated
func (s *mqlTerraformBlock) ComputeArguments() error {
	var err error
	if _, ok := s.Cache.Load("arguments"); ok {
		return nil
	}
	vres, err := s.GetArguments()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("arguments", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeAttributes computer autogenerated
func (s *mqlTerraformBlock) ComputeAttributes() error {
	var err error
	if _, ok := s.Cache.Load("attributes"); ok {
		return nil
	}
	vres, err := s.GetAttributes()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("attributes", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeBlocks computer autogenerated
func (s *mqlTerraformBlock) ComputeBlocks() error {
	var err error
	if _, ok := s.Cache.Load("blocks"); ok {
		return nil
	}
	vres, err := s.GetBlocks()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("blocks", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformModule resource interface
type TerraformModule interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Key() (string, error)
	Source() (string, error)
	Version() (string, error)
	Dir() (string, error)
	Block() (TerraformBlock, error)
}

// mqlTerraformModule for the terraform.module resource
type mqlTerraformModule struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformModule) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.module resource
func newTerraformModule(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformModule{runtime.NewResource("terraform.module")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "key":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"key\" argument has the wrong type (expected type \"string\")")
			}
		case "source":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"source\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "dir":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"dir\" argument has the wrong type (expected type \"string\")")
			}
		case "block":
			if _, ok := val.(TerraformBlock); !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"block\" argument has the wrong type (expected type \"TerraformBlock\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.module\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.module with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformModule) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("key"); !ok {
		return errors.New("Initialized \"terraform.module\" resource without a \"key\". This field is required.")
	}
	if _, ok := s.Cache.Load("source"); !ok {
		return errors.New("Initialized \"terraform.module\" resource without a \"source\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"terraform.module\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("dir"); !ok {
		return errors.New("Initialized \"terraform.module\" resource without a \"dir\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformModule) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.module].Register")
	switch name {
	case "key":
		return nil
	case "source":
		return nil
	case "version":
		return nil
	case "dir":
		return nil
	case "block":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.module\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformModule) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.module].Field")
	switch name {
	case "key":
		return s.Key()
	case "source":
		return s.Source()
	case "version":
		return s.Version()
	case "dir":
		return s.Dir()
	case "block":
		return s.Block()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.module\" resource")
	}
}

// Key accessor autogenerated
func (s *mqlTerraformModule) Key() (string, error) {
	res, ok := s.Cache.Load("key")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.module\" failed: no value provided for static field \"key\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.module\" failed to cast field \"key\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Source accessor autogenerated
func (s *mqlTerraformModule) Source() (string, error) {
	res, ok := s.Cache.Load("source")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.module\" failed: no value provided for static field \"source\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.module\" failed to cast field \"source\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlTerraformModule) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.module\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.module\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Dir accessor autogenerated
func (s *mqlTerraformModule) Dir() (string, error) {
	res, ok := s.Cache.Load("dir")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.module\" failed: no value provided for static field \"dir\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.module\" failed to cast field \"dir\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Block accessor autogenerated
func (s *mqlTerraformModule) Block() (TerraformBlock, error) {
	res, ok := s.Cache.Load("block")
	if !ok || !res.Valid {
		if err := s.ComputeBlock(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("block")
		if !ok {
			return nil, errors.New("\"terraform.module\" calculated \"block\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "block")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformBlock)
	if !ok {
		return nil, fmt.Errorf("\"terraform.module\" failed to cast field \"block\" to the right type (TerraformBlock): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformModule) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.module].Compute")
	switch name {
	case "key":
		return nil
	case "source":
		return nil
	case "version":
		return nil
	case "dir":
		return nil
	case "block":
		return s.ComputeBlock()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.module\" resource")
	}
}

// ComputeBlock computer autogenerated
func (s *mqlTerraformModule) ComputeBlock() error {
	var err error
	if _, ok := s.Cache.Load("block"); ok {
		return nil
	}
	vres, err := s.GetBlock()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("block", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformSettings resource interface
type TerraformSettings interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Block() (TerraformBlock, error)
	RequiredProviders() (interface{}, error)
}

// mqlTerraformSettings for the terraform.settings resource
type mqlTerraformSettings struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformSettings) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.settings resource
func newTerraformSettings(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformSettings{runtime.NewResource("terraform.settings")}
	var existing TerraformSettings
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "block":
			if _, ok := val.(TerraformBlock); !ok {
				return nil, errors.New("Failed to initialize \"terraform.settings\", its \"block\" argument has the wrong type (expected type \"TerraformBlock\")")
			}
		case "requiredProviders":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.settings\", its \"requiredProviders\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.settings\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.settings with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformSettings) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("block"); !ok {
		return errors.New("Initialized \"terraform.settings\" resource without a \"block\". This field is required.")
	}
	if _, ok := s.Cache.Load("requiredProviders"); !ok {
		return errors.New("Initialized \"terraform.settings\" resource without a \"requiredProviders\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformSettings) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.settings].Register")
	switch name {
	case "block":
		return nil
	case "requiredProviders":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.settings\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformSettings) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.settings].Field")
	switch name {
	case "block":
		return s.Block()
	case "requiredProviders":
		return s.RequiredProviders()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.settings\" resource")
	}
}

// Block accessor autogenerated
func (s *mqlTerraformSettings) Block() (TerraformBlock, error) {
	res, ok := s.Cache.Load("block")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.settings\" failed: no value provided for static field \"block\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformBlock)
	if !ok {
		return nil, fmt.Errorf("\"terraform.settings\" failed to cast field \"block\" to the right type (TerraformBlock): %#v", res)
	}
	return tres, nil
}

// RequiredProviders accessor autogenerated
func (s *mqlTerraformSettings) RequiredProviders() (interface{}, error) {
	res, ok := s.Cache.Load("requiredProviders")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.settings\" failed: no value provided for static field \"requiredProviders\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.settings\" failed to cast field \"requiredProviders\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformSettings) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.settings].Compute")
	switch name {
	case "block":
		return nil
	case "requiredProviders":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.settings\" resource")
	}
}

// TerraformState resource interface
type TerraformState interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	FormatVersion() (string, error)
	TerraformVersion() (string, error)
	Outputs() ([]interface{}, error)
	RootModule() (TerraformStateModule, error)
	Modules() ([]interface{}, error)
	Resources() ([]interface{}, error)
}

// mqlTerraformState for the terraform.state resource
type mqlTerraformState struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformState) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.state resource
func newTerraformState(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformState{runtime.NewResource("terraform.state")}
	var existing TerraformState
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "formatVersion":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"formatVersion\" argument has the wrong type (expected type \"string\")")
			}
		case "terraformVersion":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"terraformVersion\" argument has the wrong type (expected type \"string\")")
			}
		case "outputs":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"outputs\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "rootModule":
			if _, ok := val.(TerraformStateModule); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"rootModule\" argument has the wrong type (expected type \"TerraformStateModule\")")
			}
		case "modules":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"modules\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "resources":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"resources\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.state\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.state with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformState) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("formatVersion"); !ok {
		return errors.New("Initialized \"terraform.state\" resource without a \"formatVersion\". This field is required.")
	}
	if _, ok := s.Cache.Load("terraformVersion"); !ok {
		return errors.New("Initialized \"terraform.state\" resource without a \"terraformVersion\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformState) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state].Register")
	switch name {
	case "formatVersion":
		return nil
	case "terraformVersion":
		return nil
	case "outputs":
		return nil
	case "rootModule":
		return nil
	case "modules":
		return nil
	case "resources":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformState) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.state].Field")
	switch name {
	case "formatVersion":
		return s.FormatVersion()
	case "terraformVersion":
		return s.TerraformVersion()
	case "outputs":
		return s.Outputs()
	case "rootModule":
		return s.RootModule()
	case "modules":
		return s.Modules()
	case "resources":
		return s.Resources()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.state\" resource")
	}
}

// FormatVersion accessor autogenerated
func (s *mqlTerraformState) FormatVersion() (string, error) {
	res, ok := s.Cache.Load("formatVersion")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state\" failed: no value provided for static field \"formatVersion\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state\" failed to cast field \"formatVersion\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TerraformVersion accessor autogenerated
func (s *mqlTerraformState) TerraformVersion() (string, error) {
	res, ok := s.Cache.Load("terraformVersion")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state\" failed: no value provided for static field \"terraformVersion\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state\" failed to cast field \"terraformVersion\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Outputs accessor autogenerated
func (s *mqlTerraformState) Outputs() ([]interface{}, error) {
	res, ok := s.Cache.Load("outputs")
	if !ok || !res.Valid {
		if err := s.ComputeOutputs(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("outputs")
		if !ok {
			return nil, errors.New("\"terraform.state\" calculated \"outputs\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "outputs")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state\" failed to cast field \"outputs\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// RootModule accessor autogenerated
func (s *mqlTerraformState) RootModule() (TerraformStateModule, error) {
	res, ok := s.Cache.Load("rootModule")
	if !ok || !res.Valid {
		if err := s.ComputeRootModule(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("rootModule")
		if !ok {
			return nil, errors.New("\"terraform.state\" calculated \"rootModule\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "rootModule")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformStateModule)
	if !ok {
		return nil, fmt.Errorf("\"terraform.state\" failed to cast field \"rootModule\" to the right type (TerraformStateModule): %#v", res)
	}
	return tres, nil
}

// Modules accessor autogenerated
func (s *mqlTerraformState) Modules() ([]interface{}, error) {
	res, ok := s.Cache.Load("modules")
	if !ok || !res.Valid {
		if err := s.ComputeModules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("modules")
		if !ok {
			return nil, errors.New("\"terraform.state\" calculated \"modules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "modules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state\" failed to cast field \"modules\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Resources accessor autogenerated
func (s *mqlTerraformState) Resources() ([]interface{}, error) {
	res, ok := s.Cache.Load("resources")
	if !ok || !res.Valid {
		if err := s.ComputeResources(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("resources")
		if !ok {
			return nil, errors.New("\"terraform.state\" calculated \"resources\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "resources")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state\" failed to cast field \"resources\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformState) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state].Compute")
	switch name {
	case "formatVersion":
		return nil
	case "terraformVersion":
		return nil
	case "outputs":
		return s.ComputeOutputs()
	case "rootModule":
		return s.ComputeRootModule()
	case "modules":
		return s.ComputeModules()
	case "resources":
		return s.ComputeResources()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state\" resource")
	}
}

// ComputeOutputs computer autogenerated
func (s *mqlTerraformState) ComputeOutputs() error {
	var err error
	if _, ok := s.Cache.Load("outputs"); ok {
		return nil
	}
	vres, err := s.GetOutputs()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("outputs", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRootModule computer autogenerated
func (s *mqlTerraformState) ComputeRootModule() error {
	var err error
	if _, ok := s.Cache.Load("rootModule"); ok {
		return nil
	}
	vres, err := s.GetRootModule()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("rootModule", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeModules computer autogenerated
func (s *mqlTerraformState) ComputeModules() error {
	var err error
	if _, ok := s.Cache.Load("modules"); ok {
		return nil
	}
	vres, err := s.GetModules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("modules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeResources computer autogenerated
func (s *mqlTerraformState) ComputeResources() error {
	var err error
	if _, ok := s.Cache.Load("resources"); ok {
		return nil
	}
	vres, err := s.GetResources()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("resources", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformStateOutput resource interface
type TerraformStateOutput interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Identifier() (string, error)
	Sensitive() (bool, error)
	Value() (interface{}, error)
	Type() (interface{}, error)
}

// mqlTerraformStateOutput for the terraform.state.output resource
type mqlTerraformStateOutput struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformStateOutput) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.state.output resource
func newTerraformStateOutput(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformStateOutput{runtime.NewResource("terraform.state.output")}
	var existing TerraformStateOutput
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "identifier":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.output\", its \"identifier\" argument has the wrong type (expected type \"string\")")
			}
		case "sensitive":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.output\", its \"sensitive\" argument has the wrong type (expected type \"bool\")")
			}
		case "value":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.output\", its \"value\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "type":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.output\", its \"type\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.output\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.state.output with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformStateOutput) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("identifier"); !ok {
		return errors.New("Initialized \"terraform.state.output\" resource without a \"identifier\". This field is required.")
	}
	if _, ok := s.Cache.Load("sensitive"); !ok {
		return errors.New("Initialized \"terraform.state.output\" resource without a \"sensitive\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformStateOutput) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.output].Register")
	switch name {
	case "identifier":
		return nil
	case "sensitive":
		return nil
	case "value":
		return nil
	case "type":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.output\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformStateOutput) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.state.output].Field")
	switch name {
	case "identifier":
		return s.Identifier()
	case "sensitive":
		return s.Sensitive()
	case "value":
		return s.Value()
	case "type":
		return s.Type()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.state.output\" resource")
	}
}

// Identifier accessor autogenerated
func (s *mqlTerraformStateOutput) Identifier() (string, error) {
	res, ok := s.Cache.Load("identifier")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.output\" failed: no value provided for static field \"identifier\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.output\" failed to cast field \"identifier\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sensitive accessor autogenerated
func (s *mqlTerraformStateOutput) Sensitive() (bool, error) {
	res, ok := s.Cache.Load("sensitive")
	if !ok || !res.Valid {
		return false, errors.New("\"terraform.state.output\" failed: no value provided for static field \"sensitive\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"terraform.state.output\" failed to cast field \"sensitive\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Value accessor autogenerated
func (s *mqlTerraformStateOutput) Value() (interface{}, error) {
	res, ok := s.Cache.Load("value")
	if !ok || !res.Valid {
		if err := s.ComputeValue(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("value")
		if !ok {
			return nil, errors.New("\"terraform.state.output\" calculated \"value\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "value")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.output\" failed to cast field \"value\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlTerraformStateOutput) Type() (interface{}, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		if err := s.ComputeType(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("type")
		if !ok {
			return nil, errors.New("\"terraform.state.output\" calculated \"type\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "type")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.output\" failed to cast field \"type\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformStateOutput) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.output].Compute")
	switch name {
	case "identifier":
		return nil
	case "sensitive":
		return nil
	case "value":
		return s.ComputeValue()
	case "type":
		return s.ComputeType()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.output\" resource")
	}
}

// ComputeValue computer autogenerated
func (s *mqlTerraformStateOutput) ComputeValue() error {
	var err error
	if _, ok := s.Cache.Load("value"); ok {
		return nil
	}
	vres, err := s.GetValue()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("value", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeType computer autogenerated
func (s *mqlTerraformStateOutput) ComputeType() error {
	var err error
	if _, ok := s.Cache.Load("type"); ok {
		return nil
	}
	vres, err := s.GetType()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("type", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformStateModule resource interface
type TerraformStateModule interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Address() (string, error)
	Resources() ([]interface{}, error)
	ChildModules() ([]interface{}, error)
}

// mqlTerraformStateModule for the terraform.state.module resource
type mqlTerraformStateModule struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformStateModule) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.state.module resource
func newTerraformStateModule(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformStateModule{runtime.NewResource("terraform.state.module")}
	var existing TerraformStateModule
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.module\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "resources":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.module\", its \"resources\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "childModules":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.module\", its \"childModules\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.module\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.state.module with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformStateModule) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"terraform.state.module\" resource without a \"address\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformStateModule) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.module].Register")
	switch name {
	case "address":
		return nil
	case "resources":
		return nil
	case "childModules":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.module\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformStateModule) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.state.module].Field")
	switch name {
	case "address":
		return s.Address()
	case "resources":
		return s.Resources()
	case "childModules":
		return s.ChildModules()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.state.module\" resource")
	}
}

// Address accessor autogenerated
func (s *mqlTerraformStateModule) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.module\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.module\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Resources accessor autogenerated
func (s *mqlTerraformStateModule) Resources() ([]interface{}, error) {
	res, ok := s.Cache.Load("resources")
	if !ok || !res.Valid {
		if err := s.ComputeResources(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("resources")
		if !ok {
			return nil, errors.New("\"terraform.state.module\" calculated \"resources\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "resources")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.module\" failed to cast field \"resources\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// ChildModules accessor autogenerated
func (s *mqlTerraformStateModule) ChildModules() ([]interface{}, error) {
	res, ok := s.Cache.Load("childModules")
	if !ok || !res.Valid {
		if err := s.ComputeChildModules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("childModules")
		if !ok {
			return nil, errors.New("\"terraform.state.module\" calculated \"childModules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "childModules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.module\" failed to cast field \"childModules\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformStateModule) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.module].Compute")
	switch name {
	case "address":
		return nil
	case "resources":
		return s.ComputeResources()
	case "childModules":
		return s.ComputeChildModules()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.module\" resource")
	}
}

// ComputeResources computer autogenerated
func (s *mqlTerraformStateModule) ComputeResources() error {
	var err error
	if _, ok := s.Cache.Load("resources"); ok {
		return nil
	}
	vres, err := s.GetResources()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("resources", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeChildModules computer autogenerated
func (s *mqlTerraformStateModule) ComputeChildModules() error {
	var err error
	if _, ok := s.Cache.Load("childModules"); ok {
		return nil
	}
	vres, err := s.GetChildModules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("childModules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformStateResource resource interface
type TerraformStateResource interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Address() (string, error)
	Mode() (string, error)
	Type() (string, error)
	Name() (string, error)
	ProviderName() (string, error)
	SchemaVersion() (int64, error)
	Values() (interface{}, error)
	DependsOn() ([]interface{}, error)
	Tainted() (bool, error)
	DeposedKey() (string, error)
}

// mqlTerraformStateResource for the terraform.state.resource resource
type mqlTerraformStateResource struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformStateResource) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.state.resource resource
func newTerraformStateResource(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformStateResource{runtime.NewResource("terraform.state.resource")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "mode":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"mode\" argument has the wrong type (expected type \"string\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "providerName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"providerName\" argument has the wrong type (expected type \"string\")")
			}
		case "schemaVersion":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"schemaVersion\" argument has the wrong type (expected type \"int64\")")
			}
		case "values":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"values\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "dependsOn":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"dependsOn\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "tainted":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"tainted\" argument has the wrong type (expected type \"bool\")")
			}
		case "deposedKey":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"deposedKey\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.state.resource\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.state.resource with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformStateResource) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"address\". This field is required.")
	}
	if _, ok := s.Cache.Load("mode"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"mode\". This field is required.")
	}
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("providerName"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"providerName\". This field is required.")
	}
	if _, ok := s.Cache.Load("schemaVersion"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"schemaVersion\". This field is required.")
	}
	if _, ok := s.Cache.Load("values"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"values\". This field is required.")
	}
	if _, ok := s.Cache.Load("dependsOn"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"dependsOn\". This field is required.")
	}
	if _, ok := s.Cache.Load("tainted"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"tainted\". This field is required.")
	}
	if _, ok := s.Cache.Load("deposedKey"); !ok {
		return errors.New("Initialized \"terraform.state.resource\" resource without a \"deposedKey\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformStateResource) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.resource].Register")
	switch name {
	case "address":
		return nil
	case "mode":
		return nil
	case "type":
		return nil
	case "name":
		return nil
	case "providerName":
		return nil
	case "schemaVersion":
		return nil
	case "values":
		return nil
	case "dependsOn":
		return nil
	case "tainted":
		return nil
	case "deposedKey":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.resource\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformStateResource) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.state.resource].Field")
	switch name {
	case "address":
		return s.Address()
	case "mode":
		return s.Mode()
	case "type":
		return s.Type()
	case "name":
		return s.Name()
	case "providerName":
		return s.ProviderName()
	case "schemaVersion":
		return s.SchemaVersion()
	case "values":
		return s.Values()
	case "dependsOn":
		return s.DependsOn()
	case "tainted":
		return s.Tainted()
	case "deposedKey":
		return s.DeposedKey()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.state.resource\" resource")
	}
}

// Address accessor autogenerated
func (s *mqlTerraformStateResource) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mode accessor autogenerated
func (s *mqlTerraformStateResource) Mode() (string, error) {
	res, ok := s.Cache.Load("mode")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"mode\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"mode\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlTerraformStateResource) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlTerraformStateResource) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ProviderName accessor autogenerated
func (s *mqlTerraformStateResource) ProviderName() (string, error) {
	res, ok := s.Cache.Load("providerName")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"providerName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"providerName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SchemaVersion accessor autogenerated
func (s *mqlTerraformStateResource) SchemaVersion() (int64, error) {
	res, ok := s.Cache.Load("schemaVersion")
	if !ok || !res.Valid {
		return 0, errors.New("\"terraform.state.resource\" failed: no value provided for static field \"schemaVersion\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"terraform.state.resource\" failed to cast field \"schemaVersion\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Values accessor autogenerated
func (s *mqlTerraformStateResource) Values() (interface{}, error) {
	res, ok := s.Cache.Load("values")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.state.resource\" failed: no value provided for static field \"values\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.resource\" failed to cast field \"values\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// DependsOn accessor autogenerated
func (s *mqlTerraformStateResource) DependsOn() ([]interface{}, error) {
	res, ok := s.Cache.Load("dependsOn")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.state.resource\" failed: no value provided for static field \"dependsOn\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.state.resource\" failed to cast field \"dependsOn\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Tainted accessor autogenerated
func (s *mqlTerraformStateResource) Tainted() (bool, error) {
	res, ok := s.Cache.Load("tainted")
	if !ok || !res.Valid {
		return false, errors.New("\"terraform.state.resource\" failed: no value provided for static field \"tainted\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"terraform.state.resource\" failed to cast field \"tainted\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// DeposedKey accessor autogenerated
func (s *mqlTerraformStateResource) DeposedKey() (string, error) {
	res, ok := s.Cache.Load("deposedKey")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.state.resource\" failed: no value provided for static field \"deposedKey\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.state.resource\" failed to cast field \"deposedKey\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformStateResource) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.state.resource].Compute")
	switch name {
	case "address":
		return nil
	case "mode":
		return nil
	case "type":
		return nil
	case "name":
		return nil
	case "providerName":
		return nil
	case "schemaVersion":
		return nil
	case "values":
		return nil
	case "dependsOn":
		return nil
	case "tainted":
		return nil
	case "deposedKey":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.state.resource\" resource")
	}
}

// TerraformPlan resource interface
type TerraformPlan interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	FormatVersion() (string, error)
	TerraformVersion() (string, error)
	ResourceChanges() ([]interface{}, error)
}

// mqlTerraformPlan for the terraform.plan resource
type mqlTerraformPlan struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformPlan) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.plan resource
func newTerraformPlan(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformPlan{runtime.NewResource("terraform.plan")}
	var existing TerraformPlan
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "formatVersion":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan\", its \"formatVersion\" argument has the wrong type (expected type \"string\")")
			}
		case "terraformVersion":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan\", its \"terraformVersion\" argument has the wrong type (expected type \"string\")")
			}
		case "resourceChanges":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan\", its \"resourceChanges\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.plan with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformPlan) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("formatVersion"); !ok {
		return errors.New("Initialized \"terraform.plan\" resource without a \"formatVersion\". This field is required.")
	}
	if _, ok := s.Cache.Load("terraformVersion"); !ok {
		return errors.New("Initialized \"terraform.plan\" resource without a \"terraformVersion\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformPlan) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan].Register")
	switch name {
	case "formatVersion":
		return nil
	case "terraformVersion":
		return nil
	case "resourceChanges":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformPlan) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.plan].Field")
	switch name {
	case "formatVersion":
		return s.FormatVersion()
	case "terraformVersion":
		return s.TerraformVersion()
	case "resourceChanges":
		return s.ResourceChanges()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.plan\" resource")
	}
}

// FormatVersion accessor autogenerated
func (s *mqlTerraformPlan) FormatVersion() (string, error) {
	res, ok := s.Cache.Load("formatVersion")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan\" failed: no value provided for static field \"formatVersion\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan\" failed to cast field \"formatVersion\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TerraformVersion accessor autogenerated
func (s *mqlTerraformPlan) TerraformVersion() (string, error) {
	res, ok := s.Cache.Load("terraformVersion")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan\" failed: no value provided for static field \"terraformVersion\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan\" failed to cast field \"terraformVersion\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ResourceChanges accessor autogenerated
func (s *mqlTerraformPlan) ResourceChanges() ([]interface{}, error) {
	res, ok := s.Cache.Load("resourceChanges")
	if !ok || !res.Valid {
		if err := s.ComputeResourceChanges(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("resourceChanges")
		if !ok {
			return nil, errors.New("\"terraform.plan\" calculated \"resourceChanges\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "resourceChanges")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan\" failed to cast field \"resourceChanges\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformPlan) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan].Compute")
	switch name {
	case "formatVersion":
		return nil
	case "terraformVersion":
		return nil
	case "resourceChanges":
		return s.ComputeResourceChanges()
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan\" resource")
	}
}

// ComputeResourceChanges computer autogenerated
func (s *mqlTerraformPlan) ComputeResourceChanges() error {
	var err error
	if _, ok := s.Cache.Load("resourceChanges"); ok {
		return nil
	}
	vres, err := s.GetResourceChanges()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("resourceChanges", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// TerraformPlanResourceChange resource interface
type TerraformPlanResourceChange interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Address() (string, error)
	PreviousAddress() (string, error)
	ModuleAddress() (string, error)
	Mode() (string, error)
	Type() (string, error)
	Name() (string, error)
	ProviderName() (string, error)
	Deposed() (string, error)
	Change() (TerraformPlanProposedChange, error)
	ActionReason() (string, error)
}

// mqlTerraformPlanResourceChange for the terraform.plan.resourceChange resource
type mqlTerraformPlanResourceChange struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformPlanResourceChange) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.plan.resourceChange resource
func newTerraformPlanResourceChange(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformPlanResourceChange{runtime.NewResource("terraform.plan.resourceChange")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "previousAddress":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"previousAddress\" argument has the wrong type (expected type \"string\")")
			}
		case "moduleAddress":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"moduleAddress\" argument has the wrong type (expected type \"string\")")
			}
		case "mode":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"mode\" argument has the wrong type (expected type \"string\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "providerName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"providerName\" argument has the wrong type (expected type \"string\")")
			}
		case "deposed":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"deposed\" argument has the wrong type (expected type \"string\")")
			}
		case "change":
			if _, ok := val.(TerraformPlanProposedChange); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"change\" argument has the wrong type (expected type \"TerraformPlanProposedChange\")")
			}
		case "actionReason":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"actionReason\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.resourceChange\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.plan.resourceChange with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformPlanResourceChange) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"address\". This field is required.")
	}
	if _, ok := s.Cache.Load("previousAddress"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"previousAddress\". This field is required.")
	}
	if _, ok := s.Cache.Load("moduleAddress"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"moduleAddress\". This field is required.")
	}
	if _, ok := s.Cache.Load("mode"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"mode\". This field is required.")
	}
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("providerName"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"providerName\". This field is required.")
	}
	if _, ok := s.Cache.Load("deposed"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"deposed\". This field is required.")
	}
	if _, ok := s.Cache.Load("change"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"change\". This field is required.")
	}
	if _, ok := s.Cache.Load("actionReason"); !ok {
		return errors.New("Initialized \"terraform.plan.resourceChange\" resource without a \"actionReason\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan.resourceChange].Register")
	switch name {
	case "address":
		return nil
	case "previousAddress":
		return nil
	case "moduleAddress":
		return nil
	case "mode":
		return nil
	case "type":
		return nil
	case "name":
		return nil
	case "providerName":
		return nil
	case "deposed":
		return nil
	case "change":
		return nil
	case "actionReason":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan.resourceChange\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.plan.resourceChange].Field")
	switch name {
	case "address":
		return s.Address()
	case "previousAddress":
		return s.PreviousAddress()
	case "moduleAddress":
		return s.ModuleAddress()
	case "mode":
		return s.Mode()
	case "type":
		return s.Type()
	case "name":
		return s.Name()
	case "providerName":
		return s.ProviderName()
	case "deposed":
		return s.Deposed()
	case "change":
		return s.Change()
	case "actionReason":
		return s.ActionReason()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.plan.resourceChange\" resource")
	}
}

// Address accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PreviousAddress accessor autogenerated
func (s *mqlTerraformPlanResourceChange) PreviousAddress() (string, error) {
	res, ok := s.Cache.Load("previousAddress")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"previousAddress\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"previousAddress\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ModuleAddress accessor autogenerated
func (s *mqlTerraformPlanResourceChange) ModuleAddress() (string, error) {
	res, ok := s.Cache.Load("moduleAddress")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"moduleAddress\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"moduleAddress\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mode accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Mode() (string, error) {
	res, ok := s.Cache.Load("mode")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"mode\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"mode\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ProviderName accessor autogenerated
func (s *mqlTerraformPlanResourceChange) ProviderName() (string, error) {
	res, ok := s.Cache.Load("providerName")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"providerName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"providerName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Deposed accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Deposed() (string, error) {
	res, ok := s.Cache.Load("deposed")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"deposed\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"deposed\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Change accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Change() (TerraformPlanProposedChange, error) {
	res, ok := s.Cache.Load("change")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"change\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(TerraformPlanProposedChange)
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"change\" to the right type (TerraformPlanProposedChange): %#v", res)
	}
	return tres, nil
}

// ActionReason accessor autogenerated
func (s *mqlTerraformPlanResourceChange) ActionReason() (string, error) {
	res, ok := s.Cache.Load("actionReason")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.resourceChange\" failed: no value provided for static field \"actionReason\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.resourceChange\" failed to cast field \"actionReason\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformPlanResourceChange) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan.resourceChange].Compute")
	switch name {
	case "address":
		return nil
	case "previousAddress":
		return nil
	case "moduleAddress":
		return nil
	case "mode":
		return nil
	case "type":
		return nil
	case "name":
		return nil
	case "providerName":
		return nil
	case "deposed":
		return nil
	case "change":
		return nil
	case "actionReason":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan.resourceChange\" resource")
	}
}

// TerraformPlanProposedChange resource interface
type TerraformPlanProposedChange interface {
	MqlResource() (*resources.Resource)
	Compute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Address() (string, error)
	Actions() ([]interface{}, error)
	Before() (interface{}, error)
	After() (interface{}, error)
	AfterUnknown() (interface{}, error)
	BeforeSensitive() (interface{}, error)
	AfterSensitive() (interface{}, error)
	ReplacePaths() (interface{}, error)
}

// mqlTerraformPlanProposedChange for the terraform.plan.proposedChange resource
type mqlTerraformPlanProposedChange struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTerraformPlanProposedChange) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the terraform.plan.proposedChange resource
func newTerraformPlanProposedChange(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTerraformPlanProposedChange{runtime.NewResource("terraform.plan.proposedChange")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "actions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"actions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "before":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"before\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "after":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"after\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "afterUnknown":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"afterUnknown\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "beforeSensitive":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"beforeSensitive\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "afterSensitive":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"afterSensitive\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "replacePaths":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"replacePaths\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"terraform.plan.proposedChange\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized terraform.plan.proposedChange with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTerraformPlanProposedChange) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"address\". This field is required.")
	}
	if _, ok := s.Cache.Load("actions"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"actions\". This field is required.")
	}
	if _, ok := s.Cache.Load("before"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"before\". This field is required.")
	}
	if _, ok := s.Cache.Load("after"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"after\". This field is required.")
	}
	if _, ok := s.Cache.Load("afterUnknown"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"afterUnknown\". This field is required.")
	}
	if _, ok := s.Cache.Load("beforeSensitive"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"beforeSensitive\". This field is required.")
	}
	if _, ok := s.Cache.Load("afterSensitive"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"afterSensitive\". This field is required.")
	}
	if _, ok := s.Cache.Load("replacePaths"); !ok {
		return errors.New("Initialized \"terraform.plan.proposedChange\" resource without a \"replacePaths\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Register(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan.proposedChange].Register")
	switch name {
	case "address":
		return nil
	case "actions":
		return nil
	case "before":
		return nil
	case "after":
		return nil
	case "afterUnknown":
		return nil
	case "beforeSensitive":
		return nil
	case "afterSensitive":
		return nil
	case "replacePaths":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan.proposedChange\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[terraform.plan.proposedChange].Field")
	switch name {
	case "address":
		return s.Address()
	case "actions":
		return s.Actions()
	case "before":
		return s.Before()
	case "after":
		return s.After()
	case "afterUnknown":
		return s.AfterUnknown()
	case "beforeSensitive":
		return s.BeforeSensitive()
	case "afterSensitive":
		return s.AfterSensitive()
	case "replacePaths":
		return s.ReplacePaths()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"terraform.plan.proposedChange\" resource")
	}
}

// Address accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Actions accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Actions() ([]interface{}, error) {
	res, ok := s.Cache.Load("actions")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"actions\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"actions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Before accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Before() (interface{}, error) {
	res, ok := s.Cache.Load("before")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"before\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"before\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// After accessor autogenerated
func (s *mqlTerraformPlanProposedChange) After() (interface{}, error) {
	res, ok := s.Cache.Load("after")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"after\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"after\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AfterUnknown accessor autogenerated
func (s *mqlTerraformPlanProposedChange) AfterUnknown() (interface{}, error) {
	res, ok := s.Cache.Load("afterUnknown")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"afterUnknown\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"afterUnknown\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// BeforeSensitive accessor autogenerated
func (s *mqlTerraformPlanProposedChange) BeforeSensitive() (interface{}, error) {
	res, ok := s.Cache.Load("beforeSensitive")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"beforeSensitive\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"beforeSensitive\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AfterSensitive accessor autogenerated
func (s *mqlTerraformPlanProposedChange) AfterSensitive() (interface{}, error) {
	res, ok := s.Cache.Load("afterSensitive")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"afterSensitive\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"afterSensitive\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// ReplacePaths accessor autogenerated
func (s *mqlTerraformPlanProposedChange) ReplacePaths() (interface{}, error) {
	res, ok := s.Cache.Load("replacePaths")
	if !ok || !res.Valid {
		return nil, errors.New("\"terraform.plan.proposedChange\" failed: no value provided for static field \"replacePaths\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"terraform.plan.proposedChange\" failed to cast field \"replacePaths\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTerraformPlanProposedChange) Compute(name string) error {
	log.Trace().Str("field", name).Msg("[terraform.plan.proposedChange].Compute")
	switch name {
	case "address":
		return nil
	case "actions":
		return nil
	case "before":
		return nil
	case "after":
		return nil
	case "afterUnknown":
		return nil
	case "beforeSensitive":
		return nil
	case "afterSensitive":
		return nil
	case "replacePaths":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"terraform.plan.proposedChange\" resource")
	}
}

