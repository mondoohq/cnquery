// Code generated by resources. DO NOT EDIT.
package os

import (
	"errors"
	"fmt"
	"time"

	"go.mondoo.com/cnquery/resources"
	"github.com/rs/zerolog/log"
	"go.mondoo.com/cnquery/resources/packs/core"
)

// Init all resources into the registry
func Init(registry *resources.Registry) {
	registry.AddFactory("command", newCommand)
	registry.AddFactory("powershell", newPowershell)
	registry.AddFactory("files.find", newFilesFind)
	registry.AddFactory("pam.conf", newPamConf)
	registry.AddFactory("pam.conf.serviceEntry", newPamConfServiceEntry)
	registry.AddFactory("sshd", newSshd)
	registry.AddFactory("sshd.config", newSshdConfig)
	registry.AddFactory("ntp.conf", newNtpConf)
	registry.AddFactory("rsyslog.conf", newRsyslogConf)
	registry.AddFactory("machine", newMachine)
	registry.AddFactory("machine.bios", newMachineBios)
	registry.AddFactory("machine.system", newMachineSystem)
	registry.AddFactory("machine.baseboard", newMachineBaseboard)
	registry.AddFactory("machine.chassis", newMachineChassis)
	registry.AddFactory("os.base", newOsBase)
	registry.AddFactory("os.unix", newOsUnix)
	registry.AddFactory("os.linux", newOsLinux)
	registry.AddFactory("os", newOs)
	registry.AddFactory("os.update", newOsUpdate)
	registry.AddFactory("os.rootCertificates", newOsRootCertificates)
	registry.AddFactory("service", newService)
	registry.AddFactory("services", newServices)
	registry.AddFactory("docker", newDocker)
	registry.AddFactory("docker.image", newDockerImage)
	registry.AddFactory("docker.container", newDockerContainer)
	registry.AddFactory("auditpol", newAuditpol)
	registry.AddFactory("auditpol.entry", newAuditpolEntry)
	registry.AddFactory("secpol", newSecpol)
	registry.AddFactory("logindefs", newLogindefs)
	registry.AddFactory("lsblk", newLsblk)
	registry.AddFactory("lsblk.entry", newLsblkEntry)
	registry.AddFactory("mount", newMount)
	registry.AddFactory("mount.point", newMountPoint)
	registry.AddFactory("shadow", newShadow)
	registry.AddFactory("shadow.entry", newShadowEntry)
	registry.AddFactory("registrykey", newRegistrykey)
	registry.AddFactory("registrykey.property", newRegistrykeyProperty)
	registry.AddFactory("windows", newWindows)
	registry.AddFactory("windows.hotfix", newWindowsHotfix)
	registry.AddFactory("windows.feature", newWindowsFeature)
	registry.AddFactory("windows.firewall", newWindowsFirewall)
	registry.AddFactory("windows.firewall.profile", newWindowsFirewallProfile)
	registry.AddFactory("windows.firewall.rule", newWindowsFirewallRule)
	registry.AddFactory("windows.bitlocker", newWindowsBitlocker)
	registry.AddFactory("windows.bitlocker.volume", newWindowsBitlockerVolume)
	registry.AddFactory("windows.security", newWindowsSecurity)
	registry.AddFactory("windows.security.product", newWindowsSecurityProduct)
	registry.AddFactory("windows.security.health", newWindowsSecurityHealth)
	registry.AddFactory("yum", newYum)
	registry.AddFactory("yum.repo", newYumRepo)
	registry.AddFactory("container.image", newContainerImage)
	registry.AddFactory("container.repository", newContainerRepository)
	registry.AddFactory("equinix.metal.project", newEquinixMetalProject)
	registry.AddFactory("equinix.metal.organization", newEquinixMetalOrganization)
	registry.AddFactory("equinix.metal.user", newEquinixMetalUser)
	registry.AddFactory("equinix.metal.sshkey", newEquinixMetalSshkey)
	registry.AddFactory("equinix.metal.device", newEquinixMetalDevice)
	registry.AddFactory("macos", newMacos)
	registry.AddFactory("macos.alf", newMacosAlf)
	registry.AddFactory("macos.systemsetup", newMacosSystemsetup)
	registry.AddFactory("macos.timemachine", newMacosTimemachine)
	registry.AddFactory("macos.security", newMacosSecurity)
	registry.AddFactory("iptables", newIptables)
	registry.AddFactory("ip6tables", newIp6tables)
	registry.AddFactory("iptables.entry", newIptablesEntry)
}

// Command resource interface
type Command interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Command() (string, error)
	Stdout() (string, error)
	Stderr() (string, error)
	Exitcode() (int64, error)
}

// mqlCommand for the command resource
type mqlCommand struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlCommand) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the command resource
func newCommand(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlCommand{runtime.NewResource("command")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "command":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"command\", its \"command\" argument has the wrong type (expected type \"string\")")
			}
		case "stdout":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"command\", its \"stdout\" argument has the wrong type (expected type \"string\")")
			}
		case "stderr":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"command\", its \"stderr\" argument has the wrong type (expected type \"string\")")
			}
		case "exitcode":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"command\", its \"exitcode\" argument has the wrong type (expected type \"int64\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"command\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized command with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlCommand) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("command"); !ok {
		return errors.New("Initialized \"command\" resource without a \"command\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlCommand) Register(name string) error {
	log.Trace().Str("field", name).Msg("[command].Register")
	switch name {
	case "command":
		return nil
	case "stdout":
		return nil
	case "stderr":
		return nil
	case "exitcode":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"command\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlCommand) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[command].Field")
	switch name {
	case "command":
		return s.Command()
	case "stdout":
		return s.Stdout()
	case "stderr":
		return s.Stderr()
	case "exitcode":
		return s.Exitcode()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"command\" resource")
	}
}

// Command accessor autogenerated
func (s *mqlCommand) Command() (string, error) {
	res, ok := s.Cache.Load("command")
	if !ok || !res.Valid {
		return "", errors.New("\"command\" failed: no value provided for static field \"command\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"command\" failed to cast field \"command\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Stdout accessor autogenerated
func (s *mqlCommand) Stdout() (string, error) {
	res, ok := s.Cache.Load("stdout")
	if !ok || !res.Valid {
		if err := s.ComputeStdout(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("stdout")
		if !ok {
			return "", errors.New("\"command\" calculated \"stdout\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stdout")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"command\" failed to cast field \"stdout\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Stderr accessor autogenerated
func (s *mqlCommand) Stderr() (string, error) {
	res, ok := s.Cache.Load("stderr")
	if !ok || !res.Valid {
		if err := s.ComputeStderr(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("stderr")
		if !ok {
			return "", errors.New("\"command\" calculated \"stderr\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stderr")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"command\" failed to cast field \"stderr\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exitcode accessor autogenerated
func (s *mqlCommand) Exitcode() (int64, error) {
	res, ok := s.Cache.Load("exitcode")
	if !ok || !res.Valid {
		if err := s.ComputeExitcode(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("exitcode")
		if !ok {
			return 0, errors.New("\"command\" calculated \"exitcode\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "exitcode")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"command\" failed to cast field \"exitcode\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlCommand) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[command].MqlCompute")
	switch name {
	case "command":
		return nil
	case "stdout":
		return s.ComputeStdout()
	case "stderr":
		return s.ComputeStderr()
	case "exitcode":
		return s.ComputeExitcode()
	default:
		return errors.New("Cannot find field '" + name + "' in \"command\" resource")
	}
}

// ComputeStdout computer autogenerated
func (s *mqlCommand) ComputeStdout() error {
	var err error
	if _, ok := s.Cache.Load("stdout"); ok {
		return nil
	}
	vres, err := s.GetStdout()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stdout", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeStderr computer autogenerated
func (s *mqlCommand) ComputeStderr() error {
	var err error
	if _, ok := s.Cache.Load("stderr"); ok {
		return nil
	}
	vres, err := s.GetStderr()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stderr", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExitcode computer autogenerated
func (s *mqlCommand) ComputeExitcode() error {
	var err error
	if _, ok := s.Cache.Load("exitcode"); ok {
		return nil
	}
	vres, err := s.GetExitcode()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("exitcode", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Powershell resource interface
type Powershell interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Script() (string, error)
	Stdout() (string, error)
	Stderr() (string, error)
	Exitcode() (int64, error)
}

// mqlPowershell for the powershell resource
type mqlPowershell struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPowershell) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the powershell resource
func newPowershell(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPowershell{runtime.NewResource("powershell")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "script":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"powershell\", its \"script\" argument has the wrong type (expected type \"string\")")
			}
		case "stdout":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"powershell\", its \"stdout\" argument has the wrong type (expected type \"string\")")
			}
		case "stderr":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"powershell\", its \"stderr\" argument has the wrong type (expected type \"string\")")
			}
		case "exitcode":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"powershell\", its \"exitcode\" argument has the wrong type (expected type \"int64\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"powershell\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized powershell with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPowershell) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("script"); !ok {
		return errors.New("Initialized \"powershell\" resource without a \"script\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPowershell) Register(name string) error {
	log.Trace().Str("field", name).Msg("[powershell].Register")
	switch name {
	case "script":
		return nil
	case "stdout":
		return nil
	case "stderr":
		return nil
	case "exitcode":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"powershell\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPowershell) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[powershell].Field")
	switch name {
	case "script":
		return s.Script()
	case "stdout":
		return s.Stdout()
	case "stderr":
		return s.Stderr()
	case "exitcode":
		return s.Exitcode()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"powershell\" resource")
	}
}

// Script accessor autogenerated
func (s *mqlPowershell) Script() (string, error) {
	res, ok := s.Cache.Load("script")
	if !ok || !res.Valid {
		return "", errors.New("\"powershell\" failed: no value provided for static field \"script\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"powershell\" failed to cast field \"script\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Stdout accessor autogenerated
func (s *mqlPowershell) Stdout() (string, error) {
	res, ok := s.Cache.Load("stdout")
	if !ok || !res.Valid {
		if err := s.ComputeStdout(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("stdout")
		if !ok {
			return "", errors.New("\"powershell\" calculated \"stdout\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stdout")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"powershell\" failed to cast field \"stdout\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Stderr accessor autogenerated
func (s *mqlPowershell) Stderr() (string, error) {
	res, ok := s.Cache.Load("stderr")
	if !ok || !res.Valid {
		if err := s.ComputeStderr(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("stderr")
		if !ok {
			return "", errors.New("\"powershell\" calculated \"stderr\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stderr")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"powershell\" failed to cast field \"stderr\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exitcode accessor autogenerated
func (s *mqlPowershell) Exitcode() (int64, error) {
	res, ok := s.Cache.Load("exitcode")
	if !ok || !res.Valid {
		if err := s.ComputeExitcode(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("exitcode")
		if !ok {
			return 0, errors.New("\"powershell\" calculated \"exitcode\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "exitcode")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"powershell\" failed to cast field \"exitcode\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPowershell) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[powershell].MqlCompute")
	switch name {
	case "script":
		return nil
	case "stdout":
		return s.ComputeStdout()
	case "stderr":
		return s.ComputeStderr()
	case "exitcode":
		return s.ComputeExitcode()
	default:
		return errors.New("Cannot find field '" + name + "' in \"powershell\" resource")
	}
}

// ComputeStdout computer autogenerated
func (s *mqlPowershell) ComputeStdout() error {
	var err error
	if _, ok := s.Cache.Load("stdout"); ok {
		return nil
	}
	vres, err := s.GetStdout()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stdout", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeStderr computer autogenerated
func (s *mqlPowershell) ComputeStderr() error {
	var err error
	if _, ok := s.Cache.Load("stderr"); ok {
		return nil
	}
	vres, err := s.GetStderr()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stderr", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExitcode computer autogenerated
func (s *mqlPowershell) ComputeExitcode() error {
	var err error
	if _, ok := s.Cache.Load("exitcode"); ok {
		return nil
	}
	vres, err := s.GetExitcode()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("exitcode", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// FilesFind resource interface
type FilesFind interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	From() (string, error)
	Xdev() (bool, error)
	Type() (string, error)
	Regex() (string, error)
	Permissions() (int64, error)
	Name() (string, error)
	List() ([]interface{}, error)
}

// mqlFilesFind for the files.find resource
type mqlFilesFind struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlFilesFind) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the files.find resource
func newFilesFind(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlFilesFind{runtime.NewResource("files.find")}
	var existing FilesFind
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "from":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"from\" argument has the wrong type (expected type \"string\")")
			}
		case "xdev":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"xdev\" argument has the wrong type (expected type \"bool\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "regex":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"regex\" argument has the wrong type (expected type \"string\")")
			}
		case "permissions":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"permissions\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"files.find\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized files.find with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlFilesFind) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("from"); !ok {
		return errors.New("Initialized \"files.find\" resource without a \"from\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlFilesFind) Register(name string) error {
	log.Trace().Str("field", name).Msg("[files.find].Register")
	switch name {
	case "from":
		return nil
	case "xdev":
		return nil
	case "type":
		return nil
	case "regex":
		return nil
	case "permissions":
		return nil
	case "name":
		return nil
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"files.find\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlFilesFind) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[files.find].Field")
	switch name {
	case "from":
		return s.From()
	case "xdev":
		return s.Xdev()
	case "type":
		return s.Type()
	case "regex":
		return s.Regex()
	case "permissions":
		return s.Permissions()
	case "name":
		return s.Name()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"files.find\" resource")
	}
}

// From accessor autogenerated
func (s *mqlFilesFind) From() (string, error) {
	res, ok := s.Cache.Load("from")
	if !ok || !res.Valid {
		return "", errors.New("\"files.find\" failed: no value provided for static field \"from\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"files.find\" failed to cast field \"from\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Xdev accessor autogenerated
func (s *mqlFilesFind) Xdev() (bool, error) {
	res, ok := s.Cache.Load("xdev")
	if !ok || !res.Valid {
		if err := s.ComputeXdev(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("xdev")
		if !ok {
			return false, errors.New("\"files.find\" calculated \"xdev\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "xdev")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"files.find\" failed to cast field \"xdev\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlFilesFind) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		if err := s.ComputeType(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("type")
		if !ok {
			return "", errors.New("\"files.find\" calculated \"type\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "type")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"files.find\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Regex accessor autogenerated
func (s *mqlFilesFind) Regex() (string, error) {
	res, ok := s.Cache.Load("regex")
	if !ok || !res.Valid {
		if err := s.ComputeRegex(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("regex")
		if !ok {
			return "", errors.New("\"files.find\" calculated \"regex\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "regex")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"files.find\" failed to cast field \"regex\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Permissions accessor autogenerated
func (s *mqlFilesFind) Permissions() (int64, error) {
	res, ok := s.Cache.Load("permissions")
	if !ok || !res.Valid {
		if err := s.ComputePermissions(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("permissions")
		if !ok {
			return 0, errors.New("\"files.find\" calculated \"permissions\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "permissions")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"files.find\" failed to cast field \"permissions\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlFilesFind) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		if err := s.ComputeName(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("name")
		if !ok {
			return "", errors.New("\"files.find\" calculated \"name\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "name")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"files.find\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlFilesFind) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"files.find\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"files.find\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlFilesFind) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[files.find].MqlCompute")
	switch name {
	case "from":
		return nil
	case "xdev":
		return s.ComputeXdev()
	case "type":
		return s.ComputeType()
	case "regex":
		return s.ComputeRegex()
	case "permissions":
		return s.ComputePermissions()
	case "name":
		return s.ComputeName()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"files.find\" resource")
	}
}

// ComputeXdev computer autogenerated
func (s *mqlFilesFind) ComputeXdev() error {
	var err error
	if _, ok := s.Cache.Load("xdev"); ok {
		return nil
	}
	vres, err := s.GetXdev()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("xdev", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeType computer autogenerated
func (s *mqlFilesFind) ComputeType() error {
	var err error
	if _, ok := s.Cache.Load("type"); ok {
		return nil
	}
	vres, err := s.GetType()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("type", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRegex computer autogenerated
func (s *mqlFilesFind) ComputeRegex() error {
	var err error
	if _, ok := s.Cache.Load("regex"); ok {
		return nil
	}
	vres, err := s.GetRegex()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("regex", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePermissions computer autogenerated
func (s *mqlFilesFind) ComputePermissions() error {
	var err error
	if _, ok := s.Cache.Load("permissions"); ok {
		return nil
	}
	vres, err := s.GetPermissions()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("permissions", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeName computer autogenerated
func (s *mqlFilesFind) ComputeName() error {
	var err error
	if _, ok := s.Cache.Load("name"); ok {
		return nil
	}
	vres, err := s.GetName()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("name", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlFilesFind) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PamConf resource interface
type PamConf interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Files() ([]interface{}, error)
	Content() (string, error)
	Services() (map[string]interface{}, error)
	Entries() (map[string]interface{}, error)
}

// mqlPamConf for the pam.conf resource
type mqlPamConf struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPamConf) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the pam.conf resource
func newPamConf(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPamConf{runtime.NewResource("pam.conf")}
	var existing PamConf
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "services":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf\", its \"services\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "entries":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf\", its \"entries\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"pam.conf\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized pam.conf with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPamConf) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPamConf) Register(name string) error {
	log.Trace().Str("field", name).Msg("[pam.conf].Register")
	switch name {
	case "files":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "content"); err != nil {
			return err
		}
		return nil
	case "services":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "services"); err != nil {
			return err
		}
		return nil
	case "entries":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "entries"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pam.conf\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPamConf) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[pam.conf].Field")
	switch name {
	case "files":
		return s.Files()
	case "content":
		return s.Content()
	case "services":
		return s.Services()
	case "entries":
		return s.Entries()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"pam.conf\" resource")
	}
}

// Files accessor autogenerated
func (s *mqlPamConf) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"pam.conf\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pam.conf\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlPamConf) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pam.conf\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Services accessor autogenerated
func (s *mqlPamConf) Services() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("services")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pam.conf\" failed to cast field \"services\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Entries accessor autogenerated
func (s *mqlPamConf) Entries() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("entries")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pam.conf\" failed to cast field \"entries\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPamConf) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[pam.conf].MqlCompute")
	switch name {
	case "files":
		return s.ComputeFiles()
	case "content":
		return s.ComputeContent()
	case "services":
		return s.ComputeServices()
	case "entries":
		return s.ComputeEntries()
	default:
		return errors.New("Cannot find field '" + name + "' in \"pam.conf\" resource")
	}
}

// ComputeFiles computer autogenerated
func (s *mqlPamConf) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlPamConf) ComputeContent() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeServices computer autogenerated
func (s *mqlPamConf) ComputeServices() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("services", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetServices(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("services", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEntries computer autogenerated
func (s *mqlPamConf) ComputeEntries() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("entries", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetEntries(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("entries", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PamConfServiceEntry resource interface
type PamConfServiceEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Service() (string, error)
	LineNumber() (int64, error)
	PamType() (string, error)
	Control() (string, error)
	Module() (string, error)
	Options() ([]interface{}, error)
}

// mqlPamConfServiceEntry for the pam.conf.serviceEntry resource
type mqlPamConfServiceEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPamConfServiceEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the pam.conf.serviceEntry resource
func newPamConfServiceEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPamConfServiceEntry{runtime.NewResource("pam.conf.serviceEntry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "service":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"service\" argument has the wrong type (expected type \"string\")")
			}
		case "lineNumber":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"lineNumber\" argument has the wrong type (expected type \"int64\")")
			}
		case "pamType":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"pamType\" argument has the wrong type (expected type \"string\")")
			}
		case "control":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"control\" argument has the wrong type (expected type \"string\")")
			}
		case "module":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"module\" argument has the wrong type (expected type \"string\")")
			}
		case "options":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"options\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"pam.conf.serviceEntry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized pam.conf.serviceEntry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPamConfServiceEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("service"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"service\". This field is required.")
	}
	if _, ok := s.Cache.Load("lineNumber"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"lineNumber\". This field is required.")
	}
	if _, ok := s.Cache.Load("pamType"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"pamType\". This field is required.")
	}
	if _, ok := s.Cache.Load("control"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"control\". This field is required.")
	}
	if _, ok := s.Cache.Load("module"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"module\". This field is required.")
	}
	if _, ok := s.Cache.Load("options"); !ok {
		return errors.New("Initialized \"pam.conf.serviceEntry\" resource without a \"options\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPamConfServiceEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[pam.conf.serviceEntry].Register")
	switch name {
	case "service":
		return nil
	case "lineNumber":
		return nil
	case "pamType":
		return nil
	case "control":
		return nil
	case "module":
		return nil
	case "options":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pam.conf.serviceEntry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPamConfServiceEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[pam.conf.serviceEntry].Field")
	switch name {
	case "service":
		return s.Service()
	case "lineNumber":
		return s.LineNumber()
	case "pamType":
		return s.PamType()
	case "control":
		return s.Control()
	case "module":
		return s.Module()
	case "options":
		return s.Options()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"pam.conf.serviceEntry\" resource")
	}
}

// Service accessor autogenerated
func (s *mqlPamConfServiceEntry) Service() (string, error) {
	res, ok := s.Cache.Load("service")
	if !ok || !res.Valid {
		return "", errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"service\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"service\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// LineNumber accessor autogenerated
func (s *mqlPamConfServiceEntry) LineNumber() (int64, error) {
	res, ok := s.Cache.Load("lineNumber")
	if !ok || !res.Valid {
		return 0, errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"lineNumber\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"lineNumber\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// PamType accessor autogenerated
func (s *mqlPamConfServiceEntry) PamType() (string, error) {
	res, ok := s.Cache.Load("pamType")
	if !ok || !res.Valid {
		return "", errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"pamType\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"pamType\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Control accessor autogenerated
func (s *mqlPamConfServiceEntry) Control() (string, error) {
	res, ok := s.Cache.Load("control")
	if !ok || !res.Valid {
		return "", errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"control\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"control\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Module accessor autogenerated
func (s *mqlPamConfServiceEntry) Module() (string, error) {
	res, ok := s.Cache.Load("module")
	if !ok || !res.Valid {
		return "", errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"module\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"module\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Options accessor autogenerated
func (s *mqlPamConfServiceEntry) Options() ([]interface{}, error) {
	res, ok := s.Cache.Load("options")
	if !ok || !res.Valid {
		return nil, errors.New("\"pam.conf.serviceEntry\" failed: no value provided for static field \"options\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pam.conf.serviceEntry\" failed to cast field \"options\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPamConfServiceEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[pam.conf.serviceEntry].MqlCompute")
	switch name {
	case "service":
		return nil
	case "lineNumber":
		return nil
	case "pamType":
		return nil
	case "control":
		return nil
	case "module":
		return nil
	case "options":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pam.conf.serviceEntry\" resource")
	}
}

// Sshd resource interface
type Sshd interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
}

// mqlSshd for the sshd resource
type mqlSshd struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlSshd) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the sshd resource
func newSshd(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlSshd{runtime.NewResource("sshd")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"sshd\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized sshd with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlSshd) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlSshd) Register(name string) error {
	log.Trace().Str("field", name).Msg("[sshd].Register")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"sshd\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlSshd) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[sshd].Field")
	switch name {
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"sshd\" resource")
	}
}

// Compute accessor autogenerated
func (s *mqlSshd) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[sshd].MqlCompute")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"sshd\" resource")
	}
}

// SshdConfig resource interface
type SshdConfig interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (core.File, error)
	Files() ([]interface{}, error)
	Content() (string, error)
	Params() (map[string]interface{}, error)
	Ciphers() ([]interface{}, error)
	Macs() ([]interface{}, error)
	Kexs() ([]interface{}, error)
	Hostkeys() ([]interface{}, error)
}

// mqlSshdConfig for the sshd.config resource
type mqlSshdConfig struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlSshdConfig) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the sshd.config resource
func newSshdConfig(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlSshdConfig{runtime.NewResource("sshd.config")}
	var existing SshdConfig
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(core.File); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"file\" argument has the wrong type (expected type \"core.File\")")
			}
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"params\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "ciphers":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"ciphers\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "macs":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"macs\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "kexs":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"kexs\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "hostkeys":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"hostkeys\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"sshd.config\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized sshd.config with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlSshdConfig) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlSshdConfig) Register(name string) error {
	log.Trace().Str("field", name).Msg("[sshd.config].Register")
	switch name {
	case "file":
		return nil
	case "files":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "content"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "params"); err != nil {
			return err
		}
		return nil
	case "ciphers":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "ciphers"); err != nil {
			return err
		}
		return nil
	case "macs":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "macs"); err != nil {
			return err
		}
		return nil
	case "kexs":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "kexs"); err != nil {
			return err
		}
		return nil
	case "hostkeys":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "hostkeys"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"sshd.config\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlSshdConfig) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[sshd.config].Field")
	switch name {
	case "file":
		return s.File()
	case "files":
		return s.Files()
	case "content":
		return s.Content()
	case "params":
		return s.Params()
	case "ciphers":
		return s.Ciphers()
	case "macs":
		return s.Macs()
	case "kexs":
		return s.Kexs()
	case "hostkeys":
		return s.Hostkeys()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"sshd.config\" resource")
	}
}

// File accessor autogenerated
func (s *mqlSshdConfig) File() (core.File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"sshd.config\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.File)
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"file\" to the right type (core.File): %#v", res)
	}
	return tres, nil
}

// Files accessor autogenerated
func (s *mqlSshdConfig) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"sshd.config\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlSshdConfig) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"sshd.config\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlSshdConfig) Params() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"params\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Ciphers accessor autogenerated
func (s *mqlSshdConfig) Ciphers() ([]interface{}, error) {
	res, ok := s.Cache.Load("ciphers")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"ciphers\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Macs accessor autogenerated
func (s *mqlSshdConfig) Macs() ([]interface{}, error) {
	res, ok := s.Cache.Load("macs")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"macs\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Kexs accessor autogenerated
func (s *mqlSshdConfig) Kexs() ([]interface{}, error) {
	res, ok := s.Cache.Load("kexs")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"kexs\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Hostkeys accessor autogenerated
func (s *mqlSshdConfig) Hostkeys() ([]interface{}, error) {
	res, ok := s.Cache.Load("hostkeys")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"sshd.config\" failed to cast field \"hostkeys\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlSshdConfig) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[sshd.config].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "files":
		return s.ComputeFiles()
	case "content":
		return s.ComputeContent()
	case "params":
		return s.ComputeParams()
	case "ciphers":
		return s.ComputeCiphers()
	case "macs":
		return s.ComputeMacs()
	case "kexs":
		return s.ComputeKexs()
	case "hostkeys":
		return s.ComputeHostkeys()
	default:
		return errors.New("Cannot find field '" + name + "' in \"sshd.config\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlSshdConfig) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFiles computer autogenerated
func (s *mqlSshdConfig) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlSshdConfig) ComputeContent() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlSshdConfig) ComputeParams() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCiphers computer autogenerated
func (s *mqlSshdConfig) ComputeCiphers() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("ciphers", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetCiphers(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ciphers", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMacs computer autogenerated
func (s *mqlSshdConfig) ComputeMacs() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("macs", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetMacs(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("macs", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeKexs computer autogenerated
func (s *mqlSshdConfig) ComputeKexs() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("kexs", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetKexs(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("kexs", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHostkeys computer autogenerated
func (s *mqlSshdConfig) ComputeHostkeys() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("hostkeys", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetHostkeys(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("hostkeys", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// NtpConf resource interface
type NtpConf interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (core.File, error)
	Content() (string, error)
	Settings() ([]interface{}, error)
	Servers() ([]interface{}, error)
	Restrict() ([]interface{}, error)
	Fudge() ([]interface{}, error)
}

// mqlNtpConf for the ntp.conf resource
type mqlNtpConf struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlNtpConf) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the ntp.conf resource
func newNtpConf(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlNtpConf{runtime.NewResource("ntp.conf")}
	var existing NtpConf
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(core.File); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"file\" argument has the wrong type (expected type \"core.File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "settings":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"settings\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "servers":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"servers\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "restrict":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"restrict\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "fudge":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"fudge\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"ntp.conf\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized ntp.conf with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlNtpConf) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlNtpConf) Register(name string) error {
	log.Trace().Str("field", name).Msg("[ntp.conf].Register")
	switch name {
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "settings":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "settings"); err != nil {
			return err
		}
		return nil
	case "servers":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "settings", s, "servers"); err != nil {
			return err
		}
		return nil
	case "restrict":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "settings", s, "restrict"); err != nil {
			return err
		}
		return nil
	case "fudge":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "settings", s, "fudge"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"ntp.conf\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlNtpConf) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[ntp.conf].Field")
	switch name {
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "settings":
		return s.Settings()
	case "servers":
		return s.Servers()
	case "restrict":
		return s.Restrict()
	case "fudge":
		return s.Fudge()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"ntp.conf\" resource")
	}
}

// File accessor autogenerated
func (s *mqlNtpConf) File() (core.File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"ntp.conf\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.File)
	if !ok {
		return nil, fmt.Errorf("\"ntp.conf\" failed to cast field \"file\" to the right type (core.File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlNtpConf) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"ntp.conf\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Settings accessor autogenerated
func (s *mqlNtpConf) Settings() ([]interface{}, error) {
	res, ok := s.Cache.Load("settings")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ntp.conf\" failed to cast field \"settings\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Servers accessor autogenerated
func (s *mqlNtpConf) Servers() ([]interface{}, error) {
	res, ok := s.Cache.Load("servers")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ntp.conf\" failed to cast field \"servers\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Restrict accessor autogenerated
func (s *mqlNtpConf) Restrict() ([]interface{}, error) {
	res, ok := s.Cache.Load("restrict")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ntp.conf\" failed to cast field \"restrict\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Fudge accessor autogenerated
func (s *mqlNtpConf) Fudge() ([]interface{}, error) {
	res, ok := s.Cache.Load("fudge")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ntp.conf\" failed to cast field \"fudge\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlNtpConf) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[ntp.conf].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "settings":
		return s.ComputeSettings()
	case "servers":
		return s.ComputeServers()
	case "restrict":
		return s.ComputeRestrict()
	case "fudge":
		return s.ComputeFudge()
	default:
		return errors.New("Cannot find field '" + name + "' in \"ntp.conf\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlNtpConf) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlNtpConf) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSettings computer autogenerated
func (s *mqlNtpConf) ComputeSettings() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("settings", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetSettings(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("settings", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeServers computer autogenerated
func (s *mqlNtpConf) ComputeServers() error {
	var err error
	vargSettings, err := s.Settings()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("servers", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetServers(vargSettings)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("servers", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRestrict computer autogenerated
func (s *mqlNtpConf) ComputeRestrict() error {
	var err error
	vargSettings, err := s.Settings()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("restrict", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetRestrict(vargSettings)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("restrict", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFudge computer autogenerated
func (s *mqlNtpConf) ComputeFudge() error {
	var err error
	vargSettings, err := s.Settings()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("fudge", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetFudge(vargSettings)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("fudge", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// RsyslogConf resource interface
type RsyslogConf interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Files() ([]interface{}, error)
	Content() (string, error)
	Settings() ([]interface{}, error)
}

// mqlRsyslogConf for the rsyslog.conf resource
type mqlRsyslogConf struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlRsyslogConf) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the rsyslog.conf resource
func newRsyslogConf(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlRsyslogConf{runtime.NewResource("rsyslog.conf")}
	var existing RsyslogConf
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"rsyslog.conf\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"rsyslog.conf\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "settings":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"rsyslog.conf\", its \"settings\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"rsyslog.conf\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized rsyslog.conf with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlRsyslogConf) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlRsyslogConf) Register(name string) error {
	log.Trace().Str("field", name).Msg("[rsyslog.conf].Register")
	switch name {
	case "files":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "content"); err != nil {
			return err
		}
		return nil
	case "settings":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "settings"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"rsyslog.conf\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlRsyslogConf) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[rsyslog.conf].Field")
	switch name {
	case "files":
		return s.Files()
	case "content":
		return s.Content()
	case "settings":
		return s.Settings()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"rsyslog.conf\" resource")
	}
}

// Files accessor autogenerated
func (s *mqlRsyslogConf) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"rsyslog.conf\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"rsyslog.conf\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlRsyslogConf) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"rsyslog.conf\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Settings accessor autogenerated
func (s *mqlRsyslogConf) Settings() ([]interface{}, error) {
	res, ok := s.Cache.Load("settings")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"rsyslog.conf\" failed to cast field \"settings\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlRsyslogConf) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[rsyslog.conf].MqlCompute")
	switch name {
	case "files":
		return s.ComputeFiles()
	case "content":
		return s.ComputeContent()
	case "settings":
		return s.ComputeSettings()
	default:
		return errors.New("Cannot find field '" + name + "' in \"rsyslog.conf\" resource")
	}
}

// ComputeFiles computer autogenerated
func (s *mqlRsyslogConf) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlRsyslogConf) ComputeContent() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSettings computer autogenerated
func (s *mqlRsyslogConf) ComputeSettings() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("settings", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetSettings(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("settings", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Machine resource interface
type Machine interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
}

// mqlMachine for the machine resource
type mqlMachine struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMachine) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the machine resource
func newMachine(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMachine{runtime.NewResource("machine")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"machine\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized machine with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMachine) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMachine) Register(name string) error {
	log.Trace().Str("field", name).Msg("[machine].Register")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMachine) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[machine].Field")
	switch name {
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"machine\" resource")
	}
}

// Compute accessor autogenerated
func (s *mqlMachine) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[machine].MqlCompute")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine\" resource")
	}
}

// MachineBios resource interface
type MachineBios interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Vendor() (string, error)
	Version() (string, error)
	ReleaseDate() (string, error)
}

// mqlMachineBios for the machine.bios resource
type mqlMachineBios struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMachineBios) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the machine.bios resource
func newMachineBios(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMachineBios{runtime.NewResource("machine.bios")}
	var existing MachineBios
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "vendor":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.bios\", its \"vendor\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.bios\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "releaseDate":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.bios\", its \"releaseDate\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"machine.bios\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized machine.bios with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMachineBios) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("vendor"); !ok {
		return errors.New("Initialized \"machine.bios\" resource without a \"vendor\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"machine.bios\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("releaseDate"); !ok {
		return errors.New("Initialized \"machine.bios\" resource without a \"releaseDate\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMachineBios) Register(name string) error {
	log.Trace().Str("field", name).Msg("[machine.bios].Register")
	switch name {
	case "vendor":
		return nil
	case "version":
		return nil
	case "releaseDate":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.bios\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMachineBios) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[machine.bios].Field")
	switch name {
	case "vendor":
		return s.Vendor()
	case "version":
		return s.Version()
	case "releaseDate":
		return s.ReleaseDate()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"machine.bios\" resource")
	}
}

// Vendor accessor autogenerated
func (s *mqlMachineBios) Vendor() (string, error) {
	res, ok := s.Cache.Load("vendor")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.bios\" failed: no value provided for static field \"vendor\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.bios\" failed to cast field \"vendor\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMachineBios) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.bios\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.bios\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ReleaseDate accessor autogenerated
func (s *mqlMachineBios) ReleaseDate() (string, error) {
	res, ok := s.Cache.Load("releaseDate")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.bios\" failed: no value provided for static field \"releaseDate\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.bios\" failed to cast field \"releaseDate\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMachineBios) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[machine.bios].MqlCompute")
	switch name {
	case "vendor":
		return nil
	case "version":
		return nil
	case "releaseDate":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.bios\" resource")
	}
}

// MachineSystem resource interface
type MachineSystem interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Manufacturer() (string, error)
	Product() (string, error)
	Version() (string, error)
	Serial() (string, error)
	Uuid() (string, error)
	Sku() (string, error)
	Family() (string, error)
}

// mqlMachineSystem for the machine.system resource
type mqlMachineSystem struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMachineSystem) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the machine.system resource
func newMachineSystem(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMachineSystem{runtime.NewResource("machine.system")}
	var existing MachineSystem
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "manufacturer":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"manufacturer\" argument has the wrong type (expected type \"string\")")
			}
		case "product":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"product\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "serial":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"serial\" argument has the wrong type (expected type \"string\")")
			}
		case "uuid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"uuid\" argument has the wrong type (expected type \"string\")")
			}
		case "sku":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"sku\" argument has the wrong type (expected type \"string\")")
			}
		case "family":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"family\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"machine.system\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized machine.system with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMachineSystem) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("manufacturer"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"manufacturer\". This field is required.")
	}
	if _, ok := s.Cache.Load("product"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"product\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("serial"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"serial\". This field is required.")
	}
	if _, ok := s.Cache.Load("uuid"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"uuid\". This field is required.")
	}
	if _, ok := s.Cache.Load("sku"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"sku\". This field is required.")
	}
	if _, ok := s.Cache.Load("family"); !ok {
		return errors.New("Initialized \"machine.system\" resource without a \"family\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMachineSystem) Register(name string) error {
	log.Trace().Str("field", name).Msg("[machine.system].Register")
	switch name {
	case "manufacturer":
		return nil
	case "product":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "uuid":
		return nil
	case "sku":
		return nil
	case "family":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.system\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMachineSystem) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[machine.system].Field")
	switch name {
	case "manufacturer":
		return s.Manufacturer()
	case "product":
		return s.Product()
	case "version":
		return s.Version()
	case "serial":
		return s.Serial()
	case "uuid":
		return s.Uuid()
	case "sku":
		return s.Sku()
	case "family":
		return s.Family()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"machine.system\" resource")
	}
}

// Manufacturer accessor autogenerated
func (s *mqlMachineSystem) Manufacturer() (string, error) {
	res, ok := s.Cache.Load("manufacturer")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"manufacturer\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"manufacturer\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Product accessor autogenerated
func (s *mqlMachineSystem) Product() (string, error) {
	res, ok := s.Cache.Load("product")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"product\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"product\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMachineSystem) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Serial accessor autogenerated
func (s *mqlMachineSystem) Serial() (string, error) {
	res, ok := s.Cache.Load("serial")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"serial\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"serial\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Uuid accessor autogenerated
func (s *mqlMachineSystem) Uuid() (string, error) {
	res, ok := s.Cache.Load("uuid")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"uuid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"uuid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sku accessor autogenerated
func (s *mqlMachineSystem) Sku() (string, error) {
	res, ok := s.Cache.Load("sku")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"sku\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"sku\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Family accessor autogenerated
func (s *mqlMachineSystem) Family() (string, error) {
	res, ok := s.Cache.Load("family")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.system\" failed: no value provided for static field \"family\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.system\" failed to cast field \"family\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMachineSystem) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[machine.system].MqlCompute")
	switch name {
	case "manufacturer":
		return nil
	case "product":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "uuid":
		return nil
	case "sku":
		return nil
	case "family":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.system\" resource")
	}
}

// MachineBaseboard resource interface
type MachineBaseboard interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Manufacturer() (string, error)
	Product() (string, error)
	Version() (string, error)
	Serial() (string, error)
	AssetTag() (string, error)
}

// mqlMachineBaseboard for the machine.baseboard resource
type mqlMachineBaseboard struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMachineBaseboard) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the machine.baseboard resource
func newMachineBaseboard(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMachineBaseboard{runtime.NewResource("machine.baseboard")}
	var existing MachineBaseboard
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "manufacturer":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"manufacturer\" argument has the wrong type (expected type \"string\")")
			}
		case "product":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"product\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "serial":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"serial\" argument has the wrong type (expected type \"string\")")
			}
		case "assetTag":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"assetTag\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"machine.baseboard\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized machine.baseboard with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMachineBaseboard) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("manufacturer"); !ok {
		return errors.New("Initialized \"machine.baseboard\" resource without a \"manufacturer\". This field is required.")
	}
	if _, ok := s.Cache.Load("product"); !ok {
		return errors.New("Initialized \"machine.baseboard\" resource without a \"product\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"machine.baseboard\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("serial"); !ok {
		return errors.New("Initialized \"machine.baseboard\" resource without a \"serial\". This field is required.")
	}
	if _, ok := s.Cache.Load("assetTag"); !ok {
		return errors.New("Initialized \"machine.baseboard\" resource without a \"assetTag\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMachineBaseboard) Register(name string) error {
	log.Trace().Str("field", name).Msg("[machine.baseboard].Register")
	switch name {
	case "manufacturer":
		return nil
	case "product":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "assetTag":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.baseboard\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMachineBaseboard) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[machine.baseboard].Field")
	switch name {
	case "manufacturer":
		return s.Manufacturer()
	case "product":
		return s.Product()
	case "version":
		return s.Version()
	case "serial":
		return s.Serial()
	case "assetTag":
		return s.AssetTag()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"machine.baseboard\" resource")
	}
}

// Manufacturer accessor autogenerated
func (s *mqlMachineBaseboard) Manufacturer() (string, error) {
	res, ok := s.Cache.Load("manufacturer")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.baseboard\" failed: no value provided for static field \"manufacturer\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.baseboard\" failed to cast field \"manufacturer\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Product accessor autogenerated
func (s *mqlMachineBaseboard) Product() (string, error) {
	res, ok := s.Cache.Load("product")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.baseboard\" failed: no value provided for static field \"product\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.baseboard\" failed to cast field \"product\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMachineBaseboard) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.baseboard\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.baseboard\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Serial accessor autogenerated
func (s *mqlMachineBaseboard) Serial() (string, error) {
	res, ok := s.Cache.Load("serial")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.baseboard\" failed: no value provided for static field \"serial\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.baseboard\" failed to cast field \"serial\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AssetTag accessor autogenerated
func (s *mqlMachineBaseboard) AssetTag() (string, error) {
	res, ok := s.Cache.Load("assetTag")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.baseboard\" failed: no value provided for static field \"assetTag\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.baseboard\" failed to cast field \"assetTag\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMachineBaseboard) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[machine.baseboard].MqlCompute")
	switch name {
	case "manufacturer":
		return nil
	case "product":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "assetTag":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.baseboard\" resource")
	}
}

// MachineChassis resource interface
type MachineChassis interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Manufacturer() (string, error)
	Version() (string, error)
	Serial() (string, error)
	AssetTag() (string, error)
}

// mqlMachineChassis for the machine.chassis resource
type mqlMachineChassis struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMachineChassis) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the machine.chassis resource
func newMachineChassis(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMachineChassis{runtime.NewResource("machine.chassis")}
	var existing MachineChassis
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "manufacturer":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.chassis\", its \"manufacturer\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.chassis\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "serial":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.chassis\", its \"serial\" argument has the wrong type (expected type \"string\")")
			}
		case "assetTag":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"machine.chassis\", its \"assetTag\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"machine.chassis\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized machine.chassis with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMachineChassis) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("manufacturer"); !ok {
		return errors.New("Initialized \"machine.chassis\" resource without a \"manufacturer\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"machine.chassis\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("serial"); !ok {
		return errors.New("Initialized \"machine.chassis\" resource without a \"serial\". This field is required.")
	}
	if _, ok := s.Cache.Load("assetTag"); !ok {
		return errors.New("Initialized \"machine.chassis\" resource without a \"assetTag\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMachineChassis) Register(name string) error {
	log.Trace().Str("field", name).Msg("[machine.chassis].Register")
	switch name {
	case "manufacturer":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "assetTag":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.chassis\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMachineChassis) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[machine.chassis].Field")
	switch name {
	case "manufacturer":
		return s.Manufacturer()
	case "version":
		return s.Version()
	case "serial":
		return s.Serial()
	case "assetTag":
		return s.AssetTag()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"machine.chassis\" resource")
	}
}

// Manufacturer accessor autogenerated
func (s *mqlMachineChassis) Manufacturer() (string, error) {
	res, ok := s.Cache.Load("manufacturer")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.chassis\" failed: no value provided for static field \"manufacturer\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.chassis\" failed to cast field \"manufacturer\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMachineChassis) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.chassis\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.chassis\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Serial accessor autogenerated
func (s *mqlMachineChassis) Serial() (string, error) {
	res, ok := s.Cache.Load("serial")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.chassis\" failed: no value provided for static field \"serial\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.chassis\" failed to cast field \"serial\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AssetTag accessor autogenerated
func (s *mqlMachineChassis) AssetTag() (string, error) {
	res, ok := s.Cache.Load("assetTag")
	if !ok || !res.Valid {
		return "", errors.New("\"machine.chassis\" failed: no value provided for static field \"assetTag\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"machine.chassis\" failed to cast field \"assetTag\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMachineChassis) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[machine.chassis].MqlCompute")
	switch name {
	case "manufacturer":
		return nil
	case "version":
		return nil
	case "serial":
		return nil
	case "assetTag":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"machine.chassis\" resource")
	}
}

// OsBase resource interface
type OsBase interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Machine() (resources.ResourceType, error)
	Name() (string, error)
	Env() (map[string]interface{}, error)
	Path() ([]interface{}, error)
	Uptime() (*time.Time, error)
	Updates() ([]interface{}, error)
	Rebootpending() (bool, error)
	Hostname() (string, error)
	Groups() (core.Groups, error)
	Users() (core.Users, error)
}

// mqlOsBase for the os.base resource
type mqlOsBase struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOsBase) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os.base resource
func newOsBase(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOsBase{runtime.NewResource("os.base")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "machine":
			if _, ok := val.(Machine); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"machine\" argument has the wrong type (expected type \"Machine\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "env":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"env\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "path":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"path\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "uptime":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"uptime\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updates":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"updates\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "rebootpending":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"rebootpending\" argument has the wrong type (expected type \"bool\")")
			}
		case "hostname":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"hostname\" argument has the wrong type (expected type \"string\")")
			}
		case "groups":
			if _, ok := val.(core.Groups); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"groups\" argument has the wrong type (expected type \"core.Groups\")")
			}
		case "users":
			if _, ok := val.(core.Users); !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"users\" argument has the wrong type (expected type \"core.Users\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os.base\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os.base with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOsBase) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlOsBase) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os.base].Register")
	switch name {
	case "machine":
		return nil
	case "name":
		return nil
	case "env":
		return nil
	case "path":
		return nil
	case "uptime":
		return nil
	case "updates":
		return nil
	case "rebootpending":
		return nil
	case "hostname":
		return nil
	case "groups":
		return nil
	case "users":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.base\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOsBase) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os.base].Field")
	switch name {
	case "machine":
		return s.Machine()
	case "name":
		return s.Name()
	case "env":
		return s.Env()
	case "path":
		return s.Path()
	case "uptime":
		return s.Uptime()
	case "updates":
		return s.Updates()
	case "rebootpending":
		return s.Rebootpending()
	case "hostname":
		return s.Hostname()
	case "groups":
		return s.Groups()
	case "users":
		return s.Users()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os.base\" resource")
	}
}

// Machine accessor autogenerated
func (s *mqlOsBase) Machine() (resources.ResourceType, error) {
	res, ok := s.Cache.Load("machine")
	if !ok || !res.Valid {
		if err := s.ComputeMachine(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("machine")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"machine\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "machine")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Machine)
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"machine\" to the right type (Machine): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlOsBase) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		if err := s.ComputeName(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("name")
		if !ok {
			return "", errors.New("\"os.base\" calculated \"name\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "name")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.base\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Env accessor autogenerated
func (s *mqlOsBase) Env() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("env")
	if !ok || !res.Valid {
		if err := s.ComputeEnv(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("env")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"env\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "env")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"env\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Path accessor autogenerated
func (s *mqlOsBase) Path() ([]interface{}, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		if err := s.ComputePath(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("path")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"path\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "path")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"path\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Uptime accessor autogenerated
func (s *mqlOsBase) Uptime() (*time.Time, error) {
	res, ok := s.Cache.Load("uptime")
	if !ok || !res.Valid {
		if err := s.ComputeUptime(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("uptime")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"uptime\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "uptime")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"uptime\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Updates accessor autogenerated
func (s *mqlOsBase) Updates() ([]interface{}, error) {
	res, ok := s.Cache.Load("updates")
	if !ok || !res.Valid {
		if err := s.ComputeUpdates(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("updates")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"updates\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "updates")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"updates\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Rebootpending accessor autogenerated
func (s *mqlOsBase) Rebootpending() (bool, error) {
	res, ok := s.Cache.Load("rebootpending")
	if !ok || !res.Valid {
		if err := s.ComputeRebootpending(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("rebootpending")
		if !ok {
			return false, errors.New("\"os.base\" calculated \"rebootpending\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "rebootpending")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"os.base\" failed to cast field \"rebootpending\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Hostname accessor autogenerated
func (s *mqlOsBase) Hostname() (string, error) {
	res, ok := s.Cache.Load("hostname")
	if !ok || !res.Valid {
		if err := s.ComputeHostname(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("hostname")
		if !ok {
			return "", errors.New("\"os.base\" calculated \"hostname\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "hostname")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.base\" failed to cast field \"hostname\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Groups accessor autogenerated
func (s *mqlOsBase) Groups() (core.Groups, error) {
	res, ok := s.Cache.Load("groups")
	if !ok || !res.Valid {
		if err := s.ComputeGroups(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("groups")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"groups\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "groups")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.Groups)
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"groups\" to the right type (core.Groups): %#v", res)
	}
	return tres, nil
}

// Users accessor autogenerated
func (s *mqlOsBase) Users() (core.Users, error) {
	res, ok := s.Cache.Load("users")
	if !ok || !res.Valid {
		if err := s.ComputeUsers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("users")
		if !ok {
			return nil, errors.New("\"os.base\" calculated \"users\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "users")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.Users)
	if !ok {
		return nil, fmt.Errorf("\"os.base\" failed to cast field \"users\" to the right type (core.Users): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOsBase) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os.base].MqlCompute")
	switch name {
	case "machine":
		return s.ComputeMachine()
	case "name":
		return s.ComputeName()
	case "env":
		return s.ComputeEnv()
	case "path":
		return s.ComputePath()
	case "uptime":
		return s.ComputeUptime()
	case "updates":
		return s.ComputeUpdates()
	case "rebootpending":
		return s.ComputeRebootpending()
	case "hostname":
		return s.ComputeHostname()
	case "groups":
		return s.ComputeGroups()
	case "users":
		return s.ComputeUsers()
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.base\" resource")
	}
}

// ComputeMachine computer autogenerated
func (s *mqlOsBase) ComputeMachine() error {
	var err error
	if _, ok := s.Cache.Load("machine"); ok {
		return nil
	}
	vres, err := s.GetMachine()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("machine", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeName computer autogenerated
func (s *mqlOsBase) ComputeName() error {
	var err error
	if _, ok := s.Cache.Load("name"); ok {
		return nil
	}
	vres, err := s.GetName()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("name", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEnv computer autogenerated
func (s *mqlOsBase) ComputeEnv() error {
	var err error
	if _, ok := s.Cache.Load("env"); ok {
		return nil
	}
	vres, err := s.GetEnv()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("env", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePath computer autogenerated
func (s *mqlOsBase) ComputePath() error {
	var err error
	if _, ok := s.Cache.Load("path"); ok {
		return nil
	}
	vres, err := s.GetPath()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("path", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUptime computer autogenerated
func (s *mqlOsBase) ComputeUptime() error {
	var err error
	if _, ok := s.Cache.Load("uptime"); ok {
		return nil
	}
	vres, err := s.GetUptime()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("uptime", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUpdates computer autogenerated
func (s *mqlOsBase) ComputeUpdates() error {
	var err error
	if _, ok := s.Cache.Load("updates"); ok {
		return nil
	}
	vres, err := s.GetUpdates()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("updates", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRebootpending computer autogenerated
func (s *mqlOsBase) ComputeRebootpending() error {
	var err error
	if _, ok := s.Cache.Load("rebootpending"); ok {
		return nil
	}
	vres, err := s.GetRebootpending()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("rebootpending", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHostname computer autogenerated
func (s *mqlOsBase) ComputeHostname() error {
	var err error
	if _, ok := s.Cache.Load("hostname"); ok {
		return nil
	}
	vres, err := s.GetHostname()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("hostname", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeGroups computer autogenerated
func (s *mqlOsBase) ComputeGroups() error {
	var err error
	if _, ok := s.Cache.Load("groups"); ok {
		return nil
	}
	vres, err := s.GetGroups()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("groups", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUsers computer autogenerated
func (s *mqlOsBase) ComputeUsers() error {
	var err error
	if _, ok := s.Cache.Load("users"); ok {
		return nil
	}
	vres, err := s.GetUsers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("users", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OsUnix resource interface
type OsUnix interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Base() (resources.ResourceType, error)
}

// mqlOsUnix for the os.unix resource
type mqlOsUnix struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOsUnix) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os.unix resource
func newOsUnix(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOsUnix{runtime.NewResource("os.unix")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "base":
			if _, ok := val.(OsBase); !ok {
				return nil, errors.New("Failed to initialize \"os.unix\", its \"base\" argument has the wrong type (expected type \"OsBase\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os.unix\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os.unix with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOsUnix) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlOsUnix) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os.unix].Register")
	switch name {
	case "base":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.unix\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOsUnix) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os.unix].Field")
	switch name {
	case "base":
		return s.Base()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os.unix\" resource")
	}
}

// Base accessor autogenerated
func (s *mqlOsUnix) Base() (resources.ResourceType, error) {
	res, ok := s.Cache.Load("base")
	if !ok || !res.Valid {
		if err := s.ComputeBase(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("base")
		if !ok {
			return nil, errors.New("\"os.unix\" calculated \"base\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "base")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(OsBase)
	if !ok {
		return nil, fmt.Errorf("\"os.unix\" failed to cast field \"base\" to the right type (OsBase): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOsUnix) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os.unix].MqlCompute")
	switch name {
	case "base":
		return s.ComputeBase()
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.unix\" resource")
	}
}

// ComputeBase computer autogenerated
func (s *mqlOsUnix) ComputeBase() error {
	var err error
	if _, ok := s.Cache.Load("base"); ok {
		return nil
	}
	vres, err := s.GetBase()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("base", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OsLinux resource interface
type OsLinux interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Unix() (resources.ResourceType, error)
	Iptables() (Iptables, error)
	Ip6tables() (Ip6tables, error)
}

// mqlOsLinux for the os.linux resource
type mqlOsLinux struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOsLinux) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os.linux resource
func newOsLinux(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOsLinux{runtime.NewResource("os.linux")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "unix":
			if _, ok := val.(OsUnix); !ok {
				return nil, errors.New("Failed to initialize \"os.linux\", its \"unix\" argument has the wrong type (expected type \"OsUnix\")")
			}
		case "iptables":
			if _, ok := val.(Iptables); !ok {
				return nil, errors.New("Failed to initialize \"os.linux\", its \"iptables\" argument has the wrong type (expected type \"Iptables\")")
			}
		case "ip6tables":
			if _, ok := val.(Ip6tables); !ok {
				return nil, errors.New("Failed to initialize \"os.linux\", its \"ip6tables\" argument has the wrong type (expected type \"Ip6tables\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os.linux\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os.linux with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOsLinux) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlOsLinux) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os.linux].Register")
	switch name {
	case "unix":
		return nil
	case "iptables":
		return nil
	case "ip6tables":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.linux\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOsLinux) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os.linux].Field")
	switch name {
	case "unix":
		return s.Unix()
	case "iptables":
		return s.Iptables()
	case "ip6tables":
		return s.Ip6tables()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os.linux\" resource")
	}
}

// Unix accessor autogenerated
func (s *mqlOsLinux) Unix() (resources.ResourceType, error) {
	res, ok := s.Cache.Load("unix")
	if !ok || !res.Valid {
		if err := s.ComputeUnix(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("unix")
		if !ok {
			return nil, errors.New("\"os.linux\" calculated \"unix\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "unix")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(OsUnix)
	if !ok {
		return nil, fmt.Errorf("\"os.linux\" failed to cast field \"unix\" to the right type (OsUnix): %#v", res)
	}
	return tres, nil
}

// Iptables accessor autogenerated
func (s *mqlOsLinux) Iptables() (Iptables, error) {
	res, ok := s.Cache.Load("iptables")
	if !ok || !res.Valid {
		if err := s.ComputeIptables(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("iptables")
		if !ok {
			return nil, errors.New("\"os.linux\" calculated \"iptables\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "iptables")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Iptables)
	if !ok {
		return nil, fmt.Errorf("\"os.linux\" failed to cast field \"iptables\" to the right type (Iptables): %#v", res)
	}
	return tres, nil
}

// Ip6tables accessor autogenerated
func (s *mqlOsLinux) Ip6tables() (Ip6tables, error) {
	res, ok := s.Cache.Load("ip6tables")
	if !ok || !res.Valid {
		if err := s.ComputeIp6tables(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("ip6tables")
		if !ok {
			return nil, errors.New("\"os.linux\" calculated \"ip6tables\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "ip6tables")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Ip6tables)
	if !ok {
		return nil, fmt.Errorf("\"os.linux\" failed to cast field \"ip6tables\" to the right type (Ip6tables): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOsLinux) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os.linux].MqlCompute")
	switch name {
	case "unix":
		return s.ComputeUnix()
	case "iptables":
		return s.ComputeIptables()
	case "ip6tables":
		return s.ComputeIp6tables()
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.linux\" resource")
	}
}

// ComputeUnix computer autogenerated
func (s *mqlOsLinux) ComputeUnix() error {
	var err error
	if _, ok := s.Cache.Load("unix"); ok {
		return nil
	}
	vres, err := s.GetUnix()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("unix", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIptables computer autogenerated
func (s *mqlOsLinux) ComputeIptables() error {
	var err error
	if _, ok := s.Cache.Load("iptables"); ok {
		return nil
	}
	vres, err := s.GetIptables()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("iptables", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIp6tables computer autogenerated
func (s *mqlOsLinux) ComputeIp6tables() error {
	var err error
	if _, ok := s.Cache.Load("ip6tables"); ok {
		return nil
	}
	vres, err := s.GetIp6tables()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ip6tables", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Os resource interface
type Os interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Env() (map[string]interface{}, error)
	Path() ([]interface{}, error)
	Uptime() (*time.Time, error)
	Updates() ([]interface{}, error)
	Rebootpending() (bool, error)
	Hostname() (string, error)
	Machineid() (string, error)
}

// mqlOs for the os resource
type mqlOs struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOs) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os resource
func newOs(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOs{runtime.NewResource("os")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "env":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"env\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "path":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"path\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "uptime":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"uptime\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updates":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"updates\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "rebootpending":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"rebootpending\" argument has the wrong type (expected type \"bool\")")
			}
		case "hostname":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"hostname\" argument has the wrong type (expected type \"string\")")
			}
		case "machineid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"machineid\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOs) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlOs) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os].Register")
	switch name {
	case "name":
		return nil
	case "env":
		return nil
	case "path":
		return nil
	case "uptime":
		return nil
	case "updates":
		return nil
	case "rebootpending":
		return nil
	case "hostname":
		return nil
	case "machineid":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOs) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os].Field")
	switch name {
	case "name":
		return s.Name()
	case "env":
		return s.Env()
	case "path":
		return s.Path()
	case "uptime":
		return s.Uptime()
	case "updates":
		return s.Updates()
	case "rebootpending":
		return s.Rebootpending()
	case "hostname":
		return s.Hostname()
	case "machineid":
		return s.Machineid()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlOs) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		if err := s.ComputeName(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("name")
		if !ok {
			return "", errors.New("\"os\" calculated \"name\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "name")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Env accessor autogenerated
func (s *mqlOs) Env() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("env")
	if !ok || !res.Valid {
		if err := s.ComputeEnv(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("env")
		if !ok {
			return nil, errors.New("\"os\" calculated \"env\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "env")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os\" failed to cast field \"env\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Path accessor autogenerated
func (s *mqlOs) Path() ([]interface{}, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		if err := s.ComputePath(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("path")
		if !ok {
			return nil, errors.New("\"os\" calculated \"path\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "path")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os\" failed to cast field \"path\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Uptime accessor autogenerated
func (s *mqlOs) Uptime() (*time.Time, error) {
	res, ok := s.Cache.Load("uptime")
	if !ok || !res.Valid {
		if err := s.ComputeUptime(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("uptime")
		if !ok {
			return nil, errors.New("\"os\" calculated \"uptime\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "uptime")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"os\" failed to cast field \"uptime\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Updates accessor autogenerated
func (s *mqlOs) Updates() ([]interface{}, error) {
	res, ok := s.Cache.Load("updates")
	if !ok || !res.Valid {
		if err := s.ComputeUpdates(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("updates")
		if !ok {
			return nil, errors.New("\"os\" calculated \"updates\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "updates")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os\" failed to cast field \"updates\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Rebootpending accessor autogenerated
func (s *mqlOs) Rebootpending() (bool, error) {
	res, ok := s.Cache.Load("rebootpending")
	if !ok || !res.Valid {
		if err := s.ComputeRebootpending(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("rebootpending")
		if !ok {
			return false, errors.New("\"os\" calculated \"rebootpending\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "rebootpending")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"os\" failed to cast field \"rebootpending\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Hostname accessor autogenerated
func (s *mqlOs) Hostname() (string, error) {
	res, ok := s.Cache.Load("hostname")
	if !ok || !res.Valid {
		if err := s.ComputeHostname(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("hostname")
		if !ok {
			return "", errors.New("\"os\" calculated \"hostname\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "hostname")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os\" failed to cast field \"hostname\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Machineid accessor autogenerated
func (s *mqlOs) Machineid() (string, error) {
	res, ok := s.Cache.Load("machineid")
	if !ok || !res.Valid {
		if err := s.ComputeMachineid(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("machineid")
		if !ok {
			return "", errors.New("\"os\" calculated \"machineid\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "machineid")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os\" failed to cast field \"machineid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOs) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os].MqlCompute")
	switch name {
	case "name":
		return s.ComputeName()
	case "env":
		return s.ComputeEnv()
	case "path":
		return s.ComputePath()
	case "uptime":
		return s.ComputeUptime()
	case "updates":
		return s.ComputeUpdates()
	case "rebootpending":
		return s.ComputeRebootpending()
	case "hostname":
		return s.ComputeHostname()
	case "machineid":
		return s.ComputeMachineid()
	default:
		return errors.New("Cannot find field '" + name + "' in \"os\" resource")
	}
}

// ComputeName computer autogenerated
func (s *mqlOs) ComputeName() error {
	var err error
	if _, ok := s.Cache.Load("name"); ok {
		return nil
	}
	vres, err := s.GetName()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("name", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEnv computer autogenerated
func (s *mqlOs) ComputeEnv() error {
	var err error
	if _, ok := s.Cache.Load("env"); ok {
		return nil
	}
	vres, err := s.GetEnv()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("env", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePath computer autogenerated
func (s *mqlOs) ComputePath() error {
	var err error
	if _, ok := s.Cache.Load("path"); ok {
		return nil
	}
	vres, err := s.GetPath()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("path", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUptime computer autogenerated
func (s *mqlOs) ComputeUptime() error {
	var err error
	if _, ok := s.Cache.Load("uptime"); ok {
		return nil
	}
	vres, err := s.GetUptime()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("uptime", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUpdates computer autogenerated
func (s *mqlOs) ComputeUpdates() error {
	var err error
	if _, ok := s.Cache.Load("updates"); ok {
		return nil
	}
	vres, err := s.GetUpdates()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("updates", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRebootpending computer autogenerated
func (s *mqlOs) ComputeRebootpending() error {
	var err error
	if _, ok := s.Cache.Load("rebootpending"); ok {
		return nil
	}
	vres, err := s.GetRebootpending()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("rebootpending", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHostname computer autogenerated
func (s *mqlOs) ComputeHostname() error {
	var err error
	if _, ok := s.Cache.Load("hostname"); ok {
		return nil
	}
	vres, err := s.GetHostname()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("hostname", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMachineid computer autogenerated
func (s *mqlOs) ComputeMachineid() error {
	var err error
	if _, ok := s.Cache.Load("machineid"); ok {
		return nil
	}
	vres, err := s.GetMachineid()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("machineid", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OsUpdate resource interface
type OsUpdate interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Category() (string, error)
	Severity() (string, error)
	Restart() (bool, error)
	Format() (string, error)
}

// mqlOsUpdate for the os.update resource
type mqlOsUpdate struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOsUpdate) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os.update resource
func newOsUpdate(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOsUpdate{runtime.NewResource("os.update")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "category":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"category\" argument has the wrong type (expected type \"string\")")
			}
		case "severity":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"severity\" argument has the wrong type (expected type \"string\")")
			}
		case "restart":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"restart\" argument has the wrong type (expected type \"bool\")")
			}
		case "format":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"format\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os.update\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os.update with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOsUpdate) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"os.update\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("category"); !ok {
		return errors.New("Initialized \"os.update\" resource without a \"category\". This field is required.")
	}
	if _, ok := s.Cache.Load("severity"); !ok {
		return errors.New("Initialized \"os.update\" resource without a \"severity\". This field is required.")
	}
	if _, ok := s.Cache.Load("restart"); !ok {
		return errors.New("Initialized \"os.update\" resource without a \"restart\". This field is required.")
	}
	if _, ok := s.Cache.Load("format"); !ok {
		return errors.New("Initialized \"os.update\" resource without a \"format\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlOsUpdate) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os.update].Register")
	switch name {
	case "name":
		return nil
	case "category":
		return nil
	case "severity":
		return nil
	case "restart":
		return nil
	case "format":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.update\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOsUpdate) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os.update].Field")
	switch name {
	case "name":
		return s.Name()
	case "category":
		return s.Category()
	case "severity":
		return s.Severity()
	case "restart":
		return s.Restart()
	case "format":
		return s.Format()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os.update\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlOsUpdate) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"os.update\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.update\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Category accessor autogenerated
func (s *mqlOsUpdate) Category() (string, error) {
	res, ok := s.Cache.Load("category")
	if !ok || !res.Valid {
		return "", errors.New("\"os.update\" failed: no value provided for static field \"category\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.update\" failed to cast field \"category\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Severity accessor autogenerated
func (s *mqlOsUpdate) Severity() (string, error) {
	res, ok := s.Cache.Load("severity")
	if !ok || !res.Valid {
		return "", errors.New("\"os.update\" failed: no value provided for static field \"severity\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.update\" failed to cast field \"severity\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Restart accessor autogenerated
func (s *mqlOsUpdate) Restart() (bool, error) {
	res, ok := s.Cache.Load("restart")
	if !ok || !res.Valid {
		return false, errors.New("\"os.update\" failed: no value provided for static field \"restart\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"os.update\" failed to cast field \"restart\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Format accessor autogenerated
func (s *mqlOsUpdate) Format() (string, error) {
	res, ok := s.Cache.Load("format")
	if !ok || !res.Valid {
		return "", errors.New("\"os.update\" failed: no value provided for static field \"format\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"os.update\" failed to cast field \"format\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOsUpdate) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os.update].MqlCompute")
	switch name {
	case "name":
		return nil
	case "category":
		return nil
	case "severity":
		return nil
	case "restart":
		return nil
	case "format":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.update\" resource")
	}
}

// OsRootCertificates resource interface
type OsRootCertificates interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Files() ([]interface{}, error)
	Content() ([]interface{}, error)
	List() ([]interface{}, error)
}

// mqlOsRootCertificates for the os.rootCertificates resource
type mqlOsRootCertificates struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOsRootCertificates) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the os.rootCertificates resource
func newOsRootCertificates(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOsRootCertificates{runtime.NewResource("os.rootCertificates")}
	var existing OsRootCertificates
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.rootCertificates\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "content":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.rootCertificates\", its \"content\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"os.rootCertificates\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"os.rootCertificates\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized os.rootCertificates with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOsRootCertificates) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlOsRootCertificates) Register(name string) error {
	log.Trace().Str("field", name).Msg("[os.rootCertificates].Register")
	switch name {
	case "files":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "files", s, "content"); err != nil {
			return err
		}
		return nil
	case "list":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "list"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.rootCertificates\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOsRootCertificates) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[os.rootCertificates].Field")
	switch name {
	case "files":
		return s.Files()
	case "content":
		return s.Content()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"os.rootCertificates\" resource")
	}
}

// Files accessor autogenerated
func (s *mqlOsRootCertificates) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"os.rootCertificates\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.rootCertificates\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlOsRootCertificates) Content() ([]interface{}, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.rootCertificates\" failed to cast field \"content\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlOsRootCertificates) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"os.rootCertificates\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOsRootCertificates) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[os.rootCertificates].MqlCompute")
	switch name {
	case "files":
		return s.ComputeFiles()
	case "content":
		return s.ComputeContent()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"os.rootCertificates\" resource")
	}
}

// ComputeFiles computer autogenerated
func (s *mqlOsRootCertificates) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlOsRootCertificates) ComputeContent() error {
	var err error
	vargFiles, err := s.Files()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFiles)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlOsRootCertificates) ComputeList() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetList(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Service resource interface
type Service interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Description() (string, error)
	Installed() (bool, error)
	Running() (bool, error)
	Enabled() (bool, error)
	Type() (string, error)
	Masked() (bool, error)
}

// mqlService for the service resource
type mqlService struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlService) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the service resource
func newService(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlService{runtime.NewResource("service")}
	var existing Service
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "installed":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"installed\" argument has the wrong type (expected type \"bool\")")
			}
		case "running":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"running\" argument has the wrong type (expected type \"bool\")")
			}
		case "enabled":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"enabled\" argument has the wrong type (expected type \"bool\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "masked":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"masked\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"service\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized service with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlService) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"service\" resource without a \"name\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlService) Register(name string) error {
	log.Trace().Str("field", name).Msg("[service].Register")
	switch name {
	case "name":
		return nil
	case "description":
		return nil
	case "installed":
		return nil
	case "running":
		return nil
	case "enabled":
		return nil
	case "type":
		return nil
	case "masked":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"service\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlService) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[service].Field")
	switch name {
	case "name":
		return s.Name()
	case "description":
		return s.Description()
	case "installed":
		return s.Installed()
	case "running":
		return s.Running()
	case "enabled":
		return s.Enabled()
	case "type":
		return s.Type()
	case "masked":
		return s.Masked()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"service\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlService) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"service\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"service\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlService) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		if err := s.ComputeDescription(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("description")
		if !ok {
			return "", errors.New("\"service\" calculated \"description\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "description")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"service\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Installed accessor autogenerated
func (s *mqlService) Installed() (bool, error) {
	res, ok := s.Cache.Load("installed")
	if !ok || !res.Valid {
		if err := s.ComputeInstalled(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("installed")
		if !ok {
			return false, errors.New("\"service\" calculated \"installed\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "installed")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"service\" failed to cast field \"installed\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Running accessor autogenerated
func (s *mqlService) Running() (bool, error) {
	res, ok := s.Cache.Load("running")
	if !ok || !res.Valid {
		if err := s.ComputeRunning(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("running")
		if !ok {
			return false, errors.New("\"service\" calculated \"running\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "running")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"service\" failed to cast field \"running\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Enabled accessor autogenerated
func (s *mqlService) Enabled() (bool, error) {
	res, ok := s.Cache.Load("enabled")
	if !ok || !res.Valid {
		if err := s.ComputeEnabled(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("enabled")
		if !ok {
			return false, errors.New("\"service\" calculated \"enabled\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "enabled")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"service\" failed to cast field \"enabled\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlService) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		if err := s.ComputeType(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("type")
		if !ok {
			return "", errors.New("\"service\" calculated \"type\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "type")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"service\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Masked accessor autogenerated
func (s *mqlService) Masked() (bool, error) {
	res, ok := s.Cache.Load("masked")
	if !ok || !res.Valid {
		if err := s.ComputeMasked(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("masked")
		if !ok {
			return false, errors.New("\"service\" calculated \"masked\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "masked")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"service\" failed to cast field \"masked\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlService) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[service].MqlCompute")
	switch name {
	case "name":
		return nil
	case "description":
		return s.ComputeDescription()
	case "installed":
		return s.ComputeInstalled()
	case "running":
		return s.ComputeRunning()
	case "enabled":
		return s.ComputeEnabled()
	case "type":
		return s.ComputeType()
	case "masked":
		return s.ComputeMasked()
	default:
		return errors.New("Cannot find field '" + name + "' in \"service\" resource")
	}
}

// ComputeDescription computer autogenerated
func (s *mqlService) ComputeDescription() error {
	var err error
	if _, ok := s.Cache.Load("description"); ok {
		return nil
	}
	vres, err := s.GetDescription()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("description", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeInstalled computer autogenerated
func (s *mqlService) ComputeInstalled() error {
	var err error
	if _, ok := s.Cache.Load("installed"); ok {
		return nil
	}
	vres, err := s.GetInstalled()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("installed", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRunning computer autogenerated
func (s *mqlService) ComputeRunning() error {
	var err error
	if _, ok := s.Cache.Load("running"); ok {
		return nil
	}
	vres, err := s.GetRunning()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("running", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEnabled computer autogenerated
func (s *mqlService) ComputeEnabled() error {
	var err error
	if _, ok := s.Cache.Load("enabled"); ok {
		return nil
	}
	vres, err := s.GetEnabled()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("enabled", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeType computer autogenerated
func (s *mqlService) ComputeType() error {
	var err error
	if _, ok := s.Cache.Load("type"); ok {
		return nil
	}
	vres, err := s.GetType()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("type", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMasked computer autogenerated
func (s *mqlService) ComputeMasked() error {
	var err error
	if _, ok := s.Cache.Load("masked"); ok {
		return nil
	}
	vres, err := s.GetMasked()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("masked", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Services resource interface
type Services interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlServices for the services resource
type mqlServices struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlServices) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the services resource
func newServices(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlServices{runtime.NewResource("services")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"services\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"services\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized services with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlServices) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlServices) Register(name string) error {
	log.Trace().Str("field", name).Msg("[services].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"services\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlServices) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[services].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"services\" resource")
	}
}

// List accessor autogenerated
func (s *mqlServices) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"services\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"services\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlServices) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[services].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"services\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlServices) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Docker resource interface
type Docker interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Images() ([]interface{}, error)
	Containers() ([]interface{}, error)
}

// mqlDocker for the docker resource
type mqlDocker struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDocker) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the docker resource
func newDocker(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDocker{runtime.NewResource("docker")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "images":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker\", its \"images\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "containers":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker\", its \"containers\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"docker\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized docker with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDocker) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlDocker) Register(name string) error {
	log.Trace().Str("field", name).Msg("[docker].Register")
	switch name {
	case "images":
		return nil
	case "containers":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDocker) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[docker].Field")
	switch name {
	case "images":
		return s.Images()
	case "containers":
		return s.Containers()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"docker\" resource")
	}
}

// Images accessor autogenerated
func (s *mqlDocker) Images() ([]interface{}, error) {
	res, ok := s.Cache.Load("images")
	if !ok || !res.Valid {
		if err := s.ComputeImages(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("images")
		if !ok {
			return nil, errors.New("\"docker\" calculated \"images\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "images")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker\" failed to cast field \"images\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Containers accessor autogenerated
func (s *mqlDocker) Containers() ([]interface{}, error) {
	res, ok := s.Cache.Load("containers")
	if !ok || !res.Valid {
		if err := s.ComputeContainers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("containers")
		if !ok {
			return nil, errors.New("\"docker\" calculated \"containers\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "containers")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker\" failed to cast field \"containers\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDocker) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[docker].MqlCompute")
	switch name {
	case "images":
		return s.ComputeImages()
	case "containers":
		return s.ComputeContainers()
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker\" resource")
	}
}

// ComputeImages computer autogenerated
func (s *mqlDocker) ComputeImages() error {
	var err error
	if _, ok := s.Cache.Load("images"); ok {
		return nil
	}
	vres, err := s.GetImages()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("images", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContainers computer autogenerated
func (s *mqlDocker) ComputeContainers() error {
	var err error
	if _, ok := s.Cache.Load("containers"); ok {
		return nil
	}
	vres, err := s.GetContainers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("containers", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// DockerImage resource interface
type DockerImage interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Size() (int64, error)
	Virtualsize() (int64, error)
	Tags() ([]interface{}, error)
	Labels() (map[string]interface{}, error)
}

// mqlDockerImage for the docker.image resource
type mqlDockerImage struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDockerImage) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the docker.image resource
func newDockerImage(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDockerImage{runtime.NewResource("docker.image")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "size":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"size\" argument has the wrong type (expected type \"int64\")")
			}
		case "virtualsize":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"virtualsize\" argument has the wrong type (expected type \"int64\")")
			}
		case "tags":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"tags\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "labels":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"labels\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"docker.image\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized docker.image with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDockerImage) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"docker.image\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("size"); !ok {
		return errors.New("Initialized \"docker.image\" resource without a \"size\". This field is required.")
	}
	if _, ok := s.Cache.Load("virtualsize"); !ok {
		return errors.New("Initialized \"docker.image\" resource without a \"virtualsize\". This field is required.")
	}
	if _, ok := s.Cache.Load("tags"); !ok {
		return errors.New("Initialized \"docker.image\" resource without a \"tags\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"docker.image\" resource without a \"labels\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDockerImage) Register(name string) error {
	log.Trace().Str("field", name).Msg("[docker.image].Register")
	switch name {
	case "id":
		return nil
	case "size":
		return nil
	case "virtualsize":
		return nil
	case "tags":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker.image\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDockerImage) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[docker.image].Field")
	switch name {
	case "id":
		return s.Id()
	case "size":
		return s.Size()
	case "virtualsize":
		return s.Virtualsize()
	case "tags":
		return s.Tags()
	case "labels":
		return s.Labels()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"docker.image\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlDockerImage) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.image\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.image\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Size accessor autogenerated
func (s *mqlDockerImage) Size() (int64, error) {
	res, ok := s.Cache.Load("size")
	if !ok || !res.Valid {
		return 0, errors.New("\"docker.image\" failed: no value provided for static field \"size\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"docker.image\" failed to cast field \"size\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Virtualsize accessor autogenerated
func (s *mqlDockerImage) Virtualsize() (int64, error) {
	res, ok := s.Cache.Load("virtualsize")
	if !ok || !res.Valid {
		return 0, errors.New("\"docker.image\" failed: no value provided for static field \"virtualsize\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"docker.image\" failed to cast field \"virtualsize\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Tags accessor autogenerated
func (s *mqlDockerImage) Tags() ([]interface{}, error) {
	res, ok := s.Cache.Load("tags")
	if !ok || !res.Valid {
		return nil, errors.New("\"docker.image\" failed: no value provided for static field \"tags\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker.image\" failed to cast field \"tags\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlDockerImage) Labels() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"docker.image\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker.image\" failed to cast field \"labels\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDockerImage) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[docker.image].MqlCompute")
	switch name {
	case "id":
		return nil
	case "size":
		return nil
	case "virtualsize":
		return nil
	case "tags":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker.image\" resource")
	}
}

// DockerContainer resource interface
type DockerContainer interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Os() (resources.ResourceType, error)
	Id() (string, error)
	Command() (string, error)
	Image() (string, error)
	Imageid() (string, error)
	Names() ([]interface{}, error)
	State() (string, error)
	Status() (string, error)
	Labels() (map[string]interface{}, error)
}

// mqlDockerContainer for the docker.container resource
type mqlDockerContainer struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDockerContainer) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the docker.container resource
func newDockerContainer(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDockerContainer{runtime.NewResource("docker.container")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "os":
			if _, ok := val.(OsLinux); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"os\" argument has the wrong type (expected type \"OsLinux\")")
			}
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "command":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"command\" argument has the wrong type (expected type \"string\")")
			}
		case "image":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"image\" argument has the wrong type (expected type \"string\")")
			}
		case "imageid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"imageid\" argument has the wrong type (expected type \"string\")")
			}
		case "names":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"names\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "status":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"status\" argument has the wrong type (expected type \"string\")")
			}
		case "labels":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"labels\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"docker.container\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized docker.container with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDockerContainer) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("command"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"command\". This field is required.")
	}
	if _, ok := s.Cache.Load("image"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"image\". This field is required.")
	}
	if _, ok := s.Cache.Load("imageid"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"imageid\". This field is required.")
	}
	if _, ok := s.Cache.Load("names"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"names\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("status"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"status\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"docker.container\" resource without a \"labels\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDockerContainer) Register(name string) error {
	log.Trace().Str("field", name).Msg("[docker.container].Register")
	switch name {
	case "os":
		return nil
	case "id":
		return nil
	case "command":
		return nil
	case "image":
		return nil
	case "imageid":
		return nil
	case "names":
		return nil
	case "state":
		return nil
	case "status":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker.container\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDockerContainer) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[docker.container].Field")
	switch name {
	case "os":
		return s.Os()
	case "id":
		return s.Id()
	case "command":
		return s.Command()
	case "image":
		return s.Image()
	case "imageid":
		return s.Imageid()
	case "names":
		return s.Names()
	case "state":
		return s.State()
	case "status":
		return s.Status()
	case "labels":
		return s.Labels()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"docker.container\" resource")
	}
}

// Os accessor autogenerated
func (s *mqlDockerContainer) Os() (resources.ResourceType, error) {
	res, ok := s.Cache.Load("os")
	if !ok || !res.Valid {
		if err := s.ComputeOs(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("os")
		if !ok {
			return nil, errors.New("\"docker.container\" calculated \"os\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "os")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(OsLinux)
	if !ok {
		return nil, fmt.Errorf("\"docker.container\" failed to cast field \"os\" to the right type (OsLinux): %#v", res)
	}
	return tres, nil
}

// Id accessor autogenerated
func (s *mqlDockerContainer) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Command accessor autogenerated
func (s *mqlDockerContainer) Command() (string, error) {
	res, ok := s.Cache.Load("command")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"command\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"command\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Image accessor autogenerated
func (s *mqlDockerContainer) Image() (string, error) {
	res, ok := s.Cache.Load("image")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"image\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"image\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Imageid accessor autogenerated
func (s *mqlDockerContainer) Imageid() (string, error) {
	res, ok := s.Cache.Load("imageid")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"imageid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"imageid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Names accessor autogenerated
func (s *mqlDockerContainer) Names() ([]interface{}, error) {
	res, ok := s.Cache.Load("names")
	if !ok || !res.Valid {
		return nil, errors.New("\"docker.container\" failed: no value provided for static field \"names\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker.container\" failed to cast field \"names\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlDockerContainer) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Status accessor autogenerated
func (s *mqlDockerContainer) Status() (string, error) {
	res, ok := s.Cache.Load("status")
	if !ok || !res.Valid {
		return "", errors.New("\"docker.container\" failed: no value provided for static field \"status\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"docker.container\" failed to cast field \"status\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlDockerContainer) Labels() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"docker.container\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"docker.container\" failed to cast field \"labels\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDockerContainer) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[docker.container].MqlCompute")
	switch name {
	case "os":
		return s.ComputeOs()
	case "id":
		return nil
	case "command":
		return nil
	case "image":
		return nil
	case "imageid":
		return nil
	case "names":
		return nil
	case "state":
		return nil
	case "status":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"docker.container\" resource")
	}
}

// ComputeOs computer autogenerated
func (s *mqlDockerContainer) ComputeOs() error {
	var err error
	if _, ok := s.Cache.Load("os"); ok {
		return nil
	}
	vres, err := s.GetOs()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("os", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Auditpol resource interface
type Auditpol interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlAuditpol for the auditpol resource
type mqlAuditpol struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuditpol) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the auditpol resource
func newAuditpol(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuditpol{runtime.NewResource("auditpol")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"auditpol\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"auditpol\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized auditpol with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuditpol) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlAuditpol) Register(name string) error {
	log.Trace().Str("field", name).Msg("[auditpol].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"auditpol\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuditpol) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[auditpol].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"auditpol\" resource")
	}
}

// List accessor autogenerated
func (s *mqlAuditpol) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"auditpol\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"auditpol\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuditpol) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[auditpol].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"auditpol\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlAuditpol) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// AuditpolEntry resource interface
type AuditpolEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Machinename() (string, error)
	Policytarget() (string, error)
	Subcategory() (string, error)
	Subcategoryguid() (string, error)
	Inclusionsetting() (string, error)
	Exclusionsetting() (string, error)
}

// mqlAuditpolEntry for the auditpol.entry resource
type mqlAuditpolEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuditpolEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the auditpol.entry resource
func newAuditpolEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuditpolEntry{runtime.NewResource("auditpol.entry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "machinename":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"machinename\" argument has the wrong type (expected type \"string\")")
			}
		case "policytarget":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"policytarget\" argument has the wrong type (expected type \"string\")")
			}
		case "subcategory":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"subcategory\" argument has the wrong type (expected type \"string\")")
			}
		case "subcategoryguid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"subcategoryguid\" argument has the wrong type (expected type \"string\")")
			}
		case "inclusionsetting":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"inclusionsetting\" argument has the wrong type (expected type \"string\")")
			}
		case "exclusionsetting":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"exclusionsetting\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"auditpol.entry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized auditpol.entry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuditpolEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("machinename"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"machinename\". This field is required.")
	}
	if _, ok := s.Cache.Load("policytarget"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"policytarget\". This field is required.")
	}
	if _, ok := s.Cache.Load("subcategory"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"subcategory\". This field is required.")
	}
	if _, ok := s.Cache.Load("subcategoryguid"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"subcategoryguid\". This field is required.")
	}
	if _, ok := s.Cache.Load("inclusionsetting"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"inclusionsetting\". This field is required.")
	}
	if _, ok := s.Cache.Load("exclusionsetting"); !ok {
		return errors.New("Initialized \"auditpol.entry\" resource without a \"exclusionsetting\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuditpolEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[auditpol.entry].Register")
	switch name {
	case "machinename":
		return nil
	case "policytarget":
		return nil
	case "subcategory":
		return nil
	case "subcategoryguid":
		return nil
	case "inclusionsetting":
		return nil
	case "exclusionsetting":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"auditpol.entry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuditpolEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[auditpol.entry].Field")
	switch name {
	case "machinename":
		return s.Machinename()
	case "policytarget":
		return s.Policytarget()
	case "subcategory":
		return s.Subcategory()
	case "subcategoryguid":
		return s.Subcategoryguid()
	case "inclusionsetting":
		return s.Inclusionsetting()
	case "exclusionsetting":
		return s.Exclusionsetting()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"auditpol.entry\" resource")
	}
}

// Machinename accessor autogenerated
func (s *mqlAuditpolEntry) Machinename() (string, error) {
	res, ok := s.Cache.Load("machinename")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"machinename\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"machinename\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Policytarget accessor autogenerated
func (s *mqlAuditpolEntry) Policytarget() (string, error) {
	res, ok := s.Cache.Load("policytarget")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"policytarget\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"policytarget\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Subcategory accessor autogenerated
func (s *mqlAuditpolEntry) Subcategory() (string, error) {
	res, ok := s.Cache.Load("subcategory")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"subcategory\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"subcategory\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Subcategoryguid accessor autogenerated
func (s *mqlAuditpolEntry) Subcategoryguid() (string, error) {
	res, ok := s.Cache.Load("subcategoryguid")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"subcategoryguid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"subcategoryguid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Inclusionsetting accessor autogenerated
func (s *mqlAuditpolEntry) Inclusionsetting() (string, error) {
	res, ok := s.Cache.Load("inclusionsetting")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"inclusionsetting\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"inclusionsetting\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exclusionsetting accessor autogenerated
func (s *mqlAuditpolEntry) Exclusionsetting() (string, error) {
	res, ok := s.Cache.Load("exclusionsetting")
	if !ok || !res.Valid {
		return "", errors.New("\"auditpol.entry\" failed: no value provided for static field \"exclusionsetting\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"auditpol.entry\" failed to cast field \"exclusionsetting\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuditpolEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[auditpol.entry].MqlCompute")
	switch name {
	case "machinename":
		return nil
	case "policytarget":
		return nil
	case "subcategory":
		return nil
	case "subcategoryguid":
		return nil
	case "inclusionsetting":
		return nil
	case "exclusionsetting":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"auditpol.entry\" resource")
	}
}

// Secpol resource interface
type Secpol interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Systemaccess() (map[string]interface{}, error)
	Eventaudit() (map[string]interface{}, error)
	Registryvalues() (map[string]interface{}, error)
	Privilegerights() (map[string]interface{}, error)
}

// mqlSecpol for the secpol resource
type mqlSecpol struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlSecpol) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the secpol resource
func newSecpol(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlSecpol{runtime.NewResource("secpol")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "systemaccess":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"secpol\", its \"systemaccess\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "eventaudit":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"secpol\", its \"eventaudit\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "registryvalues":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"secpol\", its \"registryvalues\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "privilegerights":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"secpol\", its \"privilegerights\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"secpol\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized secpol with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlSecpol) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlSecpol) Register(name string) error {
	log.Trace().Str("field", name).Msg("[secpol].Register")
	switch name {
	case "systemaccess":
		return nil
	case "eventaudit":
		return nil
	case "registryvalues":
		return nil
	case "privilegerights":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"secpol\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlSecpol) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[secpol].Field")
	switch name {
	case "systemaccess":
		return s.Systemaccess()
	case "eventaudit":
		return s.Eventaudit()
	case "registryvalues":
		return s.Registryvalues()
	case "privilegerights":
		return s.Privilegerights()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"secpol\" resource")
	}
}

// Systemaccess accessor autogenerated
func (s *mqlSecpol) Systemaccess() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("systemaccess")
	if !ok || !res.Valid {
		if err := s.ComputeSystemaccess(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("systemaccess")
		if !ok {
			return nil, errors.New("\"secpol\" calculated \"systemaccess\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "systemaccess")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"secpol\" failed to cast field \"systemaccess\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Eventaudit accessor autogenerated
func (s *mqlSecpol) Eventaudit() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("eventaudit")
	if !ok || !res.Valid {
		if err := s.ComputeEventaudit(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("eventaudit")
		if !ok {
			return nil, errors.New("\"secpol\" calculated \"eventaudit\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "eventaudit")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"secpol\" failed to cast field \"eventaudit\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Registryvalues accessor autogenerated
func (s *mqlSecpol) Registryvalues() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("registryvalues")
	if !ok || !res.Valid {
		if err := s.ComputeRegistryvalues(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("registryvalues")
		if !ok {
			return nil, errors.New("\"secpol\" calculated \"registryvalues\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "registryvalues")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"secpol\" failed to cast field \"registryvalues\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Privilegerights accessor autogenerated
func (s *mqlSecpol) Privilegerights() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("privilegerights")
	if !ok || !res.Valid {
		if err := s.ComputePrivilegerights(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("privilegerights")
		if !ok {
			return nil, errors.New("\"secpol\" calculated \"privilegerights\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "privilegerights")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"secpol\" failed to cast field \"privilegerights\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlSecpol) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[secpol].MqlCompute")
	switch name {
	case "systemaccess":
		return s.ComputeSystemaccess()
	case "eventaudit":
		return s.ComputeEventaudit()
	case "registryvalues":
		return s.ComputeRegistryvalues()
	case "privilegerights":
		return s.ComputePrivilegerights()
	default:
		return errors.New("Cannot find field '" + name + "' in \"secpol\" resource")
	}
}

// ComputeSystemaccess computer autogenerated
func (s *mqlSecpol) ComputeSystemaccess() error {
	var err error
	if _, ok := s.Cache.Load("systemaccess"); ok {
		return nil
	}
	vres, err := s.GetSystemaccess()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("systemaccess", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEventaudit computer autogenerated
func (s *mqlSecpol) ComputeEventaudit() error {
	var err error
	if _, ok := s.Cache.Load("eventaudit"); ok {
		return nil
	}
	vres, err := s.GetEventaudit()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("eventaudit", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRegistryvalues computer autogenerated
func (s *mqlSecpol) ComputeRegistryvalues() error {
	var err error
	if _, ok := s.Cache.Load("registryvalues"); ok {
		return nil
	}
	vres, err := s.GetRegistryvalues()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("registryvalues", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePrivilegerights computer autogenerated
func (s *mqlSecpol) ComputePrivilegerights() error {
	var err error
	if _, ok := s.Cache.Load("privilegerights"); ok {
		return nil
	}
	vres, err := s.GetPrivilegerights()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("privilegerights", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Logindefs resource interface
type Logindefs interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (core.File, error)
	Content() (string, error)
	Params() (map[string]interface{}, error)
}

// mqlLogindefs for the logindefs resource
type mqlLogindefs struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlLogindefs) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the logindefs resource
func newLogindefs(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlLogindefs{runtime.NewResource("logindefs")}
	var existing Logindefs
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(core.File); !ok {
				return nil, errors.New("Failed to initialize \"logindefs\", its \"file\" argument has the wrong type (expected type \"core.File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"logindefs\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"logindefs\", its \"params\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"logindefs\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized logindefs with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlLogindefs) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlLogindefs) Register(name string) error {
	log.Trace().Str("field", name).Msg("[logindefs].Register")
	switch name {
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "params"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"logindefs\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlLogindefs) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[logindefs].Field")
	switch name {
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "params":
		return s.Params()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"logindefs\" resource")
	}
}

// File accessor autogenerated
func (s *mqlLogindefs) File() (core.File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"logindefs\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.File)
	if !ok {
		return nil, fmt.Errorf("\"logindefs\" failed to cast field \"file\" to the right type (core.File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlLogindefs) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"logindefs\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlLogindefs) Params() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"logindefs\" failed to cast field \"params\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlLogindefs) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[logindefs].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "params":
		return s.ComputeParams()
	default:
		return errors.New("Cannot find field '" + name + "' in \"logindefs\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlLogindefs) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlLogindefs) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlLogindefs) ComputeParams() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Lsblk resource interface
type Lsblk interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlLsblk for the lsblk resource
type mqlLsblk struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlLsblk) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the lsblk resource
func newLsblk(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlLsblk{runtime.NewResource("lsblk")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"lsblk\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"lsblk\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized lsblk with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlLsblk) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlLsblk) Register(name string) error {
	log.Trace().Str("field", name).Msg("[lsblk].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"lsblk\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlLsblk) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[lsblk].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"lsblk\" resource")
	}
}

// List accessor autogenerated
func (s *mqlLsblk) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"lsblk\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"lsblk\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlLsblk) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[lsblk].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"lsblk\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlLsblk) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// LsblkEntry resource interface
type LsblkEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Fstype() (string, error)
	Label() (string, error)
	Uuid() (string, error)
	Mountpoints() ([]interface{}, error)
}

// mqlLsblkEntry for the lsblk.entry resource
type mqlLsblkEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlLsblkEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the lsblk.entry resource
func newLsblkEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlLsblkEntry{runtime.NewResource("lsblk.entry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "fstype":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"fstype\" argument has the wrong type (expected type \"string\")")
			}
		case "label":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"label\" argument has the wrong type (expected type \"string\")")
			}
		case "uuid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"uuid\" argument has the wrong type (expected type \"string\")")
			}
		case "mountpoints":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"mountpoints\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"lsblk.entry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized lsblk.entry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlLsblkEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"lsblk.entry\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("fstype"); !ok {
		return errors.New("Initialized \"lsblk.entry\" resource without a \"fstype\". This field is required.")
	}
	if _, ok := s.Cache.Load("label"); !ok {
		return errors.New("Initialized \"lsblk.entry\" resource without a \"label\". This field is required.")
	}
	if _, ok := s.Cache.Load("uuid"); !ok {
		return errors.New("Initialized \"lsblk.entry\" resource without a \"uuid\". This field is required.")
	}
	if _, ok := s.Cache.Load("mountpoints"); !ok {
		return errors.New("Initialized \"lsblk.entry\" resource without a \"mountpoints\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlLsblkEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[lsblk.entry].Register")
	switch name {
	case "name":
		return nil
	case "fstype":
		return nil
	case "label":
		return nil
	case "uuid":
		return nil
	case "mountpoints":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"lsblk.entry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlLsblkEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[lsblk.entry].Field")
	switch name {
	case "name":
		return s.Name()
	case "fstype":
		return s.Fstype()
	case "label":
		return s.Label()
	case "uuid":
		return s.Uuid()
	case "mountpoints":
		return s.Mountpoints()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"lsblk.entry\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlLsblkEntry) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"lsblk.entry\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"lsblk.entry\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Fstype accessor autogenerated
func (s *mqlLsblkEntry) Fstype() (string, error) {
	res, ok := s.Cache.Load("fstype")
	if !ok || !res.Valid {
		return "", errors.New("\"lsblk.entry\" failed: no value provided for static field \"fstype\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"lsblk.entry\" failed to cast field \"fstype\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Label accessor autogenerated
func (s *mqlLsblkEntry) Label() (string, error) {
	res, ok := s.Cache.Load("label")
	if !ok || !res.Valid {
		return "", errors.New("\"lsblk.entry\" failed: no value provided for static field \"label\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"lsblk.entry\" failed to cast field \"label\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Uuid accessor autogenerated
func (s *mqlLsblkEntry) Uuid() (string, error) {
	res, ok := s.Cache.Load("uuid")
	if !ok || !res.Valid {
		return "", errors.New("\"lsblk.entry\" failed: no value provided for static field \"uuid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"lsblk.entry\" failed to cast field \"uuid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mountpoints accessor autogenerated
func (s *mqlLsblkEntry) Mountpoints() ([]interface{}, error) {
	res, ok := s.Cache.Load("mountpoints")
	if !ok || !res.Valid {
		return nil, errors.New("\"lsblk.entry\" failed: no value provided for static field \"mountpoints\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"lsblk.entry\" failed to cast field \"mountpoints\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlLsblkEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[lsblk.entry].MqlCompute")
	switch name {
	case "name":
		return nil
	case "fstype":
		return nil
	case "label":
		return nil
	case "uuid":
		return nil
	case "mountpoints":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"lsblk.entry\" resource")
	}
}

// Mount resource interface
type Mount interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlMount for the mount resource
type mqlMount struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMount) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the mount resource
func newMount(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMount{runtime.NewResource("mount")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mount\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"mount\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized mount with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMount) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMount) Register(name string) error {
	log.Trace().Str("field", name).Msg("[mount].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mount\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMount) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[mount].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"mount\" resource")
	}
}

// List accessor autogenerated
func (s *mqlMount) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"mount\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"mount\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMount) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[mount].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"mount\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlMount) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MountPoint resource interface
type MountPoint interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Device() (string, error)
	Path() (string, error)
	Fstype() (string, error)
	Options() (map[string]interface{}, error)
	Mounted() (bool, error)
}

// mqlMountPoint for the mount.point resource
type mqlMountPoint struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMountPoint) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the mount.point resource
func newMountPoint(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMountPoint{runtime.NewResource("mount.point")}
	var existing MountPoint
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "device":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"device\" argument has the wrong type (expected type \"string\")")
			}
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "fstype":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"fstype\" argument has the wrong type (expected type \"string\")")
			}
		case "options":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"options\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "mounted":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"mounted\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"mount.point\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized mount.point with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMountPoint) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("device"); !ok {
		return errors.New("Initialized \"mount.point\" resource without a \"device\". This field is required.")
	}
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"mount.point\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("fstype"); !ok {
		return errors.New("Initialized \"mount.point\" resource without a \"fstype\". This field is required.")
	}
	if _, ok := s.Cache.Load("options"); !ok {
		return errors.New("Initialized \"mount.point\" resource without a \"options\". This field is required.")
	}
	if _, ok := s.Cache.Load("mounted"); !ok {
		return errors.New("Initialized \"mount.point\" resource without a \"mounted\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMountPoint) Register(name string) error {
	log.Trace().Str("field", name).Msg("[mount.point].Register")
	switch name {
	case "device":
		return nil
	case "path":
		return nil
	case "fstype":
		return nil
	case "options":
		return nil
	case "mounted":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mount.point\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMountPoint) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[mount.point].Field")
	switch name {
	case "device":
		return s.Device()
	case "path":
		return s.Path()
	case "fstype":
		return s.Fstype()
	case "options":
		return s.Options()
	case "mounted":
		return s.Mounted()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"mount.point\" resource")
	}
}

// Device accessor autogenerated
func (s *mqlMountPoint) Device() (string, error) {
	res, ok := s.Cache.Load("device")
	if !ok || !res.Valid {
		return "", errors.New("\"mount.point\" failed: no value provided for static field \"device\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mount.point\" failed to cast field \"device\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Path accessor autogenerated
func (s *mqlMountPoint) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"mount.point\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mount.point\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Fstype accessor autogenerated
func (s *mqlMountPoint) Fstype() (string, error) {
	res, ok := s.Cache.Load("fstype")
	if !ok || !res.Valid {
		return "", errors.New("\"mount.point\" failed: no value provided for static field \"fstype\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mount.point\" failed to cast field \"fstype\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Options accessor autogenerated
func (s *mqlMountPoint) Options() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("options")
	if !ok || !res.Valid {
		return nil, errors.New("\"mount.point\" failed: no value provided for static field \"options\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"mount.point\" failed to cast field \"options\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Mounted accessor autogenerated
func (s *mqlMountPoint) Mounted() (bool, error) {
	res, ok := s.Cache.Load("mounted")
	if !ok || !res.Valid {
		return false, errors.New("\"mount.point\" failed: no value provided for static field \"mounted\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"mount.point\" failed to cast field \"mounted\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMountPoint) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[mount.point].MqlCompute")
	switch name {
	case "device":
		return nil
	case "path":
		return nil
	case "fstype":
		return nil
	case "options":
		return nil
	case "mounted":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mount.point\" resource")
	}
}

// Shadow resource interface
type Shadow interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlShadow for the shadow resource
type mqlShadow struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlShadow) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the shadow resource
func newShadow(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlShadow{runtime.NewResource("shadow")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"shadow\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"shadow\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized shadow with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlShadow) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlShadow) Register(name string) error {
	log.Trace().Str("field", name).Msg("[shadow].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"shadow\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlShadow) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[shadow].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"shadow\" resource")
	}
}

// List accessor autogenerated
func (s *mqlShadow) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"shadow\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"shadow\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlShadow) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[shadow].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"shadow\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlShadow) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ShadowEntry resource interface
type ShadowEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	User() (string, error)
	Password() (string, error)
	Lastchanged() (*time.Time, error)
	Mindays() (int64, error)
	Maxdays() (int64, error)
	Warndays() (int64, error)
	Inactivedays() (int64, error)
	Expirydates() (string, error)
	Reserved() (string, error)
}

// mqlShadowEntry for the shadow.entry resource
type mqlShadowEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlShadowEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the shadow.entry resource
func newShadowEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlShadowEntry{runtime.NewResource("shadow.entry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "user":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"user\" argument has the wrong type (expected type \"string\")")
			}
		case "password":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"password\" argument has the wrong type (expected type \"string\")")
			}
		case "lastchanged":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"lastchanged\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "mindays":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"mindays\" argument has the wrong type (expected type \"int64\")")
			}
		case "maxdays":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"maxdays\" argument has the wrong type (expected type \"int64\")")
			}
		case "warndays":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"warndays\" argument has the wrong type (expected type \"int64\")")
			}
		case "inactivedays":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"inactivedays\" argument has the wrong type (expected type \"int64\")")
			}
		case "expirydates":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"expirydates\" argument has the wrong type (expected type \"string\")")
			}
		case "reserved":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"reserved\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"shadow.entry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized shadow.entry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlShadowEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("user"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"user\". This field is required.")
	}
	if _, ok := s.Cache.Load("password"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"password\". This field is required.")
	}
	if _, ok := s.Cache.Load("lastchanged"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"lastchanged\". This field is required.")
	}
	if _, ok := s.Cache.Load("mindays"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"mindays\". This field is required.")
	}
	if _, ok := s.Cache.Load("maxdays"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"maxdays\". This field is required.")
	}
	if _, ok := s.Cache.Load("warndays"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"warndays\". This field is required.")
	}
	if _, ok := s.Cache.Load("inactivedays"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"inactivedays\". This field is required.")
	}
	if _, ok := s.Cache.Load("expirydates"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"expirydates\". This field is required.")
	}
	if _, ok := s.Cache.Load("reserved"); !ok {
		return errors.New("Initialized \"shadow.entry\" resource without a \"reserved\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlShadowEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[shadow.entry].Register")
	switch name {
	case "user":
		return nil
	case "password":
		return nil
	case "lastchanged":
		return nil
	case "mindays":
		return nil
	case "maxdays":
		return nil
	case "warndays":
		return nil
	case "inactivedays":
		return nil
	case "expirydates":
		return nil
	case "reserved":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"shadow.entry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlShadowEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[shadow.entry].Field")
	switch name {
	case "user":
		return s.User()
	case "password":
		return s.Password()
	case "lastchanged":
		return s.Lastchanged()
	case "mindays":
		return s.Mindays()
	case "maxdays":
		return s.Maxdays()
	case "warndays":
		return s.Warndays()
	case "inactivedays":
		return s.Inactivedays()
	case "expirydates":
		return s.Expirydates()
	case "reserved":
		return s.Reserved()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"shadow.entry\" resource")
	}
}

// User accessor autogenerated
func (s *mqlShadowEntry) User() (string, error) {
	res, ok := s.Cache.Load("user")
	if !ok || !res.Valid {
		return "", errors.New("\"shadow.entry\" failed: no value provided for static field \"user\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"shadow.entry\" failed to cast field \"user\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Password accessor autogenerated
func (s *mqlShadowEntry) Password() (string, error) {
	res, ok := s.Cache.Load("password")
	if !ok || !res.Valid {
		return "", errors.New("\"shadow.entry\" failed: no value provided for static field \"password\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"shadow.entry\" failed to cast field \"password\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Lastchanged accessor autogenerated
func (s *mqlShadowEntry) Lastchanged() (*time.Time, error) {
	res, ok := s.Cache.Load("lastchanged")
	if !ok || !res.Valid {
		return nil, errors.New("\"shadow.entry\" failed: no value provided for static field \"lastchanged\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"shadow.entry\" failed to cast field \"lastchanged\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Mindays accessor autogenerated
func (s *mqlShadowEntry) Mindays() (int64, error) {
	res, ok := s.Cache.Load("mindays")
	if !ok || !res.Valid {
		return 0, errors.New("\"shadow.entry\" failed: no value provided for static field \"mindays\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"shadow.entry\" failed to cast field \"mindays\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Maxdays accessor autogenerated
func (s *mqlShadowEntry) Maxdays() (int64, error) {
	res, ok := s.Cache.Load("maxdays")
	if !ok || !res.Valid {
		return 0, errors.New("\"shadow.entry\" failed: no value provided for static field \"maxdays\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"shadow.entry\" failed to cast field \"maxdays\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Warndays accessor autogenerated
func (s *mqlShadowEntry) Warndays() (int64, error) {
	res, ok := s.Cache.Load("warndays")
	if !ok || !res.Valid {
		return 0, errors.New("\"shadow.entry\" failed: no value provided for static field \"warndays\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"shadow.entry\" failed to cast field \"warndays\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Inactivedays accessor autogenerated
func (s *mqlShadowEntry) Inactivedays() (int64, error) {
	res, ok := s.Cache.Load("inactivedays")
	if !ok || !res.Valid {
		return 0, errors.New("\"shadow.entry\" failed: no value provided for static field \"inactivedays\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"shadow.entry\" failed to cast field \"inactivedays\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Expirydates accessor autogenerated
func (s *mqlShadowEntry) Expirydates() (string, error) {
	res, ok := s.Cache.Load("expirydates")
	if !ok || !res.Valid {
		return "", errors.New("\"shadow.entry\" failed: no value provided for static field \"expirydates\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"shadow.entry\" failed to cast field \"expirydates\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Reserved accessor autogenerated
func (s *mqlShadowEntry) Reserved() (string, error) {
	res, ok := s.Cache.Load("reserved")
	if !ok || !res.Valid {
		return "", errors.New("\"shadow.entry\" failed: no value provided for static field \"reserved\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"shadow.entry\" failed to cast field \"reserved\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlShadowEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[shadow.entry].MqlCompute")
	switch name {
	case "user":
		return nil
	case "password":
		return nil
	case "lastchanged":
		return nil
	case "mindays":
		return nil
	case "maxdays":
		return nil
	case "warndays":
		return nil
	case "inactivedays":
		return nil
	case "expirydates":
		return nil
	case "reserved":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"shadow.entry\" resource")
	}
}

// Registrykey resource interface
type Registrykey interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Exists() (bool, error)
	Properties() (map[string]interface{}, error)
	Items() ([]interface{}, error)
	Children() ([]interface{}, error)
}

// mqlRegistrykey for the registrykey resource
type mqlRegistrykey struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlRegistrykey) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the registrykey resource
func newRegistrykey(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlRegistrykey{runtime.NewResource("registrykey")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "exists":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"exists\" argument has the wrong type (expected type \"bool\")")
			}
		case "properties":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"properties\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "items":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"items\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "children":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"children\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"registrykey\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized registrykey with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlRegistrykey) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"registrykey\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlRegistrykey) Register(name string) error {
	log.Trace().Str("field", name).Msg("[registrykey].Register")
	switch name {
	case "path":
		return nil
	case "exists":
		return nil
	case "properties":
		return nil
	case "items":
		return nil
	case "children":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"registrykey\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlRegistrykey) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[registrykey].Field")
	switch name {
	case "path":
		return s.Path()
	case "exists":
		return s.Exists()
	case "properties":
		return s.Properties()
	case "items":
		return s.Items()
	case "children":
		return s.Children()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"registrykey\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlRegistrykey) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"registrykey\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"registrykey\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exists accessor autogenerated
func (s *mqlRegistrykey) Exists() (bool, error) {
	res, ok := s.Cache.Load("exists")
	if !ok || !res.Valid {
		if err := s.ComputeExists(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("exists")
		if !ok {
			return false, errors.New("\"registrykey\" calculated \"exists\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "exists")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"registrykey\" failed to cast field \"exists\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Properties accessor autogenerated
func (s *mqlRegistrykey) Properties() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("properties")
	if !ok || !res.Valid {
		if err := s.ComputeProperties(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("properties")
		if !ok {
			return nil, errors.New("\"registrykey\" calculated \"properties\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "properties")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"registrykey\" failed to cast field \"properties\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Items accessor autogenerated
func (s *mqlRegistrykey) Items() ([]interface{}, error) {
	res, ok := s.Cache.Load("items")
	if !ok || !res.Valid {
		if err := s.ComputeItems(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("items")
		if !ok {
			return nil, errors.New("\"registrykey\" calculated \"items\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "items")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"registrykey\" failed to cast field \"items\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Children accessor autogenerated
func (s *mqlRegistrykey) Children() ([]interface{}, error) {
	res, ok := s.Cache.Load("children")
	if !ok || !res.Valid {
		if err := s.ComputeChildren(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("children")
		if !ok {
			return nil, errors.New("\"registrykey\" calculated \"children\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "children")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"registrykey\" failed to cast field \"children\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlRegistrykey) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[registrykey].MqlCompute")
	switch name {
	case "path":
		return nil
	case "exists":
		return s.ComputeExists()
	case "properties":
		return s.ComputeProperties()
	case "items":
		return s.ComputeItems()
	case "children":
		return s.ComputeChildren()
	default:
		return errors.New("Cannot find field '" + name + "' in \"registrykey\" resource")
	}
}

// ComputeExists computer autogenerated
func (s *mqlRegistrykey) ComputeExists() error {
	var err error
	if _, ok := s.Cache.Load("exists"); ok {
		return nil
	}
	vres, err := s.GetExists()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("exists", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeProperties computer autogenerated
func (s *mqlRegistrykey) ComputeProperties() error {
	var err error
	if _, ok := s.Cache.Load("properties"); ok {
		return nil
	}
	vres, err := s.GetProperties()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("properties", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeItems computer autogenerated
func (s *mqlRegistrykey) ComputeItems() error {
	var err error
	if _, ok := s.Cache.Load("items"); ok {
		return nil
	}
	vres, err := s.GetItems()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("items", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeChildren computer autogenerated
func (s *mqlRegistrykey) ComputeChildren() error {
	var err error
	if _, ok := s.Cache.Load("children"); ok {
		return nil
	}
	vres, err := s.GetChildren()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("children", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// RegistrykeyProperty resource interface
type RegistrykeyProperty interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Name() (string, error)
	Value() (string, error)
	Type() (string, error)
	Data() (interface{}, error)
	Exists() (bool, error)
}

// mqlRegistrykeyProperty for the registrykey.property resource
type mqlRegistrykeyProperty struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlRegistrykeyProperty) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the registrykey.property resource
func newRegistrykeyProperty(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlRegistrykeyProperty{runtime.NewResource("registrykey.property")}
	var existing RegistrykeyProperty
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "value":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"value\" argument has the wrong type (expected type \"string\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "data":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"data\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "exists":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"exists\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"registrykey.property\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized registrykey.property with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlRegistrykeyProperty) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"registrykey.property\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"registrykey.property\" resource without a \"name\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlRegistrykeyProperty) Register(name string) error {
	log.Trace().Str("field", name).Msg("[registrykey.property].Register")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "value":
		return nil
	case "type":
		return nil
	case "data":
		return nil
	case "exists":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"registrykey.property\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlRegistrykeyProperty) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[registrykey.property].Field")
	switch name {
	case "path":
		return s.Path()
	case "name":
		return s.Name()
	case "value":
		return s.Value()
	case "type":
		return s.Type()
	case "data":
		return s.Data()
	case "exists":
		return s.Exists()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"registrykey.property\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlRegistrykeyProperty) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"registrykey.property\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"registrykey.property\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlRegistrykeyProperty) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"registrykey.property\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"registrykey.property\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Value accessor autogenerated
func (s *mqlRegistrykeyProperty) Value() (string, error) {
	res, ok := s.Cache.Load("value")
	if !ok || !res.Valid {
		if err := s.ComputeValue(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("value")
		if !ok {
			return "", errors.New("\"registrykey.property\" calculated \"value\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "value")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"registrykey.property\" failed to cast field \"value\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlRegistrykeyProperty) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		if err := s.ComputeType(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("type")
		if !ok {
			return "", errors.New("\"registrykey.property\" calculated \"type\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "type")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"registrykey.property\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Data accessor autogenerated
func (s *mqlRegistrykeyProperty) Data() (interface{}, error) {
	res, ok := s.Cache.Load("data")
	if !ok || !res.Valid {
		if err := s.ComputeData(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("data")
		if !ok {
			return nil, errors.New("\"registrykey.property\" calculated \"data\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "data")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"registrykey.property\" failed to cast field \"data\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Exists accessor autogenerated
func (s *mqlRegistrykeyProperty) Exists() (bool, error) {
	res, ok := s.Cache.Load("exists")
	if !ok || !res.Valid {
		if err := s.ComputeExists(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("exists")
		if !ok {
			return false, errors.New("\"registrykey.property\" calculated \"exists\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "exists")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"registrykey.property\" failed to cast field \"exists\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlRegistrykeyProperty) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[registrykey.property].MqlCompute")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "value":
		return s.ComputeValue()
	case "type":
		return s.ComputeType()
	case "data":
		return s.ComputeData()
	case "exists":
		return s.ComputeExists()
	default:
		return errors.New("Cannot find field '" + name + "' in \"registrykey.property\" resource")
	}
}

// ComputeValue computer autogenerated
func (s *mqlRegistrykeyProperty) ComputeValue() error {
	var err error
	if _, ok := s.Cache.Load("value"); ok {
		return nil
	}
	vres, err := s.GetValue()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("value", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeType computer autogenerated
func (s *mqlRegistrykeyProperty) ComputeType() error {
	var err error
	if _, ok := s.Cache.Load("type"); ok {
		return nil
	}
	vres, err := s.GetType()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("type", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeData computer autogenerated
func (s *mqlRegistrykeyProperty) ComputeData() error {
	var err error
	if _, ok := s.Cache.Load("data"); ok {
		return nil
	}
	vres, err := s.GetData()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("data", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExists computer autogenerated
func (s *mqlRegistrykeyProperty) ComputeExists() error {
	var err error
	if _, ok := s.Cache.Load("exists"); ok {
		return nil
	}
	vres, err := s.GetExists()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("exists", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Windows resource interface
type Windows interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	ComputerInfo() (interface{}, error)
	Hotfixes() ([]interface{}, error)
	Features() ([]interface{}, error)
}

// mqlWindows for the windows resource
type mqlWindows struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindows) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows resource
func newWindows(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindows{runtime.NewResource("windows")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "computerInfo":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows\", its \"computerInfo\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "hotfixes":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows\", its \"hotfixes\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "features":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows\", its \"features\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindows) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlWindows) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows].Register")
	switch name {
	case "computerInfo":
		return nil
	case "hotfixes":
		return nil
	case "features":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindows) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows].Field")
	switch name {
	case "computerInfo":
		return s.ComputerInfo()
	case "hotfixes":
		return s.Hotfixes()
	case "features":
		return s.Features()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows\" resource")
	}
}

// ComputerInfo accessor autogenerated
func (s *mqlWindows) ComputerInfo() (interface{}, error) {
	res, ok := s.Cache.Load("computerInfo")
	if !ok || !res.Valid {
		if err := s.ComputeComputerInfo(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("computerInfo")
		if !ok {
			return nil, errors.New("\"windows\" calculated \"computerInfo\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "computerInfo")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows\" failed to cast field \"computerInfo\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Hotfixes accessor autogenerated
func (s *mqlWindows) Hotfixes() ([]interface{}, error) {
	res, ok := s.Cache.Load("hotfixes")
	if !ok || !res.Valid {
		if err := s.ComputeHotfixes(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("hotfixes")
		if !ok {
			return nil, errors.New("\"windows\" calculated \"hotfixes\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "hotfixes")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows\" failed to cast field \"hotfixes\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Features accessor autogenerated
func (s *mqlWindows) Features() ([]interface{}, error) {
	res, ok := s.Cache.Load("features")
	if !ok || !res.Valid {
		if err := s.ComputeFeatures(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("features")
		if !ok {
			return nil, errors.New("\"windows\" calculated \"features\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "features")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows\" failed to cast field \"features\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindows) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows].MqlCompute")
	switch name {
	case "computerInfo":
		return s.ComputeComputerInfo()
	case "hotfixes":
		return s.ComputeHotfixes()
	case "features":
		return s.ComputeFeatures()
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows\" resource")
	}
}

// ComputeComputerInfo computer autogenerated
func (s *mqlWindows) ComputeComputerInfo() error {
	var err error
	if _, ok := s.Cache.Load("computerInfo"); ok {
		return nil
	}
	vres, err := s.GetComputerInfo()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("computerInfo", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHotfixes computer autogenerated
func (s *mqlWindows) ComputeHotfixes() error {
	var err error
	if _, ok := s.Cache.Load("hotfixes"); ok {
		return nil
	}
	vres, err := s.GetHotfixes()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("hotfixes", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFeatures computer autogenerated
func (s *mqlWindows) ComputeFeatures() error {
	var err error
	if _, ok := s.Cache.Load("features"); ok {
		return nil
	}
	vres, err := s.GetFeatures()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("features", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// WindowsHotfix resource interface
type WindowsHotfix interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	HotfixId() (string, error)
	Description() (string, error)
	Caption() (string, error)
	InstalledOn() (*time.Time, error)
	InstalledBy() (string, error)
}

// mqlWindowsHotfix for the windows.hotfix resource
type mqlWindowsHotfix struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsHotfix) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.hotfix resource
func newWindowsHotfix(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsHotfix{runtime.NewResource("windows.hotfix")}
	var existing WindowsHotfix
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "hotfixId":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"hotfixId\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "caption":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"caption\" argument has the wrong type (expected type \"string\")")
			}
		case "installedOn":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"installedOn\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "installedBy":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"installedBy\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.hotfix\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.hotfix with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsHotfix) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("hotfixId"); !ok {
		return errors.New("Initialized \"windows.hotfix\" resource without a \"hotfixId\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"windows.hotfix\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("caption"); !ok {
		return errors.New("Initialized \"windows.hotfix\" resource without a \"caption\". This field is required.")
	}
	if _, ok := s.Cache.Load("installedOn"); !ok {
		return errors.New("Initialized \"windows.hotfix\" resource without a \"installedOn\". This field is required.")
	}
	if _, ok := s.Cache.Load("installedBy"); !ok {
		return errors.New("Initialized \"windows.hotfix\" resource without a \"installedBy\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsHotfix) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.hotfix].Register")
	switch name {
	case "hotfixId":
		return nil
	case "description":
		return nil
	case "caption":
		return nil
	case "installedOn":
		return nil
	case "installedBy":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.hotfix\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsHotfix) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.hotfix].Field")
	switch name {
	case "hotfixId":
		return s.HotfixId()
	case "description":
		return s.Description()
	case "caption":
		return s.Caption()
	case "installedOn":
		return s.InstalledOn()
	case "installedBy":
		return s.InstalledBy()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.hotfix\" resource")
	}
}

// HotfixId accessor autogenerated
func (s *mqlWindowsHotfix) HotfixId() (string, error) {
	res, ok := s.Cache.Load("hotfixId")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.hotfix\" failed: no value provided for static field \"hotfixId\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.hotfix\" failed to cast field \"hotfixId\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlWindowsHotfix) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.hotfix\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.hotfix\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Caption accessor autogenerated
func (s *mqlWindowsHotfix) Caption() (string, error) {
	res, ok := s.Cache.Load("caption")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.hotfix\" failed: no value provided for static field \"caption\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.hotfix\" failed to cast field \"caption\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// InstalledOn accessor autogenerated
func (s *mqlWindowsHotfix) InstalledOn() (*time.Time, error) {
	res, ok := s.Cache.Load("installedOn")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.hotfix\" failed: no value provided for static field \"installedOn\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"windows.hotfix\" failed to cast field \"installedOn\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// InstalledBy accessor autogenerated
func (s *mqlWindowsHotfix) InstalledBy() (string, error) {
	res, ok := s.Cache.Load("installedBy")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.hotfix\" failed: no value provided for static field \"installedBy\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.hotfix\" failed to cast field \"installedBy\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsHotfix) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.hotfix].MqlCompute")
	switch name {
	case "hotfixId":
		return nil
	case "description":
		return nil
	case "caption":
		return nil
	case "installedOn":
		return nil
	case "installedBy":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.hotfix\" resource")
	}
}

// WindowsFeature resource interface
type WindowsFeature interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Name() (string, error)
	DisplayName() (string, error)
	Description() (string, error)
	Installed() (bool, error)
	InstallState() (int64, error)
}

// mqlWindowsFeature for the windows.feature resource
type mqlWindowsFeature struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsFeature) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.feature resource
func newWindowsFeature(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsFeature{runtime.NewResource("windows.feature")}
	var existing WindowsFeature
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "displayName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"displayName\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "installed":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"installed\" argument has the wrong type (expected type \"bool\")")
			}
		case "installState":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"installState\" argument has the wrong type (expected type \"int64\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.feature\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.feature with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsFeature) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("displayName"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"displayName\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("installed"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"installed\". This field is required.")
	}
	if _, ok := s.Cache.Load("installState"); !ok {
		return errors.New("Initialized \"windows.feature\" resource without a \"installState\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsFeature) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.feature].Register")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "displayName":
		return nil
	case "description":
		return nil
	case "installed":
		return nil
	case "installState":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.feature\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsFeature) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.feature].Field")
	switch name {
	case "path":
		return s.Path()
	case "name":
		return s.Name()
	case "displayName":
		return s.DisplayName()
	case "description":
		return s.Description()
	case "installed":
		return s.Installed()
	case "installState":
		return s.InstallState()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.feature\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlWindowsFeature) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.feature\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.feature\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlWindowsFeature) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.feature\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.feature\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DisplayName accessor autogenerated
func (s *mqlWindowsFeature) DisplayName() (string, error) {
	res, ok := s.Cache.Load("displayName")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.feature\" failed: no value provided for static field \"displayName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.feature\" failed to cast field \"displayName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlWindowsFeature) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.feature\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.feature\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Installed accessor autogenerated
func (s *mqlWindowsFeature) Installed() (bool, error) {
	res, ok := s.Cache.Load("installed")
	if !ok || !res.Valid {
		return false, errors.New("\"windows.feature\" failed: no value provided for static field \"installed\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"windows.feature\" failed to cast field \"installed\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// InstallState accessor autogenerated
func (s *mqlWindowsFeature) InstallState() (int64, error) {
	res, ok := s.Cache.Load("installState")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.feature\" failed: no value provided for static field \"installState\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.feature\" failed to cast field \"installState\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsFeature) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.feature].MqlCompute")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "displayName":
		return nil
	case "description":
		return nil
	case "installed":
		return nil
	case "installState":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.feature\" resource")
	}
}

// WindowsFirewall resource interface
type WindowsFirewall interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Settings() (interface{}, error)
	Profiles() ([]interface{}, error)
	Rules() ([]interface{}, error)
}

// mqlWindowsFirewall for the windows.firewall resource
type mqlWindowsFirewall struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsFirewall) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.firewall resource
func newWindowsFirewall(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsFirewall{runtime.NewResource("windows.firewall")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "settings":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall\", its \"settings\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "profiles":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall\", its \"profiles\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "rules":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall\", its \"rules\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.firewall with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsFirewall) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsFirewall) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall].Register")
	switch name {
	case "settings":
		return nil
	case "profiles":
		return nil
	case "rules":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsFirewall) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.firewall].Field")
	switch name {
	case "settings":
		return s.Settings()
	case "profiles":
		return s.Profiles()
	case "rules":
		return s.Rules()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.firewall\" resource")
	}
}

// Settings accessor autogenerated
func (s *mqlWindowsFirewall) Settings() (interface{}, error) {
	res, ok := s.Cache.Load("settings")
	if !ok || !res.Valid {
		if err := s.ComputeSettings(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("settings")
		if !ok {
			return nil, errors.New("\"windows.firewall\" calculated \"settings\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "settings")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.firewall\" failed to cast field \"settings\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Profiles accessor autogenerated
func (s *mqlWindowsFirewall) Profiles() ([]interface{}, error) {
	res, ok := s.Cache.Load("profiles")
	if !ok || !res.Valid {
		if err := s.ComputeProfiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("profiles")
		if !ok {
			return nil, errors.New("\"windows.firewall\" calculated \"profiles\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "profiles")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.firewall\" failed to cast field \"profiles\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Rules accessor autogenerated
func (s *mqlWindowsFirewall) Rules() ([]interface{}, error) {
	res, ok := s.Cache.Load("rules")
	if !ok || !res.Valid {
		if err := s.ComputeRules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("rules")
		if !ok {
			return nil, errors.New("\"windows.firewall\" calculated \"rules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "rules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.firewall\" failed to cast field \"rules\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsFirewall) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall].MqlCompute")
	switch name {
	case "settings":
		return s.ComputeSettings()
	case "profiles":
		return s.ComputeProfiles()
	case "rules":
		return s.ComputeRules()
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall\" resource")
	}
}

// ComputeSettings computer autogenerated
func (s *mqlWindowsFirewall) ComputeSettings() error {
	var err error
	if _, ok := s.Cache.Load("settings"); ok {
		return nil
	}
	vres, err := s.GetSettings()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("settings", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeProfiles computer autogenerated
func (s *mqlWindowsFirewall) ComputeProfiles() error {
	var err error
	if _, ok := s.Cache.Load("profiles"); ok {
		return nil
	}
	vres, err := s.GetProfiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("profiles", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRules computer autogenerated
func (s *mqlWindowsFirewall) ComputeRules() error {
	var err error
	if _, ok := s.Cache.Load("rules"); ok {
		return nil
	}
	vres, err := s.GetRules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("rules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// WindowsFirewallProfile resource interface
type WindowsFirewallProfile interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	InstanceID() (string, error)
	Name() (string, error)
	Enabled() (int64, error)
	DefaultInboundAction() (int64, error)
	DefaultOutboundAction() (int64, error)
	AllowInboundRules() (int64, error)
	AllowLocalFirewallRules() (int64, error)
	AllowLocalIPsecRules() (int64, error)
	AllowUserApps() (int64, error)
	AllowUserPorts() (int64, error)
	AllowUnicastResponseToMulticast() (int64, error)
	NotifyOnListen() (int64, error)
	EnableStealthModeForIPsec() (int64, error)
	LogMaxSizeKilobytes() (int64, error)
	LogAllowed() (int64, error)
	LogBlocked() (int64, error)
	LogIgnored() (int64, error)
	LogFileName() (string, error)
}

// mqlWindowsFirewallProfile for the windows.firewall.profile resource
type mqlWindowsFirewallProfile struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsFirewallProfile) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.firewall.profile resource
func newWindowsFirewallProfile(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsFirewallProfile{runtime.NewResource("windows.firewall.profile")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "instanceID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"instanceID\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "enabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"enabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "defaultInboundAction":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"defaultInboundAction\" argument has the wrong type (expected type \"int64\")")
			}
		case "defaultOutboundAction":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"defaultOutboundAction\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowInboundRules":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowInboundRules\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowLocalFirewallRules":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowLocalFirewallRules\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowLocalIPsecRules":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowLocalIPsecRules\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowUserApps":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowUserApps\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowUserPorts":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowUserPorts\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowUnicastResponseToMulticast":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"allowUnicastResponseToMulticast\" argument has the wrong type (expected type \"int64\")")
			}
		case "notifyOnListen":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"notifyOnListen\" argument has the wrong type (expected type \"int64\")")
			}
		case "enableStealthModeForIPsec":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"enableStealthModeForIPsec\" argument has the wrong type (expected type \"int64\")")
			}
		case "logMaxSizeKilobytes":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"logMaxSizeKilobytes\" argument has the wrong type (expected type \"int64\")")
			}
		case "logAllowed":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"logAllowed\" argument has the wrong type (expected type \"int64\")")
			}
		case "logBlocked":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"logBlocked\" argument has the wrong type (expected type \"int64\")")
			}
		case "logIgnored":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"logIgnored\" argument has the wrong type (expected type \"int64\")")
			}
		case "logFileName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"logFileName\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.profile\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.firewall.profile with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsFirewallProfile) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("instanceID"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"instanceID\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("enabled"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"enabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("defaultInboundAction"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"defaultInboundAction\". This field is required.")
	}
	if _, ok := s.Cache.Load("defaultOutboundAction"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"defaultOutboundAction\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowInboundRules"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowInboundRules\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowLocalFirewallRules"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowLocalFirewallRules\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowLocalIPsecRules"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowLocalIPsecRules\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowUserApps"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowUserApps\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowUserPorts"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowUserPorts\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowUnicastResponseToMulticast"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"allowUnicastResponseToMulticast\". This field is required.")
	}
	if _, ok := s.Cache.Load("notifyOnListen"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"notifyOnListen\". This field is required.")
	}
	if _, ok := s.Cache.Load("enableStealthModeForIPsec"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"enableStealthModeForIPsec\". This field is required.")
	}
	if _, ok := s.Cache.Load("logMaxSizeKilobytes"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"logMaxSizeKilobytes\". This field is required.")
	}
	if _, ok := s.Cache.Load("logAllowed"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"logAllowed\". This field is required.")
	}
	if _, ok := s.Cache.Load("logBlocked"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"logBlocked\". This field is required.")
	}
	if _, ok := s.Cache.Load("logIgnored"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"logIgnored\". This field is required.")
	}
	if _, ok := s.Cache.Load("logFileName"); !ok {
		return errors.New("Initialized \"windows.firewall.profile\" resource without a \"logFileName\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsFirewallProfile) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall.profile].Register")
	switch name {
	case "instanceID":
		return nil
	case "name":
		return nil
	case "enabled":
		return nil
	case "defaultInboundAction":
		return nil
	case "defaultOutboundAction":
		return nil
	case "allowInboundRules":
		return nil
	case "allowLocalFirewallRules":
		return nil
	case "allowLocalIPsecRules":
		return nil
	case "allowUserApps":
		return nil
	case "allowUserPorts":
		return nil
	case "allowUnicastResponseToMulticast":
		return nil
	case "notifyOnListen":
		return nil
	case "enableStealthModeForIPsec":
		return nil
	case "logMaxSizeKilobytes":
		return nil
	case "logAllowed":
		return nil
	case "logBlocked":
		return nil
	case "logIgnored":
		return nil
	case "logFileName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall.profile\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsFirewallProfile) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.firewall.profile].Field")
	switch name {
	case "instanceID":
		return s.InstanceID()
	case "name":
		return s.Name()
	case "enabled":
		return s.Enabled()
	case "defaultInboundAction":
		return s.DefaultInboundAction()
	case "defaultOutboundAction":
		return s.DefaultOutboundAction()
	case "allowInboundRules":
		return s.AllowInboundRules()
	case "allowLocalFirewallRules":
		return s.AllowLocalFirewallRules()
	case "allowLocalIPsecRules":
		return s.AllowLocalIPsecRules()
	case "allowUserApps":
		return s.AllowUserApps()
	case "allowUserPorts":
		return s.AllowUserPorts()
	case "allowUnicastResponseToMulticast":
		return s.AllowUnicastResponseToMulticast()
	case "notifyOnListen":
		return s.NotifyOnListen()
	case "enableStealthModeForIPsec":
		return s.EnableStealthModeForIPsec()
	case "logMaxSizeKilobytes":
		return s.LogMaxSizeKilobytes()
	case "logAllowed":
		return s.LogAllowed()
	case "logBlocked":
		return s.LogBlocked()
	case "logIgnored":
		return s.LogIgnored()
	case "logFileName":
		return s.LogFileName()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.firewall.profile\" resource")
	}
}

// InstanceID accessor autogenerated
func (s *mqlWindowsFirewallProfile) InstanceID() (string, error) {
	res, ok := s.Cache.Load("instanceID")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"instanceID\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"instanceID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlWindowsFirewallProfile) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Enabled accessor autogenerated
func (s *mqlWindowsFirewallProfile) Enabled() (int64, error) {
	res, ok := s.Cache.Load("enabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"enabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"enabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// DefaultInboundAction accessor autogenerated
func (s *mqlWindowsFirewallProfile) DefaultInboundAction() (int64, error) {
	res, ok := s.Cache.Load("defaultInboundAction")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"defaultInboundAction\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"defaultInboundAction\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// DefaultOutboundAction accessor autogenerated
func (s *mqlWindowsFirewallProfile) DefaultOutboundAction() (int64, error) {
	res, ok := s.Cache.Load("defaultOutboundAction")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"defaultOutboundAction\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"defaultOutboundAction\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowInboundRules accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowInboundRules() (int64, error) {
	res, ok := s.Cache.Load("allowInboundRules")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowInboundRules\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowInboundRules\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowLocalFirewallRules accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowLocalFirewallRules() (int64, error) {
	res, ok := s.Cache.Load("allowLocalFirewallRules")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowLocalFirewallRules\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowLocalFirewallRules\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowLocalIPsecRules accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowLocalIPsecRules() (int64, error) {
	res, ok := s.Cache.Load("allowLocalIPsecRules")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowLocalIPsecRules\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowLocalIPsecRules\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowUserApps accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowUserApps() (int64, error) {
	res, ok := s.Cache.Load("allowUserApps")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowUserApps\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowUserApps\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowUserPorts accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowUserPorts() (int64, error) {
	res, ok := s.Cache.Load("allowUserPorts")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowUserPorts\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowUserPorts\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowUnicastResponseToMulticast accessor autogenerated
func (s *mqlWindowsFirewallProfile) AllowUnicastResponseToMulticast() (int64, error) {
	res, ok := s.Cache.Load("allowUnicastResponseToMulticast")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"allowUnicastResponseToMulticast\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"allowUnicastResponseToMulticast\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// NotifyOnListen accessor autogenerated
func (s *mqlWindowsFirewallProfile) NotifyOnListen() (int64, error) {
	res, ok := s.Cache.Load("notifyOnListen")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"notifyOnListen\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"notifyOnListen\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// EnableStealthModeForIPsec accessor autogenerated
func (s *mqlWindowsFirewallProfile) EnableStealthModeForIPsec() (int64, error) {
	res, ok := s.Cache.Load("enableStealthModeForIPsec")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"enableStealthModeForIPsec\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"enableStealthModeForIPsec\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LogMaxSizeKilobytes accessor autogenerated
func (s *mqlWindowsFirewallProfile) LogMaxSizeKilobytes() (int64, error) {
	res, ok := s.Cache.Load("logMaxSizeKilobytes")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"logMaxSizeKilobytes\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"logMaxSizeKilobytes\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LogAllowed accessor autogenerated
func (s *mqlWindowsFirewallProfile) LogAllowed() (int64, error) {
	res, ok := s.Cache.Load("logAllowed")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"logAllowed\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"logAllowed\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LogBlocked accessor autogenerated
func (s *mqlWindowsFirewallProfile) LogBlocked() (int64, error) {
	res, ok := s.Cache.Load("logBlocked")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"logBlocked\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"logBlocked\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LogIgnored accessor autogenerated
func (s *mqlWindowsFirewallProfile) LogIgnored() (int64, error) {
	res, ok := s.Cache.Load("logIgnored")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"logIgnored\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"logIgnored\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LogFileName accessor autogenerated
func (s *mqlWindowsFirewallProfile) LogFileName() (string, error) {
	res, ok := s.Cache.Load("logFileName")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.profile\" failed: no value provided for static field \"logFileName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.profile\" failed to cast field \"logFileName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsFirewallProfile) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall.profile].MqlCompute")
	switch name {
	case "instanceID":
		return nil
	case "name":
		return nil
	case "enabled":
		return nil
	case "defaultInboundAction":
		return nil
	case "defaultOutboundAction":
		return nil
	case "allowInboundRules":
		return nil
	case "allowLocalFirewallRules":
		return nil
	case "allowLocalIPsecRules":
		return nil
	case "allowUserApps":
		return nil
	case "allowUserPorts":
		return nil
	case "allowUnicastResponseToMulticast":
		return nil
	case "notifyOnListen":
		return nil
	case "enableStealthModeForIPsec":
		return nil
	case "logMaxSizeKilobytes":
		return nil
	case "logAllowed":
		return nil
	case "logBlocked":
		return nil
	case "logIgnored":
		return nil
	case "logFileName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall.profile\" resource")
	}
}

// WindowsFirewallRule resource interface
type WindowsFirewallRule interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	InstanceID() (string, error)
	Name() (string, error)
	DisplayName() (string, error)
	Description() (string, error)
	DisplayGroup() (string, error)
	Enabled() (int64, error)
	Direction() (int64, error)
	Action() (int64, error)
	EdgeTraversalPolicy() (int64, error)
	LooseSourceMapping() (bool, error)
	LocalOnlyMapping() (bool, error)
	PrimaryStatus() (int64, error)
	Status() (string, error)
	EnforcementStatus() (string, error)
	PolicyStoreSource() (string, error)
	PolicyStoreSourceType() (int64, error)
}

// mqlWindowsFirewallRule for the windows.firewall.rule resource
type mqlWindowsFirewallRule struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsFirewallRule) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.firewall.rule resource
func newWindowsFirewallRule(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsFirewallRule{runtime.NewResource("windows.firewall.rule")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "instanceID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"instanceID\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "displayName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"displayName\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "displayGroup":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"displayGroup\" argument has the wrong type (expected type \"string\")")
			}
		case "enabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"enabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "direction":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"direction\" argument has the wrong type (expected type \"int64\")")
			}
		case "action":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"action\" argument has the wrong type (expected type \"int64\")")
			}
		case "edgeTraversalPolicy":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"edgeTraversalPolicy\" argument has the wrong type (expected type \"int64\")")
			}
		case "looseSourceMapping":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"looseSourceMapping\" argument has the wrong type (expected type \"bool\")")
			}
		case "localOnlyMapping":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"localOnlyMapping\" argument has the wrong type (expected type \"bool\")")
			}
		case "primaryStatus":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"primaryStatus\" argument has the wrong type (expected type \"int64\")")
			}
		case "status":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"status\" argument has the wrong type (expected type \"string\")")
			}
		case "enforcementStatus":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"enforcementStatus\" argument has the wrong type (expected type \"string\")")
			}
		case "policyStoreSource":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"policyStoreSource\" argument has the wrong type (expected type \"string\")")
			}
		case "policyStoreSourceType":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"policyStoreSourceType\" argument has the wrong type (expected type \"int64\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.firewall.rule\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.firewall.rule with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsFirewallRule) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("instanceID"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"instanceID\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("displayName"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"displayName\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("displayGroup"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"displayGroup\". This field is required.")
	}
	if _, ok := s.Cache.Load("enabled"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"enabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("direction"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"direction\". This field is required.")
	}
	if _, ok := s.Cache.Load("action"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"action\". This field is required.")
	}
	if _, ok := s.Cache.Load("edgeTraversalPolicy"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"edgeTraversalPolicy\". This field is required.")
	}
	if _, ok := s.Cache.Load("looseSourceMapping"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"looseSourceMapping\". This field is required.")
	}
	if _, ok := s.Cache.Load("localOnlyMapping"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"localOnlyMapping\". This field is required.")
	}
	if _, ok := s.Cache.Load("primaryStatus"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"primaryStatus\". This field is required.")
	}
	if _, ok := s.Cache.Load("status"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"status\". This field is required.")
	}
	if _, ok := s.Cache.Load("enforcementStatus"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"enforcementStatus\". This field is required.")
	}
	if _, ok := s.Cache.Load("policyStoreSource"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"policyStoreSource\". This field is required.")
	}
	if _, ok := s.Cache.Load("policyStoreSourceType"); !ok {
		return errors.New("Initialized \"windows.firewall.rule\" resource without a \"policyStoreSourceType\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsFirewallRule) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall.rule].Register")
	switch name {
	case "instanceID":
		return nil
	case "name":
		return nil
	case "displayName":
		return nil
	case "description":
		return nil
	case "displayGroup":
		return nil
	case "enabled":
		return nil
	case "direction":
		return nil
	case "action":
		return nil
	case "edgeTraversalPolicy":
		return nil
	case "looseSourceMapping":
		return nil
	case "localOnlyMapping":
		return nil
	case "primaryStatus":
		return nil
	case "status":
		return nil
	case "enforcementStatus":
		return nil
	case "policyStoreSource":
		return nil
	case "policyStoreSourceType":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall.rule\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsFirewallRule) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.firewall.rule].Field")
	switch name {
	case "instanceID":
		return s.InstanceID()
	case "name":
		return s.Name()
	case "displayName":
		return s.DisplayName()
	case "description":
		return s.Description()
	case "displayGroup":
		return s.DisplayGroup()
	case "enabled":
		return s.Enabled()
	case "direction":
		return s.Direction()
	case "action":
		return s.Action()
	case "edgeTraversalPolicy":
		return s.EdgeTraversalPolicy()
	case "looseSourceMapping":
		return s.LooseSourceMapping()
	case "localOnlyMapping":
		return s.LocalOnlyMapping()
	case "primaryStatus":
		return s.PrimaryStatus()
	case "status":
		return s.Status()
	case "enforcementStatus":
		return s.EnforcementStatus()
	case "policyStoreSource":
		return s.PolicyStoreSource()
	case "policyStoreSourceType":
		return s.PolicyStoreSourceType()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.firewall.rule\" resource")
	}
}

// InstanceID accessor autogenerated
func (s *mqlWindowsFirewallRule) InstanceID() (string, error) {
	res, ok := s.Cache.Load("instanceID")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"instanceID\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"instanceID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlWindowsFirewallRule) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DisplayName accessor autogenerated
func (s *mqlWindowsFirewallRule) DisplayName() (string, error) {
	res, ok := s.Cache.Load("displayName")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"displayName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"displayName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlWindowsFirewallRule) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DisplayGroup accessor autogenerated
func (s *mqlWindowsFirewallRule) DisplayGroup() (string, error) {
	res, ok := s.Cache.Load("displayGroup")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"displayGroup\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"displayGroup\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Enabled accessor autogenerated
func (s *mqlWindowsFirewallRule) Enabled() (int64, error) {
	res, ok := s.Cache.Load("enabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"enabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"enabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Direction accessor autogenerated
func (s *mqlWindowsFirewallRule) Direction() (int64, error) {
	res, ok := s.Cache.Load("direction")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"direction\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"direction\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Action accessor autogenerated
func (s *mqlWindowsFirewallRule) Action() (int64, error) {
	res, ok := s.Cache.Load("action")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"action\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"action\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// EdgeTraversalPolicy accessor autogenerated
func (s *mqlWindowsFirewallRule) EdgeTraversalPolicy() (int64, error) {
	res, ok := s.Cache.Load("edgeTraversalPolicy")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"edgeTraversalPolicy\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"edgeTraversalPolicy\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LooseSourceMapping accessor autogenerated
func (s *mqlWindowsFirewallRule) LooseSourceMapping() (bool, error) {
	res, ok := s.Cache.Load("looseSourceMapping")
	if !ok || !res.Valid {
		return false, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"looseSourceMapping\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"looseSourceMapping\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// LocalOnlyMapping accessor autogenerated
func (s *mqlWindowsFirewallRule) LocalOnlyMapping() (bool, error) {
	res, ok := s.Cache.Load("localOnlyMapping")
	if !ok || !res.Valid {
		return false, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"localOnlyMapping\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"localOnlyMapping\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// PrimaryStatus accessor autogenerated
func (s *mqlWindowsFirewallRule) PrimaryStatus() (int64, error) {
	res, ok := s.Cache.Load("primaryStatus")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"primaryStatus\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"primaryStatus\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Status accessor autogenerated
func (s *mqlWindowsFirewallRule) Status() (string, error) {
	res, ok := s.Cache.Load("status")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"status\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"status\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// EnforcementStatus accessor autogenerated
func (s *mqlWindowsFirewallRule) EnforcementStatus() (string, error) {
	res, ok := s.Cache.Load("enforcementStatus")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"enforcementStatus\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"enforcementStatus\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PolicyStoreSource accessor autogenerated
func (s *mqlWindowsFirewallRule) PolicyStoreSource() (string, error) {
	res, ok := s.Cache.Load("policyStoreSource")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"policyStoreSource\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"policyStoreSource\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PolicyStoreSourceType accessor autogenerated
func (s *mqlWindowsFirewallRule) PolicyStoreSourceType() (int64, error) {
	res, ok := s.Cache.Load("policyStoreSourceType")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.firewall.rule\" failed: no value provided for static field \"policyStoreSourceType\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.firewall.rule\" failed to cast field \"policyStoreSourceType\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsFirewallRule) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.firewall.rule].MqlCompute")
	switch name {
	case "instanceID":
		return nil
	case "name":
		return nil
	case "displayName":
		return nil
	case "description":
		return nil
	case "displayGroup":
		return nil
	case "enabled":
		return nil
	case "direction":
		return nil
	case "action":
		return nil
	case "edgeTraversalPolicy":
		return nil
	case "looseSourceMapping":
		return nil
	case "localOnlyMapping":
		return nil
	case "primaryStatus":
		return nil
	case "status":
		return nil
	case "enforcementStatus":
		return nil
	case "policyStoreSource":
		return nil
	case "policyStoreSourceType":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.firewall.rule\" resource")
	}
}

// WindowsBitlocker resource interface
type WindowsBitlocker interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Volumes() ([]interface{}, error)
}

// mqlWindowsBitlocker for the windows.bitlocker resource
type mqlWindowsBitlocker struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsBitlocker) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.bitlocker resource
func newWindowsBitlocker(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsBitlocker{runtime.NewResource("windows.bitlocker")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "volumes":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker\", its \"volumes\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.bitlocker with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsBitlocker) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsBitlocker) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.bitlocker].Register")
	switch name {
	case "volumes":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.bitlocker\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsBitlocker) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.bitlocker].Field")
	switch name {
	case "volumes":
		return s.Volumes()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.bitlocker\" resource")
	}
}

// Volumes accessor autogenerated
func (s *mqlWindowsBitlocker) Volumes() ([]interface{}, error) {
	res, ok := s.Cache.Load("volumes")
	if !ok || !res.Valid {
		if err := s.ComputeVolumes(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("volumes")
		if !ok {
			return nil, errors.New("\"windows.bitlocker\" calculated \"volumes\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "volumes")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.bitlocker\" failed to cast field \"volumes\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsBitlocker) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.bitlocker].MqlCompute")
	switch name {
	case "volumes":
		return s.ComputeVolumes()
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.bitlocker\" resource")
	}
}

// ComputeVolumes computer autogenerated
func (s *mqlWindowsBitlocker) ComputeVolumes() error {
	var err error
	if _, ok := s.Cache.Load("volumes"); ok {
		return nil
	}
	vres, err := s.GetVolumes()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("volumes", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// WindowsBitlockerVolume resource interface
type WindowsBitlockerVolume interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	DeviceID() (string, error)
	DriveLetter() (string, error)
	ConversionStatus() (interface{}, error)
	EncryptionMethod() (interface{}, error)
	LockStatus() (int64, error)
	PersistentVolumeID() (string, error)
	ProtectionStatus() (interface{}, error)
	Version() (interface{}, error)
}

// mqlWindowsBitlockerVolume for the windows.bitlocker.volume resource
type mqlWindowsBitlockerVolume struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsBitlockerVolume) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.bitlocker.volume resource
func newWindowsBitlockerVolume(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsBitlockerVolume{runtime.NewResource("windows.bitlocker.volume")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "deviceID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"deviceID\" argument has the wrong type (expected type \"string\")")
			}
		case "driveLetter":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"driveLetter\" argument has the wrong type (expected type \"string\")")
			}
		case "conversionStatus":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"conversionStatus\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "encryptionMethod":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"encryptionMethod\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "lockStatus":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"lockStatus\" argument has the wrong type (expected type \"int64\")")
			}
		case "persistentVolumeID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"persistentVolumeID\" argument has the wrong type (expected type \"string\")")
			}
		case "protectionStatus":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"protectionStatus\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "version":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"version\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.bitlocker.volume\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.bitlocker.volume with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsBitlockerVolume) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("deviceID"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"deviceID\". This field is required.")
	}
	if _, ok := s.Cache.Load("driveLetter"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"driveLetter\". This field is required.")
	}
	if _, ok := s.Cache.Load("conversionStatus"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"conversionStatus\". This field is required.")
	}
	if _, ok := s.Cache.Load("encryptionMethod"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"encryptionMethod\". This field is required.")
	}
	if _, ok := s.Cache.Load("lockStatus"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"lockStatus\". This field is required.")
	}
	if _, ok := s.Cache.Load("persistentVolumeID"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"persistentVolumeID\". This field is required.")
	}
	if _, ok := s.Cache.Load("protectionStatus"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"protectionStatus\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"windows.bitlocker.volume\" resource without a \"version\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsBitlockerVolume) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.bitlocker.volume].Register")
	switch name {
	case "deviceID":
		return nil
	case "driveLetter":
		return nil
	case "conversionStatus":
		return nil
	case "encryptionMethod":
		return nil
	case "lockStatus":
		return nil
	case "persistentVolumeID":
		return nil
	case "protectionStatus":
		return nil
	case "version":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.bitlocker.volume\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsBitlockerVolume) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.bitlocker.volume].Field")
	switch name {
	case "deviceID":
		return s.DeviceID()
	case "driveLetter":
		return s.DriveLetter()
	case "conversionStatus":
		return s.ConversionStatus()
	case "encryptionMethod":
		return s.EncryptionMethod()
	case "lockStatus":
		return s.LockStatus()
	case "persistentVolumeID":
		return s.PersistentVolumeID()
	case "protectionStatus":
		return s.ProtectionStatus()
	case "version":
		return s.Version()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.bitlocker.volume\" resource")
	}
}

// DeviceID accessor autogenerated
func (s *mqlWindowsBitlockerVolume) DeviceID() (string, error) {
	res, ok := s.Cache.Load("deviceID")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"deviceID\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"deviceID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DriveLetter accessor autogenerated
func (s *mqlWindowsBitlockerVolume) DriveLetter() (string, error) {
	res, ok := s.Cache.Load("driveLetter")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"driveLetter\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"driveLetter\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ConversionStatus accessor autogenerated
func (s *mqlWindowsBitlockerVolume) ConversionStatus() (interface{}, error) {
	res, ok := s.Cache.Load("conversionStatus")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"conversionStatus\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"conversionStatus\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// EncryptionMethod accessor autogenerated
func (s *mqlWindowsBitlockerVolume) EncryptionMethod() (interface{}, error) {
	res, ok := s.Cache.Load("encryptionMethod")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"encryptionMethod\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"encryptionMethod\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// LockStatus accessor autogenerated
func (s *mqlWindowsBitlockerVolume) LockStatus() (int64, error) {
	res, ok := s.Cache.Load("lockStatus")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"lockStatus\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"lockStatus\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// PersistentVolumeID accessor autogenerated
func (s *mqlWindowsBitlockerVolume) PersistentVolumeID() (string, error) {
	res, ok := s.Cache.Load("persistentVolumeID")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"persistentVolumeID\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"persistentVolumeID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ProtectionStatus accessor autogenerated
func (s *mqlWindowsBitlockerVolume) ProtectionStatus() (interface{}, error) {
	res, ok := s.Cache.Load("protectionStatus")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"protectionStatus\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"protectionStatus\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlWindowsBitlockerVolume) Version() (interface{}, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.bitlocker.volume\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.bitlocker.volume\" failed to cast field \"version\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsBitlockerVolume) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.bitlocker.volume].MqlCompute")
	switch name {
	case "deviceID":
		return nil
	case "driveLetter":
		return nil
	case "conversionStatus":
		return nil
	case "encryptionMethod":
		return nil
	case "lockStatus":
		return nil
	case "persistentVolumeID":
		return nil
	case "protectionStatus":
		return nil
	case "version":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.bitlocker.volume\" resource")
	}
}

// WindowsSecurity resource interface
type WindowsSecurity interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Products() ([]interface{}, error)
}

// mqlWindowsSecurity for the windows.security resource
type mqlWindowsSecurity struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsSecurity) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.security resource
func newWindowsSecurity(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsSecurity{runtime.NewResource("windows.security")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "products":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security\", its \"products\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.security\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.security with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsSecurity) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsSecurity) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security].Register")
	switch name {
	case "products":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsSecurity) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.security].Field")
	switch name {
	case "products":
		return s.Products()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.security\" resource")
	}
}

// Products accessor autogenerated
func (s *mqlWindowsSecurity) Products() ([]interface{}, error) {
	res, ok := s.Cache.Load("products")
	if !ok || !res.Valid {
		if err := s.ComputeProducts(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("products")
		if !ok {
			return nil, errors.New("\"windows.security\" calculated \"products\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "products")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security\" failed to cast field \"products\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsSecurity) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security].MqlCompute")
	switch name {
	case "products":
		return s.ComputeProducts()
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security\" resource")
	}
}

// ComputeProducts computer autogenerated
func (s *mqlWindowsSecurity) ComputeProducts() error {
	var err error
	if _, ok := s.Cache.Load("products"); ok {
		return nil
	}
	vres, err := s.GetProducts()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("products", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// WindowsSecurityProduct resource interface
type WindowsSecurityProduct interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Type() (string, error)
	Guid() (string, error)
	Name() (string, error)
	State() (int64, error)
	ProductState() (string, error)
	SignatureState() (string, error)
	Timestamp() (*time.Time, error)
}

// mqlWindowsSecurityProduct for the windows.security.product resource
type mqlWindowsSecurityProduct struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsSecurityProduct) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.security.product resource
func newWindowsSecurityProduct(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsSecurityProduct{runtime.NewResource("windows.security.product")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "guid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"guid\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "state":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"state\" argument has the wrong type (expected type \"int64\")")
			}
		case "productState":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"productState\" argument has the wrong type (expected type \"string\")")
			}
		case "signatureState":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"signatureState\" argument has the wrong type (expected type \"string\")")
			}
		case "timestamp":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"timestamp\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.security.product\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.security.product with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsSecurityProduct) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("guid"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"guid\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("productState"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"productState\". This field is required.")
	}
	if _, ok := s.Cache.Load("signatureState"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"signatureState\". This field is required.")
	}
	if _, ok := s.Cache.Load("timestamp"); !ok {
		return errors.New("Initialized \"windows.security.product\" resource without a \"timestamp\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsSecurityProduct) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security.product].Register")
	switch name {
	case "type":
		return nil
	case "guid":
		return nil
	case "name":
		return nil
	case "state":
		return nil
	case "productState":
		return nil
	case "signatureState":
		return nil
	case "timestamp":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security.product\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsSecurityProduct) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.security.product].Field")
	switch name {
	case "type":
		return s.Type()
	case "guid":
		return s.Guid()
	case "name":
		return s.Name()
	case "state":
		return s.State()
	case "productState":
		return s.ProductState()
	case "signatureState":
		return s.SignatureState()
	case "timestamp":
		return s.Timestamp()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.security.product\" resource")
	}
}

// Type accessor autogenerated
func (s *mqlWindowsSecurityProduct) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.security.product\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.security.product\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Guid accessor autogenerated
func (s *mqlWindowsSecurityProduct) Guid() (string, error) {
	res, ok := s.Cache.Load("guid")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.security.product\" failed: no value provided for static field \"guid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.security.product\" failed to cast field \"guid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlWindowsSecurityProduct) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.security.product\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.security.product\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlWindowsSecurityProduct) State() (int64, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return 0, errors.New("\"windows.security.product\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"windows.security.product\" failed to cast field \"state\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// ProductState accessor autogenerated
func (s *mqlWindowsSecurityProduct) ProductState() (string, error) {
	res, ok := s.Cache.Load("productState")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.security.product\" failed: no value provided for static field \"productState\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.security.product\" failed to cast field \"productState\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SignatureState accessor autogenerated
func (s *mqlWindowsSecurityProduct) SignatureState() (string, error) {
	res, ok := s.Cache.Load("signatureState")
	if !ok || !res.Valid {
		return "", errors.New("\"windows.security.product\" failed: no value provided for static field \"signatureState\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"windows.security.product\" failed to cast field \"signatureState\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Timestamp accessor autogenerated
func (s *mqlWindowsSecurityProduct) Timestamp() (*time.Time, error) {
	res, ok := s.Cache.Load("timestamp")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.product\" failed: no value provided for static field \"timestamp\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"windows.security.product\" failed to cast field \"timestamp\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsSecurityProduct) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security.product].MqlCompute")
	switch name {
	case "type":
		return nil
	case "guid":
		return nil
	case "name":
		return nil
	case "state":
		return nil
	case "productState":
		return nil
	case "signatureState":
		return nil
	case "timestamp":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security.product\" resource")
	}
}

// WindowsSecurityHealth resource interface
type WindowsSecurityHealth interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Firewall() (interface{}, error)
	AutoUpdate() (interface{}, error)
	AntiVirus() (interface{}, error)
	AntiSpyware() (interface{}, error)
	InternetSettings() (interface{}, error)
	Uac() (interface{}, error)
	SecurityCenterService() (interface{}, error)
}

// mqlWindowsSecurityHealth for the windows.security.health resource
type mqlWindowsSecurityHealth struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlWindowsSecurityHealth) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the windows.security.health resource
func newWindowsSecurityHealth(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlWindowsSecurityHealth{runtime.NewResource("windows.security.health")}
	var existing WindowsSecurityHealth
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "firewall":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"firewall\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "autoUpdate":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"autoUpdate\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "antiVirus":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"antiVirus\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "antiSpyware":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"antiSpyware\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "internetSettings":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"internetSettings\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "uac":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"uac\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "securityCenterService":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"securityCenterService\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"windows.security.health\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized windows.security.health with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlWindowsSecurityHealth) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("firewall"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"firewall\". This field is required.")
	}
	if _, ok := s.Cache.Load("autoUpdate"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"autoUpdate\". This field is required.")
	}
	if _, ok := s.Cache.Load("antiVirus"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"antiVirus\". This field is required.")
	}
	if _, ok := s.Cache.Load("antiSpyware"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"antiSpyware\". This field is required.")
	}
	if _, ok := s.Cache.Load("internetSettings"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"internetSettings\". This field is required.")
	}
	if _, ok := s.Cache.Load("uac"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"uac\". This field is required.")
	}
	if _, ok := s.Cache.Load("securityCenterService"); !ok {
		return errors.New("Initialized \"windows.security.health\" resource without a \"securityCenterService\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlWindowsSecurityHealth) Register(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security.health].Register")
	switch name {
	case "firewall":
		return nil
	case "autoUpdate":
		return nil
	case "antiVirus":
		return nil
	case "antiSpyware":
		return nil
	case "internetSettings":
		return nil
	case "uac":
		return nil
	case "securityCenterService":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security.health\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlWindowsSecurityHealth) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[windows.security.health].Field")
	switch name {
	case "firewall":
		return s.Firewall()
	case "autoUpdate":
		return s.AutoUpdate()
	case "antiVirus":
		return s.AntiVirus()
	case "antiSpyware":
		return s.AntiSpyware()
	case "internetSettings":
		return s.InternetSettings()
	case "uac":
		return s.Uac()
	case "securityCenterService":
		return s.SecurityCenterService()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"windows.security.health\" resource")
	}
}

// Firewall accessor autogenerated
func (s *mqlWindowsSecurityHealth) Firewall() (interface{}, error) {
	res, ok := s.Cache.Load("firewall")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"firewall\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"firewall\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AutoUpdate accessor autogenerated
func (s *mqlWindowsSecurityHealth) AutoUpdate() (interface{}, error) {
	res, ok := s.Cache.Load("autoUpdate")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"autoUpdate\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"autoUpdate\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AntiVirus accessor autogenerated
func (s *mqlWindowsSecurityHealth) AntiVirus() (interface{}, error) {
	res, ok := s.Cache.Load("antiVirus")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"antiVirus\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"antiVirus\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AntiSpyware accessor autogenerated
func (s *mqlWindowsSecurityHealth) AntiSpyware() (interface{}, error) {
	res, ok := s.Cache.Load("antiSpyware")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"antiSpyware\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"antiSpyware\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// InternetSettings accessor autogenerated
func (s *mqlWindowsSecurityHealth) InternetSettings() (interface{}, error) {
	res, ok := s.Cache.Load("internetSettings")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"internetSettings\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"internetSettings\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Uac accessor autogenerated
func (s *mqlWindowsSecurityHealth) Uac() (interface{}, error) {
	res, ok := s.Cache.Load("uac")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"uac\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"uac\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// SecurityCenterService accessor autogenerated
func (s *mqlWindowsSecurityHealth) SecurityCenterService() (interface{}, error) {
	res, ok := s.Cache.Load("securityCenterService")
	if !ok || !res.Valid {
		return nil, errors.New("\"windows.security.health\" failed: no value provided for static field \"securityCenterService\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"windows.security.health\" failed to cast field \"securityCenterService\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlWindowsSecurityHealth) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[windows.security.health].MqlCompute")
	switch name {
	case "firewall":
		return nil
	case "autoUpdate":
		return nil
	case "antiVirus":
		return nil
	case "antiSpyware":
		return nil
	case "internetSettings":
		return nil
	case "uac":
		return nil
	case "securityCenterService":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"windows.security.health\" resource")
	}
}

// Yum resource interface
type Yum interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Vars() (map[string]interface{}, error)
	Repos() ([]interface{}, error)
}

// mqlYum for the yum resource
type mqlYum struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlYum) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the yum resource
func newYum(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlYum{runtime.NewResource("yum")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "vars":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"yum\", its \"vars\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "repos":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"yum\", its \"repos\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"yum\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized yum with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlYum) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlYum) Register(name string) error {
	log.Trace().Str("field", name).Msg("[yum].Register")
	switch name {
	case "vars":
		return nil
	case "repos":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"yum\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlYum) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[yum].Field")
	switch name {
	case "vars":
		return s.Vars()
	case "repos":
		return s.Repos()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"yum\" resource")
	}
}

// Vars accessor autogenerated
func (s *mqlYum) Vars() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("vars")
	if !ok || !res.Valid {
		if err := s.ComputeVars(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("vars")
		if !ok {
			return nil, errors.New("\"yum\" calculated \"vars\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "vars")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"yum\" failed to cast field \"vars\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Repos accessor autogenerated
func (s *mqlYum) Repos() ([]interface{}, error) {
	res, ok := s.Cache.Load("repos")
	if !ok || !res.Valid {
		if err := s.ComputeRepos(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repos")
		if !ok {
			return nil, errors.New("\"yum\" calculated \"repos\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repos")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"yum\" failed to cast field \"repos\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlYum) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[yum].MqlCompute")
	switch name {
	case "vars":
		return s.ComputeVars()
	case "repos":
		return s.ComputeRepos()
	default:
		return errors.New("Cannot find field '" + name + "' in \"yum\" resource")
	}
}

// ComputeVars computer autogenerated
func (s *mqlYum) ComputeVars() error {
	var err error
	if _, ok := s.Cache.Load("vars"); ok {
		return nil
	}
	vres, err := s.GetVars()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("vars", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRepos computer autogenerated
func (s *mqlYum) ComputeRepos() error {
	var err error
	if _, ok := s.Cache.Load("repos"); ok {
		return nil
	}
	vres, err := s.GetRepos()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repos", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// YumRepo resource interface
type YumRepo interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Name() (string, error)
	Status() (string, error)
	Baseurl() ([]interface{}, error)
	Expire() (string, error)
	Filename() (string, error)
	File() (core.File, error)
	Revision() (string, error)
	Pkgs() (string, error)
	Size() (string, error)
	Mirrors() (string, error)
	Enabled() (bool, error)
}

// mqlYumRepo for the yum.repo resource
type mqlYumRepo struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlYumRepo) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the yum.repo resource
func newYumRepo(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlYumRepo{runtime.NewResource("yum.repo")}
	var existing YumRepo
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "status":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"status\" argument has the wrong type (expected type \"string\")")
			}
		case "baseurl":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"baseurl\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "expire":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"expire\" argument has the wrong type (expected type \"string\")")
			}
		case "filename":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"filename\" argument has the wrong type (expected type \"string\")")
			}
		case "file":
			if _, ok := val.(core.File); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"file\" argument has the wrong type (expected type \"core.File\")")
			}
		case "revision":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"revision\" argument has the wrong type (expected type \"string\")")
			}
		case "pkgs":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"pkgs\" argument has the wrong type (expected type \"string\")")
			}
		case "size":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"size\" argument has the wrong type (expected type \"string\")")
			}
		case "mirrors":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"mirrors\" argument has the wrong type (expected type \"string\")")
			}
		case "enabled":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"enabled\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"yum.repo\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized yum.repo with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlYumRepo) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("status"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"status\". This field is required.")
	}
	if _, ok := s.Cache.Load("baseurl"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"baseurl\". This field is required.")
	}
	if _, ok := s.Cache.Load("expire"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"expire\". This field is required.")
	}
	if _, ok := s.Cache.Load("filename"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"filename\". This field is required.")
	}
	if _, ok := s.Cache.Load("file"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"file\". This field is required.")
	}
	if _, ok := s.Cache.Load("revision"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"revision\". This field is required.")
	}
	if _, ok := s.Cache.Load("pkgs"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"pkgs\". This field is required.")
	}
	if _, ok := s.Cache.Load("size"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"size\". This field is required.")
	}
	if _, ok := s.Cache.Load("mirrors"); !ok {
		return errors.New("Initialized \"yum.repo\" resource without a \"mirrors\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlYumRepo) Register(name string) error {
	log.Trace().Str("field", name).Msg("[yum.repo].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "status":
		return nil
	case "baseurl":
		return nil
	case "expire":
		return nil
	case "filename":
		return nil
	case "file":
		return nil
	case "revision":
		return nil
	case "pkgs":
		return nil
	case "size":
		return nil
	case "mirrors":
		return nil
	case "enabled":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"yum.repo\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlYumRepo) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[yum.repo].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "status":
		return s.Status()
	case "baseurl":
		return s.Baseurl()
	case "expire":
		return s.Expire()
	case "filename":
		return s.Filename()
	case "file":
		return s.File()
	case "revision":
		return s.Revision()
	case "pkgs":
		return s.Pkgs()
	case "size":
		return s.Size()
	case "mirrors":
		return s.Mirrors()
	case "enabled":
		return s.Enabled()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"yum.repo\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlYumRepo) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlYumRepo) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Status accessor autogenerated
func (s *mqlYumRepo) Status() (string, error) {
	res, ok := s.Cache.Load("status")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"status\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"status\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Baseurl accessor autogenerated
func (s *mqlYumRepo) Baseurl() ([]interface{}, error) {
	res, ok := s.Cache.Load("baseurl")
	if !ok || !res.Valid {
		return nil, errors.New("\"yum.repo\" failed: no value provided for static field \"baseurl\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"yum.repo\" failed to cast field \"baseurl\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Expire accessor autogenerated
func (s *mqlYumRepo) Expire() (string, error) {
	res, ok := s.Cache.Load("expire")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"expire\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"expire\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Filename accessor autogenerated
func (s *mqlYumRepo) Filename() (string, error) {
	res, ok := s.Cache.Load("filename")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"filename\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"filename\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlYumRepo) File() (core.File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		return nil, errors.New("\"yum.repo\" failed: no value provided for static field \"file\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(core.File)
	if !ok {
		return nil, fmt.Errorf("\"yum.repo\" failed to cast field \"file\" to the right type (core.File): %#v", res)
	}
	return tres, nil
}

// Revision accessor autogenerated
func (s *mqlYumRepo) Revision() (string, error) {
	res, ok := s.Cache.Load("revision")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"revision\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"revision\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Pkgs accessor autogenerated
func (s *mqlYumRepo) Pkgs() (string, error) {
	res, ok := s.Cache.Load("pkgs")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"pkgs\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"pkgs\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Size accessor autogenerated
func (s *mqlYumRepo) Size() (string, error) {
	res, ok := s.Cache.Load("size")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"size\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"size\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mirrors accessor autogenerated
func (s *mqlYumRepo) Mirrors() (string, error) {
	res, ok := s.Cache.Load("mirrors")
	if !ok || !res.Valid {
		return "", errors.New("\"yum.repo\" failed: no value provided for static field \"mirrors\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yum.repo\" failed to cast field \"mirrors\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Enabled accessor autogenerated
func (s *mqlYumRepo) Enabled() (bool, error) {
	res, ok := s.Cache.Load("enabled")
	if !ok || !res.Valid {
		if err := s.ComputeEnabled(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("enabled")
		if !ok {
			return false, errors.New("\"yum.repo\" calculated \"enabled\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "enabled")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"yum.repo\" failed to cast field \"enabled\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlYumRepo) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[yum.repo].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "status":
		return nil
	case "baseurl":
		return nil
	case "expire":
		return nil
	case "filename":
		return nil
	case "file":
		return nil
	case "revision":
		return nil
	case "pkgs":
		return nil
	case "size":
		return nil
	case "mirrors":
		return nil
	case "enabled":
		return s.ComputeEnabled()
	default:
		return errors.New("Cannot find field '" + name + "' in \"yum.repo\" resource")
	}
}

// ComputeEnabled computer autogenerated
func (s *mqlYumRepo) ComputeEnabled() error {
	var err error
	if _, ok := s.Cache.Load("enabled"); ok {
		return nil
	}
	vres, err := s.GetEnabled()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("enabled", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ContainerImage resource interface
type ContainerImage interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Identifier() (string, error)
	IdentifierType() (string, error)
	Repository() (ContainerRepository, error)
}

// mqlContainerImage for the container.image resource
type mqlContainerImage struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlContainerImage) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the container.image resource
func newContainerImage(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlContainerImage{runtime.NewResource("container.image")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.image\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "identifier":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.image\", its \"identifier\" argument has the wrong type (expected type \"string\")")
			}
		case "identifierType":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.image\", its \"identifierType\" argument has the wrong type (expected type \"string\")")
			}
		case "repository":
			if _, ok := val.(ContainerRepository); !ok {
				return nil, errors.New("Failed to initialize \"container.image\", its \"repository\" argument has the wrong type (expected type \"ContainerRepository\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"container.image\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized container.image with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlContainerImage) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"container.image\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("identifier"); !ok {
		return errors.New("Initialized \"container.image\" resource without a \"identifier\". This field is required.")
	}
	if _, ok := s.Cache.Load("identifierType"); !ok {
		return errors.New("Initialized \"container.image\" resource without a \"identifierType\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlContainerImage) Register(name string) error {
	log.Trace().Str("field", name).Msg("[container.image].Register")
	switch name {
	case "name":
		return nil
	case "identifier":
		return nil
	case "identifierType":
		return nil
	case "repository":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"container.image\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlContainerImage) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[container.image].Field")
	switch name {
	case "name":
		return s.Name()
	case "identifier":
		return s.Identifier()
	case "identifierType":
		return s.IdentifierType()
	case "repository":
		return s.Repository()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"container.image\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlContainerImage) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"container.image\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.image\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Identifier accessor autogenerated
func (s *mqlContainerImage) Identifier() (string, error) {
	res, ok := s.Cache.Load("identifier")
	if !ok || !res.Valid {
		return "", errors.New("\"container.image\" failed: no value provided for static field \"identifier\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.image\" failed to cast field \"identifier\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// IdentifierType accessor autogenerated
func (s *mqlContainerImage) IdentifierType() (string, error) {
	res, ok := s.Cache.Load("identifierType")
	if !ok || !res.Valid {
		return "", errors.New("\"container.image\" failed: no value provided for static field \"identifierType\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.image\" failed to cast field \"identifierType\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Repository accessor autogenerated
func (s *mqlContainerImage) Repository() (ContainerRepository, error) {
	res, ok := s.Cache.Load("repository")
	if !ok || !res.Valid {
		if err := s.ComputeRepository(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repository")
		if !ok {
			return nil, errors.New("\"container.image\" calculated \"repository\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repository")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(ContainerRepository)
	if !ok {
		return nil, fmt.Errorf("\"container.image\" failed to cast field \"repository\" to the right type (ContainerRepository): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlContainerImage) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[container.image].MqlCompute")
	switch name {
	case "name":
		return nil
	case "identifier":
		return nil
	case "identifierType":
		return nil
	case "repository":
		return s.ComputeRepository()
	default:
		return errors.New("Cannot find field '" + name + "' in \"container.image\" resource")
	}
}

// ComputeRepository computer autogenerated
func (s *mqlContainerImage) ComputeRepository() error {
	var err error
	if _, ok := s.Cache.Load("repository"); ok {
		return nil
	}
	vres, err := s.GetRepository()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repository", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ContainerRepository resource interface
type ContainerRepository interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Scheme() (string, error)
	FullName() (string, error)
	Registry() (string, error)
}

// mqlContainerRepository for the container.repository resource
type mqlContainerRepository struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlContainerRepository) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the container.repository resource
func newContainerRepository(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlContainerRepository{runtime.NewResource("container.repository")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.repository\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "scheme":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.repository\", its \"scheme\" argument has the wrong type (expected type \"string\")")
			}
		case "fullName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.repository\", its \"fullName\" argument has the wrong type (expected type \"string\")")
			}
		case "registry":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"container.repository\", its \"registry\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"container.repository\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized container.repository with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlContainerRepository) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"container.repository\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("scheme"); !ok {
		return errors.New("Initialized \"container.repository\" resource without a \"scheme\". This field is required.")
	}
	if _, ok := s.Cache.Load("fullName"); !ok {
		return errors.New("Initialized \"container.repository\" resource without a \"fullName\". This field is required.")
	}
	if _, ok := s.Cache.Load("registry"); !ok {
		return errors.New("Initialized \"container.repository\" resource without a \"registry\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlContainerRepository) Register(name string) error {
	log.Trace().Str("field", name).Msg("[container.repository].Register")
	switch name {
	case "name":
		return nil
	case "scheme":
		return nil
	case "fullName":
		return nil
	case "registry":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"container.repository\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlContainerRepository) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[container.repository].Field")
	switch name {
	case "name":
		return s.Name()
	case "scheme":
		return s.Scheme()
	case "fullName":
		return s.FullName()
	case "registry":
		return s.Registry()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"container.repository\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlContainerRepository) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"container.repository\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.repository\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Scheme accessor autogenerated
func (s *mqlContainerRepository) Scheme() (string, error) {
	res, ok := s.Cache.Load("scheme")
	if !ok || !res.Valid {
		return "", errors.New("\"container.repository\" failed: no value provided for static field \"scheme\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.repository\" failed to cast field \"scheme\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// FullName accessor autogenerated
func (s *mqlContainerRepository) FullName() (string, error) {
	res, ok := s.Cache.Load("fullName")
	if !ok || !res.Valid {
		return "", errors.New("\"container.repository\" failed: no value provided for static field \"fullName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.repository\" failed to cast field \"fullName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Registry accessor autogenerated
func (s *mqlContainerRepository) Registry() (string, error) {
	res, ok := s.Cache.Load("registry")
	if !ok || !res.Valid {
		return "", errors.New("\"container.repository\" failed: no value provided for static field \"registry\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"container.repository\" failed to cast field \"registry\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlContainerRepository) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[container.repository].MqlCompute")
	switch name {
	case "name":
		return nil
	case "scheme":
		return nil
	case "fullName":
		return nil
	case "registry":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"container.repository\" resource")
	}
}

// EquinixMetalProject resource interface
type EquinixMetalProject interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Name() (string, error)
	Organization() (EquinixMetalOrganization, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Url() (string, error)
	PaymentMethod() (interface{}, error)
	Users() ([]interface{}, error)
	SshKeys() ([]interface{}, error)
	Devices() ([]interface{}, error)
}

// mqlEquinixMetalProject for the equinix.metal.project resource
type mqlEquinixMetalProject struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlEquinixMetalProject) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the equinix.metal.project resource
func newEquinixMetalProject(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlEquinixMetalProject{runtime.NewResource("equinix.metal.project")}
	var existing EquinixMetalProject
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "organization":
			if _, ok := val.(EquinixMetalOrganization); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"organization\" argument has the wrong type (expected type \"EquinixMetalOrganization\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "paymentMethod":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"paymentMethod\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "users":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"users\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "sshKeys":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"sshKeys\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "devices":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"devices\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.project\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized equinix.metal.project with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlEquinixMetalProject) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("paymentMethod"); !ok {
		return errors.New("Initialized \"equinix.metal.project\" resource without a \"paymentMethod\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlEquinixMetalProject) Register(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.project].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "organization":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "url":
		return nil
	case "paymentMethod":
		return nil
	case "users":
		return nil
	case "sshKeys":
		return nil
	case "devices":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.project\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlEquinixMetalProject) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[equinix.metal.project].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "organization":
		return s.Organization()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "url":
		return s.Url()
	case "paymentMethod":
		return s.PaymentMethod()
	case "users":
		return s.Users()
	case "sshKeys":
		return s.SshKeys()
	case "devices":
		return s.Devices()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"equinix.metal.project\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlEquinixMetalProject) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.project\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.project\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlEquinixMetalProject) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.project\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.project\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Organization accessor autogenerated
func (s *mqlEquinixMetalProject) Organization() (EquinixMetalOrganization, error) {
	res, ok := s.Cache.Load("organization")
	if !ok || !res.Valid {
		if err := s.ComputeOrganization(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("organization")
		if !ok {
			return nil, errors.New("\"equinix.metal.project\" calculated \"organization\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "organization")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(EquinixMetalOrganization)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"organization\" to the right type (EquinixMetalOrganization): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlEquinixMetalProject) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.project\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlEquinixMetalProject) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.project\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlEquinixMetalProject) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.project\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.project\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PaymentMethod accessor autogenerated
func (s *mqlEquinixMetalProject) PaymentMethod() (interface{}, error) {
	res, ok := s.Cache.Load("paymentMethod")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.project\" failed: no value provided for static field \"paymentMethod\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"paymentMethod\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Users accessor autogenerated
func (s *mqlEquinixMetalProject) Users() ([]interface{}, error) {
	res, ok := s.Cache.Load("users")
	if !ok || !res.Valid {
		if err := s.ComputeUsers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("users")
		if !ok {
			return nil, errors.New("\"equinix.metal.project\" calculated \"users\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "users")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"users\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// SshKeys accessor autogenerated
func (s *mqlEquinixMetalProject) SshKeys() ([]interface{}, error) {
	res, ok := s.Cache.Load("sshKeys")
	if !ok || !res.Valid {
		if err := s.ComputeSshKeys(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("sshKeys")
		if !ok {
			return nil, errors.New("\"equinix.metal.project\" calculated \"sshKeys\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "sshKeys")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"sshKeys\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Devices accessor autogenerated
func (s *mqlEquinixMetalProject) Devices() ([]interface{}, error) {
	res, ok := s.Cache.Load("devices")
	if !ok || !res.Valid {
		if err := s.ComputeDevices(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("devices")
		if !ok {
			return nil, errors.New("\"equinix.metal.project\" calculated \"devices\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "devices")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.project\" failed to cast field \"devices\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlEquinixMetalProject) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.project].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "organization":
		return s.ComputeOrganization()
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "url":
		return nil
	case "paymentMethod":
		return nil
	case "users":
		return s.ComputeUsers()
	case "sshKeys":
		return s.ComputeSshKeys()
	case "devices":
		return s.ComputeDevices()
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.project\" resource")
	}
}

// ComputeOrganization computer autogenerated
func (s *mqlEquinixMetalProject) ComputeOrganization() error {
	var err error
	if _, ok := s.Cache.Load("organization"); ok {
		return nil
	}
	vres, err := s.GetOrganization()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("organization", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUsers computer autogenerated
func (s *mqlEquinixMetalProject) ComputeUsers() error {
	var err error
	if _, ok := s.Cache.Load("users"); ok {
		return nil
	}
	vres, err := s.GetUsers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("users", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSshKeys computer autogenerated
func (s *mqlEquinixMetalProject) ComputeSshKeys() error {
	var err error
	if _, ok := s.Cache.Load("sshKeys"); ok {
		return nil
	}
	vres, err := s.GetSshKeys()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("sshKeys", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDevices computer autogenerated
func (s *mqlEquinixMetalProject) ComputeDevices() error {
	var err error
	if _, ok := s.Cache.Load("devices"); ok {
		return nil
	}
	vres, err := s.GetDevices()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("devices", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// EquinixMetalOrganization resource interface
type EquinixMetalOrganization interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Name() (string, error)
	Description() (string, error)
	Website() (string, error)
	Twitter() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Address() (interface{}, error)
	TaxId() (string, error)
	MainPhone() (string, error)
	BillingPhone() (string, error)
	CreditAmount() (float64, error)
	Url() (string, error)
}

// mqlEquinixMetalOrganization for the equinix.metal.organization resource
type mqlEquinixMetalOrganization struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlEquinixMetalOrganization) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the equinix.metal.organization resource
func newEquinixMetalOrganization(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlEquinixMetalOrganization{runtime.NewResource("equinix.metal.organization")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "website":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"website\" argument has the wrong type (expected type \"string\")")
			}
		case "twitter":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"twitter\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "address":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"address\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "taxId":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"taxId\" argument has the wrong type (expected type \"string\")")
			}
		case "mainPhone":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"mainPhone\" argument has the wrong type (expected type \"string\")")
			}
		case "billingPhone":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"billingPhone\" argument has the wrong type (expected type \"string\")")
			}
		case "creditAmount":
			if _, ok := val.(float64); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"creditAmount\" argument has the wrong type (expected type \"float64\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.organization\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized equinix.metal.organization with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlEquinixMetalOrganization) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("website"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"website\". This field is required.")
	}
	if _, ok := s.Cache.Load("twitter"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"twitter\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"address\". This field is required.")
	}
	if _, ok := s.Cache.Load("taxId"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"taxId\". This field is required.")
	}
	if _, ok := s.Cache.Load("mainPhone"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"mainPhone\". This field is required.")
	}
	if _, ok := s.Cache.Load("billingPhone"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"billingPhone\". This field is required.")
	}
	if _, ok := s.Cache.Load("creditAmount"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"creditAmount\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"equinix.metal.organization\" resource without a \"url\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlEquinixMetalOrganization) Register(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.organization].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "description":
		return nil
	case "website":
		return nil
	case "twitter":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "address":
		return nil
	case "taxId":
		return nil
	case "mainPhone":
		return nil
	case "billingPhone":
		return nil
	case "creditAmount":
		return nil
	case "url":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.organization\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlEquinixMetalOrganization) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[equinix.metal.organization].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "description":
		return s.Description()
	case "website":
		return s.Website()
	case "twitter":
		return s.Twitter()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "address":
		return s.Address()
	case "taxId":
		return s.TaxId()
	case "mainPhone":
		return s.MainPhone()
	case "billingPhone":
		return s.BillingPhone()
	case "creditAmount":
		return s.CreditAmount()
	case "url":
		return s.Url()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"equinix.metal.organization\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlEquinixMetalOrganization) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlEquinixMetalOrganization) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlEquinixMetalOrganization) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Website accessor autogenerated
func (s *mqlEquinixMetalOrganization) Website() (string, error) {
	res, ok := s.Cache.Load("website")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"website\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"website\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Twitter accessor autogenerated
func (s *mqlEquinixMetalOrganization) Twitter() (string, error) {
	res, ok := s.Cache.Load("twitter")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"twitter\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"twitter\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlEquinixMetalOrganization) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlEquinixMetalOrganization) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Address accessor autogenerated
func (s *mqlEquinixMetalOrganization) Address() (interface{}, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"address\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// TaxId accessor autogenerated
func (s *mqlEquinixMetalOrganization) TaxId() (string, error) {
	res, ok := s.Cache.Load("taxId")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"taxId\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"taxId\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// MainPhone accessor autogenerated
func (s *mqlEquinixMetalOrganization) MainPhone() (string, error) {
	res, ok := s.Cache.Load("mainPhone")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"mainPhone\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"mainPhone\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// BillingPhone accessor autogenerated
func (s *mqlEquinixMetalOrganization) BillingPhone() (string, error) {
	res, ok := s.Cache.Load("billingPhone")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"billingPhone\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"billingPhone\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreditAmount accessor autogenerated
func (s *mqlEquinixMetalOrganization) CreditAmount() (float64, error) {
	res, ok := s.Cache.Load("creditAmount")
	if !ok || !res.Valid {
		return 0.0, errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"creditAmount\"")
	}
	if res.Error != nil {
		return 0.0, res.Error
	}
	tres, ok := res.Data.(float64)
	if !ok {
		return 0.0, fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"creditAmount\" to the right type (float64): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlEquinixMetalOrganization) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.organization\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.organization\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlEquinixMetalOrganization) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.organization].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "description":
		return nil
	case "website":
		return nil
	case "twitter":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "address":
		return nil
	case "taxId":
		return nil
	case "mainPhone":
		return nil
	case "billingPhone":
		return nil
	case "creditAmount":
		return nil
	case "url":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.organization\" resource")
	}
}

// EquinixMetalUser resource interface
type EquinixMetalUser interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	FirstName() (string, error)
	LastName() (string, error)
	FullName() (string, error)
	Email() (string, error)
	TwoFactorAuth() (string, error)
	AvatarUrl() (string, error)
	Twitter() (string, error)
	Facebook() (string, error)
	Linkedin() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Timezone() (string, error)
	PhoneNumber() (string, error)
	Url() (string, error)
	Vpn() (bool, error)
}

// mqlEquinixMetalUser for the equinix.metal.user resource
type mqlEquinixMetalUser struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlEquinixMetalUser) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the equinix.metal.user resource
func newEquinixMetalUser(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlEquinixMetalUser{runtime.NewResource("equinix.metal.user")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "firstName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"firstName\" argument has the wrong type (expected type \"string\")")
			}
		case "lastName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"lastName\" argument has the wrong type (expected type \"string\")")
			}
		case "fullName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"fullName\" argument has the wrong type (expected type \"string\")")
			}
		case "email":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"email\" argument has the wrong type (expected type \"string\")")
			}
		case "twoFactorAuth":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"twoFactorAuth\" argument has the wrong type (expected type \"string\")")
			}
		case "avatarUrl":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"avatarUrl\" argument has the wrong type (expected type \"string\")")
			}
		case "twitter":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"twitter\" argument has the wrong type (expected type \"string\")")
			}
		case "facebook":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"facebook\" argument has the wrong type (expected type \"string\")")
			}
		case "linkedin":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"linkedin\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "timezone":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"timezone\" argument has the wrong type (expected type \"string\")")
			}
		case "phoneNumber":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"phoneNumber\" argument has the wrong type (expected type \"string\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "vpn":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"vpn\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.user\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized equinix.metal.user with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlEquinixMetalUser) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("firstName"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"firstName\". This field is required.")
	}
	if _, ok := s.Cache.Load("lastName"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"lastName\". This field is required.")
	}
	if _, ok := s.Cache.Load("fullName"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"fullName\". This field is required.")
	}
	if _, ok := s.Cache.Load("email"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"email\". This field is required.")
	}
	if _, ok := s.Cache.Load("twoFactorAuth"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"twoFactorAuth\". This field is required.")
	}
	if _, ok := s.Cache.Load("avatarUrl"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"avatarUrl\". This field is required.")
	}
	if _, ok := s.Cache.Load("twitter"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"twitter\". This field is required.")
	}
	if _, ok := s.Cache.Load("facebook"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"facebook\". This field is required.")
	}
	if _, ok := s.Cache.Load("linkedin"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"linkedin\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("timezone"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"timezone\". This field is required.")
	}
	if _, ok := s.Cache.Load("phoneNumber"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"phoneNumber\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("vpn"); !ok {
		return errors.New("Initialized \"equinix.metal.user\" resource without a \"vpn\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlEquinixMetalUser) Register(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.user].Register")
	switch name {
	case "id":
		return nil
	case "firstName":
		return nil
	case "lastName":
		return nil
	case "fullName":
		return nil
	case "email":
		return nil
	case "twoFactorAuth":
		return nil
	case "avatarUrl":
		return nil
	case "twitter":
		return nil
	case "facebook":
		return nil
	case "linkedin":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "timezone":
		return nil
	case "phoneNumber":
		return nil
	case "url":
		return nil
	case "vpn":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.user\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlEquinixMetalUser) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[equinix.metal.user].Field")
	switch name {
	case "id":
		return s.Id()
	case "firstName":
		return s.FirstName()
	case "lastName":
		return s.LastName()
	case "fullName":
		return s.FullName()
	case "email":
		return s.Email()
	case "twoFactorAuth":
		return s.TwoFactorAuth()
	case "avatarUrl":
		return s.AvatarUrl()
	case "twitter":
		return s.Twitter()
	case "facebook":
		return s.Facebook()
	case "linkedin":
		return s.Linkedin()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "timezone":
		return s.Timezone()
	case "phoneNumber":
		return s.PhoneNumber()
	case "url":
		return s.Url()
	case "vpn":
		return s.Vpn()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"equinix.metal.user\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlEquinixMetalUser) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// FirstName accessor autogenerated
func (s *mqlEquinixMetalUser) FirstName() (string, error) {
	res, ok := s.Cache.Load("firstName")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"firstName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"firstName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// LastName accessor autogenerated
func (s *mqlEquinixMetalUser) LastName() (string, error) {
	res, ok := s.Cache.Load("lastName")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"lastName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"lastName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// FullName accessor autogenerated
func (s *mqlEquinixMetalUser) FullName() (string, error) {
	res, ok := s.Cache.Load("fullName")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"fullName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"fullName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlEquinixMetalUser) Email() (string, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"email\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"email\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TwoFactorAuth accessor autogenerated
func (s *mqlEquinixMetalUser) TwoFactorAuth() (string, error) {
	res, ok := s.Cache.Load("twoFactorAuth")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"twoFactorAuth\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"twoFactorAuth\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AvatarUrl accessor autogenerated
func (s *mqlEquinixMetalUser) AvatarUrl() (string, error) {
	res, ok := s.Cache.Load("avatarUrl")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"avatarUrl\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"avatarUrl\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Twitter accessor autogenerated
func (s *mqlEquinixMetalUser) Twitter() (string, error) {
	res, ok := s.Cache.Load("twitter")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"twitter\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"twitter\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Facebook accessor autogenerated
func (s *mqlEquinixMetalUser) Facebook() (string, error) {
	res, ok := s.Cache.Load("facebook")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"facebook\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"facebook\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Linkedin accessor autogenerated
func (s *mqlEquinixMetalUser) Linkedin() (string, error) {
	res, ok := s.Cache.Load("linkedin")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"linkedin\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"linkedin\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlEquinixMetalUser) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.user\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.user\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlEquinixMetalUser) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.user\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.user\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Timezone accessor autogenerated
func (s *mqlEquinixMetalUser) Timezone() (string, error) {
	res, ok := s.Cache.Load("timezone")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"timezone\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"timezone\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PhoneNumber accessor autogenerated
func (s *mqlEquinixMetalUser) PhoneNumber() (string, error) {
	res, ok := s.Cache.Load("phoneNumber")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"phoneNumber\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"phoneNumber\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlEquinixMetalUser) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.user\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.user\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Vpn accessor autogenerated
func (s *mqlEquinixMetalUser) Vpn() (bool, error) {
	res, ok := s.Cache.Load("vpn")
	if !ok || !res.Valid {
		return false, errors.New("\"equinix.metal.user\" failed: no value provided for static field \"vpn\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"equinix.metal.user\" failed to cast field \"vpn\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlEquinixMetalUser) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.user].MqlCompute")
	switch name {
	case "id":
		return nil
	case "firstName":
		return nil
	case "lastName":
		return nil
	case "fullName":
		return nil
	case "email":
		return nil
	case "twoFactorAuth":
		return nil
	case "avatarUrl":
		return nil
	case "twitter":
		return nil
	case "facebook":
		return nil
	case "linkedin":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "timezone":
		return nil
	case "phoneNumber":
		return nil
	case "url":
		return nil
	case "vpn":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.user\" resource")
	}
}

// EquinixMetalSshkey resource interface
type EquinixMetalSshkey interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Label() (string, error)
	Key() (string, error)
	FingerPrint() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Url() (string, error)
}

// mqlEquinixMetalSshkey for the equinix.metal.sshkey resource
type mqlEquinixMetalSshkey struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlEquinixMetalSshkey) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the equinix.metal.sshkey resource
func newEquinixMetalSshkey(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlEquinixMetalSshkey{runtime.NewResource("equinix.metal.sshkey")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "label":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"label\" argument has the wrong type (expected type \"string\")")
			}
		case "key":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"key\" argument has the wrong type (expected type \"string\")")
			}
		case "fingerPrint":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"fingerPrint\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.sshkey\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized equinix.metal.sshkey with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlEquinixMetalSshkey) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("label"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"label\". This field is required.")
	}
	if _, ok := s.Cache.Load("key"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"key\". This field is required.")
	}
	if _, ok := s.Cache.Load("fingerPrint"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"fingerPrint\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"equinix.metal.sshkey\" resource without a \"url\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlEquinixMetalSshkey) Register(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.sshkey].Register")
	switch name {
	case "id":
		return nil
	case "label":
		return nil
	case "key":
		return nil
	case "fingerPrint":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "url":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.sshkey\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlEquinixMetalSshkey) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[equinix.metal.sshkey].Field")
	switch name {
	case "id":
		return s.Id()
	case "label":
		return s.Label()
	case "key":
		return s.Key()
	case "fingerPrint":
		return s.FingerPrint()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "url":
		return s.Url()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"equinix.metal.sshkey\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlEquinixMetalSshkey) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Label accessor autogenerated
func (s *mqlEquinixMetalSshkey) Label() (string, error) {
	res, ok := s.Cache.Load("label")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"label\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"label\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Key accessor autogenerated
func (s *mqlEquinixMetalSshkey) Key() (string, error) {
	res, ok := s.Cache.Load("key")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"key\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"key\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// FingerPrint accessor autogenerated
func (s *mqlEquinixMetalSshkey) FingerPrint() (string, error) {
	res, ok := s.Cache.Load("fingerPrint")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"fingerPrint\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"fingerPrint\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlEquinixMetalSshkey) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlEquinixMetalSshkey) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlEquinixMetalSshkey) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.sshkey\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.sshkey\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlEquinixMetalSshkey) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.sshkey].MqlCompute")
	switch name {
	case "id":
		return nil
	case "label":
		return nil
	case "key":
		return nil
	case "fingerPrint":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "url":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.sshkey\" resource")
	}
}

// EquinixMetalDevice resource interface
type EquinixMetalDevice interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	ShortID() (string, error)
	Url() (string, error)
	Hostname() (string, error)
	Description() (string, error)
	State() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Locked() (bool, error)
	BillingCycle() (string, error)
	SpotInstance() (bool, error)
	Os() (interface{}, error)
}

// mqlEquinixMetalDevice for the equinix.metal.device resource
type mqlEquinixMetalDevice struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlEquinixMetalDevice) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the equinix.metal.device resource
func newEquinixMetalDevice(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlEquinixMetalDevice{runtime.NewResource("equinix.metal.device")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "shortID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"shortID\" argument has the wrong type (expected type \"string\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "hostname":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"hostname\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "locked":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"locked\" argument has the wrong type (expected type \"bool\")")
			}
		case "billingCycle":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"billingCycle\" argument has the wrong type (expected type \"string\")")
			}
		case "spotInstance":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"spotInstance\" argument has the wrong type (expected type \"bool\")")
			}
		case "os":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"os\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"equinix.metal.device\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized equinix.metal.device with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlEquinixMetalDevice) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("shortID"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"shortID\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("hostname"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"hostname\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("locked"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"locked\". This field is required.")
	}
	if _, ok := s.Cache.Load("billingCycle"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"billingCycle\". This field is required.")
	}
	if _, ok := s.Cache.Load("spotInstance"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"spotInstance\". This field is required.")
	}
	if _, ok := s.Cache.Load("os"); !ok {
		return errors.New("Initialized \"equinix.metal.device\" resource without a \"os\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlEquinixMetalDevice) Register(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.device].Register")
	switch name {
	case "id":
		return nil
	case "shortID":
		return nil
	case "url":
		return nil
	case "hostname":
		return nil
	case "description":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "locked":
		return nil
	case "billingCycle":
		return nil
	case "spotInstance":
		return nil
	case "os":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.device\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlEquinixMetalDevice) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[equinix.metal.device].Field")
	switch name {
	case "id":
		return s.Id()
	case "shortID":
		return s.ShortID()
	case "url":
		return s.Url()
	case "hostname":
		return s.Hostname()
	case "description":
		return s.Description()
	case "state":
		return s.State()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "locked":
		return s.Locked()
	case "billingCycle":
		return s.BillingCycle()
	case "spotInstance":
		return s.SpotInstance()
	case "os":
		return s.Os()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"equinix.metal.device\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlEquinixMetalDevice) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ShortID accessor autogenerated
func (s *mqlEquinixMetalDevice) ShortID() (string, error) {
	res, ok := s.Cache.Load("shortID")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"shortID\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"shortID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlEquinixMetalDevice) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Hostname accessor autogenerated
func (s *mqlEquinixMetalDevice) Hostname() (string, error) {
	res, ok := s.Cache.Load("hostname")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"hostname\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"hostname\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlEquinixMetalDevice) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlEquinixMetalDevice) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlEquinixMetalDevice) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.device\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.device\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlEquinixMetalDevice) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.device\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.device\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Locked accessor autogenerated
func (s *mqlEquinixMetalDevice) Locked() (bool, error) {
	res, ok := s.Cache.Load("locked")
	if !ok || !res.Valid {
		return false, errors.New("\"equinix.metal.device\" failed: no value provided for static field \"locked\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"equinix.metal.device\" failed to cast field \"locked\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// BillingCycle accessor autogenerated
func (s *mqlEquinixMetalDevice) BillingCycle() (string, error) {
	res, ok := s.Cache.Load("billingCycle")
	if !ok || !res.Valid {
		return "", errors.New("\"equinix.metal.device\" failed: no value provided for static field \"billingCycle\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"equinix.metal.device\" failed to cast field \"billingCycle\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SpotInstance accessor autogenerated
func (s *mqlEquinixMetalDevice) SpotInstance() (bool, error) {
	res, ok := s.Cache.Load("spotInstance")
	if !ok || !res.Valid {
		return false, errors.New("\"equinix.metal.device\" failed: no value provided for static field \"spotInstance\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"equinix.metal.device\" failed to cast field \"spotInstance\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Os accessor autogenerated
func (s *mqlEquinixMetalDevice) Os() (interface{}, error) {
	res, ok := s.Cache.Load("os")
	if !ok || !res.Valid {
		return nil, errors.New("\"equinix.metal.device\" failed: no value provided for static field \"os\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"equinix.metal.device\" failed to cast field \"os\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlEquinixMetalDevice) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[equinix.metal.device].MqlCompute")
	switch name {
	case "id":
		return nil
	case "shortID":
		return nil
	case "url":
		return nil
	case "hostname":
		return nil
	case "description":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "locked":
		return nil
	case "billingCycle":
		return nil
	case "spotInstance":
		return nil
	case "os":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"equinix.metal.device\" resource")
	}
}

// Macos resource interface
type Macos interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	UserPreferences() (map[string]interface{}, error)
	UserHostPreferences() (map[string]interface{}, error)
	GlobalAccountPolicies() (interface{}, error)
}

// mqlMacos for the macos resource
type mqlMacos struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMacos) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the macos resource
func newMacos(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMacos{runtime.NewResource("macos")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "userPreferences":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos\", its \"userPreferences\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "userHostPreferences":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos\", its \"userHostPreferences\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "globalAccountPolicies":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos\", its \"globalAccountPolicies\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"macos\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized macos with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMacos) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMacos) Register(name string) error {
	log.Trace().Str("field", name).Msg("[macos].Register")
	switch name {
	case "userPreferences":
		return nil
	case "userHostPreferences":
		return nil
	case "globalAccountPolicies":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMacos) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[macos].Field")
	switch name {
	case "userPreferences":
		return s.UserPreferences()
	case "userHostPreferences":
		return s.UserHostPreferences()
	case "globalAccountPolicies":
		return s.GlobalAccountPolicies()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"macos\" resource")
	}
}

// UserPreferences accessor autogenerated
func (s *mqlMacos) UserPreferences() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("userPreferences")
	if !ok || !res.Valid {
		if err := s.ComputeUserPreferences(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("userPreferences")
		if !ok {
			return nil, errors.New("\"macos\" calculated \"userPreferences\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "userPreferences")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos\" failed to cast field \"userPreferences\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// UserHostPreferences accessor autogenerated
func (s *mqlMacos) UserHostPreferences() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("userHostPreferences")
	if !ok || !res.Valid {
		if err := s.ComputeUserHostPreferences(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("userHostPreferences")
		if !ok {
			return nil, errors.New("\"macos\" calculated \"userHostPreferences\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "userHostPreferences")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos\" failed to cast field \"userHostPreferences\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// GlobalAccountPolicies accessor autogenerated
func (s *mqlMacos) GlobalAccountPolicies() (interface{}, error) {
	res, ok := s.Cache.Load("globalAccountPolicies")
	if !ok || !res.Valid {
		if err := s.ComputeGlobalAccountPolicies(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("globalAccountPolicies")
		if !ok {
			return nil, errors.New("\"macos\" calculated \"globalAccountPolicies\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "globalAccountPolicies")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos\" failed to cast field \"globalAccountPolicies\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMacos) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[macos].MqlCompute")
	switch name {
	case "userPreferences":
		return s.ComputeUserPreferences()
	case "userHostPreferences":
		return s.ComputeUserHostPreferences()
	case "globalAccountPolicies":
		return s.ComputeGlobalAccountPolicies()
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos\" resource")
	}
}

// ComputeUserPreferences computer autogenerated
func (s *mqlMacos) ComputeUserPreferences() error {
	var err error
	if _, ok := s.Cache.Load("userPreferences"); ok {
		return nil
	}
	vres, err := s.GetUserPreferences()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("userPreferences", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUserHostPreferences computer autogenerated
func (s *mqlMacos) ComputeUserHostPreferences() error {
	var err error
	if _, ok := s.Cache.Load("userHostPreferences"); ok {
		return nil
	}
	vres, err := s.GetUserHostPreferences()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("userHostPreferences", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeGlobalAccountPolicies computer autogenerated
func (s *mqlMacos) ComputeGlobalAccountPolicies() error {
	var err error
	if _, ok := s.Cache.Load("globalAccountPolicies"); ok {
		return nil
	}
	vres, err := s.GetGlobalAccountPolicies()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("globalAccountPolicies", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MacosAlf resource interface
type MacosAlf interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	AllowDownloadSignedEnabled() (int64, error)
	AllowSignedEnabled() (int64, error)
	FirewallUnload() (int64, error)
	GlobalState() (int64, error)
	LoggingEnabled() (int64, error)
	LoggingOption() (int64, error)
	StealthEnabled() (int64, error)
	Version() (string, error)
	Exceptions() ([]interface{}, error)
	ExplicitAuths() ([]interface{}, error)
	Applications() ([]interface{}, error)
}

// mqlMacosAlf for the macos.alf resource
type mqlMacosAlf struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMacosAlf) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the macos.alf resource
func newMacosAlf(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMacosAlf{runtime.NewResource("macos.alf")}
	var existing MacosAlf
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "allowDownloadSignedEnabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"allowDownloadSignedEnabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "allowSignedEnabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"allowSignedEnabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "firewallUnload":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"firewallUnload\" argument has the wrong type (expected type \"int64\")")
			}
		case "globalState":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"globalState\" argument has the wrong type (expected type \"int64\")")
			}
		case "loggingEnabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"loggingEnabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "loggingOption":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"loggingOption\" argument has the wrong type (expected type \"int64\")")
			}
		case "stealthEnabled":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"stealthEnabled\" argument has the wrong type (expected type \"int64\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "exceptions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"exceptions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "explicitAuths":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"explicitAuths\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "applications":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"applications\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"macos.alf\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized macos.alf with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMacosAlf) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("allowDownloadSignedEnabled"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"allowDownloadSignedEnabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowSignedEnabled"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"allowSignedEnabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("firewallUnload"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"firewallUnload\". This field is required.")
	}
	if _, ok := s.Cache.Load("globalState"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"globalState\". This field is required.")
	}
	if _, ok := s.Cache.Load("loggingEnabled"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"loggingEnabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("loggingOption"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"loggingOption\". This field is required.")
	}
	if _, ok := s.Cache.Load("stealthEnabled"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"stealthEnabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("exceptions"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"exceptions\". This field is required.")
	}
	if _, ok := s.Cache.Load("explicitAuths"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"explicitAuths\". This field is required.")
	}
	if _, ok := s.Cache.Load("applications"); !ok {
		return errors.New("Initialized \"macos.alf\" resource without a \"applications\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMacosAlf) Register(name string) error {
	log.Trace().Str("field", name).Msg("[macos.alf].Register")
	switch name {
	case "allowDownloadSignedEnabled":
		return nil
	case "allowSignedEnabled":
		return nil
	case "firewallUnload":
		return nil
	case "globalState":
		return nil
	case "loggingEnabled":
		return nil
	case "loggingOption":
		return nil
	case "stealthEnabled":
		return nil
	case "version":
		return nil
	case "exceptions":
		return nil
	case "explicitAuths":
		return nil
	case "applications":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.alf\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMacosAlf) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[macos.alf].Field")
	switch name {
	case "allowDownloadSignedEnabled":
		return s.AllowDownloadSignedEnabled()
	case "allowSignedEnabled":
		return s.AllowSignedEnabled()
	case "firewallUnload":
		return s.FirewallUnload()
	case "globalState":
		return s.GlobalState()
	case "loggingEnabled":
		return s.LoggingEnabled()
	case "loggingOption":
		return s.LoggingOption()
	case "stealthEnabled":
		return s.StealthEnabled()
	case "version":
		return s.Version()
	case "exceptions":
		return s.Exceptions()
	case "explicitAuths":
		return s.ExplicitAuths()
	case "applications":
		return s.Applications()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"macos.alf\" resource")
	}
}

// AllowDownloadSignedEnabled accessor autogenerated
func (s *mqlMacosAlf) AllowDownloadSignedEnabled() (int64, error) {
	res, ok := s.Cache.Load("allowDownloadSignedEnabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"allowDownloadSignedEnabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"allowDownloadSignedEnabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AllowSignedEnabled accessor autogenerated
func (s *mqlMacosAlf) AllowSignedEnabled() (int64, error) {
	res, ok := s.Cache.Load("allowSignedEnabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"allowSignedEnabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"allowSignedEnabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// FirewallUnload accessor autogenerated
func (s *mqlMacosAlf) FirewallUnload() (int64, error) {
	res, ok := s.Cache.Load("firewallUnload")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"firewallUnload\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"firewallUnload\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// GlobalState accessor autogenerated
func (s *mqlMacosAlf) GlobalState() (int64, error) {
	res, ok := s.Cache.Load("globalState")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"globalState\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"globalState\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LoggingEnabled accessor autogenerated
func (s *mqlMacosAlf) LoggingEnabled() (int64, error) {
	res, ok := s.Cache.Load("loggingEnabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"loggingEnabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"loggingEnabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// LoggingOption accessor autogenerated
func (s *mqlMacosAlf) LoggingOption() (int64, error) {
	res, ok := s.Cache.Load("loggingOption")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"loggingOption\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"loggingOption\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// StealthEnabled accessor autogenerated
func (s *mqlMacosAlf) StealthEnabled() (int64, error) {
	res, ok := s.Cache.Load("stealthEnabled")
	if !ok || !res.Valid {
		return 0, errors.New("\"macos.alf\" failed: no value provided for static field \"stealthEnabled\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"macos.alf\" failed to cast field \"stealthEnabled\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMacosAlf) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"macos.alf\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.alf\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exceptions accessor autogenerated
func (s *mqlMacosAlf) Exceptions() ([]interface{}, error) {
	res, ok := s.Cache.Load("exceptions")
	if !ok || !res.Valid {
		return nil, errors.New("\"macos.alf\" failed: no value provided for static field \"exceptions\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.alf\" failed to cast field \"exceptions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// ExplicitAuths accessor autogenerated
func (s *mqlMacosAlf) ExplicitAuths() ([]interface{}, error) {
	res, ok := s.Cache.Load("explicitAuths")
	if !ok || !res.Valid {
		return nil, errors.New("\"macos.alf\" failed: no value provided for static field \"explicitAuths\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.alf\" failed to cast field \"explicitAuths\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Applications accessor autogenerated
func (s *mqlMacosAlf) Applications() ([]interface{}, error) {
	res, ok := s.Cache.Load("applications")
	if !ok || !res.Valid {
		return nil, errors.New("\"macos.alf\" failed: no value provided for static field \"applications\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.alf\" failed to cast field \"applications\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMacosAlf) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[macos.alf].MqlCompute")
	switch name {
	case "allowDownloadSignedEnabled":
		return nil
	case "allowSignedEnabled":
		return nil
	case "firewallUnload":
		return nil
	case "globalState":
		return nil
	case "loggingEnabled":
		return nil
	case "loggingOption":
		return nil
	case "stealthEnabled":
		return nil
	case "version":
		return nil
	case "exceptions":
		return nil
	case "explicitAuths":
		return nil
	case "applications":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.alf\" resource")
	}
}

// MacosSystemsetup resource interface
type MacosSystemsetup interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Date() (string, error)
	Time() (string, error)
	TimeZone() (string, error)
	UsingNetworkTime() (string, error)
	NetworkTimeServer() (string, error)
	Sleep() ([]interface{}, error)
	DisplaySleep() (string, error)
	HarddiskSleep() (string, error)
	WakeOnModem() (string, error)
	WakeOnNetworkAccess() (string, error)
	RestartPowerFailure() (string, error)
	RestartFreeze() (string, error)
	AllowPowerButtonToSleepComputer() (string, error)
	RemoteLogin() (string, error)
	RemoteAppleEvents() (string, error)
	ComputerName() (string, error)
	LocalSubnetName() (string, error)
	StartupDisk() (string, error)
	WaitForStartupAfterPowerFailure() (string, error)
	DisableKeyboardWhenEnclosureLockIsEngaged() (string, error)
}

// mqlMacosSystemsetup for the macos.systemsetup resource
type mqlMacosSystemsetup struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMacosSystemsetup) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the macos.systemsetup resource
func newMacosSystemsetup(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMacosSystemsetup{runtime.NewResource("macos.systemsetup")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "date":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"date\" argument has the wrong type (expected type \"string\")")
			}
		case "time":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"time\" argument has the wrong type (expected type \"string\")")
			}
		case "timeZone":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"timeZone\" argument has the wrong type (expected type \"string\")")
			}
		case "usingNetworkTime":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"usingNetworkTime\" argument has the wrong type (expected type \"string\")")
			}
		case "networkTimeServer":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"networkTimeServer\" argument has the wrong type (expected type \"string\")")
			}
		case "sleep":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"sleep\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "displaySleep":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"displaySleep\" argument has the wrong type (expected type \"string\")")
			}
		case "harddiskSleep":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"harddiskSleep\" argument has the wrong type (expected type \"string\")")
			}
		case "wakeOnModem":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"wakeOnModem\" argument has the wrong type (expected type \"string\")")
			}
		case "wakeOnNetworkAccess":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"wakeOnNetworkAccess\" argument has the wrong type (expected type \"string\")")
			}
		case "restartPowerFailure":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"restartPowerFailure\" argument has the wrong type (expected type \"string\")")
			}
		case "restartFreeze":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"restartFreeze\" argument has the wrong type (expected type \"string\")")
			}
		case "allowPowerButtonToSleepComputer":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"allowPowerButtonToSleepComputer\" argument has the wrong type (expected type \"string\")")
			}
		case "remoteLogin":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"remoteLogin\" argument has the wrong type (expected type \"string\")")
			}
		case "remoteAppleEvents":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"remoteAppleEvents\" argument has the wrong type (expected type \"string\")")
			}
		case "computerName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"computerName\" argument has the wrong type (expected type \"string\")")
			}
		case "localSubnetName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"localSubnetName\" argument has the wrong type (expected type \"string\")")
			}
		case "startupDisk":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"startupDisk\" argument has the wrong type (expected type \"string\")")
			}
		case "waitForStartupAfterPowerFailure":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"waitForStartupAfterPowerFailure\" argument has the wrong type (expected type \"string\")")
			}
		case "disableKeyboardWhenEnclosureLockIsEngaged":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"disableKeyboardWhenEnclosureLockIsEngaged\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"macos.systemsetup\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized macos.systemsetup with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMacosSystemsetup) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMacosSystemsetup) Register(name string) error {
	log.Trace().Str("field", name).Msg("[macos.systemsetup].Register")
	switch name {
	case "date":
		return nil
	case "time":
		return nil
	case "timeZone":
		return nil
	case "usingNetworkTime":
		return nil
	case "networkTimeServer":
		return nil
	case "sleep":
		return nil
	case "displaySleep":
		return nil
	case "harddiskSleep":
		return nil
	case "wakeOnModem":
		return nil
	case "wakeOnNetworkAccess":
		return nil
	case "restartPowerFailure":
		return nil
	case "restartFreeze":
		return nil
	case "allowPowerButtonToSleepComputer":
		return nil
	case "remoteLogin":
		return nil
	case "remoteAppleEvents":
		return nil
	case "computerName":
		return nil
	case "localSubnetName":
		return nil
	case "startupDisk":
		return nil
	case "waitForStartupAfterPowerFailure":
		return nil
	case "disableKeyboardWhenEnclosureLockIsEngaged":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.systemsetup\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMacosSystemsetup) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[macos.systemsetup].Field")
	switch name {
	case "date":
		return s.Date()
	case "time":
		return s.Time()
	case "timeZone":
		return s.TimeZone()
	case "usingNetworkTime":
		return s.UsingNetworkTime()
	case "networkTimeServer":
		return s.NetworkTimeServer()
	case "sleep":
		return s.Sleep()
	case "displaySleep":
		return s.DisplaySleep()
	case "harddiskSleep":
		return s.HarddiskSleep()
	case "wakeOnModem":
		return s.WakeOnModem()
	case "wakeOnNetworkAccess":
		return s.WakeOnNetworkAccess()
	case "restartPowerFailure":
		return s.RestartPowerFailure()
	case "restartFreeze":
		return s.RestartFreeze()
	case "allowPowerButtonToSleepComputer":
		return s.AllowPowerButtonToSleepComputer()
	case "remoteLogin":
		return s.RemoteLogin()
	case "remoteAppleEvents":
		return s.RemoteAppleEvents()
	case "computerName":
		return s.ComputerName()
	case "localSubnetName":
		return s.LocalSubnetName()
	case "startupDisk":
		return s.StartupDisk()
	case "waitForStartupAfterPowerFailure":
		return s.WaitForStartupAfterPowerFailure()
	case "disableKeyboardWhenEnclosureLockIsEngaged":
		return s.DisableKeyboardWhenEnclosureLockIsEngaged()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"macos.systemsetup\" resource")
	}
}

// Date accessor autogenerated
func (s *mqlMacosSystemsetup) Date() (string, error) {
	res, ok := s.Cache.Load("date")
	if !ok || !res.Valid {
		if err := s.ComputeDate(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("date")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"date\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "date")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"date\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Time accessor autogenerated
func (s *mqlMacosSystemsetup) Time() (string, error) {
	res, ok := s.Cache.Load("time")
	if !ok || !res.Valid {
		if err := s.ComputeTime(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("time")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"time\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "time")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"time\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TimeZone accessor autogenerated
func (s *mqlMacosSystemsetup) TimeZone() (string, error) {
	res, ok := s.Cache.Load("timeZone")
	if !ok || !res.Valid {
		if err := s.ComputeTimeZone(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("timeZone")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"timeZone\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "timeZone")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"timeZone\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// UsingNetworkTime accessor autogenerated
func (s *mqlMacosSystemsetup) UsingNetworkTime() (string, error) {
	res, ok := s.Cache.Load("usingNetworkTime")
	if !ok || !res.Valid {
		if err := s.ComputeUsingNetworkTime(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("usingNetworkTime")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"usingNetworkTime\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "usingNetworkTime")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"usingNetworkTime\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// NetworkTimeServer accessor autogenerated
func (s *mqlMacosSystemsetup) NetworkTimeServer() (string, error) {
	res, ok := s.Cache.Load("networkTimeServer")
	if !ok || !res.Valid {
		if err := s.ComputeNetworkTimeServer(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("networkTimeServer")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"networkTimeServer\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "networkTimeServer")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"networkTimeServer\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sleep accessor autogenerated
func (s *mqlMacosSystemsetup) Sleep() ([]interface{}, error) {
	res, ok := s.Cache.Load("sleep")
	if !ok || !res.Valid {
		if err := s.ComputeSleep(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("sleep")
		if !ok {
			return nil, errors.New("\"macos.systemsetup\" calculated \"sleep\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "sleep")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.systemsetup\" failed to cast field \"sleep\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// DisplaySleep accessor autogenerated
func (s *mqlMacosSystemsetup) DisplaySleep() (string, error) {
	res, ok := s.Cache.Load("displaySleep")
	if !ok || !res.Valid {
		if err := s.ComputeDisplaySleep(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("displaySleep")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"displaySleep\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "displaySleep")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"displaySleep\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// HarddiskSleep accessor autogenerated
func (s *mqlMacosSystemsetup) HarddiskSleep() (string, error) {
	res, ok := s.Cache.Load("harddiskSleep")
	if !ok || !res.Valid {
		if err := s.ComputeHarddiskSleep(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("harddiskSleep")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"harddiskSleep\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "harddiskSleep")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"harddiskSleep\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// WakeOnModem accessor autogenerated
func (s *mqlMacosSystemsetup) WakeOnModem() (string, error) {
	res, ok := s.Cache.Load("wakeOnModem")
	if !ok || !res.Valid {
		if err := s.ComputeWakeOnModem(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("wakeOnModem")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"wakeOnModem\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "wakeOnModem")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"wakeOnModem\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// WakeOnNetworkAccess accessor autogenerated
func (s *mqlMacosSystemsetup) WakeOnNetworkAccess() (string, error) {
	res, ok := s.Cache.Load("wakeOnNetworkAccess")
	if !ok || !res.Valid {
		if err := s.ComputeWakeOnNetworkAccess(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("wakeOnNetworkAccess")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"wakeOnNetworkAccess\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "wakeOnNetworkAccess")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"wakeOnNetworkAccess\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RestartPowerFailure accessor autogenerated
func (s *mqlMacosSystemsetup) RestartPowerFailure() (string, error) {
	res, ok := s.Cache.Load("restartPowerFailure")
	if !ok || !res.Valid {
		if err := s.ComputeRestartPowerFailure(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("restartPowerFailure")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"restartPowerFailure\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "restartPowerFailure")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"restartPowerFailure\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RestartFreeze accessor autogenerated
func (s *mqlMacosSystemsetup) RestartFreeze() (string, error) {
	res, ok := s.Cache.Load("restartFreeze")
	if !ok || !res.Valid {
		if err := s.ComputeRestartFreeze(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("restartFreeze")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"restartFreeze\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "restartFreeze")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"restartFreeze\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AllowPowerButtonToSleepComputer accessor autogenerated
func (s *mqlMacosSystemsetup) AllowPowerButtonToSleepComputer() (string, error) {
	res, ok := s.Cache.Load("allowPowerButtonToSleepComputer")
	if !ok || !res.Valid {
		if err := s.ComputeAllowPowerButtonToSleepComputer(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("allowPowerButtonToSleepComputer")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"allowPowerButtonToSleepComputer\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "allowPowerButtonToSleepComputer")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"allowPowerButtonToSleepComputer\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RemoteLogin accessor autogenerated
func (s *mqlMacosSystemsetup) RemoteLogin() (string, error) {
	res, ok := s.Cache.Load("remoteLogin")
	if !ok || !res.Valid {
		if err := s.ComputeRemoteLogin(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("remoteLogin")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"remoteLogin\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "remoteLogin")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"remoteLogin\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RemoteAppleEvents accessor autogenerated
func (s *mqlMacosSystemsetup) RemoteAppleEvents() (string, error) {
	res, ok := s.Cache.Load("remoteAppleEvents")
	if !ok || !res.Valid {
		if err := s.ComputeRemoteAppleEvents(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("remoteAppleEvents")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"remoteAppleEvents\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "remoteAppleEvents")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"remoteAppleEvents\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ComputerName accessor autogenerated
func (s *mqlMacosSystemsetup) ComputerName() (string, error) {
	res, ok := s.Cache.Load("computerName")
	if !ok || !res.Valid {
		if err := s.ComputeComputerName(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("computerName")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"computerName\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "computerName")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"computerName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// LocalSubnetName accessor autogenerated
func (s *mqlMacosSystemsetup) LocalSubnetName() (string, error) {
	res, ok := s.Cache.Load("localSubnetName")
	if !ok || !res.Valid {
		if err := s.ComputeLocalSubnetName(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("localSubnetName")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"localSubnetName\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "localSubnetName")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"localSubnetName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// StartupDisk accessor autogenerated
func (s *mqlMacosSystemsetup) StartupDisk() (string, error) {
	res, ok := s.Cache.Load("startupDisk")
	if !ok || !res.Valid {
		if err := s.ComputeStartupDisk(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("startupDisk")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"startupDisk\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "startupDisk")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"startupDisk\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// WaitForStartupAfterPowerFailure accessor autogenerated
func (s *mqlMacosSystemsetup) WaitForStartupAfterPowerFailure() (string, error) {
	res, ok := s.Cache.Load("waitForStartupAfterPowerFailure")
	if !ok || !res.Valid {
		if err := s.ComputeWaitForStartupAfterPowerFailure(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("waitForStartupAfterPowerFailure")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"waitForStartupAfterPowerFailure\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "waitForStartupAfterPowerFailure")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"waitForStartupAfterPowerFailure\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DisableKeyboardWhenEnclosureLockIsEngaged accessor autogenerated
func (s *mqlMacosSystemsetup) DisableKeyboardWhenEnclosureLockIsEngaged() (string, error) {
	res, ok := s.Cache.Load("disableKeyboardWhenEnclosureLockIsEngaged")
	if !ok || !res.Valid {
		if err := s.ComputeDisableKeyboardWhenEnclosureLockIsEngaged(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("disableKeyboardWhenEnclosureLockIsEngaged")
		if !ok {
			return "", errors.New("\"macos.systemsetup\" calculated \"disableKeyboardWhenEnclosureLockIsEngaged\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "disableKeyboardWhenEnclosureLockIsEngaged")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"macos.systemsetup\" failed to cast field \"disableKeyboardWhenEnclosureLockIsEngaged\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMacosSystemsetup) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[macos.systemsetup].MqlCompute")
	switch name {
	case "date":
		return s.ComputeDate()
	case "time":
		return s.ComputeTime()
	case "timeZone":
		return s.ComputeTimeZone()
	case "usingNetworkTime":
		return s.ComputeUsingNetworkTime()
	case "networkTimeServer":
		return s.ComputeNetworkTimeServer()
	case "sleep":
		return s.ComputeSleep()
	case "displaySleep":
		return s.ComputeDisplaySleep()
	case "harddiskSleep":
		return s.ComputeHarddiskSleep()
	case "wakeOnModem":
		return s.ComputeWakeOnModem()
	case "wakeOnNetworkAccess":
		return s.ComputeWakeOnNetworkAccess()
	case "restartPowerFailure":
		return s.ComputeRestartPowerFailure()
	case "restartFreeze":
		return s.ComputeRestartFreeze()
	case "allowPowerButtonToSleepComputer":
		return s.ComputeAllowPowerButtonToSleepComputer()
	case "remoteLogin":
		return s.ComputeRemoteLogin()
	case "remoteAppleEvents":
		return s.ComputeRemoteAppleEvents()
	case "computerName":
		return s.ComputeComputerName()
	case "localSubnetName":
		return s.ComputeLocalSubnetName()
	case "startupDisk":
		return s.ComputeStartupDisk()
	case "waitForStartupAfterPowerFailure":
		return s.ComputeWaitForStartupAfterPowerFailure()
	case "disableKeyboardWhenEnclosureLockIsEngaged":
		return s.ComputeDisableKeyboardWhenEnclosureLockIsEngaged()
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.systemsetup\" resource")
	}
}

// ComputeDate computer autogenerated
func (s *mqlMacosSystemsetup) ComputeDate() error {
	var err error
	if _, ok := s.Cache.Load("date"); ok {
		return nil
	}
	vres, err := s.GetDate()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("date", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeTime computer autogenerated
func (s *mqlMacosSystemsetup) ComputeTime() error {
	var err error
	if _, ok := s.Cache.Load("time"); ok {
		return nil
	}
	vres, err := s.GetTime()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("time", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeTimeZone computer autogenerated
func (s *mqlMacosSystemsetup) ComputeTimeZone() error {
	var err error
	if _, ok := s.Cache.Load("timeZone"); ok {
		return nil
	}
	vres, err := s.GetTimeZone()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("timeZone", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUsingNetworkTime computer autogenerated
func (s *mqlMacosSystemsetup) ComputeUsingNetworkTime() error {
	var err error
	if _, ok := s.Cache.Load("usingNetworkTime"); ok {
		return nil
	}
	vres, err := s.GetUsingNetworkTime()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("usingNetworkTime", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeNetworkTimeServer computer autogenerated
func (s *mqlMacosSystemsetup) ComputeNetworkTimeServer() error {
	var err error
	if _, ok := s.Cache.Load("networkTimeServer"); ok {
		return nil
	}
	vres, err := s.GetNetworkTimeServer()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("networkTimeServer", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSleep computer autogenerated
func (s *mqlMacosSystemsetup) ComputeSleep() error {
	var err error
	if _, ok := s.Cache.Load("sleep"); ok {
		return nil
	}
	vres, err := s.GetSleep()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("sleep", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDisplaySleep computer autogenerated
func (s *mqlMacosSystemsetup) ComputeDisplaySleep() error {
	var err error
	if _, ok := s.Cache.Load("displaySleep"); ok {
		return nil
	}
	vres, err := s.GetDisplaySleep()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("displaySleep", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHarddiskSleep computer autogenerated
func (s *mqlMacosSystemsetup) ComputeHarddiskSleep() error {
	var err error
	if _, ok := s.Cache.Load("harddiskSleep"); ok {
		return nil
	}
	vres, err := s.GetHarddiskSleep()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("harddiskSleep", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWakeOnModem computer autogenerated
func (s *mqlMacosSystemsetup) ComputeWakeOnModem() error {
	var err error
	if _, ok := s.Cache.Load("wakeOnModem"); ok {
		return nil
	}
	vres, err := s.GetWakeOnModem()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("wakeOnModem", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWakeOnNetworkAccess computer autogenerated
func (s *mqlMacosSystemsetup) ComputeWakeOnNetworkAccess() error {
	var err error
	if _, ok := s.Cache.Load("wakeOnNetworkAccess"); ok {
		return nil
	}
	vres, err := s.GetWakeOnNetworkAccess()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("wakeOnNetworkAccess", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRestartPowerFailure computer autogenerated
func (s *mqlMacosSystemsetup) ComputeRestartPowerFailure() error {
	var err error
	if _, ok := s.Cache.Load("restartPowerFailure"); ok {
		return nil
	}
	vres, err := s.GetRestartPowerFailure()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("restartPowerFailure", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRestartFreeze computer autogenerated
func (s *mqlMacosSystemsetup) ComputeRestartFreeze() error {
	var err error
	if _, ok := s.Cache.Load("restartFreeze"); ok {
		return nil
	}
	vres, err := s.GetRestartFreeze()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("restartFreeze", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeAllowPowerButtonToSleepComputer computer autogenerated
func (s *mqlMacosSystemsetup) ComputeAllowPowerButtonToSleepComputer() error {
	var err error
	if _, ok := s.Cache.Load("allowPowerButtonToSleepComputer"); ok {
		return nil
	}
	vres, err := s.GetAllowPowerButtonToSleepComputer()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("allowPowerButtonToSleepComputer", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRemoteLogin computer autogenerated
func (s *mqlMacosSystemsetup) ComputeRemoteLogin() error {
	var err error
	if _, ok := s.Cache.Load("remoteLogin"); ok {
		return nil
	}
	vres, err := s.GetRemoteLogin()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("remoteLogin", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRemoteAppleEvents computer autogenerated
func (s *mqlMacosSystemsetup) ComputeRemoteAppleEvents() error {
	var err error
	if _, ok := s.Cache.Load("remoteAppleEvents"); ok {
		return nil
	}
	vres, err := s.GetRemoteAppleEvents()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("remoteAppleEvents", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeComputerName computer autogenerated
func (s *mqlMacosSystemsetup) ComputeComputerName() error {
	var err error
	if _, ok := s.Cache.Load("computerName"); ok {
		return nil
	}
	vres, err := s.GetComputerName()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("computerName", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeLocalSubnetName computer autogenerated
func (s *mqlMacosSystemsetup) ComputeLocalSubnetName() error {
	var err error
	if _, ok := s.Cache.Load("localSubnetName"); ok {
		return nil
	}
	vres, err := s.GetLocalSubnetName()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("localSubnetName", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeStartupDisk computer autogenerated
func (s *mqlMacosSystemsetup) ComputeStartupDisk() error {
	var err error
	if _, ok := s.Cache.Load("startupDisk"); ok {
		return nil
	}
	vres, err := s.GetStartupDisk()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("startupDisk", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWaitForStartupAfterPowerFailure computer autogenerated
func (s *mqlMacosSystemsetup) ComputeWaitForStartupAfterPowerFailure() error {
	var err error
	if _, ok := s.Cache.Load("waitForStartupAfterPowerFailure"); ok {
		return nil
	}
	vres, err := s.GetWaitForStartupAfterPowerFailure()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("waitForStartupAfterPowerFailure", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDisableKeyboardWhenEnclosureLockIsEngaged computer autogenerated
func (s *mqlMacosSystemsetup) ComputeDisableKeyboardWhenEnclosureLockIsEngaged() error {
	var err error
	if _, ok := s.Cache.Load("disableKeyboardWhenEnclosureLockIsEngaged"); ok {
		return nil
	}
	vres, err := s.GetDisableKeyboardWhenEnclosureLockIsEngaged()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("disableKeyboardWhenEnclosureLockIsEngaged", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MacosTimemachine resource interface
type MacosTimemachine interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Preferences() (interface{}, error)
}

// mqlMacosTimemachine for the macos.timemachine resource
type mqlMacosTimemachine struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMacosTimemachine) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the macos.timemachine resource
func newMacosTimemachine(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMacosTimemachine{runtime.NewResource("macos.timemachine")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "preferences":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.timemachine\", its \"preferences\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"macos.timemachine\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized macos.timemachine with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMacosTimemachine) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMacosTimemachine) Register(name string) error {
	log.Trace().Str("field", name).Msg("[macos.timemachine].Register")
	switch name {
	case "preferences":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.timemachine\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMacosTimemachine) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[macos.timemachine].Field")
	switch name {
	case "preferences":
		return s.Preferences()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"macos.timemachine\" resource")
	}
}

// Preferences accessor autogenerated
func (s *mqlMacosTimemachine) Preferences() (interface{}, error) {
	res, ok := s.Cache.Load("preferences")
	if !ok || !res.Valid {
		if err := s.ComputePreferences(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("preferences")
		if !ok {
			return nil, errors.New("\"macos.timemachine\" calculated \"preferences\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "preferences")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.timemachine\" failed to cast field \"preferences\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMacosTimemachine) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[macos.timemachine].MqlCompute")
	switch name {
	case "preferences":
		return s.ComputePreferences()
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.timemachine\" resource")
	}
}

// ComputePreferences computer autogenerated
func (s *mqlMacosTimemachine) ComputePreferences() error {
	var err error
	if _, ok := s.Cache.Load("preferences"); ok {
		return nil
	}
	vres, err := s.GetPreferences()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("preferences", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MacosSecurity resource interface
type MacosSecurity interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	AuthorizationDB() (interface{}, error)
}

// mqlMacosSecurity for the macos.security resource
type mqlMacosSecurity struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMacosSecurity) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the macos.security resource
func newMacosSecurity(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMacosSecurity{runtime.NewResource("macos.security")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "authorizationDB":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"macos.security\", its \"authorizationDB\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"macos.security\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized macos.security with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMacosSecurity) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMacosSecurity) Register(name string) error {
	log.Trace().Str("field", name).Msg("[macos.security].Register")
	switch name {
	case "authorizationDB":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.security\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMacosSecurity) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[macos.security].Field")
	switch name {
	case "authorizationDB":
		return s.AuthorizationDB()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"macos.security\" resource")
	}
}

// AuthorizationDB accessor autogenerated
func (s *mqlMacosSecurity) AuthorizationDB() (interface{}, error) {
	res, ok := s.Cache.Load("authorizationDB")
	if !ok || !res.Valid {
		if err := s.ComputeAuthorizationDB(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("authorizationDB")
		if !ok {
			return nil, errors.New("\"macos.security\" calculated \"authorizationDB\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "authorizationDB")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"macos.security\" failed to cast field \"authorizationDB\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMacosSecurity) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[macos.security].MqlCompute")
	switch name {
	case "authorizationDB":
		return s.ComputeAuthorizationDB()
	default:
		return errors.New("Cannot find field '" + name + "' in \"macos.security\" resource")
	}
}

// ComputeAuthorizationDB computer autogenerated
func (s *mqlMacosSecurity) ComputeAuthorizationDB() error {
	var err error
	if _, ok := s.Cache.Load("authorizationDB"); ok {
		return nil
	}
	vres, err := s.GetAuthorizationDB()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("authorizationDB", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Iptables resource interface
type Iptables interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Input() ([]interface{}, error)
	Output() ([]interface{}, error)
}

// mqlIptables for the iptables resource
type mqlIptables struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlIptables) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the iptables resource
func newIptables(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlIptables{runtime.NewResource("iptables")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "input":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"iptables\", its \"input\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "output":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"iptables\", its \"output\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"iptables\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized iptables with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlIptables) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlIptables) Register(name string) error {
	log.Trace().Str("field", name).Msg("[iptables].Register")
	switch name {
	case "input":
		return nil
	case "output":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"iptables\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlIptables) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[iptables].Field")
	switch name {
	case "input":
		return s.Input()
	case "output":
		return s.Output()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"iptables\" resource")
	}
}

// Input accessor autogenerated
func (s *mqlIptables) Input() ([]interface{}, error) {
	res, ok := s.Cache.Load("input")
	if !ok || !res.Valid {
		if err := s.ComputeInput(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("input")
		if !ok {
			return nil, errors.New("\"iptables\" calculated \"input\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "input")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"iptables\" failed to cast field \"input\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Output accessor autogenerated
func (s *mqlIptables) Output() ([]interface{}, error) {
	res, ok := s.Cache.Load("output")
	if !ok || !res.Valid {
		if err := s.ComputeOutput(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("output")
		if !ok {
			return nil, errors.New("\"iptables\" calculated \"output\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "output")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"iptables\" failed to cast field \"output\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlIptables) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[iptables].MqlCompute")
	switch name {
	case "input":
		return s.ComputeInput()
	case "output":
		return s.ComputeOutput()
	default:
		return errors.New("Cannot find field '" + name + "' in \"iptables\" resource")
	}
}

// ComputeInput computer autogenerated
func (s *mqlIptables) ComputeInput() error {
	var err error
	if _, ok := s.Cache.Load("input"); ok {
		return nil
	}
	vres, err := s.GetInput()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("input", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOutput computer autogenerated
func (s *mqlIptables) ComputeOutput() error {
	var err error
	if _, ok := s.Cache.Load("output"); ok {
		return nil
	}
	vres, err := s.GetOutput()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("output", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Ip6tables resource interface
type Ip6tables interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Input() ([]interface{}, error)
	Output() ([]interface{}, error)
}

// mqlIp6tables for the ip6tables resource
type mqlIp6tables struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlIp6tables) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the ip6tables resource
func newIp6tables(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlIp6tables{runtime.NewResource("ip6tables")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "input":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ip6tables\", its \"input\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "output":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ip6tables\", its \"output\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"ip6tables\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized ip6tables with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlIp6tables) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlIp6tables) Register(name string) error {
	log.Trace().Str("field", name).Msg("[ip6tables].Register")
	switch name {
	case "input":
		return nil
	case "output":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"ip6tables\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlIp6tables) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[ip6tables].Field")
	switch name {
	case "input":
		return s.Input()
	case "output":
		return s.Output()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"ip6tables\" resource")
	}
}

// Input accessor autogenerated
func (s *mqlIp6tables) Input() ([]interface{}, error) {
	res, ok := s.Cache.Load("input")
	if !ok || !res.Valid {
		if err := s.ComputeInput(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("input")
		if !ok {
			return nil, errors.New("\"ip6tables\" calculated \"input\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "input")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ip6tables\" failed to cast field \"input\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Output accessor autogenerated
func (s *mqlIp6tables) Output() ([]interface{}, error) {
	res, ok := s.Cache.Load("output")
	if !ok || !res.Valid {
		if err := s.ComputeOutput(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("output")
		if !ok {
			return nil, errors.New("\"ip6tables\" calculated \"output\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "output")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ip6tables\" failed to cast field \"output\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlIp6tables) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[ip6tables].MqlCompute")
	switch name {
	case "input":
		return s.ComputeInput()
	case "output":
		return s.ComputeOutput()
	default:
		return errors.New("Cannot find field '" + name + "' in \"ip6tables\" resource")
	}
}

// ComputeInput computer autogenerated
func (s *mqlIp6tables) ComputeInput() error {
	var err error
	if _, ok := s.Cache.Load("input"); ok {
		return nil
	}
	vres, err := s.GetInput()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("input", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOutput computer autogenerated
func (s *mqlIp6tables) ComputeOutput() error {
	var err error
	if _, ok := s.Cache.Load("output"); ok {
		return nil
	}
	vres, err := s.GetOutput()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("output", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// IptablesEntry resource interface
type IptablesEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	LineNumber() (int64, error)
	Packets() (int64, error)
	Bytes() (int64, error)
	Target() (string, error)
	Protocol() (string, error)
	Opt() (string, error)
	In() (string, error)
	Out() (string, error)
	Source() (string, error)
	Destination() (string, error)
	Options() (string, error)
	Chain() (string, error)
}

// mqlIptablesEntry for the iptables.entry resource
type mqlIptablesEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlIptablesEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the iptables.entry resource
func newIptablesEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlIptablesEntry{runtime.NewResource("iptables.entry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "lineNumber":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"lineNumber\" argument has the wrong type (expected type \"int64\")")
			}
		case "packets":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"packets\" argument has the wrong type (expected type \"int64\")")
			}
		case "bytes":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"bytes\" argument has the wrong type (expected type \"int64\")")
			}
		case "target":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"target\" argument has the wrong type (expected type \"string\")")
			}
		case "protocol":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"protocol\" argument has the wrong type (expected type \"string\")")
			}
		case "opt":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"opt\" argument has the wrong type (expected type \"string\")")
			}
		case "in":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"in\" argument has the wrong type (expected type \"string\")")
			}
		case "out":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"out\" argument has the wrong type (expected type \"string\")")
			}
		case "source":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"source\" argument has the wrong type (expected type \"string\")")
			}
		case "destination":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"destination\" argument has the wrong type (expected type \"string\")")
			}
		case "options":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"options\" argument has the wrong type (expected type \"string\")")
			}
		case "chain":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"chain\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"iptables.entry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized iptables.entry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlIptablesEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("lineNumber"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"lineNumber\". This field is required.")
	}
	if _, ok := s.Cache.Load("packets"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"packets\". This field is required.")
	}
	if _, ok := s.Cache.Load("bytes"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"bytes\". This field is required.")
	}
	if _, ok := s.Cache.Load("target"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"target\". This field is required.")
	}
	if _, ok := s.Cache.Load("protocol"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"protocol\". This field is required.")
	}
	if _, ok := s.Cache.Load("opt"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"opt\". This field is required.")
	}
	if _, ok := s.Cache.Load("in"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"in\". This field is required.")
	}
	if _, ok := s.Cache.Load("out"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"out\". This field is required.")
	}
	if _, ok := s.Cache.Load("source"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"source\". This field is required.")
	}
	if _, ok := s.Cache.Load("destination"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"destination\". This field is required.")
	}
	if _, ok := s.Cache.Load("options"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"options\". This field is required.")
	}
	if _, ok := s.Cache.Load("chain"); !ok {
		return errors.New("Initialized \"iptables.entry\" resource without a \"chain\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlIptablesEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[iptables.entry].Register")
	switch name {
	case "lineNumber":
		return nil
	case "packets":
		return nil
	case "bytes":
		return nil
	case "target":
		return nil
	case "protocol":
		return nil
	case "opt":
		return nil
	case "in":
		return nil
	case "out":
		return nil
	case "source":
		return nil
	case "destination":
		return nil
	case "options":
		return nil
	case "chain":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"iptables.entry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlIptablesEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[iptables.entry].Field")
	switch name {
	case "lineNumber":
		return s.LineNumber()
	case "packets":
		return s.Packets()
	case "bytes":
		return s.Bytes()
	case "target":
		return s.Target()
	case "protocol":
		return s.Protocol()
	case "opt":
		return s.Opt()
	case "in":
		return s.In()
	case "out":
		return s.Out()
	case "source":
		return s.Source()
	case "destination":
		return s.Destination()
	case "options":
		return s.Options()
	case "chain":
		return s.Chain()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"iptables.entry\" resource")
	}
}

// LineNumber accessor autogenerated
func (s *mqlIptablesEntry) LineNumber() (int64, error) {
	res, ok := s.Cache.Load("lineNumber")
	if !ok || !res.Valid {
		return 0, errors.New("\"iptables.entry\" failed: no value provided for static field \"lineNumber\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"iptables.entry\" failed to cast field \"lineNumber\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Packets accessor autogenerated
func (s *mqlIptablesEntry) Packets() (int64, error) {
	res, ok := s.Cache.Load("packets")
	if !ok || !res.Valid {
		return 0, errors.New("\"iptables.entry\" failed: no value provided for static field \"packets\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"iptables.entry\" failed to cast field \"packets\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Bytes accessor autogenerated
func (s *mqlIptablesEntry) Bytes() (int64, error) {
	res, ok := s.Cache.Load("bytes")
	if !ok || !res.Valid {
		return 0, errors.New("\"iptables.entry\" failed: no value provided for static field \"bytes\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"iptables.entry\" failed to cast field \"bytes\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Target accessor autogenerated
func (s *mqlIptablesEntry) Target() (string, error) {
	res, ok := s.Cache.Load("target")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"target\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"target\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Protocol accessor autogenerated
func (s *mqlIptablesEntry) Protocol() (string, error) {
	res, ok := s.Cache.Load("protocol")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"protocol\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"protocol\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Opt accessor autogenerated
func (s *mqlIptablesEntry) Opt() (string, error) {
	res, ok := s.Cache.Load("opt")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"opt\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"opt\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// In accessor autogenerated
func (s *mqlIptablesEntry) In() (string, error) {
	res, ok := s.Cache.Load("in")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"in\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"in\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Out accessor autogenerated
func (s *mqlIptablesEntry) Out() (string, error) {
	res, ok := s.Cache.Load("out")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"out\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"out\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Source accessor autogenerated
func (s *mqlIptablesEntry) Source() (string, error) {
	res, ok := s.Cache.Load("source")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"source\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"source\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Destination accessor autogenerated
func (s *mqlIptablesEntry) Destination() (string, error) {
	res, ok := s.Cache.Load("destination")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"destination\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"destination\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Options accessor autogenerated
func (s *mqlIptablesEntry) Options() (string, error) {
	res, ok := s.Cache.Load("options")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"options\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"options\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Chain accessor autogenerated
func (s *mqlIptablesEntry) Chain() (string, error) {
	res, ok := s.Cache.Load("chain")
	if !ok || !res.Valid {
		return "", errors.New("\"iptables.entry\" failed: no value provided for static field \"chain\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"iptables.entry\" failed to cast field \"chain\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlIptablesEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[iptables.entry].MqlCompute")
	switch name {
	case "lineNumber":
		return nil
	case "packets":
		return nil
	case "bytes":
		return nil
	case "target":
		return nil
	case "protocol":
		return nil
	case "opt":
		return nil
	case "in":
		return nil
	case "out":
		return nil
	case "source":
		return nil
	case "destination":
		return nil
	case "options":
		return nil
	case "chain":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"iptables.entry\" resource")
	}
}

