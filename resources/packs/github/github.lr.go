// Code generated by resources. DO NOT EDIT.
package github

import (
	"errors"
	"fmt"
	"time"

	"go.mondoo.com/cnquery/resources"
	"github.com/rs/zerolog/log"
)

// Init all resources into the registry
func Init(registry *resources.Registry) {
	registry.AddFactory("git.commit", newGitCommit)
	registry.AddFactory("git.commitAuthor", newGitCommitAuthor)
	registry.AddFactory("git.gpgSignature", newGitGpgSignature)
	registry.AddFactory("github.organization", newGithubOrganization)
	registry.AddFactory("github.user", newGithubUser)
	registry.AddFactory("github.team", newGithubTeam)
	registry.AddFactory("github.collaborator", newGithubCollaborator)
	registry.AddFactory("github.package", newGithubPackage)
	registry.AddFactory("github.repository", newGithubRepository)
	registry.AddFactory("github.file", newGithubFile)
	registry.AddFactory("github.release", newGithubRelease)
	registry.AddFactory("github.webhook", newGithubWebhook)
	registry.AddFactory("github.workflow", newGithubWorkflow)
	registry.AddFactory("github.branch", newGithubBranch)
	registry.AddFactory("github.branchprotection", newGithubBranchprotection)
	registry.AddFactory("github.commit", newGithubCommit)
	registry.AddFactory("github.mergeRequest", newGithubMergeRequest)
	registry.AddFactory("github.review", newGithubReview)
	registry.AddFactory("github.installation", newGithubInstallation)
}

// GitCommit resource interface
type GitCommit interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Sha() (string, error)
	Message() (string, error)
	Author() (GitCommitAuthor, error)
	Committer() (GitCommitAuthor, error)
	SignatureVerification() (GitGpgSignature, error)
}

// mqlGitCommit for the git.commit resource
type mqlGitCommit struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGitCommit) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the git.commit resource
func newGitCommit(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGitCommit{runtime.NewResource("git.commit")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "sha":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"sha\" argument has the wrong type (expected type \"string\")")
			}
		case "message":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"message\" argument has the wrong type (expected type \"string\")")
			}
		case "author":
			if _, ok := val.(GitCommitAuthor); !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"author\" argument has the wrong type (expected type \"GitCommitAuthor\")")
			}
		case "committer":
			if _, ok := val.(GitCommitAuthor); !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"committer\" argument has the wrong type (expected type \"GitCommitAuthor\")")
			}
		case "signatureVerification":
			if _, ok := val.(GitGpgSignature); !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"signatureVerification\" argument has the wrong type (expected type \"GitGpgSignature\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"git.commit\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized git.commit with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGitCommit) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("sha"); !ok {
		return errors.New("Initialized \"git.commit\" resource without a \"sha\". This field is required.")
	}
	if _, ok := s.Cache.Load("message"); !ok {
		return errors.New("Initialized \"git.commit\" resource without a \"message\". This field is required.")
	}
	if _, ok := s.Cache.Load("author"); !ok {
		return errors.New("Initialized \"git.commit\" resource without a \"author\". This field is required.")
	}
	if _, ok := s.Cache.Load("committer"); !ok {
		return errors.New("Initialized \"git.commit\" resource without a \"committer\". This field is required.")
	}
	if _, ok := s.Cache.Load("signatureVerification"); !ok {
		return errors.New("Initialized \"git.commit\" resource without a \"signatureVerification\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGitCommit) Register(name string) error {
	log.Trace().Str("field", name).Msg("[git.commit].Register")
	switch name {
	case "sha":
		return nil
	case "message":
		return nil
	case "author":
		return nil
	case "committer":
		return nil
	case "signatureVerification":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.commit\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGitCommit) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[git.commit].Field")
	switch name {
	case "sha":
		return s.Sha()
	case "message":
		return s.Message()
	case "author":
		return s.Author()
	case "committer":
		return s.Committer()
	case "signatureVerification":
		return s.SignatureVerification()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"git.commit\" resource")
	}
}

// Sha accessor autogenerated
func (s *mqlGitCommit) Sha() (string, error) {
	res, ok := s.Cache.Load("sha")
	if !ok || !res.Valid {
		return "", errors.New("\"git.commit\" failed: no value provided for static field \"sha\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.commit\" failed to cast field \"sha\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Message accessor autogenerated
func (s *mqlGitCommit) Message() (string, error) {
	res, ok := s.Cache.Load("message")
	if !ok || !res.Valid {
		return "", errors.New("\"git.commit\" failed: no value provided for static field \"message\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.commit\" failed to cast field \"message\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Author accessor autogenerated
func (s *mqlGitCommit) Author() (GitCommitAuthor, error) {
	res, ok := s.Cache.Load("author")
	if !ok || !res.Valid {
		return nil, errors.New("\"git.commit\" failed: no value provided for static field \"author\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GitCommitAuthor)
	if !ok {
		return nil, fmt.Errorf("\"git.commit\" failed to cast field \"author\" to the right type (GitCommitAuthor): %#v", res)
	}
	return tres, nil
}

// Committer accessor autogenerated
func (s *mqlGitCommit) Committer() (GitCommitAuthor, error) {
	res, ok := s.Cache.Load("committer")
	if !ok || !res.Valid {
		return nil, errors.New("\"git.commit\" failed: no value provided for static field \"committer\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GitCommitAuthor)
	if !ok {
		return nil, fmt.Errorf("\"git.commit\" failed to cast field \"committer\" to the right type (GitCommitAuthor): %#v", res)
	}
	return tres, nil
}

// SignatureVerification accessor autogenerated
func (s *mqlGitCommit) SignatureVerification() (GitGpgSignature, error) {
	res, ok := s.Cache.Load("signatureVerification")
	if !ok || !res.Valid {
		return nil, errors.New("\"git.commit\" failed: no value provided for static field \"signatureVerification\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GitGpgSignature)
	if !ok {
		return nil, fmt.Errorf("\"git.commit\" failed to cast field \"signatureVerification\" to the right type (GitGpgSignature): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGitCommit) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[git.commit].MqlCompute")
	switch name {
	case "sha":
		return nil
	case "message":
		return nil
	case "author":
		return nil
	case "committer":
		return nil
	case "signatureVerification":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.commit\" resource")
	}
}

// GitCommitAuthor resource interface
type GitCommitAuthor interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Sha() (string, error)
	Name() (string, error)
	Email() (string, error)
	Date() (*time.Time, error)
}

// mqlGitCommitAuthor for the git.commitAuthor resource
type mqlGitCommitAuthor struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGitCommitAuthor) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the git.commitAuthor resource
func newGitCommitAuthor(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGitCommitAuthor{runtime.NewResource("git.commitAuthor")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "sha":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.commitAuthor\", its \"sha\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.commitAuthor\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "email":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.commitAuthor\", its \"email\" argument has the wrong type (expected type \"string\")")
			}
		case "date":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"git.commitAuthor\", its \"date\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"git.commitAuthor\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized git.commitAuthor with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGitCommitAuthor) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("sha"); !ok {
		return errors.New("Initialized \"git.commitAuthor\" resource without a \"sha\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"git.commitAuthor\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("email"); !ok {
		return errors.New("Initialized \"git.commitAuthor\" resource without a \"email\". This field is required.")
	}
	if _, ok := s.Cache.Load("date"); !ok {
		return errors.New("Initialized \"git.commitAuthor\" resource without a \"date\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGitCommitAuthor) Register(name string) error {
	log.Trace().Str("field", name).Msg("[git.commitAuthor].Register")
	switch name {
	case "sha":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "date":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.commitAuthor\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGitCommitAuthor) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[git.commitAuthor].Field")
	switch name {
	case "sha":
		return s.Sha()
	case "name":
		return s.Name()
	case "email":
		return s.Email()
	case "date":
		return s.Date()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"git.commitAuthor\" resource")
	}
}

// Sha accessor autogenerated
func (s *mqlGitCommitAuthor) Sha() (string, error) {
	res, ok := s.Cache.Load("sha")
	if !ok || !res.Valid {
		return "", errors.New("\"git.commitAuthor\" failed: no value provided for static field \"sha\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.commitAuthor\" failed to cast field \"sha\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGitCommitAuthor) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"git.commitAuthor\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.commitAuthor\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlGitCommitAuthor) Email() (string, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		return "", errors.New("\"git.commitAuthor\" failed: no value provided for static field \"email\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.commitAuthor\" failed to cast field \"email\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Date accessor autogenerated
func (s *mqlGitCommitAuthor) Date() (*time.Time, error) {
	res, ok := s.Cache.Load("date")
	if !ok || !res.Valid {
		return nil, errors.New("\"git.commitAuthor\" failed: no value provided for static field \"date\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"git.commitAuthor\" failed to cast field \"date\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGitCommitAuthor) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[git.commitAuthor].MqlCompute")
	switch name {
	case "sha":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "date":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.commitAuthor\" resource")
	}
}

// GitGpgSignature resource interface
type GitGpgSignature interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Sha() (string, error)
	Reason() (string, error)
	Verified() (bool, error)
	Payload() (string, error)
	Signature() (string, error)
}

// mqlGitGpgSignature for the git.gpgSignature resource
type mqlGitGpgSignature struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGitGpgSignature) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the git.gpgSignature resource
func newGitGpgSignature(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGitGpgSignature{runtime.NewResource("git.gpgSignature")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "sha":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"sha\" argument has the wrong type (expected type \"string\")")
			}
		case "reason":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"reason\" argument has the wrong type (expected type \"string\")")
			}
		case "verified":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"verified\" argument has the wrong type (expected type \"bool\")")
			}
		case "payload":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"payload\" argument has the wrong type (expected type \"string\")")
			}
		case "signature":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"signature\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"git.gpgSignature\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized git.gpgSignature with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGitGpgSignature) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("sha"); !ok {
		return errors.New("Initialized \"git.gpgSignature\" resource without a \"sha\". This field is required.")
	}
	if _, ok := s.Cache.Load("reason"); !ok {
		return errors.New("Initialized \"git.gpgSignature\" resource without a \"reason\". This field is required.")
	}
	if _, ok := s.Cache.Load("verified"); !ok {
		return errors.New("Initialized \"git.gpgSignature\" resource without a \"verified\". This field is required.")
	}
	if _, ok := s.Cache.Load("payload"); !ok {
		return errors.New("Initialized \"git.gpgSignature\" resource without a \"payload\". This field is required.")
	}
	if _, ok := s.Cache.Load("signature"); !ok {
		return errors.New("Initialized \"git.gpgSignature\" resource without a \"signature\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGitGpgSignature) Register(name string) error {
	log.Trace().Str("field", name).Msg("[git.gpgSignature].Register")
	switch name {
	case "sha":
		return nil
	case "reason":
		return nil
	case "verified":
		return nil
	case "payload":
		return nil
	case "signature":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.gpgSignature\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGitGpgSignature) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[git.gpgSignature].Field")
	switch name {
	case "sha":
		return s.Sha()
	case "reason":
		return s.Reason()
	case "verified":
		return s.Verified()
	case "payload":
		return s.Payload()
	case "signature":
		return s.Signature()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"git.gpgSignature\" resource")
	}
}

// Sha accessor autogenerated
func (s *mqlGitGpgSignature) Sha() (string, error) {
	res, ok := s.Cache.Load("sha")
	if !ok || !res.Valid {
		return "", errors.New("\"git.gpgSignature\" failed: no value provided for static field \"sha\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.gpgSignature\" failed to cast field \"sha\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Reason accessor autogenerated
func (s *mqlGitGpgSignature) Reason() (string, error) {
	res, ok := s.Cache.Load("reason")
	if !ok || !res.Valid {
		return "", errors.New("\"git.gpgSignature\" failed: no value provided for static field \"reason\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.gpgSignature\" failed to cast field \"reason\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Verified accessor autogenerated
func (s *mqlGitGpgSignature) Verified() (bool, error) {
	res, ok := s.Cache.Load("verified")
	if !ok || !res.Valid {
		return false, errors.New("\"git.gpgSignature\" failed: no value provided for static field \"verified\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"git.gpgSignature\" failed to cast field \"verified\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Payload accessor autogenerated
func (s *mqlGitGpgSignature) Payload() (string, error) {
	res, ok := s.Cache.Load("payload")
	if !ok || !res.Valid {
		return "", errors.New("\"git.gpgSignature\" failed: no value provided for static field \"payload\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.gpgSignature\" failed to cast field \"payload\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Signature accessor autogenerated
func (s *mqlGitGpgSignature) Signature() (string, error) {
	res, ok := s.Cache.Load("signature")
	if !ok || !res.Valid {
		return "", errors.New("\"git.gpgSignature\" failed: no value provided for static field \"signature\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"git.gpgSignature\" failed to cast field \"signature\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGitGpgSignature) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[git.gpgSignature].MqlCompute")
	switch name {
	case "sha":
		return nil
	case "reason":
		return nil
	case "verified":
		return nil
	case "payload":
		return nil
	case "signature":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"git.gpgSignature\" resource")
	}
}

// GithubOrganization resource interface
type GithubOrganization interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Login() (string, error)
	Id() (int64, error)
	NodeId() (string, error)
	Name() (string, error)
	Company() (string, error)
	Blog() (string, error)
	Location() (string, error)
	Email() (string, error)
	TwitterUsername() (string, error)
	Description() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	TotalPrivateRepos() (int64, error)
	OwnedPrivateRepos() (int64, error)
	PrivateGists() (int64, error)
	DiskUsage() (int64, error)
	Collaborators() (int64, error)
	BillingEmail() (string, error)
	Plan() (interface{}, error)
	TwoFactorRequirementEnabled() (bool, error)
	IsVerified() (bool, error)
	DefaultRepositoryPermission() (string, error)
	MembersCanCreateRepositories() (bool, error)
	MembersCanCreatePublicRepositories() (bool, error)
	MembersCanCreatePrivateRepositories() (bool, error)
	MembersCanCreateInternalRepositories() (bool, error)
	MembersCanCreatePages() (bool, error)
	MembersCanCreatePublicPages() (bool, error)
	MembersCanCreatePrivatePages() (bool, error)
	Owners() ([]interface{}, error)
	Members() ([]interface{}, error)
	Teams() ([]interface{}, error)
	Repositories() ([]interface{}, error)
	Installations() ([]interface{}, error)
	Webhooks() ([]interface{}, error)
	Packages() ([]interface{}, error)
}

// mqlGithubOrganization for the github.organization resource
type mqlGithubOrganization struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubOrganization) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.organization resource
func newGithubOrganization(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubOrganization{runtime.NewResource("github.organization")}
	var existing GithubOrganization
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "login":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"login\" argument has the wrong type (expected type \"string\")")
			}
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "nodeId":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"nodeId\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "company":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"company\" argument has the wrong type (expected type \"string\")")
			}
		case "blog":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"blog\" argument has the wrong type (expected type \"string\")")
			}
		case "location":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"location\" argument has the wrong type (expected type \"string\")")
			}
		case "email":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"email\" argument has the wrong type (expected type \"string\")")
			}
		case "twitterUsername":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"twitterUsername\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "totalPrivateRepos":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"totalPrivateRepos\" argument has the wrong type (expected type \"int64\")")
			}
		case "ownedPrivateRepos":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"ownedPrivateRepos\" argument has the wrong type (expected type \"int64\")")
			}
		case "privateGists":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"privateGists\" argument has the wrong type (expected type \"int64\")")
			}
		case "diskUsage":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"diskUsage\" argument has the wrong type (expected type \"int64\")")
			}
		case "collaborators":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"collaborators\" argument has the wrong type (expected type \"int64\")")
			}
		case "billingEmail":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"billingEmail\" argument has the wrong type (expected type \"string\")")
			}
		case "plan":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"plan\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "twoFactorRequirementEnabled":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"twoFactorRequirementEnabled\" argument has the wrong type (expected type \"bool\")")
			}
		case "isVerified":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"isVerified\" argument has the wrong type (expected type \"bool\")")
			}
		case "defaultRepositoryPermission":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"defaultRepositoryPermission\" argument has the wrong type (expected type \"string\")")
			}
		case "membersCanCreateRepositories":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreateRepositories\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreatePublicRepositories":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreatePublicRepositories\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreatePrivateRepositories":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreatePrivateRepositories\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreateInternalRepositories":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreateInternalRepositories\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreatePages":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreatePages\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreatePublicPages":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreatePublicPages\" argument has the wrong type (expected type \"bool\")")
			}
		case "membersCanCreatePrivatePages":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"membersCanCreatePrivatePages\" argument has the wrong type (expected type \"bool\")")
			}
		case "owners":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"owners\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "members":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"members\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "teams":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"teams\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "repositories":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"repositories\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "installations":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"installations\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "webhooks":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"webhooks\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "packages":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"packages\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.organization\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.organization with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubOrganization) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("login"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"login\". This field is required.")
	}
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("nodeId"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"nodeId\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("company"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"company\". This field is required.")
	}
	if _, ok := s.Cache.Load("blog"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"blog\". This field is required.")
	}
	if _, ok := s.Cache.Load("location"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"location\". This field is required.")
	}
	if _, ok := s.Cache.Load("email"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"email\". This field is required.")
	}
	if _, ok := s.Cache.Load("twitterUsername"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"twitterUsername\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("totalPrivateRepos"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"totalPrivateRepos\". This field is required.")
	}
	if _, ok := s.Cache.Load("ownedPrivateRepos"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"ownedPrivateRepos\". This field is required.")
	}
	if _, ok := s.Cache.Load("privateGists"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"privateGists\". This field is required.")
	}
	if _, ok := s.Cache.Load("diskUsage"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"diskUsage\". This field is required.")
	}
	if _, ok := s.Cache.Load("collaborators"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"collaborators\". This field is required.")
	}
	if _, ok := s.Cache.Load("billingEmail"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"billingEmail\". This field is required.")
	}
	if _, ok := s.Cache.Load("plan"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"plan\". This field is required.")
	}
	if _, ok := s.Cache.Load("twoFactorRequirementEnabled"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"twoFactorRequirementEnabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("isVerified"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"isVerified\". This field is required.")
	}
	if _, ok := s.Cache.Load("defaultRepositoryPermission"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"defaultRepositoryPermission\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreateRepositories"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreateRepositories\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreatePublicRepositories"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreatePublicRepositories\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreatePrivateRepositories"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreatePrivateRepositories\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreateInternalRepositories"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreateInternalRepositories\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreatePages"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreatePages\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreatePublicPages"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreatePublicPages\". This field is required.")
	}
	if _, ok := s.Cache.Load("membersCanCreatePrivatePages"); !ok {
		return errors.New("Initialized \"github.organization\" resource without a \"membersCanCreatePrivatePages\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubOrganization) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.organization].Register")
	switch name {
	case "login":
		return nil
	case "id":
		return nil
	case "nodeId":
		return nil
	case "name":
		return nil
	case "company":
		return nil
	case "blog":
		return nil
	case "location":
		return nil
	case "email":
		return nil
	case "twitterUsername":
		return nil
	case "description":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "totalPrivateRepos":
		return nil
	case "ownedPrivateRepos":
		return nil
	case "privateGists":
		return nil
	case "diskUsage":
		return nil
	case "collaborators":
		return nil
	case "billingEmail":
		return nil
	case "plan":
		return nil
	case "twoFactorRequirementEnabled":
		return nil
	case "isVerified":
		return nil
	case "defaultRepositoryPermission":
		return nil
	case "membersCanCreateRepositories":
		return nil
	case "membersCanCreatePublicRepositories":
		return nil
	case "membersCanCreatePrivateRepositories":
		return nil
	case "membersCanCreateInternalRepositories":
		return nil
	case "membersCanCreatePages":
		return nil
	case "membersCanCreatePublicPages":
		return nil
	case "membersCanCreatePrivatePages":
		return nil
	case "owners":
		return nil
	case "members":
		return nil
	case "teams":
		return nil
	case "repositories":
		return nil
	case "installations":
		return nil
	case "webhooks":
		return nil
	case "packages":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.organization\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubOrganization) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.organization].Field")
	switch name {
	case "login":
		return s.Login()
	case "id":
		return s.Id()
	case "nodeId":
		return s.NodeId()
	case "name":
		return s.Name()
	case "company":
		return s.Company()
	case "blog":
		return s.Blog()
	case "location":
		return s.Location()
	case "email":
		return s.Email()
	case "twitterUsername":
		return s.TwitterUsername()
	case "description":
		return s.Description()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "totalPrivateRepos":
		return s.TotalPrivateRepos()
	case "ownedPrivateRepos":
		return s.OwnedPrivateRepos()
	case "privateGists":
		return s.PrivateGists()
	case "diskUsage":
		return s.DiskUsage()
	case "collaborators":
		return s.Collaborators()
	case "billingEmail":
		return s.BillingEmail()
	case "plan":
		return s.Plan()
	case "twoFactorRequirementEnabled":
		return s.TwoFactorRequirementEnabled()
	case "isVerified":
		return s.IsVerified()
	case "defaultRepositoryPermission":
		return s.DefaultRepositoryPermission()
	case "membersCanCreateRepositories":
		return s.MembersCanCreateRepositories()
	case "membersCanCreatePublicRepositories":
		return s.MembersCanCreatePublicRepositories()
	case "membersCanCreatePrivateRepositories":
		return s.MembersCanCreatePrivateRepositories()
	case "membersCanCreateInternalRepositories":
		return s.MembersCanCreateInternalRepositories()
	case "membersCanCreatePages":
		return s.MembersCanCreatePages()
	case "membersCanCreatePublicPages":
		return s.MembersCanCreatePublicPages()
	case "membersCanCreatePrivatePages":
		return s.MembersCanCreatePrivatePages()
	case "owners":
		return s.Owners()
	case "members":
		return s.Members()
	case "teams":
		return s.Teams()
	case "repositories":
		return s.Repositories()
	case "installations":
		return s.Installations()
	case "webhooks":
		return s.Webhooks()
	case "packages":
		return s.Packages()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.organization\" resource")
	}
}

// Login accessor autogenerated
func (s *mqlGithubOrganization) Login() (string, error) {
	res, ok := s.Cache.Load("login")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"login\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"login\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Id accessor autogenerated
func (s *mqlGithubOrganization) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// NodeId accessor autogenerated
func (s *mqlGithubOrganization) NodeId() (string, error) {
	res, ok := s.Cache.Load("nodeId")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"nodeId\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"nodeId\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubOrganization) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Company accessor autogenerated
func (s *mqlGithubOrganization) Company() (string, error) {
	res, ok := s.Cache.Load("company")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"company\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"company\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Blog accessor autogenerated
func (s *mqlGithubOrganization) Blog() (string, error) {
	res, ok := s.Cache.Load("blog")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"blog\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"blog\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Location accessor autogenerated
func (s *mqlGithubOrganization) Location() (string, error) {
	res, ok := s.Cache.Load("location")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"location\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"location\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlGithubOrganization) Email() (string, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"email\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"email\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TwitterUsername accessor autogenerated
func (s *mqlGithubOrganization) TwitterUsername() (string, error) {
	res, ok := s.Cache.Load("twitterUsername")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"twitterUsername\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"twitterUsername\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlGithubOrganization) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubOrganization) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.organization\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubOrganization) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.organization\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// TotalPrivateRepos accessor autogenerated
func (s *mqlGithubOrganization) TotalPrivateRepos() (int64, error) {
	res, ok := s.Cache.Load("totalPrivateRepos")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"totalPrivateRepos\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"totalPrivateRepos\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// OwnedPrivateRepos accessor autogenerated
func (s *mqlGithubOrganization) OwnedPrivateRepos() (int64, error) {
	res, ok := s.Cache.Load("ownedPrivateRepos")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"ownedPrivateRepos\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"ownedPrivateRepos\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// PrivateGists accessor autogenerated
func (s *mqlGithubOrganization) PrivateGists() (int64, error) {
	res, ok := s.Cache.Load("privateGists")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"privateGists\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"privateGists\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// DiskUsage accessor autogenerated
func (s *mqlGithubOrganization) DiskUsage() (int64, error) {
	res, ok := s.Cache.Load("diskUsage")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"diskUsage\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"diskUsage\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Collaborators accessor autogenerated
func (s *mqlGithubOrganization) Collaborators() (int64, error) {
	res, ok := s.Cache.Load("collaborators")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.organization\" failed: no value provided for static field \"collaborators\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.organization\" failed to cast field \"collaborators\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// BillingEmail accessor autogenerated
func (s *mqlGithubOrganization) BillingEmail() (string, error) {
	res, ok := s.Cache.Load("billingEmail")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"billingEmail\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"billingEmail\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Plan accessor autogenerated
func (s *mqlGithubOrganization) Plan() (interface{}, error) {
	res, ok := s.Cache.Load("plan")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.organization\" failed: no value provided for static field \"plan\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"plan\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// TwoFactorRequirementEnabled accessor autogenerated
func (s *mqlGithubOrganization) TwoFactorRequirementEnabled() (bool, error) {
	res, ok := s.Cache.Load("twoFactorRequirementEnabled")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"twoFactorRequirementEnabled\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"twoFactorRequirementEnabled\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// IsVerified accessor autogenerated
func (s *mqlGithubOrganization) IsVerified() (bool, error) {
	res, ok := s.Cache.Load("isVerified")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"isVerified\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"isVerified\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// DefaultRepositoryPermission accessor autogenerated
func (s *mqlGithubOrganization) DefaultRepositoryPermission() (string, error) {
	res, ok := s.Cache.Load("defaultRepositoryPermission")
	if !ok || !res.Valid {
		return "", errors.New("\"github.organization\" failed: no value provided for static field \"defaultRepositoryPermission\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.organization\" failed to cast field \"defaultRepositoryPermission\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// MembersCanCreateRepositories accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreateRepositories() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreateRepositories")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreateRepositories\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreateRepositories\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreatePublicRepositories accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreatePublicRepositories() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreatePublicRepositories")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreatePublicRepositories\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreatePublicRepositories\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreatePrivateRepositories accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreatePrivateRepositories() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreatePrivateRepositories")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreatePrivateRepositories\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreatePrivateRepositories\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreateInternalRepositories accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreateInternalRepositories() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreateInternalRepositories")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreateInternalRepositories\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreateInternalRepositories\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreatePages accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreatePages() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreatePages")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreatePages\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreatePages\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreatePublicPages accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreatePublicPages() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreatePublicPages")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreatePublicPages\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreatePublicPages\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// MembersCanCreatePrivatePages accessor autogenerated
func (s *mqlGithubOrganization) MembersCanCreatePrivatePages() (bool, error) {
	res, ok := s.Cache.Load("membersCanCreatePrivatePages")
	if !ok || !res.Valid {
		return false, errors.New("\"github.organization\" failed: no value provided for static field \"membersCanCreatePrivatePages\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.organization\" failed to cast field \"membersCanCreatePrivatePages\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Owners accessor autogenerated
func (s *mqlGithubOrganization) Owners() ([]interface{}, error) {
	res, ok := s.Cache.Load("owners")
	if !ok || !res.Valid {
		if err := s.ComputeOwners(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("owners")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"owners\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "owners")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"owners\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Members accessor autogenerated
func (s *mqlGithubOrganization) Members() ([]interface{}, error) {
	res, ok := s.Cache.Load("members")
	if !ok || !res.Valid {
		if err := s.ComputeMembers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("members")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"members\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "members")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"members\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Teams accessor autogenerated
func (s *mqlGithubOrganization) Teams() ([]interface{}, error) {
	res, ok := s.Cache.Load("teams")
	if !ok || !res.Valid {
		if err := s.ComputeTeams(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("teams")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"teams\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "teams")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"teams\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Repositories accessor autogenerated
func (s *mqlGithubOrganization) Repositories() ([]interface{}, error) {
	res, ok := s.Cache.Load("repositories")
	if !ok || !res.Valid {
		if err := s.ComputeRepositories(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repositories")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"repositories\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repositories")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"repositories\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Installations accessor autogenerated
func (s *mqlGithubOrganization) Installations() ([]interface{}, error) {
	res, ok := s.Cache.Load("installations")
	if !ok || !res.Valid {
		if err := s.ComputeInstallations(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("installations")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"installations\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "installations")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"installations\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Webhooks accessor autogenerated
func (s *mqlGithubOrganization) Webhooks() ([]interface{}, error) {
	res, ok := s.Cache.Load("webhooks")
	if !ok || !res.Valid {
		if err := s.ComputeWebhooks(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("webhooks")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"webhooks\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "webhooks")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"webhooks\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Packages accessor autogenerated
func (s *mqlGithubOrganization) Packages() ([]interface{}, error) {
	res, ok := s.Cache.Load("packages")
	if !ok || !res.Valid {
		if err := s.ComputePackages(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("packages")
		if !ok {
			return nil, errors.New("\"github.organization\" calculated \"packages\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "packages")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.organization\" failed to cast field \"packages\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubOrganization) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.organization].MqlCompute")
	switch name {
	case "login":
		return nil
	case "id":
		return nil
	case "nodeId":
		return nil
	case "name":
		return nil
	case "company":
		return nil
	case "blog":
		return nil
	case "location":
		return nil
	case "email":
		return nil
	case "twitterUsername":
		return nil
	case "description":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "totalPrivateRepos":
		return nil
	case "ownedPrivateRepos":
		return nil
	case "privateGists":
		return nil
	case "diskUsage":
		return nil
	case "collaborators":
		return nil
	case "billingEmail":
		return nil
	case "plan":
		return nil
	case "twoFactorRequirementEnabled":
		return nil
	case "isVerified":
		return nil
	case "defaultRepositoryPermission":
		return nil
	case "membersCanCreateRepositories":
		return nil
	case "membersCanCreatePublicRepositories":
		return nil
	case "membersCanCreatePrivateRepositories":
		return nil
	case "membersCanCreateInternalRepositories":
		return nil
	case "membersCanCreatePages":
		return nil
	case "membersCanCreatePublicPages":
		return nil
	case "membersCanCreatePrivatePages":
		return nil
	case "owners":
		return s.ComputeOwners()
	case "members":
		return s.ComputeMembers()
	case "teams":
		return s.ComputeTeams()
	case "repositories":
		return s.ComputeRepositories()
	case "installations":
		return s.ComputeInstallations()
	case "webhooks":
		return s.ComputeWebhooks()
	case "packages":
		return s.ComputePackages()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.organization\" resource")
	}
}

// ComputeOwners computer autogenerated
func (s *mqlGithubOrganization) ComputeOwners() error {
	var err error
	if _, ok := s.Cache.Load("owners"); ok {
		return nil
	}
	vres, err := s.GetOwners()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("owners", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMembers computer autogenerated
func (s *mqlGithubOrganization) ComputeMembers() error {
	var err error
	if _, ok := s.Cache.Load("members"); ok {
		return nil
	}
	vres, err := s.GetMembers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("members", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeTeams computer autogenerated
func (s *mqlGithubOrganization) ComputeTeams() error {
	var err error
	if _, ok := s.Cache.Load("teams"); ok {
		return nil
	}
	vres, err := s.GetTeams()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("teams", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRepositories computer autogenerated
func (s *mqlGithubOrganization) ComputeRepositories() error {
	var err error
	if _, ok := s.Cache.Load("repositories"); ok {
		return nil
	}
	vres, err := s.GetRepositories()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repositories", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeInstallations computer autogenerated
func (s *mqlGithubOrganization) ComputeInstallations() error {
	var err error
	if _, ok := s.Cache.Load("installations"); ok {
		return nil
	}
	vres, err := s.GetInstallations()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("installations", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWebhooks computer autogenerated
func (s *mqlGithubOrganization) ComputeWebhooks() error {
	var err error
	if _, ok := s.Cache.Load("webhooks"); ok {
		return nil
	}
	vres, err := s.GetWebhooks()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("webhooks", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePackages computer autogenerated
func (s *mqlGithubOrganization) ComputePackages() error {
	var err error
	if _, ok := s.Cache.Load("packages"); ok {
		return nil
	}
	vres, err := s.GetPackages()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("packages", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubUser resource interface
type GithubUser interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Login() (string, error)
	Name() (string, error)
	Email() (string, error)
	Bio() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	SuspendedAt() (*time.Time, error)
	Company() (string, error)
	Repositories() ([]interface{}, error)
}

// mqlGithubUser for the github.user resource
type mqlGithubUser struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubUser) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.user resource
func newGithubUser(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubUser{runtime.NewResource("github.user")}
	var existing GithubUser
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "login":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"login\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "email":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"email\" argument has the wrong type (expected type \"string\")")
			}
		case "bio":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"bio\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "suspendedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"suspendedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "company":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"company\" argument has the wrong type (expected type \"string\")")
			}
		case "repositories":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"repositories\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.user\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.user with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubUser) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("login"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"login\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("email"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"email\". This field is required.")
	}
	if _, ok := s.Cache.Load("bio"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"bio\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("suspendedAt"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"suspendedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("company"); !ok {
		return errors.New("Initialized \"github.user\" resource without a \"company\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubUser) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.user].Register")
	switch name {
	case "id":
		return nil
	case "login":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "bio":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "suspendedAt":
		return nil
	case "company":
		return nil
	case "repositories":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.user\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubUser) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.user].Field")
	switch name {
	case "id":
		return s.Id()
	case "login":
		return s.Login()
	case "name":
		return s.Name()
	case "email":
		return s.Email()
	case "bio":
		return s.Bio()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "suspendedAt":
		return s.SuspendedAt()
	case "company":
		return s.Company()
	case "repositories":
		return s.Repositories()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.user\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubUser) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.user\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.user\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Login accessor autogenerated
func (s *mqlGithubUser) Login() (string, error) {
	res, ok := s.Cache.Load("login")
	if !ok || !res.Valid {
		return "", errors.New("\"github.user\" failed: no value provided for static field \"login\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.user\" failed to cast field \"login\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubUser) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.user\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.user\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlGithubUser) Email() (string, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		return "", errors.New("\"github.user\" failed: no value provided for static field \"email\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.user\" failed to cast field \"email\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Bio accessor autogenerated
func (s *mqlGithubUser) Bio() (string, error) {
	res, ok := s.Cache.Load("bio")
	if !ok || !res.Valid {
		return "", errors.New("\"github.user\" failed: no value provided for static field \"bio\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.user\" failed to cast field \"bio\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubUser) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.user\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.user\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubUser) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.user\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.user\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// SuspendedAt accessor autogenerated
func (s *mqlGithubUser) SuspendedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("suspendedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.user\" failed: no value provided for static field \"suspendedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.user\" failed to cast field \"suspendedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Company accessor autogenerated
func (s *mqlGithubUser) Company() (string, error) {
	res, ok := s.Cache.Load("company")
	if !ok || !res.Valid {
		return "", errors.New("\"github.user\" failed: no value provided for static field \"company\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.user\" failed to cast field \"company\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Repositories accessor autogenerated
func (s *mqlGithubUser) Repositories() ([]interface{}, error) {
	res, ok := s.Cache.Load("repositories")
	if !ok || !res.Valid {
		if err := s.ComputeRepositories(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repositories")
		if !ok {
			return nil, errors.New("\"github.user\" calculated \"repositories\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repositories")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.user\" failed to cast field \"repositories\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubUser) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.user].MqlCompute")
	switch name {
	case "id":
		return nil
	case "login":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "bio":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "suspendedAt":
		return nil
	case "company":
		return nil
	case "repositories":
		return s.ComputeRepositories()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.user\" resource")
	}
}

// ComputeRepositories computer autogenerated
func (s *mqlGithubUser) ComputeRepositories() error {
	var err error
	if _, ok := s.Cache.Load("repositories"); ok {
		return nil
	}
	vres, err := s.GetRepositories()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repositories", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubTeam resource interface
type GithubTeam interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Name() (string, error)
	Description() (string, error)
	Slug() (string, error)
	Privacy() (string, error)
	DefaultPermission() (string, error)
	Members() ([]interface{}, error)
	Repositories() ([]interface{}, error)
	Organization() (GithubOrganization, error)
}

// mqlGithubTeam for the github.team resource
type mqlGithubTeam struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubTeam) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.team resource
func newGithubTeam(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubTeam{runtime.NewResource("github.team")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "slug":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"slug\" argument has the wrong type (expected type \"string\")")
			}
		case "privacy":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"privacy\" argument has the wrong type (expected type \"string\")")
			}
		case "defaultPermission":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"defaultPermission\" argument has the wrong type (expected type \"string\")")
			}
		case "members":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"members\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "repositories":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"repositories\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "organization":
			if _, ok := val.(GithubOrganization); !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"organization\" argument has the wrong type (expected type \"GithubOrganization\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.team\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.team with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubTeam) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("slug"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"slug\". This field is required.")
	}
	if _, ok := s.Cache.Load("privacy"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"privacy\". This field is required.")
	}
	if _, ok := s.Cache.Load("defaultPermission"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"defaultPermission\". This field is required.")
	}
	if _, ok := s.Cache.Load("organization"); !ok {
		return errors.New("Initialized \"github.team\" resource without a \"organization\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubTeam) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.team].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "description":
		return nil
	case "slug":
		return nil
	case "privacy":
		return nil
	case "defaultPermission":
		return nil
	case "members":
		return nil
	case "repositories":
		return nil
	case "organization":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.team\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubTeam) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.team].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "description":
		return s.Description()
	case "slug":
		return s.Slug()
	case "privacy":
		return s.Privacy()
	case "defaultPermission":
		return s.DefaultPermission()
	case "members":
		return s.Members()
	case "repositories":
		return s.Repositories()
	case "organization":
		return s.Organization()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.team\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubTeam) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.team\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.team\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubTeam) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.team\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.team\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlGithubTeam) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"github.team\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.team\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Slug accessor autogenerated
func (s *mqlGithubTeam) Slug() (string, error) {
	res, ok := s.Cache.Load("slug")
	if !ok || !res.Valid {
		return "", errors.New("\"github.team\" failed: no value provided for static field \"slug\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.team\" failed to cast field \"slug\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Privacy accessor autogenerated
func (s *mqlGithubTeam) Privacy() (string, error) {
	res, ok := s.Cache.Load("privacy")
	if !ok || !res.Valid {
		return "", errors.New("\"github.team\" failed: no value provided for static field \"privacy\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.team\" failed to cast field \"privacy\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// DefaultPermission accessor autogenerated
func (s *mqlGithubTeam) DefaultPermission() (string, error) {
	res, ok := s.Cache.Load("defaultPermission")
	if !ok || !res.Valid {
		return "", errors.New("\"github.team\" failed: no value provided for static field \"defaultPermission\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.team\" failed to cast field \"defaultPermission\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Members accessor autogenerated
func (s *mqlGithubTeam) Members() ([]interface{}, error) {
	res, ok := s.Cache.Load("members")
	if !ok || !res.Valid {
		if err := s.ComputeMembers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("members")
		if !ok {
			return nil, errors.New("\"github.team\" calculated \"members\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "members")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.team\" failed to cast field \"members\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Repositories accessor autogenerated
func (s *mqlGithubTeam) Repositories() ([]interface{}, error) {
	res, ok := s.Cache.Load("repositories")
	if !ok || !res.Valid {
		if err := s.ComputeRepositories(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repositories")
		if !ok {
			return nil, errors.New("\"github.team\" calculated \"repositories\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repositories")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.team\" failed to cast field \"repositories\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Organization accessor autogenerated
func (s *mqlGithubTeam) Organization() (GithubOrganization, error) {
	res, ok := s.Cache.Load("organization")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.team\" failed: no value provided for static field \"organization\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubOrganization)
	if !ok {
		return nil, fmt.Errorf("\"github.team\" failed to cast field \"organization\" to the right type (GithubOrganization): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubTeam) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.team].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "description":
		return nil
	case "slug":
		return nil
	case "privacy":
		return nil
	case "defaultPermission":
		return nil
	case "members":
		return s.ComputeMembers()
	case "repositories":
		return s.ComputeRepositories()
	case "organization":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.team\" resource")
	}
}

// ComputeMembers computer autogenerated
func (s *mqlGithubTeam) ComputeMembers() error {
	var err error
	if _, ok := s.Cache.Load("members"); ok {
		return nil
	}
	vres, err := s.GetMembers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("members", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRepositories computer autogenerated
func (s *mqlGithubTeam) ComputeRepositories() error {
	var err error
	if _, ok := s.Cache.Load("repositories"); ok {
		return nil
	}
	vres, err := s.GetRepositories()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repositories", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubCollaborator resource interface
type GithubCollaborator interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	User() (GithubUser, error)
	Permissions() ([]interface{}, error)
}

// mqlGithubCollaborator for the github.collaborator resource
type mqlGithubCollaborator struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubCollaborator) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.collaborator resource
func newGithubCollaborator(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubCollaborator{runtime.NewResource("github.collaborator")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.collaborator\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "user":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.collaborator\", its \"user\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "permissions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.collaborator\", its \"permissions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.collaborator\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.collaborator with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubCollaborator) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.collaborator\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("user"); !ok {
		return errors.New("Initialized \"github.collaborator\" resource without a \"user\". This field is required.")
	}
	if _, ok := s.Cache.Load("permissions"); !ok {
		return errors.New("Initialized \"github.collaborator\" resource without a \"permissions\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubCollaborator) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.collaborator].Register")
	switch name {
	case "id":
		return nil
	case "user":
		return nil
	case "permissions":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.collaborator\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubCollaborator) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.collaborator].Field")
	switch name {
	case "id":
		return s.Id()
	case "user":
		return s.User()
	case "permissions":
		return s.Permissions()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.collaborator\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubCollaborator) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.collaborator\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.collaborator\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// User accessor autogenerated
func (s *mqlGithubCollaborator) User() (GithubUser, error) {
	res, ok := s.Cache.Load("user")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.collaborator\" failed: no value provided for static field \"user\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.collaborator\" failed to cast field \"user\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Permissions accessor autogenerated
func (s *mqlGithubCollaborator) Permissions() ([]interface{}, error) {
	res, ok := s.Cache.Load("permissions")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.collaborator\" failed: no value provided for static field \"permissions\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.collaborator\" failed to cast field \"permissions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubCollaborator) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.collaborator].MqlCompute")
	switch name {
	case "id":
		return nil
	case "user":
		return nil
	case "permissions":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.collaborator\" resource")
	}
}

// GithubPackage resource interface
type GithubPackage interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Name() (string, error)
	PackageType() (string, error)
	Owner() (GithubUser, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	VersionCount() (int64, error)
	Visibility() (string, error)
	Repository() (GithubRepository, error)
}

// mqlGithubPackage for the github.package resource
type mqlGithubPackage struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubPackage) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.package resource
func newGithubPackage(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubPackage{runtime.NewResource("github.package")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "packageType":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"packageType\" argument has the wrong type (expected type \"string\")")
			}
		case "owner":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"owner\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "versionCount":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"versionCount\" argument has the wrong type (expected type \"int64\")")
			}
		case "visibility":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"visibility\" argument has the wrong type (expected type \"string\")")
			}
		case "repository":
			if _, ok := val.(GithubRepository); !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"repository\" argument has the wrong type (expected type \"GithubRepository\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.package\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.package with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubPackage) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("packageType"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"packageType\". This field is required.")
	}
	if _, ok := s.Cache.Load("owner"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"owner\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("versionCount"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"versionCount\". This field is required.")
	}
	if _, ok := s.Cache.Load("visibility"); !ok {
		return errors.New("Initialized \"github.package\" resource without a \"visibility\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubPackage) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.package].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "packageType":
		return nil
	case "owner":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "versionCount":
		return nil
	case "visibility":
		return nil
	case "repository":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.package\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubPackage) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.package].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "packageType":
		return s.PackageType()
	case "owner":
		return s.Owner()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "versionCount":
		return s.VersionCount()
	case "visibility":
		return s.Visibility()
	case "repository":
		return s.Repository()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.package\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubPackage) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.package\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.package\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubPackage) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.package\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.package\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PackageType accessor autogenerated
func (s *mqlGithubPackage) PackageType() (string, error) {
	res, ok := s.Cache.Load("packageType")
	if !ok || !res.Valid {
		return "", errors.New("\"github.package\" failed: no value provided for static field \"packageType\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.package\" failed to cast field \"packageType\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Owner accessor autogenerated
func (s *mqlGithubPackage) Owner() (GithubUser, error) {
	res, ok := s.Cache.Load("owner")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.package\" failed: no value provided for static field \"owner\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.package\" failed to cast field \"owner\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubPackage) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.package\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.package\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubPackage) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.package\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.package\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// VersionCount accessor autogenerated
func (s *mqlGithubPackage) VersionCount() (int64, error) {
	res, ok := s.Cache.Load("versionCount")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.package\" failed: no value provided for static field \"versionCount\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.package\" failed to cast field \"versionCount\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Visibility accessor autogenerated
func (s *mqlGithubPackage) Visibility() (string, error) {
	res, ok := s.Cache.Load("visibility")
	if !ok || !res.Valid {
		return "", errors.New("\"github.package\" failed: no value provided for static field \"visibility\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.package\" failed to cast field \"visibility\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Repository accessor autogenerated
func (s *mqlGithubPackage) Repository() (GithubRepository, error) {
	res, ok := s.Cache.Load("repository")
	if !ok || !res.Valid {
		if err := s.ComputeRepository(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("repository")
		if !ok {
			return nil, errors.New("\"github.package\" calculated \"repository\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "repository")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubRepository)
	if !ok {
		return nil, fmt.Errorf("\"github.package\" failed to cast field \"repository\" to the right type (GithubRepository): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubPackage) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.package].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "packageType":
		return nil
	case "owner":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "versionCount":
		return nil
	case "visibility":
		return nil
	case "repository":
		return s.ComputeRepository()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.package\" resource")
	}
}

// ComputeRepository computer autogenerated
func (s *mqlGithubPackage) ComputeRepository() error {
	var err error
	if _, ok := s.Cache.Load("repository"); ok {
		return nil
	}
	vres, err := s.GetRepository()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("repository", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubRepository resource interface
type GithubRepository interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Name() (string, error)
	FullName() (string, error)
	Description() (string, error)
	Homepage() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	Archived() (bool, error)
	Disabled() (bool, error)
	Private() (bool, error)
	Visibility() (string, error)
	AllowAutoMerge() (bool, error)
	AllowForking() (bool, error)
	AllowMergeCommit() (bool, error)
	AllowRebaseMerge() (bool, error)
	AllowSquashMerge() (bool, error)
	HasIssues() (bool, error)
	OrganizationName() (string, error)
	OpenMergeRequests() ([]interface{}, error)
	Branches() ([]interface{}, error)
	DefaultBranchName() (string, error)
	Commits() ([]interface{}, error)
	Contributors() ([]interface{}, error)
	Collaborators() ([]interface{}, error)
	Files() ([]interface{}, error)
	Releases() ([]interface{}, error)
	Owner() (GithubUser, error)
	Webhooks() ([]interface{}, error)
	Workflows() ([]interface{}, error)
}

// mqlGithubRepository for the github.repository resource
type mqlGithubRepository struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubRepository) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.repository resource
func newGithubRepository(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubRepository{runtime.NewResource("github.repository")}
	var existing GithubRepository
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "fullName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"fullName\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "homepage":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"homepage\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "archived":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"archived\" argument has the wrong type (expected type \"bool\")")
			}
		case "disabled":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"disabled\" argument has the wrong type (expected type \"bool\")")
			}
		case "private":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"private\" argument has the wrong type (expected type \"bool\")")
			}
		case "visibility":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"visibility\" argument has the wrong type (expected type \"string\")")
			}
		case "allowAutoMerge":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"allowAutoMerge\" argument has the wrong type (expected type \"bool\")")
			}
		case "allowForking":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"allowForking\" argument has the wrong type (expected type \"bool\")")
			}
		case "allowMergeCommit":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"allowMergeCommit\" argument has the wrong type (expected type \"bool\")")
			}
		case "allowRebaseMerge":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"allowRebaseMerge\" argument has the wrong type (expected type \"bool\")")
			}
		case "allowSquashMerge":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"allowSquashMerge\" argument has the wrong type (expected type \"bool\")")
			}
		case "hasIssues":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"hasIssues\" argument has the wrong type (expected type \"bool\")")
			}
		case "organizationName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"organizationName\" argument has the wrong type (expected type \"string\")")
			}
		case "openMergeRequests":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"openMergeRequests\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "branches":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"branches\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "defaultBranchName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"defaultBranchName\" argument has the wrong type (expected type \"string\")")
			}
		case "commits":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"commits\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "contributors":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"contributors\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "collaborators":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"collaborators\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "releases":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"releases\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "owner":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"owner\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "webhooks":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"webhooks\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "workflows":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"workflows\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.repository\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.repository with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubRepository) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("fullName"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"fullName\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("homepage"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"homepage\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"updatedAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("archived"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"archived\". This field is required.")
	}
	if _, ok := s.Cache.Load("disabled"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"disabled\". This field is required.")
	}
	if _, ok := s.Cache.Load("private"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"private\". This field is required.")
	}
	if _, ok := s.Cache.Load("visibility"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"visibility\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowAutoMerge"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"allowAutoMerge\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowForking"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"allowForking\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowMergeCommit"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"allowMergeCommit\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowRebaseMerge"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"allowRebaseMerge\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowSquashMerge"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"allowSquashMerge\". This field is required.")
	}
	if _, ok := s.Cache.Load("hasIssues"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"hasIssues\". This field is required.")
	}
	if _, ok := s.Cache.Load("organizationName"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"organizationName\". This field is required.")
	}
	if _, ok := s.Cache.Load("defaultBranchName"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"defaultBranchName\". This field is required.")
	}
	if _, ok := s.Cache.Load("owner"); !ok {
		return errors.New("Initialized \"github.repository\" resource without a \"owner\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubRepository) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.repository].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "fullName":
		return nil
	case "description":
		return nil
	case "homepage":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "archived":
		return nil
	case "disabled":
		return nil
	case "private":
		return nil
	case "visibility":
		return nil
	case "allowAutoMerge":
		return nil
	case "allowForking":
		return nil
	case "allowMergeCommit":
		return nil
	case "allowRebaseMerge":
		return nil
	case "allowSquashMerge":
		return nil
	case "hasIssues":
		return nil
	case "organizationName":
		return nil
	case "openMergeRequests":
		return nil
	case "branches":
		return nil
	case "defaultBranchName":
		return nil
	case "commits":
		return nil
	case "contributors":
		return nil
	case "collaborators":
		return nil
	case "files":
		return nil
	case "releases":
		return nil
	case "owner":
		return nil
	case "webhooks":
		return nil
	case "workflows":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.repository\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubRepository) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.repository].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "fullName":
		return s.FullName()
	case "description":
		return s.Description()
	case "homepage":
		return s.Homepage()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "archived":
		return s.Archived()
	case "disabled":
		return s.Disabled()
	case "private":
		return s.Private()
	case "visibility":
		return s.Visibility()
	case "allowAutoMerge":
		return s.AllowAutoMerge()
	case "allowForking":
		return s.AllowForking()
	case "allowMergeCommit":
		return s.AllowMergeCommit()
	case "allowRebaseMerge":
		return s.AllowRebaseMerge()
	case "allowSquashMerge":
		return s.AllowSquashMerge()
	case "hasIssues":
		return s.HasIssues()
	case "organizationName":
		return s.OrganizationName()
	case "openMergeRequests":
		return s.OpenMergeRequests()
	case "branches":
		return s.Branches()
	case "defaultBranchName":
		return s.DefaultBranchName()
	case "commits":
		return s.Commits()
	case "contributors":
		return s.Contributors()
	case "collaborators":
		return s.Collaborators()
	case "files":
		return s.Files()
	case "releases":
		return s.Releases()
	case "owner":
		return s.Owner()
	case "webhooks":
		return s.Webhooks()
	case "workflows":
		return s.Workflows()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.repository\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubRepository) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.repository\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.repository\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubRepository) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// FullName accessor autogenerated
func (s *mqlGithubRepository) FullName() (string, error) {
	res, ok := s.Cache.Load("fullName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"fullName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"fullName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlGithubRepository) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Homepage accessor autogenerated
func (s *mqlGithubRepository) Homepage() (string, error) {
	res, ok := s.Cache.Load("homepage")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"homepage\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"homepage\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubRepository) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.repository\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubRepository) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.repository\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Archived accessor autogenerated
func (s *mqlGithubRepository) Archived() (bool, error) {
	res, ok := s.Cache.Load("archived")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"archived\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"archived\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Disabled accessor autogenerated
func (s *mqlGithubRepository) Disabled() (bool, error) {
	res, ok := s.Cache.Load("disabled")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"disabled\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"disabled\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Private accessor autogenerated
func (s *mqlGithubRepository) Private() (bool, error) {
	res, ok := s.Cache.Load("private")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"private\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"private\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Visibility accessor autogenerated
func (s *mqlGithubRepository) Visibility() (string, error) {
	res, ok := s.Cache.Load("visibility")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"visibility\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"visibility\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AllowAutoMerge accessor autogenerated
func (s *mqlGithubRepository) AllowAutoMerge() (bool, error) {
	res, ok := s.Cache.Load("allowAutoMerge")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"allowAutoMerge\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"allowAutoMerge\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// AllowForking accessor autogenerated
func (s *mqlGithubRepository) AllowForking() (bool, error) {
	res, ok := s.Cache.Load("allowForking")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"allowForking\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"allowForking\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// AllowMergeCommit accessor autogenerated
func (s *mqlGithubRepository) AllowMergeCommit() (bool, error) {
	res, ok := s.Cache.Load("allowMergeCommit")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"allowMergeCommit\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"allowMergeCommit\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// AllowRebaseMerge accessor autogenerated
func (s *mqlGithubRepository) AllowRebaseMerge() (bool, error) {
	res, ok := s.Cache.Load("allowRebaseMerge")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"allowRebaseMerge\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"allowRebaseMerge\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// AllowSquashMerge accessor autogenerated
func (s *mqlGithubRepository) AllowSquashMerge() (bool, error) {
	res, ok := s.Cache.Load("allowSquashMerge")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"allowSquashMerge\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"allowSquashMerge\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// HasIssues accessor autogenerated
func (s *mqlGithubRepository) HasIssues() (bool, error) {
	res, ok := s.Cache.Load("hasIssues")
	if !ok || !res.Valid {
		return false, errors.New("\"github.repository\" failed: no value provided for static field \"hasIssues\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.repository\" failed to cast field \"hasIssues\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// OrganizationName accessor autogenerated
func (s *mqlGithubRepository) OrganizationName() (string, error) {
	res, ok := s.Cache.Load("organizationName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"organizationName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"organizationName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// OpenMergeRequests accessor autogenerated
func (s *mqlGithubRepository) OpenMergeRequests() ([]interface{}, error) {
	res, ok := s.Cache.Load("openMergeRequests")
	if !ok || !res.Valid {
		if err := s.ComputeOpenMergeRequests(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("openMergeRequests")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"openMergeRequests\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "openMergeRequests")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"openMergeRequests\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Branches accessor autogenerated
func (s *mqlGithubRepository) Branches() ([]interface{}, error) {
	res, ok := s.Cache.Load("branches")
	if !ok || !res.Valid {
		if err := s.ComputeBranches(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("branches")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"branches\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "branches")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"branches\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// DefaultBranchName accessor autogenerated
func (s *mqlGithubRepository) DefaultBranchName() (string, error) {
	res, ok := s.Cache.Load("defaultBranchName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.repository\" failed: no value provided for static field \"defaultBranchName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.repository\" failed to cast field \"defaultBranchName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Commits accessor autogenerated
func (s *mqlGithubRepository) Commits() ([]interface{}, error) {
	res, ok := s.Cache.Load("commits")
	if !ok || !res.Valid {
		if err := s.ComputeCommits(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("commits")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"commits\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "commits")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"commits\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Contributors accessor autogenerated
func (s *mqlGithubRepository) Contributors() ([]interface{}, error) {
	res, ok := s.Cache.Load("contributors")
	if !ok || !res.Valid {
		if err := s.ComputeContributors(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("contributors")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"contributors\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "contributors")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"contributors\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Collaborators accessor autogenerated
func (s *mqlGithubRepository) Collaborators() ([]interface{}, error) {
	res, ok := s.Cache.Load("collaborators")
	if !ok || !res.Valid {
		if err := s.ComputeCollaborators(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("collaborators")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"collaborators\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "collaborators")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"collaborators\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Files accessor autogenerated
func (s *mqlGithubRepository) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Releases accessor autogenerated
func (s *mqlGithubRepository) Releases() ([]interface{}, error) {
	res, ok := s.Cache.Load("releases")
	if !ok || !res.Valid {
		if err := s.ComputeReleases(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("releases")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"releases\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "releases")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"releases\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Owner accessor autogenerated
func (s *mqlGithubRepository) Owner() (GithubUser, error) {
	res, ok := s.Cache.Load("owner")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.repository\" failed: no value provided for static field \"owner\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"owner\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Webhooks accessor autogenerated
func (s *mqlGithubRepository) Webhooks() ([]interface{}, error) {
	res, ok := s.Cache.Load("webhooks")
	if !ok || !res.Valid {
		if err := s.ComputeWebhooks(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("webhooks")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"webhooks\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "webhooks")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"webhooks\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Workflows accessor autogenerated
func (s *mqlGithubRepository) Workflows() ([]interface{}, error) {
	res, ok := s.Cache.Load("workflows")
	if !ok || !res.Valid {
		if err := s.ComputeWorkflows(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("workflows")
		if !ok {
			return nil, errors.New("\"github.repository\" calculated \"workflows\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "workflows")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.repository\" failed to cast field \"workflows\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubRepository) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.repository].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "fullName":
		return nil
	case "description":
		return nil
	case "homepage":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "archived":
		return nil
	case "disabled":
		return nil
	case "private":
		return nil
	case "visibility":
		return nil
	case "allowAutoMerge":
		return nil
	case "allowForking":
		return nil
	case "allowMergeCommit":
		return nil
	case "allowRebaseMerge":
		return nil
	case "allowSquashMerge":
		return nil
	case "hasIssues":
		return nil
	case "organizationName":
		return nil
	case "openMergeRequests":
		return s.ComputeOpenMergeRequests()
	case "branches":
		return s.ComputeBranches()
	case "defaultBranchName":
		return nil
	case "commits":
		return s.ComputeCommits()
	case "contributors":
		return s.ComputeContributors()
	case "collaborators":
		return s.ComputeCollaborators()
	case "files":
		return s.ComputeFiles()
	case "releases":
		return s.ComputeReleases()
	case "owner":
		return nil
	case "webhooks":
		return s.ComputeWebhooks()
	case "workflows":
		return s.ComputeWorkflows()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.repository\" resource")
	}
}

// ComputeOpenMergeRequests computer autogenerated
func (s *mqlGithubRepository) ComputeOpenMergeRequests() error {
	var err error
	if _, ok := s.Cache.Load("openMergeRequests"); ok {
		return nil
	}
	vres, err := s.GetOpenMergeRequests()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("openMergeRequests", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeBranches computer autogenerated
func (s *mqlGithubRepository) ComputeBranches() error {
	var err error
	if _, ok := s.Cache.Load("branches"); ok {
		return nil
	}
	vres, err := s.GetBranches()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("branches", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCommits computer autogenerated
func (s *mqlGithubRepository) ComputeCommits() error {
	var err error
	if _, ok := s.Cache.Load("commits"); ok {
		return nil
	}
	vres, err := s.GetCommits()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("commits", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContributors computer autogenerated
func (s *mqlGithubRepository) ComputeContributors() error {
	var err error
	if _, ok := s.Cache.Load("contributors"); ok {
		return nil
	}
	vres, err := s.GetContributors()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("contributors", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCollaborators computer autogenerated
func (s *mqlGithubRepository) ComputeCollaborators() error {
	var err error
	if _, ok := s.Cache.Load("collaborators"); ok {
		return nil
	}
	vres, err := s.GetCollaborators()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("collaborators", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFiles computer autogenerated
func (s *mqlGithubRepository) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeReleases computer autogenerated
func (s *mqlGithubRepository) ComputeReleases() error {
	var err error
	if _, ok := s.Cache.Load("releases"); ok {
		return nil
	}
	vres, err := s.GetReleases()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("releases", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWebhooks computer autogenerated
func (s *mqlGithubRepository) ComputeWebhooks() error {
	var err error
	if _, ok := s.Cache.Load("webhooks"); ok {
		return nil
	}
	vres, err := s.GetWebhooks()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("webhooks", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeWorkflows computer autogenerated
func (s *mqlGithubRepository) ComputeWorkflows() error {
	var err error
	if _, ok := s.Cache.Load("workflows"); ok {
		return nil
	}
	vres, err := s.GetWorkflows()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("workflows", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubFile resource interface
type GithubFile interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Name() (string, error)
	Type() (string, error)
	Sha() (string, error)
	IsBinary() (bool, error)
	Files() ([]interface{}, error)
	OwnerName() (string, error)
	RepoName() (string, error)
	Content() (string, error)
}

// mqlGithubFile for the github.file resource
type mqlGithubFile struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubFile) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.file resource
func newGithubFile(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubFile{runtime.NewResource("github.file")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "sha":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"sha\" argument has the wrong type (expected type \"string\")")
			}
		case "isBinary":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"isBinary\" argument has the wrong type (expected type \"bool\")")
			}
		case "files":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"files\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "ownerName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"ownerName\" argument has the wrong type (expected type \"string\")")
			}
		case "repoName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"repoName\" argument has the wrong type (expected type \"string\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.file\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.file with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubFile) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("sha"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"sha\". This field is required.")
	}
	if _, ok := s.Cache.Load("isBinary"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"isBinary\". This field is required.")
	}
	if _, ok := s.Cache.Load("ownerName"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"ownerName\". This field is required.")
	}
	if _, ok := s.Cache.Load("repoName"); !ok {
		return errors.New("Initialized \"github.file\" resource without a \"repoName\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubFile) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.file].Register")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "type":
		return nil
	case "sha":
		return nil
	case "isBinary":
		return nil
	case "files":
		return nil
	case "ownerName":
		return nil
	case "repoName":
		return nil
	case "content":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.file\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubFile) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.file].Field")
	switch name {
	case "path":
		return s.Path()
	case "name":
		return s.Name()
	case "type":
		return s.Type()
	case "sha":
		return s.Sha()
	case "isBinary":
		return s.IsBinary()
	case "files":
		return s.Files()
	case "ownerName":
		return s.OwnerName()
	case "repoName":
		return s.RepoName()
	case "content":
		return s.Content()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.file\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlGithubFile) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubFile) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlGithubFile) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sha accessor autogenerated
func (s *mqlGithubFile) Sha() (string, error) {
	res, ok := s.Cache.Load("sha")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"sha\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"sha\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// IsBinary accessor autogenerated
func (s *mqlGithubFile) IsBinary() (bool, error) {
	res, ok := s.Cache.Load("isBinary")
	if !ok || !res.Valid {
		return false, errors.New("\"github.file\" failed: no value provided for static field \"isBinary\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.file\" failed to cast field \"isBinary\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Files accessor autogenerated
func (s *mqlGithubFile) Files() ([]interface{}, error) {
	res, ok := s.Cache.Load("files")
	if !ok || !res.Valid {
		if err := s.ComputeFiles(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("files")
		if !ok {
			return nil, errors.New("\"github.file\" calculated \"files\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "files")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.file\" failed to cast field \"files\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// OwnerName accessor autogenerated
func (s *mqlGithubFile) OwnerName() (string, error) {
	res, ok := s.Cache.Load("ownerName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"ownerName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"ownerName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RepoName accessor autogenerated
func (s *mqlGithubFile) RepoName() (string, error) {
	res, ok := s.Cache.Load("repoName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.file\" failed: no value provided for static field \"repoName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"repoName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlGithubFile) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		if err := s.ComputeContent(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("content")
		if !ok {
			return "", errors.New("\"github.file\" calculated \"content\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "content")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.file\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubFile) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.file].MqlCompute")
	switch name {
	case "path":
		return nil
	case "name":
		return nil
	case "type":
		return nil
	case "sha":
		return nil
	case "isBinary":
		return nil
	case "files":
		return s.ComputeFiles()
	case "ownerName":
		return nil
	case "repoName":
		return nil
	case "content":
		return s.ComputeContent()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.file\" resource")
	}
}

// ComputeFiles computer autogenerated
func (s *mqlGithubFile) ComputeFiles() error {
	var err error
	if _, ok := s.Cache.Load("files"); ok {
		return nil
	}
	vres, err := s.GetFiles()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("files", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlGithubFile) ComputeContent() error {
	var err error
	if _, ok := s.Cache.Load("content"); ok {
		return nil
	}
	vres, err := s.GetContent()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubRelease resource interface
type GithubRelease interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Url() (string, error)
	Name() (string, error)
	TagName() (string, error)
	PreRelease() (bool, error)
}

// mqlGithubRelease for the github.release resource
type mqlGithubRelease struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubRelease) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.release resource
func newGithubRelease(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubRelease{runtime.NewResource("github.release")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.release\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.release\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "tagName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.release\", its \"tagName\" argument has the wrong type (expected type \"string\")")
			}
		case "preRelease":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.release\", its \"preRelease\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.release\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.release with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubRelease) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"github.release\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.release\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("tagName"); !ok {
		return errors.New("Initialized \"github.release\" resource without a \"tagName\". This field is required.")
	}
	if _, ok := s.Cache.Load("preRelease"); !ok {
		return errors.New("Initialized \"github.release\" resource without a \"preRelease\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubRelease) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.release].Register")
	switch name {
	case "url":
		return nil
	case "name":
		return nil
	case "tagName":
		return nil
	case "preRelease":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.release\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubRelease) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.release].Field")
	switch name {
	case "url":
		return s.Url()
	case "name":
		return s.Name()
	case "tagName":
		return s.TagName()
	case "preRelease":
		return s.PreRelease()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.release\" resource")
	}
}

// Url accessor autogenerated
func (s *mqlGithubRelease) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"github.release\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.release\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubRelease) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.release\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.release\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TagName accessor autogenerated
func (s *mqlGithubRelease) TagName() (string, error) {
	res, ok := s.Cache.Load("tagName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.release\" failed: no value provided for static field \"tagName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.release\" failed to cast field \"tagName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PreRelease accessor autogenerated
func (s *mqlGithubRelease) PreRelease() (bool, error) {
	res, ok := s.Cache.Load("preRelease")
	if !ok || !res.Valid {
		return false, errors.New("\"github.release\" failed: no value provided for static field \"preRelease\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.release\" failed to cast field \"preRelease\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubRelease) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.release].MqlCompute")
	switch name {
	case "url":
		return nil
	case "name":
		return nil
	case "tagName":
		return nil
	case "preRelease":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.release\" resource")
	}
}

// GithubWebhook resource interface
type GithubWebhook interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Name() (string, error)
	Url() (string, error)
	Events() ([]interface{}, error)
	Config() (interface{}, error)
	Active() (bool, error)
}

// mqlGithubWebhook for the github.webhook resource
type mqlGithubWebhook struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubWebhook) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.webhook resource
func newGithubWebhook(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubWebhook{runtime.NewResource("github.webhook")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "events":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"events\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "config":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"config\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "active":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"active\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.webhook\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.webhook with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubWebhook) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("events"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"events\". This field is required.")
	}
	if _, ok := s.Cache.Load("config"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"config\". This field is required.")
	}
	if _, ok := s.Cache.Load("active"); !ok {
		return errors.New("Initialized \"github.webhook\" resource without a \"active\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubWebhook) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.webhook].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "url":
		return nil
	case "events":
		return nil
	case "config":
		return nil
	case "active":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.webhook\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubWebhook) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.webhook].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "url":
		return s.Url()
	case "events":
		return s.Events()
	case "config":
		return s.Config()
	case "active":
		return s.Active()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.webhook\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubWebhook) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.webhook\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.webhook\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubWebhook) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.webhook\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.webhook\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlGithubWebhook) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"github.webhook\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.webhook\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Events accessor autogenerated
func (s *mqlGithubWebhook) Events() ([]interface{}, error) {
	res, ok := s.Cache.Load("events")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.webhook\" failed: no value provided for static field \"events\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.webhook\" failed to cast field \"events\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Config accessor autogenerated
func (s *mqlGithubWebhook) Config() (interface{}, error) {
	res, ok := s.Cache.Load("config")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.webhook\" failed: no value provided for static field \"config\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.webhook\" failed to cast field \"config\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Active accessor autogenerated
func (s *mqlGithubWebhook) Active() (bool, error) {
	res, ok := s.Cache.Load("active")
	if !ok || !res.Valid {
		return false, errors.New("\"github.webhook\" failed: no value provided for static field \"active\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.webhook\" failed to cast field \"active\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubWebhook) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.webhook].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "url":
		return nil
	case "events":
		return nil
	case "config":
		return nil
	case "active":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.webhook\" resource")
	}
}

// GithubWorkflow resource interface
type GithubWorkflow interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Name() (string, error)
	Path() (string, error)
	State() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
	File() (GithubFile, error)
	Configuration() (interface{}, error)
}

// mqlGithubWorkflow for the github.workflow resource
type mqlGithubWorkflow struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubWorkflow) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.workflow resource
func newGithubWorkflow(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubWorkflow{runtime.NewResource("github.workflow")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "file":
			if _, ok := val.(GithubFile); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"file\" argument has the wrong type (expected type \"GithubFile\")")
			}
		case "configuration":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"configuration\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.workflow\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.workflow with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubWorkflow) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"path\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.workflow\" resource without a \"updatedAt\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubWorkflow) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.workflow].Register")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "path":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "file":
		return nil
	case "configuration":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.workflow\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubWorkflow) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.workflow].Field")
	switch name {
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "path":
		return s.Path()
	case "state":
		return s.State()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	case "file":
		return s.File()
	case "configuration":
		return s.Configuration()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.workflow\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubWorkflow) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.workflow\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.workflow\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGithubWorkflow) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.workflow\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.workflow\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Path accessor autogenerated
func (s *mqlGithubWorkflow) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"github.workflow\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.workflow\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlGithubWorkflow) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"github.workflow\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.workflow\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubWorkflow) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.workflow\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.workflow\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubWorkflow) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.workflow\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.workflow\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlGithubWorkflow) File() (GithubFile, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"github.workflow\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubFile)
	if !ok {
		return nil, fmt.Errorf("\"github.workflow\" failed to cast field \"file\" to the right type (GithubFile): %#v", res)
	}
	return tres, nil
}

// Configuration accessor autogenerated
func (s *mqlGithubWorkflow) Configuration() (interface{}, error) {
	res, ok := s.Cache.Load("configuration")
	if !ok || !res.Valid {
		if err := s.ComputeConfiguration(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("configuration")
		if !ok {
			return nil, errors.New("\"github.workflow\" calculated \"configuration\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "configuration")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.workflow\" failed to cast field \"configuration\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubWorkflow) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.workflow].MqlCompute")
	switch name {
	case "id":
		return nil
	case "name":
		return nil
	case "path":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	case "file":
		return s.ComputeFile()
	case "configuration":
		return s.ComputeConfiguration()
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.workflow\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlGithubWorkflow) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeConfiguration computer autogenerated
func (s *mqlGithubWorkflow) ComputeConfiguration() error {
	var err error
	if _, ok := s.Cache.Load("configuration"); ok {
		return nil
	}
	vres, err := s.GetConfiguration()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("configuration", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubBranch resource interface
type GithubBranch interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Protected() (bool, error)
	HeadCommit() (GithubCommit, error)
	ProtectionRules() (GithubBranchprotection, error)
	OrganizationName() (string, error)
	RepoName() (string, error)
	Owner() (GithubUser, error)
	IsDefault() (bool, error)
}

// mqlGithubBranch for the github.branch resource
type mqlGithubBranch struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubBranch) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.branch resource
func newGithubBranch(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubBranch{runtime.NewResource("github.branch")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "protected":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"protected\" argument has the wrong type (expected type \"bool\")")
			}
		case "headCommit":
			if _, ok := val.(GithubCommit); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"headCommit\" argument has the wrong type (expected type \"GithubCommit\")")
			}
		case "protectionRules":
			if _, ok := val.(GithubBranchprotection); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"protectionRules\" argument has the wrong type (expected type \"GithubBranchprotection\")")
			}
		case "organizationName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"organizationName\" argument has the wrong type (expected type \"string\")")
			}
		case "repoName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"repoName\" argument has the wrong type (expected type \"string\")")
			}
		case "owner":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"owner\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "isDefault":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"isDefault\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.branch\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.branch with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubBranch) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("protected"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"protected\". This field is required.")
	}
	if _, ok := s.Cache.Load("headCommit"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"headCommit\". This field is required.")
	}
	if _, ok := s.Cache.Load("organizationName"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"organizationName\". This field is required.")
	}
	if _, ok := s.Cache.Load("repoName"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"repoName\". This field is required.")
	}
	if _, ok := s.Cache.Load("owner"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"owner\". This field is required.")
	}
	if _, ok := s.Cache.Load("isDefault"); !ok {
		return errors.New("Initialized \"github.branch\" resource without a \"isDefault\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubBranch) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.branch].Register")
	switch name {
	case "name":
		return nil
	case "protected":
		return nil
	case "headCommit":
		return nil
	case "protectionRules":
		return nil
	case "organizationName":
		return nil
	case "repoName":
		return nil
	case "owner":
		return nil
	case "isDefault":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.branch\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubBranch) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.branch].Field")
	switch name {
	case "name":
		return s.Name()
	case "protected":
		return s.Protected()
	case "headCommit":
		return s.HeadCommit()
	case "protectionRules":
		return s.ProtectionRules()
	case "organizationName":
		return s.OrganizationName()
	case "repoName":
		return s.RepoName()
	case "owner":
		return s.Owner()
	case "isDefault":
		return s.IsDefault()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.branch\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlGithubBranch) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"github.branch\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.branch\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Protected accessor autogenerated
func (s *mqlGithubBranch) Protected() (bool, error) {
	res, ok := s.Cache.Load("protected")
	if !ok || !res.Valid {
		return false, errors.New("\"github.branch\" failed: no value provided for static field \"protected\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.branch\" failed to cast field \"protected\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// HeadCommit accessor autogenerated
func (s *mqlGithubBranch) HeadCommit() (GithubCommit, error) {
	res, ok := s.Cache.Load("headCommit")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branch\" failed: no value provided for static field \"headCommit\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubCommit)
	if !ok {
		return nil, fmt.Errorf("\"github.branch\" failed to cast field \"headCommit\" to the right type (GithubCommit): %#v", res)
	}
	return tres, nil
}

// ProtectionRules accessor autogenerated
func (s *mqlGithubBranch) ProtectionRules() (GithubBranchprotection, error) {
	res, ok := s.Cache.Load("protectionRules")
	if !ok || !res.Valid {
		if err := s.ComputeProtectionRules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("protectionRules")
		if !ok {
			return nil, errors.New("\"github.branch\" calculated \"protectionRules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "protectionRules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubBranchprotection)
	if !ok {
		return nil, fmt.Errorf("\"github.branch\" failed to cast field \"protectionRules\" to the right type (GithubBranchprotection): %#v", res)
	}
	return tres, nil
}

// OrganizationName accessor autogenerated
func (s *mqlGithubBranch) OrganizationName() (string, error) {
	res, ok := s.Cache.Load("organizationName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.branch\" failed: no value provided for static field \"organizationName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.branch\" failed to cast field \"organizationName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RepoName accessor autogenerated
func (s *mqlGithubBranch) RepoName() (string, error) {
	res, ok := s.Cache.Load("repoName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.branch\" failed: no value provided for static field \"repoName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.branch\" failed to cast field \"repoName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Owner accessor autogenerated
func (s *mqlGithubBranch) Owner() (GithubUser, error) {
	res, ok := s.Cache.Load("owner")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branch\" failed: no value provided for static field \"owner\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.branch\" failed to cast field \"owner\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// IsDefault accessor autogenerated
func (s *mqlGithubBranch) IsDefault() (bool, error) {
	res, ok := s.Cache.Load("isDefault")
	if !ok || !res.Valid {
		return false, errors.New("\"github.branch\" failed: no value provided for static field \"isDefault\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.branch\" failed to cast field \"isDefault\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubBranch) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.branch].MqlCompute")
	switch name {
	case "name":
		return nil
	case "protected":
		return nil
	case "headCommit":
		return nil
	case "protectionRules":
		return s.ComputeProtectionRules()
	case "organizationName":
		return nil
	case "repoName":
		return nil
	case "owner":
		return nil
	case "isDefault":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.branch\" resource")
	}
}

// ComputeProtectionRules computer autogenerated
func (s *mqlGithubBranch) ComputeProtectionRules() error {
	var err error
	if _, ok := s.Cache.Load("protectionRules"); ok {
		return nil
	}
	vres, err := s.GetProtectionRules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("protectionRules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubBranchprotection resource interface
type GithubBranchprotection interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	RequiredStatusChecks() (interface{}, error)
	RequiredPullRequestReviews() (interface{}, error)
	RequiredConversationResolution() (interface{}, error)
	RequiredSignatures() (bool, error)
	RequireLinearHistory() (interface{}, error)
	EnforceAdmins() (interface{}, error)
	Restrictions() (interface{}, error)
	AllowForcePushes() (interface{}, error)
	AllowDeletions() (interface{}, error)
}

// mqlGithubBranchprotection for the github.branchprotection resource
type mqlGithubBranchprotection struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubBranchprotection) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.branchprotection resource
func newGithubBranchprotection(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubBranchprotection{runtime.NewResource("github.branchprotection")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "requiredStatusChecks":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"requiredStatusChecks\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "requiredPullRequestReviews":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"requiredPullRequestReviews\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "requiredConversationResolution":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"requiredConversationResolution\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "requiredSignatures":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"requiredSignatures\" argument has the wrong type (expected type \"bool\")")
			}
		case "requireLinearHistory":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"requireLinearHistory\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "enforceAdmins":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"enforceAdmins\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "restrictions":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"restrictions\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "allowForcePushes":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"allowForcePushes\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "allowDeletions":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"allowDeletions\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.branchprotection\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.branchprotection with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubBranchprotection) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("requiredStatusChecks"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"requiredStatusChecks\". This field is required.")
	}
	if _, ok := s.Cache.Load("requiredPullRequestReviews"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"requiredPullRequestReviews\". This field is required.")
	}
	if _, ok := s.Cache.Load("requiredConversationResolution"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"requiredConversationResolution\". This field is required.")
	}
	if _, ok := s.Cache.Load("requiredSignatures"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"requiredSignatures\". This field is required.")
	}
	if _, ok := s.Cache.Load("requireLinearHistory"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"requireLinearHistory\". This field is required.")
	}
	if _, ok := s.Cache.Load("enforceAdmins"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"enforceAdmins\". This field is required.")
	}
	if _, ok := s.Cache.Load("restrictions"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"restrictions\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowForcePushes"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"allowForcePushes\". This field is required.")
	}
	if _, ok := s.Cache.Load("allowDeletions"); !ok {
		return errors.New("Initialized \"github.branchprotection\" resource without a \"allowDeletions\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubBranchprotection) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.branchprotection].Register")
	switch name {
	case "id":
		return nil
	case "requiredStatusChecks":
		return nil
	case "requiredPullRequestReviews":
		return nil
	case "requiredConversationResolution":
		return nil
	case "requiredSignatures":
		return nil
	case "requireLinearHistory":
		return nil
	case "enforceAdmins":
		return nil
	case "restrictions":
		return nil
	case "allowForcePushes":
		return nil
	case "allowDeletions":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.branchprotection\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubBranchprotection) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.branchprotection].Field")
	switch name {
	case "id":
		return s.Id()
	case "requiredStatusChecks":
		return s.RequiredStatusChecks()
	case "requiredPullRequestReviews":
		return s.RequiredPullRequestReviews()
	case "requiredConversationResolution":
		return s.RequiredConversationResolution()
	case "requiredSignatures":
		return s.RequiredSignatures()
	case "requireLinearHistory":
		return s.RequireLinearHistory()
	case "enforceAdmins":
		return s.EnforceAdmins()
	case "restrictions":
		return s.Restrictions()
	case "allowForcePushes":
		return s.AllowForcePushes()
	case "allowDeletions":
		return s.AllowDeletions()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.branchprotection\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubBranchprotection) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"github.branchprotection\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.branchprotection\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RequiredStatusChecks accessor autogenerated
func (s *mqlGithubBranchprotection) RequiredStatusChecks() (interface{}, error) {
	res, ok := s.Cache.Load("requiredStatusChecks")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"requiredStatusChecks\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"requiredStatusChecks\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// RequiredPullRequestReviews accessor autogenerated
func (s *mqlGithubBranchprotection) RequiredPullRequestReviews() (interface{}, error) {
	res, ok := s.Cache.Load("requiredPullRequestReviews")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"requiredPullRequestReviews\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"requiredPullRequestReviews\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// RequiredConversationResolution accessor autogenerated
func (s *mqlGithubBranchprotection) RequiredConversationResolution() (interface{}, error) {
	res, ok := s.Cache.Load("requiredConversationResolution")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"requiredConversationResolution\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"requiredConversationResolution\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// RequiredSignatures accessor autogenerated
func (s *mqlGithubBranchprotection) RequiredSignatures() (bool, error) {
	res, ok := s.Cache.Load("requiredSignatures")
	if !ok || !res.Valid {
		return false, errors.New("\"github.branchprotection\" failed: no value provided for static field \"requiredSignatures\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"github.branchprotection\" failed to cast field \"requiredSignatures\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// RequireLinearHistory accessor autogenerated
func (s *mqlGithubBranchprotection) RequireLinearHistory() (interface{}, error) {
	res, ok := s.Cache.Load("requireLinearHistory")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"requireLinearHistory\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"requireLinearHistory\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// EnforceAdmins accessor autogenerated
func (s *mqlGithubBranchprotection) EnforceAdmins() (interface{}, error) {
	res, ok := s.Cache.Load("enforceAdmins")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"enforceAdmins\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"enforceAdmins\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Restrictions accessor autogenerated
func (s *mqlGithubBranchprotection) Restrictions() (interface{}, error) {
	res, ok := s.Cache.Load("restrictions")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"restrictions\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"restrictions\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AllowForcePushes accessor autogenerated
func (s *mqlGithubBranchprotection) AllowForcePushes() (interface{}, error) {
	res, ok := s.Cache.Load("allowForcePushes")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"allowForcePushes\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"allowForcePushes\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// AllowDeletions accessor autogenerated
func (s *mqlGithubBranchprotection) AllowDeletions() (interface{}, error) {
	res, ok := s.Cache.Load("allowDeletions")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.branchprotection\" failed: no value provided for static field \"allowDeletions\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.branchprotection\" failed to cast field \"allowDeletions\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubBranchprotection) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.branchprotection].MqlCompute")
	switch name {
	case "id":
		return nil
	case "requiredStatusChecks":
		return nil
	case "requiredPullRequestReviews":
		return nil
	case "requiredConversationResolution":
		return nil
	case "requiredSignatures":
		return nil
	case "requireLinearHistory":
		return nil
	case "enforceAdmins":
		return nil
	case "restrictions":
		return nil
	case "allowForcePushes":
		return nil
	case "allowDeletions":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.branchprotection\" resource")
	}
}

// GithubCommit resource interface
type GithubCommit interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Owner() (string, error)
	Repository() (string, error)
	Sha() (string, error)
	Url() (string, error)
	Author() (GithubUser, error)
	Committer() (GithubUser, error)
	Commit() (GitCommit, error)
	Stats() (interface{}, error)
}

// mqlGithubCommit for the github.commit resource
type mqlGithubCommit struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubCommit) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.commit resource
func newGithubCommit(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubCommit{runtime.NewResource("github.commit")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "owner":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"owner\" argument has the wrong type (expected type \"string\")")
			}
		case "repository":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"repository\" argument has the wrong type (expected type \"string\")")
			}
		case "sha":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"sha\" argument has the wrong type (expected type \"string\")")
			}
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "author":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"author\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "committer":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"committer\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "commit":
			if _, ok := val.(GitCommit); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"commit\" argument has the wrong type (expected type \"GitCommit\")")
			}
		case "stats":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"stats\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.commit\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.commit with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubCommit) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("owner"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"owner\". This field is required.")
	}
	if _, ok := s.Cache.Load("repository"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"repository\". This field is required.")
	}
	if _, ok := s.Cache.Load("sha"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"sha\". This field is required.")
	}
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("author"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"author\". This field is required.")
	}
	if _, ok := s.Cache.Load("committer"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"committer\". This field is required.")
	}
	if _, ok := s.Cache.Load("commit"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"commit\". This field is required.")
	}
	if _, ok := s.Cache.Load("stats"); !ok {
		return errors.New("Initialized \"github.commit\" resource without a \"stats\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubCommit) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.commit].Register")
	switch name {
	case "owner":
		return nil
	case "repository":
		return nil
	case "sha":
		return nil
	case "url":
		return nil
	case "author":
		return nil
	case "committer":
		return nil
	case "commit":
		return nil
	case "stats":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.commit\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubCommit) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.commit].Field")
	switch name {
	case "owner":
		return s.Owner()
	case "repository":
		return s.Repository()
	case "sha":
		return s.Sha()
	case "url":
		return s.Url()
	case "author":
		return s.Author()
	case "committer":
		return s.Committer()
	case "commit":
		return s.Commit()
	case "stats":
		return s.Stats()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.commit\" resource")
	}
}

// Owner accessor autogenerated
func (s *mqlGithubCommit) Owner() (string, error) {
	res, ok := s.Cache.Load("owner")
	if !ok || !res.Valid {
		return "", errors.New("\"github.commit\" failed: no value provided for static field \"owner\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.commit\" failed to cast field \"owner\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Repository accessor autogenerated
func (s *mqlGithubCommit) Repository() (string, error) {
	res, ok := s.Cache.Load("repository")
	if !ok || !res.Valid {
		return "", errors.New("\"github.commit\" failed: no value provided for static field \"repository\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.commit\" failed to cast field \"repository\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sha accessor autogenerated
func (s *mqlGithubCommit) Sha() (string, error) {
	res, ok := s.Cache.Load("sha")
	if !ok || !res.Valid {
		return "", errors.New("\"github.commit\" failed: no value provided for static field \"sha\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.commit\" failed to cast field \"sha\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlGithubCommit) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"github.commit\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.commit\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Author accessor autogenerated
func (s *mqlGithubCommit) Author() (GithubUser, error) {
	res, ok := s.Cache.Load("author")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.commit\" failed: no value provided for static field \"author\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.commit\" failed to cast field \"author\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Committer accessor autogenerated
func (s *mqlGithubCommit) Committer() (GithubUser, error) {
	res, ok := s.Cache.Load("committer")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.commit\" failed: no value provided for static field \"committer\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.commit\" failed to cast field \"committer\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Commit accessor autogenerated
func (s *mqlGithubCommit) Commit() (GitCommit, error) {
	res, ok := s.Cache.Load("commit")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.commit\" failed: no value provided for static field \"commit\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GitCommit)
	if !ok {
		return nil, fmt.Errorf("\"github.commit\" failed to cast field \"commit\" to the right type (GitCommit): %#v", res)
	}
	return tres, nil
}

// Stats accessor autogenerated
func (s *mqlGithubCommit) Stats() (interface{}, error) {
	res, ok := s.Cache.Load("stats")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.commit\" failed: no value provided for static field \"stats\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.commit\" failed to cast field \"stats\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubCommit) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.commit].MqlCompute")
	switch name {
	case "owner":
		return nil
	case "repository":
		return nil
	case "sha":
		return nil
	case "url":
		return nil
	case "author":
		return nil
	case "committer":
		return nil
	case "commit":
		return nil
	case "stats":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.commit\" resource")
	}
}

// GithubMergeRequest resource interface
type GithubMergeRequest interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	Number() (int64, error)
	State() (string, error)
	CreatedAt() (*time.Time, error)
	Labels() ([]interface{}, error)
	Title() (string, error)
	Owner() (GithubUser, error)
	Assignees() ([]interface{}, error)
	Commits() ([]interface{}, error)
	Reviews() ([]interface{}, error)
	OrganizationName() (string, error)
	RepoName() (string, error)
}

// mqlGithubMergeRequest for the github.mergeRequest resource
type mqlGithubMergeRequest struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubMergeRequest) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.mergeRequest resource
func newGithubMergeRequest(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubMergeRequest{runtime.NewResource("github.mergeRequest")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "number":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"number\" argument has the wrong type (expected type \"int64\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "labels":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"labels\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "title":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"title\" argument has the wrong type (expected type \"string\")")
			}
		case "owner":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"owner\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "assignees":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"assignees\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "commits":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"commits\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "reviews":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"reviews\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "organizationName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"organizationName\" argument has the wrong type (expected type \"string\")")
			}
		case "repoName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"repoName\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.mergeRequest\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.mergeRequest with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubMergeRequest) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("number"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"number\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"labels\". This field is required.")
	}
	if _, ok := s.Cache.Load("title"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"title\". This field is required.")
	}
	if _, ok := s.Cache.Load("owner"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"owner\". This field is required.")
	}
	if _, ok := s.Cache.Load("assignees"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"assignees\". This field is required.")
	}
	if _, ok := s.Cache.Load("organizationName"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"organizationName\". This field is required.")
	}
	if _, ok := s.Cache.Load("repoName"); !ok {
		return errors.New("Initialized \"github.mergeRequest\" resource without a \"repoName\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubMergeRequest) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.mergeRequest].Register")
	switch name {
	case "id":
		return nil
	case "number":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "labels":
		return nil
	case "title":
		return nil
	case "owner":
		return nil
	case "assignees":
		return nil
	case "commits":
		return nil
	case "reviews":
		return nil
	case "organizationName":
		return nil
	case "repoName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.mergeRequest\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubMergeRequest) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.mergeRequest].Field")
	switch name {
	case "id":
		return s.Id()
	case "number":
		return s.Number()
	case "state":
		return s.State()
	case "createdAt":
		return s.CreatedAt()
	case "labels":
		return s.Labels()
	case "title":
		return s.Title()
	case "owner":
		return s.Owner()
	case "assignees":
		return s.Assignees()
	case "commits":
		return s.Commits()
	case "reviews":
		return s.Reviews()
	case "organizationName":
		return s.OrganizationName()
	case "repoName":
		return s.RepoName()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.mergeRequest\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubMergeRequest) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Number accessor autogenerated
func (s *mqlGithubMergeRequest) Number() (int64, error) {
	res, ok := s.Cache.Load("number")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"number\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"number\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlGithubMergeRequest) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"github.mergeRequest\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.mergeRequest\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubMergeRequest) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlGithubMergeRequest) Labels() ([]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"labels\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Title accessor autogenerated
func (s *mqlGithubMergeRequest) Title() (string, error) {
	res, ok := s.Cache.Load("title")
	if !ok || !res.Valid {
		return "", errors.New("\"github.mergeRequest\" failed: no value provided for static field \"title\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.mergeRequest\" failed to cast field \"title\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Owner accessor autogenerated
func (s *mqlGithubMergeRequest) Owner() (GithubUser, error) {
	res, ok := s.Cache.Load("owner")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"owner\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"owner\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Assignees accessor autogenerated
func (s *mqlGithubMergeRequest) Assignees() ([]interface{}, error) {
	res, ok := s.Cache.Load("assignees")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.mergeRequest\" failed: no value provided for static field \"assignees\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"assignees\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Commits accessor autogenerated
func (s *mqlGithubMergeRequest) Commits() ([]interface{}, error) {
	res, ok := s.Cache.Load("commits")
	if !ok || !res.Valid {
		if err := s.ComputeCommits(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("commits")
		if !ok {
			return nil, errors.New("\"github.mergeRequest\" calculated \"commits\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "commits")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"commits\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Reviews accessor autogenerated
func (s *mqlGithubMergeRequest) Reviews() ([]interface{}, error) {
	res, ok := s.Cache.Load("reviews")
	if !ok || !res.Valid {
		if err := s.ComputeReviews(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("reviews")
		if !ok {
			return nil, errors.New("\"github.mergeRequest\" calculated \"reviews\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "reviews")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"github.mergeRequest\" failed to cast field \"reviews\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// OrganizationName accessor autogenerated
func (s *mqlGithubMergeRequest) OrganizationName() (string, error) {
	res, ok := s.Cache.Load("organizationName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.mergeRequest\" failed: no value provided for static field \"organizationName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.mergeRequest\" failed to cast field \"organizationName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RepoName accessor autogenerated
func (s *mqlGithubMergeRequest) RepoName() (string, error) {
	res, ok := s.Cache.Load("repoName")
	if !ok || !res.Valid {
		return "", errors.New("\"github.mergeRequest\" failed: no value provided for static field \"repoName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.mergeRequest\" failed to cast field \"repoName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubMergeRequest) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.mergeRequest].MqlCompute")
	switch name {
	case "id":
		return nil
	case "number":
		return nil
	case "state":
		return nil
	case "createdAt":
		return nil
	case "labels":
		return nil
	case "title":
		return nil
	case "owner":
		return nil
	case "assignees":
		return nil
	case "commits":
		return s.ComputeCommits()
	case "reviews":
		return s.ComputeReviews()
	case "organizationName":
		return nil
	case "repoName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.mergeRequest\" resource")
	}
}

// ComputeCommits computer autogenerated
func (s *mqlGithubMergeRequest) ComputeCommits() error {
	var err error
	if _, ok := s.Cache.Load("commits"); ok {
		return nil
	}
	vres, err := s.GetCommits()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("commits", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeReviews computer autogenerated
func (s *mqlGithubMergeRequest) ComputeReviews() error {
	var err error
	if _, ok := s.Cache.Load("reviews"); ok {
		return nil
	}
	vres, err := s.GetReviews()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("reviews", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// GithubReview resource interface
type GithubReview interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Url() (string, error)
	State() (string, error)
	AuthorAssociation() (string, error)
	User() (GithubUser, error)
}

// mqlGithubReview for the github.review resource
type mqlGithubReview struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubReview) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.review resource
func newGithubReview(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubReview{runtime.NewResource("github.review")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "url":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.review\", its \"url\" argument has the wrong type (expected type \"string\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.review\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "authorAssociation":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.review\", its \"authorAssociation\" argument has the wrong type (expected type \"string\")")
			}
		case "user":
			if _, ok := val.(GithubUser); !ok {
				return nil, errors.New("Failed to initialize \"github.review\", its \"user\" argument has the wrong type (expected type \"GithubUser\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.review\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.review with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubReview) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("url"); !ok {
		return errors.New("Initialized \"github.review\" resource without a \"url\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"github.review\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("authorAssociation"); !ok {
		return errors.New("Initialized \"github.review\" resource without a \"authorAssociation\". This field is required.")
	}
	if _, ok := s.Cache.Load("user"); !ok {
		return errors.New("Initialized \"github.review\" resource without a \"user\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubReview) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.review].Register")
	switch name {
	case "url":
		return nil
	case "state":
		return nil
	case "authorAssociation":
		return nil
	case "user":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.review\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubReview) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.review].Field")
	switch name {
	case "url":
		return s.Url()
	case "state":
		return s.State()
	case "authorAssociation":
		return s.AuthorAssociation()
	case "user":
		return s.User()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.review\" resource")
	}
}

// Url accessor autogenerated
func (s *mqlGithubReview) Url() (string, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		return "", errors.New("\"github.review\" failed: no value provided for static field \"url\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.review\" failed to cast field \"url\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlGithubReview) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"github.review\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.review\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AuthorAssociation accessor autogenerated
func (s *mqlGithubReview) AuthorAssociation() (string, error) {
	res, ok := s.Cache.Load("authorAssociation")
	if !ok || !res.Valid {
		return "", errors.New("\"github.review\" failed: no value provided for static field \"authorAssociation\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.review\" failed to cast field \"authorAssociation\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// User accessor autogenerated
func (s *mqlGithubReview) User() (GithubUser, error) {
	res, ok := s.Cache.Load("user")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.review\" failed: no value provided for static field \"user\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(GithubUser)
	if !ok {
		return nil, fmt.Errorf("\"github.review\" failed to cast field \"user\" to the right type (GithubUser): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubReview) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.review].MqlCompute")
	switch name {
	case "url":
		return nil
	case "state":
		return nil
	case "authorAssociation":
		return nil
	case "user":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.review\" resource")
	}
}

// GithubInstallation resource interface
type GithubInstallation interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (int64, error)
	AppId() (int64, error)
	AppSlug() (string, error)
	CreatedAt() (*time.Time, error)
	UpdatedAt() (*time.Time, error)
}

// mqlGithubInstallation for the github.installation resource
type mqlGithubInstallation struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGithubInstallation) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the github.installation resource
func newGithubInstallation(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGithubInstallation{runtime.NewResource("github.installation")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"id\" argument has the wrong type (expected type \"int64\")")
			}
		case "appId":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"appId\" argument has the wrong type (expected type \"int64\")")
			}
		case "appSlug":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"appSlug\" argument has the wrong type (expected type \"string\")")
			}
		case "createdAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"createdAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "updatedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"updatedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"github.installation\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized github.installation with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGithubInstallation) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"github.installation\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("appId"); !ok {
		return errors.New("Initialized \"github.installation\" resource without a \"appId\". This field is required.")
	}
	if _, ok := s.Cache.Load("appSlug"); !ok {
		return errors.New("Initialized \"github.installation\" resource without a \"appSlug\". This field is required.")
	}
	if _, ok := s.Cache.Load("createdAt"); !ok {
		return errors.New("Initialized \"github.installation\" resource without a \"createdAt\". This field is required.")
	}
	if _, ok := s.Cache.Load("updatedAt"); !ok {
		return errors.New("Initialized \"github.installation\" resource without a \"updatedAt\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGithubInstallation) Register(name string) error {
	log.Trace().Str("field", name).Msg("[github.installation].Register")
	switch name {
	case "id":
		return nil
	case "appId":
		return nil
	case "appSlug":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.installation\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGithubInstallation) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[github.installation].Field")
	switch name {
	case "id":
		return s.Id()
	case "appId":
		return s.AppId()
	case "appSlug":
		return s.AppSlug()
	case "createdAt":
		return s.CreatedAt()
	case "updatedAt":
		return s.UpdatedAt()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"github.installation\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlGithubInstallation) Id() (int64, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.installation\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.installation\" failed to cast field \"id\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AppId accessor autogenerated
func (s *mqlGithubInstallation) AppId() (int64, error) {
	res, ok := s.Cache.Load("appId")
	if !ok || !res.Valid {
		return 0, errors.New("\"github.installation\" failed: no value provided for static field \"appId\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"github.installation\" failed to cast field \"appId\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// AppSlug accessor autogenerated
func (s *mqlGithubInstallation) AppSlug() (string, error) {
	res, ok := s.Cache.Load("appSlug")
	if !ok || !res.Valid {
		return "", errors.New("\"github.installation\" failed: no value provided for static field \"appSlug\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"github.installation\" failed to cast field \"appSlug\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreatedAt accessor autogenerated
func (s *mqlGithubInstallation) CreatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("createdAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.installation\" failed: no value provided for static field \"createdAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.installation\" failed to cast field \"createdAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// UpdatedAt accessor autogenerated
func (s *mqlGithubInstallation) UpdatedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("updatedAt")
	if !ok || !res.Valid {
		return nil, errors.New("\"github.installation\" failed: no value provided for static field \"updatedAt\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"github.installation\" failed to cast field \"updatedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGithubInstallation) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[github.installation].MqlCompute")
	switch name {
	case "id":
		return nil
	case "appId":
		return nil
	case "appSlug":
		return nil
	case "createdAt":
		return nil
	case "updatedAt":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"github.installation\" resource")
	}
}

