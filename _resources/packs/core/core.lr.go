// Code generated by resources. DO NOT EDIT.
package core

import (
	"errors"
	"fmt"
	"time"

	"go.mondoo.com/cnquery/resources"
	"github.com/rs/zerolog/log"
)

// Init all resources into the registry
func Init(registry *resources.Registry) {
	registry.AddFactory("mondoo", newMondoo)
	registry.AddFactory("mondoo.eol", newMondooEol)
	registry.AddFactory("mondoo.asset", newMondooAsset)
	registry.AddFactory("asset", newAsset)
	registry.AddFactory("file", newFile)
	registry.AddFactory("file.permissions", newFilePermissions)
	registry.AddFactory("user", newUser)
	registry.AddFactory("users", newUsers)
	registry.AddFactory("authorizedkeys", newAuthorizedkeys)
	registry.AddFactory("authorizedkeys.entry", newAuthorizedkeysEntry)
	registry.AddFactory("group", newGroup)
	registry.AddFactory("groups", newGroups)
	registry.AddFactory("parse", newParse)
	registry.AddFactory("time", newTime)
	registry.AddFactory("regex", newRegex)
	registry.AddFactory("parse.ini", newParseIni)
	registry.AddFactory("parse.json", newParseJson)
	registry.AddFactory("parse.plist", newParsePlist)
	registry.AddFactory("parse.yaml", newParseYaml)
	registry.AddFactory("platform", newPlatform)
	registry.AddFactory("platform.virtualization", newPlatformVirtualization)
	registry.AddFactory("platform.eol", newPlatformEol)
	registry.AddFactory("platform.advisories", newPlatformAdvisories)
	registry.AddFactory("platform.cves", newPlatformCves)
	registry.AddFactory("audit.cvss", newAuditCvss)
	registry.AddFactory("audit.advisory", newAuditAdvisory)
	registry.AddFactory("audit.cve", newAuditCve)
	registry.AddFactory("process", newProcess)
	registry.AddFactory("processes", newProcesses)
	registry.AddFactory("port", newPort)
	registry.AddFactory("ports", newPorts)
	registry.AddFactory("socket", newSocket)
	registry.AddFactory("tls", newTls)
	registry.AddFactory("domainName", newDomainName)
	registry.AddFactory("dns", newDns)
	registry.AddFactory("dns.record", newDnsRecord)
	registry.AddFactory("dns.mxRecord", newDnsMxRecord)
	registry.AddFactory("dns.dkimRecord", newDnsDkimRecord)
	registry.AddFactory("yaml.path", newYamlPath)
	registry.AddFactory("parse.certificates", newParseCertificates)
	registry.AddFactory("pkix.name", newPkixName)
	registry.AddFactory("pkix.extension", newPkixExtension)
	registry.AddFactory("certificate", newCertificate)
	registry.AddFactory("privatekey", newPrivatekey)
	registry.AddFactory("parse.openpgp", newParseOpenpgp)
	registry.AddFactory("openpgp.entity", newOpenpgpEntity)
	registry.AddFactory("openpgp.publicKey", newOpenpgpPublicKey)
	registry.AddFactory("openpgp.identity", newOpenpgpIdentity)
	registry.AddFactory("openpgp.signature", newOpenpgpSignature)
	registry.AddFactory("uuid", newUuid)
	registry.AddFactory("socketstats", newSocketstats)
	registry.AddFactory("kernel", newKernel)
	registry.AddFactory("kernel.module", newKernelModule)
	registry.AddFactory("package", newPackage)
	registry.AddFactory("packages", newPackages)
}

// Mondoo resource interface
type Mondoo interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Version() (string, error)
	Build() (string, error)
	Resources() ([]interface{}, error)
	JobEnvironment() (interface{}, error)
	Capabilities() ([]interface{}, error)
}

// mqlMondoo for the mondoo resource
type mqlMondoo struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMondoo) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the mondoo resource
func newMondoo(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMondoo{runtime.NewResource("mondoo")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "build":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"build\" argument has the wrong type (expected type \"string\")")
			}
		case "resources":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"resources\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "jobEnvironment":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"jobEnvironment\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "capabilities":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"capabilities\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"mondoo\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized mondoo with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMondoo) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMondoo) Register(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo].Register")
	switch name {
	case "version":
		return nil
	case "build":
		return nil
	case "resources":
		return nil
	case "jobEnvironment":
		return nil
	case "capabilities":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMondoo) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[mondoo].Field")
	switch name {
	case "version":
		return s.Version()
	case "build":
		return s.Build()
	case "resources":
		return s.Resources()
	case "jobEnvironment":
		return s.JobEnvironment()
	case "capabilities":
		return s.Capabilities()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"mondoo\" resource")
	}
}

// Version accessor autogenerated
func (s *mqlMondoo) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		if err := s.ComputeVersion(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("version")
		if !ok {
			return "", errors.New("\"mondoo\" calculated \"version\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "version")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mondoo\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Build accessor autogenerated
func (s *mqlMondoo) Build() (string, error) {
	res, ok := s.Cache.Load("build")
	if !ok || !res.Valid {
		if err := s.ComputeBuild(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("build")
		if !ok {
			return "", errors.New("\"mondoo\" calculated \"build\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "build")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mondoo\" failed to cast field \"build\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Resources accessor autogenerated
func (s *mqlMondoo) Resources() ([]interface{}, error) {
	res, ok := s.Cache.Load("resources")
	if !ok || !res.Valid {
		if err := s.ComputeResources(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("resources")
		if !ok {
			return nil, errors.New("\"mondoo\" calculated \"resources\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "resources")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"mondoo\" failed to cast field \"resources\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// JobEnvironment accessor autogenerated
func (s *mqlMondoo) JobEnvironment() (interface{}, error) {
	res, ok := s.Cache.Load("jobEnvironment")
	if !ok || !res.Valid {
		if err := s.ComputeJobEnvironment(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("jobEnvironment")
		if !ok {
			return nil, errors.New("\"mondoo\" calculated \"jobEnvironment\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "jobEnvironment")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"mondoo\" failed to cast field \"jobEnvironment\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Capabilities accessor autogenerated
func (s *mqlMondoo) Capabilities() ([]interface{}, error) {
	res, ok := s.Cache.Load("capabilities")
	if !ok || !res.Valid {
		if err := s.ComputeCapabilities(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("capabilities")
		if !ok {
			return nil, errors.New("\"mondoo\" calculated \"capabilities\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "capabilities")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"mondoo\" failed to cast field \"capabilities\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMondoo) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo].MqlCompute")
	switch name {
	case "version":
		return s.ComputeVersion()
	case "build":
		return s.ComputeBuild()
	case "resources":
		return s.ComputeResources()
	case "jobEnvironment":
		return s.ComputeJobEnvironment()
	case "capabilities":
		return s.ComputeCapabilities()
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo\" resource")
	}
}

// ComputeVersion computer autogenerated
func (s *mqlMondoo) ComputeVersion() error {
	var err error
	if _, ok := s.Cache.Load("version"); ok {
		return nil
	}
	vres, err := s.GetVersion()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("version", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeBuild computer autogenerated
func (s *mqlMondoo) ComputeBuild() error {
	var err error
	if _, ok := s.Cache.Load("build"); ok {
		return nil
	}
	vres, err := s.GetBuild()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("build", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeResources computer autogenerated
func (s *mqlMondoo) ComputeResources() error {
	var err error
	if _, ok := s.Cache.Load("resources"); ok {
		return nil
	}
	vres, err := s.GetResources()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("resources", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeJobEnvironment computer autogenerated
func (s *mqlMondoo) ComputeJobEnvironment() error {
	var err error
	if _, ok := s.Cache.Load("jobEnvironment"); ok {
		return nil
	}
	vres, err := s.GetJobEnvironment()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("jobEnvironment", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCapabilities computer autogenerated
func (s *mqlMondoo) ComputeCapabilities() error {
	var err error
	if _, ok := s.Cache.Load("capabilities"); ok {
		return nil
	}
	vres, err := s.GetCapabilities()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("capabilities", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MondooEol resource interface
type MondooEol interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Product() (string, error)
	Version() (string, error)
	Date() (*time.Time, error)
}

// mqlMondooEol for the mondoo.eol resource
type mqlMondooEol struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMondooEol) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the mondoo.eol resource
func newMondooEol(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMondooEol{runtime.NewResource("mondoo.eol")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "product":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mondoo.eol\", its \"product\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"mondoo.eol\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "date":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"mondoo.eol\", its \"date\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"mondoo.eol\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized mondoo.eol with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMondooEol) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("product"); !ok {
		return errors.New("Initialized \"mondoo.eol\" resource without a \"product\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"mondoo.eol\" resource without a \"version\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlMondooEol) Register(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo.eol].Register")
	switch name {
	case "product":
		return nil
	case "version":
		return nil
	case "date":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo.eol\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMondooEol) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[mondoo.eol].Field")
	switch name {
	case "product":
		return s.Product()
	case "version":
		return s.Version()
	case "date":
		return s.Date()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"mondoo.eol\" resource")
	}
}

// Product accessor autogenerated
func (s *mqlMondooEol) Product() (string, error) {
	res, ok := s.Cache.Load("product")
	if !ok || !res.Valid {
		return "", errors.New("\"mondoo.eol\" failed: no value provided for static field \"product\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mondoo.eol\" failed to cast field \"product\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlMondooEol) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"mondoo.eol\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"mondoo.eol\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Date accessor autogenerated
func (s *mqlMondooEol) Date() (*time.Time, error) {
	res, ok := s.Cache.Load("date")
	if !ok || !res.Valid {
		if err := s.ComputeDate(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("date")
		if !ok {
			return nil, errors.New("\"mondoo.eol\" calculated \"date\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "date")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"mondoo.eol\" failed to cast field \"date\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMondooEol) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo.eol].MqlCompute")
	switch name {
	case "product":
		return nil
	case "version":
		return nil
	case "date":
		return s.ComputeDate()
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo.eol\" resource")
	}
}

// ComputeDate computer autogenerated
func (s *mqlMondooEol) ComputeDate() error {
	var err error
	if _, ok := s.Cache.Load("date"); ok {
		return nil
	}
	vres, err := s.GetDate()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("date", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// MondooAsset resource interface
type MondooAsset interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	PlatformIDs() ([]interface{}, error)
}

// mqlMondooAsset for the mondoo.asset resource
type mqlMondooAsset struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlMondooAsset) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the mondoo.asset resource
func newMondooAsset(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlMondooAsset{runtime.NewResource("mondoo.asset")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "platformIDs":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"mondoo.asset\", its \"platformIDs\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"mondoo.asset\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized mondoo.asset with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlMondooAsset) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlMondooAsset) Register(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo.asset].Register")
	switch name {
	case "platformIDs":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo.asset\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlMondooAsset) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[mondoo.asset].Field")
	switch name {
	case "platformIDs":
		return s.PlatformIDs()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"mondoo.asset\" resource")
	}
}

// PlatformIDs accessor autogenerated
func (s *mqlMondooAsset) PlatformIDs() ([]interface{}, error) {
	res, ok := s.Cache.Load("platformIDs")
	if !ok || !res.Valid {
		if err := s.ComputePlatformIDs(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("platformIDs")
		if !ok {
			return nil, errors.New("\"mondoo.asset\" calculated \"platformIDs\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "platformIDs")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"mondoo.asset\" failed to cast field \"platformIDs\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlMondooAsset) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[mondoo.asset].MqlCompute")
	switch name {
	case "platformIDs":
		return s.ComputePlatformIDs()
	default:
		return errors.New("Cannot find field '" + name + "' in \"mondoo.asset\" resource")
	}
}

// ComputePlatformIDs computer autogenerated
func (s *mqlMondooAsset) ComputePlatformIDs() error {
	var err error
	if _, ok := s.Cache.Load("platformIDs"); ok {
		return nil
	}
	vres, err := s.GetPlatformIDs()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("platformIDs", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Asset resource interface
type Asset interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Ids() ([]interface{}, error)
	Platform() (string, error)
	Kind() (string, error)
	Runtime() (string, error)
	Version() (string, error)
	Arch() (string, error)
	Title() (string, error)
	Family() ([]interface{}, error)
	Fqdn() (string, error)
	Build() (string, error)
	Labels() (map[string]interface{}, error)
	VulnerabilityReport() (interface{}, error)
}

// mqlAsset for the asset resource
type mqlAsset struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAsset) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the asset resource
func newAsset(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAsset{runtime.NewResource("asset")}
	var existing Asset
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "ids":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"ids\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "platform":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"platform\" argument has the wrong type (expected type \"string\")")
			}
		case "kind":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"kind\" argument has the wrong type (expected type \"string\")")
			}
		case "runtime":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"runtime\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "arch":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"arch\" argument has the wrong type (expected type \"string\")")
			}
		case "title":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"title\" argument has the wrong type (expected type \"string\")")
			}
		case "family":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"family\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "fqdn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"fqdn\" argument has the wrong type (expected type \"string\")")
			}
		case "build":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"build\" argument has the wrong type (expected type \"string\")")
			}
		case "labels":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"labels\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "vulnerabilityReport":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"vulnerabilityReport\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"asset\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized asset with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAsset) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("platform"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"platform\". This field is required.")
	}
	if _, ok := s.Cache.Load("kind"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"kind\". This field is required.")
	}
	if _, ok := s.Cache.Load("runtime"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"runtime\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("arch"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"arch\". This field is required.")
	}
	if _, ok := s.Cache.Load("title"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"title\". This field is required.")
	}
	if _, ok := s.Cache.Load("family"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"family\". This field is required.")
	}
	if _, ok := s.Cache.Load("fqdn"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"fqdn\". This field is required.")
	}
	if _, ok := s.Cache.Load("build"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"build\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"asset\" resource without a \"labels\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAsset) Register(name string) error {
	log.Trace().Str("field", name).Msg("[asset].Register")
	switch name {
	case "name":
		return nil
	case "ids":
		return nil
	case "platform":
		return nil
	case "kind":
		return nil
	case "runtime":
		return nil
	case "version":
		return nil
	case "arch":
		return nil
	case "title":
		return nil
	case "family":
		return nil
	case "fqdn":
		return nil
	case "build":
		return nil
	case "labels":
		return nil
	case "vulnerabilityReport":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"asset\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAsset) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[asset].Field")
	switch name {
	case "name":
		return s.Name()
	case "ids":
		return s.Ids()
	case "platform":
		return s.Platform()
	case "kind":
		return s.Kind()
	case "runtime":
		return s.Runtime()
	case "version":
		return s.Version()
	case "arch":
		return s.Arch()
	case "title":
		return s.Title()
	case "family":
		return s.Family()
	case "fqdn":
		return s.Fqdn()
	case "build":
		return s.Build()
	case "labels":
		return s.Labels()
	case "vulnerabilityReport":
		return s.VulnerabilityReport()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"asset\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlAsset) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Ids accessor autogenerated
func (s *mqlAsset) Ids() ([]interface{}, error) {
	res, ok := s.Cache.Load("ids")
	if !ok || !res.Valid {
		if err := s.ComputeIds(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("ids")
		if !ok {
			return nil, errors.New("\"asset\" calculated \"ids\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "ids")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"asset\" failed to cast field \"ids\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Platform accessor autogenerated
func (s *mqlAsset) Platform() (string, error) {
	res, ok := s.Cache.Load("platform")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"platform\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"platform\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Kind accessor autogenerated
func (s *mqlAsset) Kind() (string, error) {
	res, ok := s.Cache.Load("kind")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"kind\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"kind\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Runtime accessor autogenerated
func (s *mqlAsset) Runtime() (string, error) {
	res, ok := s.Cache.Load("runtime")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"runtime\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"runtime\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlAsset) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Arch accessor autogenerated
func (s *mqlAsset) Arch() (string, error) {
	res, ok := s.Cache.Load("arch")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"arch\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"arch\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Title accessor autogenerated
func (s *mqlAsset) Title() (string, error) {
	res, ok := s.Cache.Load("title")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"title\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"title\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Family accessor autogenerated
func (s *mqlAsset) Family() ([]interface{}, error) {
	res, ok := s.Cache.Load("family")
	if !ok || !res.Valid {
		return nil, errors.New("\"asset\" failed: no value provided for static field \"family\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"asset\" failed to cast field \"family\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Fqdn accessor autogenerated
func (s *mqlAsset) Fqdn() (string, error) {
	res, ok := s.Cache.Load("fqdn")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"fqdn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"fqdn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Build accessor autogenerated
func (s *mqlAsset) Build() (string, error) {
	res, ok := s.Cache.Load("build")
	if !ok || !res.Valid {
		return "", errors.New("\"asset\" failed: no value provided for static field \"build\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"asset\" failed to cast field \"build\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlAsset) Labels() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"asset\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"asset\" failed to cast field \"labels\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// VulnerabilityReport accessor autogenerated
func (s *mqlAsset) VulnerabilityReport() (interface{}, error) {
	res, ok := s.Cache.Load("vulnerabilityReport")
	if !ok || !res.Valid {
		if err := s.ComputeVulnerabilityReport(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("vulnerabilityReport")
		if !ok {
			return nil, errors.New("\"asset\" calculated \"vulnerabilityReport\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "vulnerabilityReport")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"asset\" failed to cast field \"vulnerabilityReport\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAsset) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[asset].MqlCompute")
	switch name {
	case "name":
		return nil
	case "ids":
		return s.ComputeIds()
	case "platform":
		return nil
	case "kind":
		return nil
	case "runtime":
		return nil
	case "version":
		return nil
	case "arch":
		return nil
	case "title":
		return nil
	case "family":
		return nil
	case "fqdn":
		return nil
	case "build":
		return nil
	case "labels":
		return nil
	case "vulnerabilityReport":
		return s.ComputeVulnerabilityReport()
	default:
		return errors.New("Cannot find field '" + name + "' in \"asset\" resource")
	}
}

// ComputeIds computer autogenerated
func (s *mqlAsset) ComputeIds() error {
	var err error
	if _, ok := s.Cache.Load("ids"); ok {
		return nil
	}
	vres, err := s.GetIds()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ids", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVulnerabilityReport computer autogenerated
func (s *mqlAsset) ComputeVulnerabilityReport() error {
	var err error
	if _, ok := s.Cache.Load("vulnerabilityReport"); ok {
		return nil
	}
	vres, err := s.GetVulnerabilityReport()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("vulnerabilityReport", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// File resource interface
type File interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	Basename() (string, error)
	Dirname() (string, error)
	Content() (string, error)
	Exists() (bool, error)
	Permissions() (FilePermissions, error)
	Size() (int64, error)
	User() (User, error)
	Group() (Group, error)
	Empty() (bool, error)
}

// mqlFile for the file resource
type mqlFile struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlFile) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the file resource
func newFile(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlFile{runtime.NewResource("file")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "basename":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"basename\" argument has the wrong type (expected type \"string\")")
			}
		case "dirname":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"dirname\" argument has the wrong type (expected type \"string\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "exists":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"exists\" argument has the wrong type (expected type \"bool\")")
			}
		case "permissions":
			if _, ok := val.(FilePermissions); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"permissions\" argument has the wrong type (expected type \"FilePermissions\")")
			}
		case "size":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"size\" argument has the wrong type (expected type \"int64\")")
			}
		case "user":
			if _, ok := val.(User); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"user\" argument has the wrong type (expected type \"User\")")
			}
		case "group":
			if _, ok := val.(Group); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"group\" argument has the wrong type (expected type \"Group\")")
			}
		case "empty":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"empty\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"file\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized file with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlFile) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"file\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlFile) Register(name string) error {
	log.Trace().Str("field", name).Msg("[file].Register")
	switch name {
	case "path":
		return nil
	case "basename":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "path", s, "basename"); err != nil {
			return err
		}
		return nil
	case "dirname":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "path", s, "dirname"); err != nil {
			return err
		}
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "path", s, "content"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "exists", s, "content"); err != nil {
			return err
		}
		return nil
	case "exists":
		return nil
	case "permissions":
		return nil
	case "size":
		return nil
	case "user":
		return nil
	case "group":
		return nil
	case "empty":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"file\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlFile) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[file].Field")
	switch name {
	case "path":
		return s.Path()
	case "basename":
		return s.Basename()
	case "dirname":
		return s.Dirname()
	case "content":
		return s.Content()
	case "exists":
		return s.Exists()
	case "permissions":
		return s.Permissions()
	case "size":
		return s.Size()
	case "user":
		return s.User()
	case "group":
		return s.Group()
	case "empty":
		return s.Empty()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"file\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlFile) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"file\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"file\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Basename accessor autogenerated
func (s *mqlFile) Basename() (string, error) {
	res, ok := s.Cache.Load("basename")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"file\" failed to cast field \"basename\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Dirname accessor autogenerated
func (s *mqlFile) Dirname() (string, error) {
	res, ok := s.Cache.Load("dirname")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"file\" failed to cast field \"dirname\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlFile) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"file\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Exists accessor autogenerated
func (s *mqlFile) Exists() (bool, error) {
	res, ok := s.Cache.Load("exists")
	if !ok || !res.Valid {
		if err := s.ComputeExists(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("exists")
		if !ok {
			return false, errors.New("\"file\" calculated \"exists\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "exists")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file\" failed to cast field \"exists\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Permissions accessor autogenerated
func (s *mqlFile) Permissions() (FilePermissions, error) {
	res, ok := s.Cache.Load("permissions")
	if !ok || !res.Valid {
		if err := s.ComputePermissions(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("permissions")
		if !ok {
			return nil, errors.New("\"file\" calculated \"permissions\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "permissions")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(FilePermissions)
	if !ok {
		return nil, fmt.Errorf("\"file\" failed to cast field \"permissions\" to the right type (FilePermissions): %#v", res)
	}
	return tres, nil
}

// Size accessor autogenerated
func (s *mqlFile) Size() (int64, error) {
	res, ok := s.Cache.Load("size")
	if !ok || !res.Valid {
		if err := s.ComputeSize(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("size")
		if !ok {
			return 0, errors.New("\"file\" calculated \"size\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "size")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"file\" failed to cast field \"size\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// User accessor autogenerated
func (s *mqlFile) User() (User, error) {
	res, ok := s.Cache.Load("user")
	if !ok || !res.Valid {
		if err := s.ComputeUser(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("user")
		if !ok {
			return nil, errors.New("\"file\" calculated \"user\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "user")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(User)
	if !ok {
		return nil, fmt.Errorf("\"file\" failed to cast field \"user\" to the right type (User): %#v", res)
	}
	return tres, nil
}

// Group accessor autogenerated
func (s *mqlFile) Group() (Group, error) {
	res, ok := s.Cache.Load("group")
	if !ok || !res.Valid {
		if err := s.ComputeGroup(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("group")
		if !ok {
			return nil, errors.New("\"file\" calculated \"group\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "group")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Group)
	if !ok {
		return nil, fmt.Errorf("\"file\" failed to cast field \"group\" to the right type (Group): %#v", res)
	}
	return tres, nil
}

// Empty accessor autogenerated
func (s *mqlFile) Empty() (bool, error) {
	res, ok := s.Cache.Load("empty")
	if !ok || !res.Valid {
		if err := s.ComputeEmpty(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("empty")
		if !ok {
			return false, errors.New("\"file\" calculated \"empty\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "empty")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file\" failed to cast field \"empty\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlFile) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[file].MqlCompute")
	switch name {
	case "path":
		return nil
	case "basename":
		return s.ComputeBasename()
	case "dirname":
		return s.ComputeDirname()
	case "content":
		return s.ComputeContent()
	case "exists":
		return s.ComputeExists()
	case "permissions":
		return s.ComputePermissions()
	case "size":
		return s.ComputeSize()
	case "user":
		return s.ComputeUser()
	case "group":
		return s.ComputeGroup()
	case "empty":
		return s.ComputeEmpty()
	default:
		return errors.New("Cannot find field '" + name + "' in \"file\" resource")
	}
}

// ComputeBasename computer autogenerated
func (s *mqlFile) ComputeBasename() error {
	var err error
	vargPath, err := s.Path()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("basename", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetBasename(vargPath)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("basename", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDirname computer autogenerated
func (s *mqlFile) ComputeDirname() error {
	var err error
	vargPath, err := s.Path()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("dirname", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetDirname(vargPath)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("dirname", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlFile) ComputeContent() error {
	var err error
	vargPath, err := s.Path()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargExists, err := s.Exists()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargPath, vargExists)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExists computer autogenerated
func (s *mqlFile) ComputeExists() error {
	var err error
	if _, ok := s.Cache.Load("exists"); ok {
		return nil
	}
	vres, err := s.GetExists()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("exists", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePermissions computer autogenerated
func (s *mqlFile) ComputePermissions() error {
	var err error
	if _, ok := s.Cache.Load("permissions"); ok {
		return nil
	}
	vres, err := s.GetPermissions()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("permissions", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSize computer autogenerated
func (s *mqlFile) ComputeSize() error {
	var err error
	if _, ok := s.Cache.Load("size"); ok {
		return nil
	}
	vres, err := s.GetSize()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("size", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUser computer autogenerated
func (s *mqlFile) ComputeUser() error {
	var err error
	if _, ok := s.Cache.Load("user"); ok {
		return nil
	}
	vres, err := s.GetUser()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("user", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeGroup computer autogenerated
func (s *mqlFile) ComputeGroup() error {
	var err error
	if _, ok := s.Cache.Load("group"); ok {
		return nil
	}
	vres, err := s.GetGroup()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("group", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEmpty computer autogenerated
func (s *mqlFile) ComputeEmpty() error {
	var err error
	if _, ok := s.Cache.Load("empty"); ok {
		return nil
	}
	vres, err := s.GetEmpty()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("empty", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// FilePermissions resource interface
type FilePermissions interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Mode() (int64, error)
	User_readable() (bool, error)
	User_writeable() (bool, error)
	User_executable() (bool, error)
	Group_readable() (bool, error)
	Group_writeable() (bool, error)
	Group_executable() (bool, error)
	Other_readable() (bool, error)
	Other_writeable() (bool, error)
	Other_executable() (bool, error)
	Suid() (bool, error)
	Sgid() (bool, error)
	Sticky() (bool, error)
	IsDirectory() (bool, error)
	IsFile() (bool, error)
	IsSymlink() (bool, error)
	String() (string, error)
}

// mqlFilePermissions for the file.permissions resource
type mqlFilePermissions struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlFilePermissions) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the file.permissions resource
func newFilePermissions(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlFilePermissions{runtime.NewResource("file.permissions")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "mode":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"mode\" argument has the wrong type (expected type \"int64\")")
			}
		case "user_readable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"user_readable\" argument has the wrong type (expected type \"bool\")")
			}
		case "user_writeable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"user_writeable\" argument has the wrong type (expected type \"bool\")")
			}
		case "user_executable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"user_executable\" argument has the wrong type (expected type \"bool\")")
			}
		case "group_readable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"group_readable\" argument has the wrong type (expected type \"bool\")")
			}
		case "group_writeable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"group_writeable\" argument has the wrong type (expected type \"bool\")")
			}
		case "group_executable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"group_executable\" argument has the wrong type (expected type \"bool\")")
			}
		case "other_readable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"other_readable\" argument has the wrong type (expected type \"bool\")")
			}
		case "other_writeable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"other_writeable\" argument has the wrong type (expected type \"bool\")")
			}
		case "other_executable":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"other_executable\" argument has the wrong type (expected type \"bool\")")
			}
		case "suid":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"suid\" argument has the wrong type (expected type \"bool\")")
			}
		case "sgid":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"sgid\" argument has the wrong type (expected type \"bool\")")
			}
		case "sticky":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"sticky\" argument has the wrong type (expected type \"bool\")")
			}
		case "isDirectory":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"isDirectory\" argument has the wrong type (expected type \"bool\")")
			}
		case "isFile":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"isFile\" argument has the wrong type (expected type \"bool\")")
			}
		case "isSymlink":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"isSymlink\" argument has the wrong type (expected type \"bool\")")
			}
		case "string":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"string\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"file.permissions\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized file.permissions with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlFilePermissions) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("mode"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"mode\". This field is required.")
	}
	if _, ok := s.Cache.Load("user_readable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"user_readable\". This field is required.")
	}
	if _, ok := s.Cache.Load("user_writeable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"user_writeable\". This field is required.")
	}
	if _, ok := s.Cache.Load("user_executable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"user_executable\". This field is required.")
	}
	if _, ok := s.Cache.Load("group_readable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"group_readable\". This field is required.")
	}
	if _, ok := s.Cache.Load("group_writeable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"group_writeable\". This field is required.")
	}
	if _, ok := s.Cache.Load("group_executable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"group_executable\". This field is required.")
	}
	if _, ok := s.Cache.Load("other_readable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"other_readable\". This field is required.")
	}
	if _, ok := s.Cache.Load("other_writeable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"other_writeable\". This field is required.")
	}
	if _, ok := s.Cache.Load("other_executable"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"other_executable\". This field is required.")
	}
	if _, ok := s.Cache.Load("suid"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"suid\". This field is required.")
	}
	if _, ok := s.Cache.Load("sgid"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"sgid\". This field is required.")
	}
	if _, ok := s.Cache.Load("sticky"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"sticky\". This field is required.")
	}
	if _, ok := s.Cache.Load("isDirectory"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"isDirectory\". This field is required.")
	}
	if _, ok := s.Cache.Load("isFile"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"isFile\". This field is required.")
	}
	if _, ok := s.Cache.Load("isSymlink"); !ok {
		return errors.New("Initialized \"file.permissions\" resource without a \"isSymlink\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlFilePermissions) Register(name string) error {
	log.Trace().Str("field", name).Msg("[file.permissions].Register")
	switch name {
	case "mode":
		return nil
	case "user_readable":
		return nil
	case "user_writeable":
		return nil
	case "user_executable":
		return nil
	case "group_readable":
		return nil
	case "group_writeable":
		return nil
	case "group_executable":
		return nil
	case "other_readable":
		return nil
	case "other_writeable":
		return nil
	case "other_executable":
		return nil
	case "suid":
		return nil
	case "sgid":
		return nil
	case "sticky":
		return nil
	case "isDirectory":
		return nil
	case "isFile":
		return nil
	case "isSymlink":
		return nil
	case "string":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"file.permissions\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlFilePermissions) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[file.permissions].Field")
	switch name {
	case "mode":
		return s.Mode()
	case "user_readable":
		return s.User_readable()
	case "user_writeable":
		return s.User_writeable()
	case "user_executable":
		return s.User_executable()
	case "group_readable":
		return s.Group_readable()
	case "group_writeable":
		return s.Group_writeable()
	case "group_executable":
		return s.Group_executable()
	case "other_readable":
		return s.Other_readable()
	case "other_writeable":
		return s.Other_writeable()
	case "other_executable":
		return s.Other_executable()
	case "suid":
		return s.Suid()
	case "sgid":
		return s.Sgid()
	case "sticky":
		return s.Sticky()
	case "isDirectory":
		return s.IsDirectory()
	case "isFile":
		return s.IsFile()
	case "isSymlink":
		return s.IsSymlink()
	case "string":
		return s.String()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"file.permissions\" resource")
	}
}

// Mode accessor autogenerated
func (s *mqlFilePermissions) Mode() (int64, error) {
	res, ok := s.Cache.Load("mode")
	if !ok || !res.Valid {
		return 0, errors.New("\"file.permissions\" failed: no value provided for static field \"mode\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"file.permissions\" failed to cast field \"mode\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// User_readable accessor autogenerated
func (s *mqlFilePermissions) User_readable() (bool, error) {
	res, ok := s.Cache.Load("user_readable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"user_readable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"user_readable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// User_writeable accessor autogenerated
func (s *mqlFilePermissions) User_writeable() (bool, error) {
	res, ok := s.Cache.Load("user_writeable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"user_writeable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"user_writeable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// User_executable accessor autogenerated
func (s *mqlFilePermissions) User_executable() (bool, error) {
	res, ok := s.Cache.Load("user_executable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"user_executable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"user_executable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Group_readable accessor autogenerated
func (s *mqlFilePermissions) Group_readable() (bool, error) {
	res, ok := s.Cache.Load("group_readable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"group_readable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"group_readable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Group_writeable accessor autogenerated
func (s *mqlFilePermissions) Group_writeable() (bool, error) {
	res, ok := s.Cache.Load("group_writeable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"group_writeable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"group_writeable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Group_executable accessor autogenerated
func (s *mqlFilePermissions) Group_executable() (bool, error) {
	res, ok := s.Cache.Load("group_executable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"group_executable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"group_executable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Other_readable accessor autogenerated
func (s *mqlFilePermissions) Other_readable() (bool, error) {
	res, ok := s.Cache.Load("other_readable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"other_readable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"other_readable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Other_writeable accessor autogenerated
func (s *mqlFilePermissions) Other_writeable() (bool, error) {
	res, ok := s.Cache.Load("other_writeable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"other_writeable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"other_writeable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Other_executable accessor autogenerated
func (s *mqlFilePermissions) Other_executable() (bool, error) {
	res, ok := s.Cache.Load("other_executable")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"other_executable\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"other_executable\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Suid accessor autogenerated
func (s *mqlFilePermissions) Suid() (bool, error) {
	res, ok := s.Cache.Load("suid")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"suid\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"suid\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Sgid accessor autogenerated
func (s *mqlFilePermissions) Sgid() (bool, error) {
	res, ok := s.Cache.Load("sgid")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"sgid\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"sgid\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Sticky accessor autogenerated
func (s *mqlFilePermissions) Sticky() (bool, error) {
	res, ok := s.Cache.Load("sticky")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"sticky\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"sticky\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// IsDirectory accessor autogenerated
func (s *mqlFilePermissions) IsDirectory() (bool, error) {
	res, ok := s.Cache.Load("isDirectory")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"isDirectory\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"isDirectory\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// IsFile accessor autogenerated
func (s *mqlFilePermissions) IsFile() (bool, error) {
	res, ok := s.Cache.Load("isFile")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"isFile\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"isFile\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// IsSymlink accessor autogenerated
func (s *mqlFilePermissions) IsSymlink() (bool, error) {
	res, ok := s.Cache.Load("isSymlink")
	if !ok || !res.Valid {
		return false, errors.New("\"file.permissions\" failed: no value provided for static field \"isSymlink\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"file.permissions\" failed to cast field \"isSymlink\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// String accessor autogenerated
func (s *mqlFilePermissions) String() (string, error) {
	res, ok := s.Cache.Load("string")
	if !ok || !res.Valid {
		if err := s.ComputeString(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("string")
		if !ok {
			return "", errors.New("\"file.permissions\" calculated \"string\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "string")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"file.permissions\" failed to cast field \"string\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlFilePermissions) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[file.permissions].MqlCompute")
	switch name {
	case "mode":
		return nil
	case "user_readable":
		return nil
	case "user_writeable":
		return nil
	case "user_executable":
		return nil
	case "group_readable":
		return nil
	case "group_writeable":
		return nil
	case "group_executable":
		return nil
	case "other_readable":
		return nil
	case "other_writeable":
		return nil
	case "other_executable":
		return nil
	case "suid":
		return nil
	case "sgid":
		return nil
	case "sticky":
		return nil
	case "isDirectory":
		return nil
	case "isFile":
		return nil
	case "isSymlink":
		return nil
	case "string":
		return s.ComputeString()
	default:
		return errors.New("Cannot find field '" + name + "' in \"file.permissions\" resource")
	}
}

// ComputeString computer autogenerated
func (s *mqlFilePermissions) ComputeString() error {
	var err error
	if _, ok := s.Cache.Load("string"); ok {
		return nil
	}
	vres, err := s.GetString()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("string", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// User resource interface
type User interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Uid() (int64, error)
	Gid() (int64, error)
	Sid() (string, error)
	Name() (string, error)
	Home() (string, error)
	Shell() (string, error)
	Enabled() (bool, error)
	Authorizedkeys() (Authorizedkeys, error)
	Sshkeys() ([]interface{}, error)
	Group() (Group, error)
}

// mqlUser for the user resource
type mqlUser struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlUser) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the user resource
func newUser(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlUser{runtime.NewResource("user")}
	var existing User
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "uid":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"uid\" argument has the wrong type (expected type \"int64\")")
			}
		case "gid":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"gid\" argument has the wrong type (expected type \"int64\")")
			}
		case "sid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"sid\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "home":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"home\" argument has the wrong type (expected type \"string\")")
			}
		case "shell":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"shell\" argument has the wrong type (expected type \"string\")")
			}
		case "enabled":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"enabled\" argument has the wrong type (expected type \"bool\")")
			}
		case "authorizedkeys":
			if _, ok := val.(Authorizedkeys); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"authorizedkeys\" argument has the wrong type (expected type \"Authorizedkeys\")")
			}
		case "sshkeys":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"sshkeys\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "group":
			if _, ok := val.(Group); !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"group\" argument has the wrong type (expected type \"Group\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"user\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized user with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlUser) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("uid"); !ok {
		return errors.New("Initialized \"user\" resource without a \"uid\". This field is required.")
	}
	if _, ok := s.Cache.Load("gid"); !ok {
		return errors.New("Initialized \"user\" resource without a \"gid\". This field is required.")
	}
	if _, ok := s.Cache.Load("sid"); !ok {
		return errors.New("Initialized \"user\" resource without a \"sid\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"user\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("home"); !ok {
		return errors.New("Initialized \"user\" resource without a \"home\". This field is required.")
	}
	if _, ok := s.Cache.Load("shell"); !ok {
		return errors.New("Initialized \"user\" resource without a \"shell\". This field is required.")
	}
	if _, ok := s.Cache.Load("enabled"); !ok {
		return errors.New("Initialized \"user\" resource without a \"enabled\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlUser) Register(name string) error {
	log.Trace().Str("field", name).Msg("[user].Register")
	switch name {
	case "uid":
		return nil
	case "gid":
		return nil
	case "sid":
		return nil
	case "name":
		return nil
	case "home":
		return nil
	case "shell":
		return nil
	case "enabled":
		return nil
	case "authorizedkeys":
		return nil
	case "sshkeys":
		return nil
	case "group":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"user\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlUser) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[user].Field")
	switch name {
	case "uid":
		return s.Uid()
	case "gid":
		return s.Gid()
	case "sid":
		return s.Sid()
	case "name":
		return s.Name()
	case "home":
		return s.Home()
	case "shell":
		return s.Shell()
	case "enabled":
		return s.Enabled()
	case "authorizedkeys":
		return s.Authorizedkeys()
	case "sshkeys":
		return s.Sshkeys()
	case "group":
		return s.Group()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"user\" resource")
	}
}

// Uid accessor autogenerated
func (s *mqlUser) Uid() (int64, error) {
	res, ok := s.Cache.Load("uid")
	if !ok || !res.Valid {
		return 0, errors.New("\"user\" failed: no value provided for static field \"uid\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"user\" failed to cast field \"uid\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Gid accessor autogenerated
func (s *mqlUser) Gid() (int64, error) {
	res, ok := s.Cache.Load("gid")
	if !ok || !res.Valid {
		return 0, errors.New("\"user\" failed: no value provided for static field \"gid\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"user\" failed to cast field \"gid\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Sid accessor autogenerated
func (s *mqlUser) Sid() (string, error) {
	res, ok := s.Cache.Load("sid")
	if !ok || !res.Valid {
		return "", errors.New("\"user\" failed: no value provided for static field \"sid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"user\" failed to cast field \"sid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlUser) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"user\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"user\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Home accessor autogenerated
func (s *mqlUser) Home() (string, error) {
	res, ok := s.Cache.Load("home")
	if !ok || !res.Valid {
		return "", errors.New("\"user\" failed: no value provided for static field \"home\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"user\" failed to cast field \"home\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Shell accessor autogenerated
func (s *mqlUser) Shell() (string, error) {
	res, ok := s.Cache.Load("shell")
	if !ok || !res.Valid {
		return "", errors.New("\"user\" failed: no value provided for static field \"shell\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"user\" failed to cast field \"shell\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Enabled accessor autogenerated
func (s *mqlUser) Enabled() (bool, error) {
	res, ok := s.Cache.Load("enabled")
	if !ok || !res.Valid {
		return false, errors.New("\"user\" failed: no value provided for static field \"enabled\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"user\" failed to cast field \"enabled\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Authorizedkeys accessor autogenerated
func (s *mqlUser) Authorizedkeys() (Authorizedkeys, error) {
	res, ok := s.Cache.Load("authorizedkeys")
	if !ok || !res.Valid {
		if err := s.ComputeAuthorizedkeys(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("authorizedkeys")
		if !ok {
			return nil, errors.New("\"user\" calculated \"authorizedkeys\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "authorizedkeys")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Authorizedkeys)
	if !ok {
		return nil, fmt.Errorf("\"user\" failed to cast field \"authorizedkeys\" to the right type (Authorizedkeys): %#v", res)
	}
	return tres, nil
}

// Sshkeys accessor autogenerated
func (s *mqlUser) Sshkeys() ([]interface{}, error) {
	res, ok := s.Cache.Load("sshkeys")
	if !ok || !res.Valid {
		if err := s.ComputeSshkeys(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("sshkeys")
		if !ok {
			return nil, errors.New("\"user\" calculated \"sshkeys\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "sshkeys")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"user\" failed to cast field \"sshkeys\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Group accessor autogenerated
func (s *mqlUser) Group() (Group, error) {
	res, ok := s.Cache.Load("group")
	if !ok || !res.Valid {
		if err := s.ComputeGroup(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("group")
		if !ok {
			return nil, errors.New("\"user\" calculated \"group\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "group")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Group)
	if !ok {
		return nil, fmt.Errorf("\"user\" failed to cast field \"group\" to the right type (Group): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlUser) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[user].MqlCompute")
	switch name {
	case "uid":
		return nil
	case "gid":
		return nil
	case "sid":
		return nil
	case "name":
		return nil
	case "home":
		return nil
	case "shell":
		return nil
	case "enabled":
		return nil
	case "authorizedkeys":
		return s.ComputeAuthorizedkeys()
	case "sshkeys":
		return s.ComputeSshkeys()
	case "group":
		return s.ComputeGroup()
	default:
		return errors.New("Cannot find field '" + name + "' in \"user\" resource")
	}
}

// ComputeAuthorizedkeys computer autogenerated
func (s *mqlUser) ComputeAuthorizedkeys() error {
	var err error
	if _, ok := s.Cache.Load("authorizedkeys"); ok {
		return nil
	}
	vres, err := s.GetAuthorizedkeys()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("authorizedkeys", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSshkeys computer autogenerated
func (s *mqlUser) ComputeSshkeys() error {
	var err error
	if _, ok := s.Cache.Load("sshkeys"); ok {
		return nil
	}
	vres, err := s.GetSshkeys()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("sshkeys", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeGroup computer autogenerated
func (s *mqlUser) ComputeGroup() error {
	var err error
	if _, ok := s.Cache.Load("group"); ok {
		return nil
	}
	vres, err := s.GetGroup()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("group", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Users resource interface
type Users interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlUsers for the users resource
type mqlUsers struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlUsers) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the users resource
func newUsers(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlUsers{runtime.NewResource("users")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"users\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"users\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized users with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlUsers) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlUsers) Register(name string) error {
	log.Trace().Str("field", name).Msg("[users].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"users\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlUsers) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[users].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"users\" resource")
	}
}

// List accessor autogenerated
func (s *mqlUsers) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"users\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"users\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlUsers) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[users].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"users\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlUsers) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Authorizedkeys resource interface
type Authorizedkeys interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	File() (File, error)
	Content() (string, error)
	List() ([]interface{}, error)
}

// mqlAuthorizedkeys for the authorizedkeys resource
type mqlAuthorizedkeys struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuthorizedkeys) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the authorizedkeys resource
func newAuthorizedkeys(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuthorizedkeys{runtime.NewResource("authorizedkeys")}
	var existing Authorizedkeys
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized authorizedkeys with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuthorizedkeys) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"authorizedkeys\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuthorizedkeys) Register(name string) error {
	log.Trace().Str("field", name).Msg("[authorizedkeys].Register")
	switch name {
	case "path":
		return nil
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "list":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "list"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "list"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"authorizedkeys\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuthorizedkeys) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[authorizedkeys].Field")
	switch name {
	case "path":
		return s.Path()
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"authorizedkeys\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlAuthorizedkeys) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"authorizedkeys\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"authorizedkeys\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlAuthorizedkeys) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"authorizedkeys\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"authorizedkeys\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlAuthorizedkeys) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"authorizedkeys\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlAuthorizedkeys) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"authorizedkeys\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuthorizedkeys) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[authorizedkeys].MqlCompute")
	switch name {
	case "path":
		return nil
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"authorizedkeys\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlAuthorizedkeys) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlAuthorizedkeys) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlAuthorizedkeys) ComputeList() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetList(vargFile, vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// AuthorizedkeysEntry resource interface
type AuthorizedkeysEntry interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Line() (int64, error)
	Type() (string, error)
	Key() (string, error)
	Label() (string, error)
	Options() ([]interface{}, error)
	File() (File, error)
}

// mqlAuthorizedkeysEntry for the authorizedkeys.entry resource
type mqlAuthorizedkeysEntry struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuthorizedkeysEntry) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the authorizedkeys.entry resource
func newAuthorizedkeysEntry(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuthorizedkeysEntry{runtime.NewResource("authorizedkeys.entry")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "line":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"line\" argument has the wrong type (expected type \"int64\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "key":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"key\" argument has the wrong type (expected type \"string\")")
			}
		case "label":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"label\" argument has the wrong type (expected type \"string\")")
			}
		case "options":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"options\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"authorizedkeys.entry\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized authorizedkeys.entry with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuthorizedkeysEntry) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("line"); !ok {
		return errors.New("Initialized \"authorizedkeys.entry\" resource without a \"line\". This field is required.")
	}
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"authorizedkeys.entry\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("key"); !ok {
		return errors.New("Initialized \"authorizedkeys.entry\" resource without a \"key\". This field is required.")
	}
	if _, ok := s.Cache.Load("file"); !ok {
		return errors.New("Initialized \"authorizedkeys.entry\" resource without a \"file\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Register(name string) error {
	log.Trace().Str("field", name).Msg("[authorizedkeys.entry].Register")
	switch name {
	case "line":
		return nil
	case "type":
		return nil
	case "key":
		return nil
	case "label":
		return nil
	case "options":
		return nil
	case "file":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"authorizedkeys.entry\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[authorizedkeys.entry].Field")
	switch name {
	case "line":
		return s.Line()
	case "type":
		return s.Type()
	case "key":
		return s.Key()
	case "label":
		return s.Label()
	case "options":
		return s.Options()
	case "file":
		return s.File()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"authorizedkeys.entry\" resource")
	}
}

// Line accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Line() (int64, error) {
	res, ok := s.Cache.Load("line")
	if !ok || !res.Valid {
		return 0, errors.New("\"authorizedkeys.entry\" failed: no value provided for static field \"line\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"line\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"authorizedkeys.entry\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Key accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Key() (string, error) {
	res, ok := s.Cache.Load("key")
	if !ok || !res.Valid {
		return "", errors.New("\"authorizedkeys.entry\" failed: no value provided for static field \"key\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"key\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Label accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Label() (string, error) {
	res, ok := s.Cache.Load("label")
	if !ok || !res.Valid {
		if err := s.ComputeLabel(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("label")
		if !ok {
			return "", errors.New("\"authorizedkeys.entry\" calculated \"label\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "label")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"label\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Options accessor autogenerated
func (s *mqlAuthorizedkeysEntry) Options() ([]interface{}, error) {
	res, ok := s.Cache.Load("options")
	if !ok || !res.Valid {
		if err := s.ComputeOptions(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("options")
		if !ok {
			return nil, errors.New("\"authorizedkeys.entry\" calculated \"options\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "options")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"options\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlAuthorizedkeysEntry) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		return nil, errors.New("\"authorizedkeys.entry\" failed: no value provided for static field \"file\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"authorizedkeys.entry\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuthorizedkeysEntry) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[authorizedkeys.entry].MqlCompute")
	switch name {
	case "line":
		return nil
	case "type":
		return nil
	case "key":
		return nil
	case "label":
		return s.ComputeLabel()
	case "options":
		return s.ComputeOptions()
	case "file":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"authorizedkeys.entry\" resource")
	}
}

// ComputeLabel computer autogenerated
func (s *mqlAuthorizedkeysEntry) ComputeLabel() error {
	var err error
	if _, ok := s.Cache.Load("label"); ok {
		return nil
	}
	vres, err := s.GetLabel()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("label", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOptions computer autogenerated
func (s *mqlAuthorizedkeysEntry) ComputeOptions() error {
	var err error
	if _, ok := s.Cache.Load("options"); ok {
		return nil
	}
	vres, err := s.GetOptions()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("options", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Group resource interface
type Group interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Gid() (int64, error)
	Sid() (string, error)
	Name() (string, error)
	Members() ([]interface{}, error)
}

// mqlGroup for the group resource
type mqlGroup struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGroup) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the group resource
func newGroup(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGroup{runtime.NewResource("group")}
	var existing Group
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "gid":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"group\", its \"gid\" argument has the wrong type (expected type \"int64\")")
			}
		case "sid":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"group\", its \"sid\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"group\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "members":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"group\", its \"members\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"group\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized group with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGroup) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("gid"); !ok {
		return errors.New("Initialized \"group\" resource without a \"gid\". This field is required.")
	}
	if _, ok := s.Cache.Load("sid"); !ok {
		return errors.New("Initialized \"group\" resource without a \"sid\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"group\" resource without a \"name\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlGroup) Register(name string) error {
	log.Trace().Str("field", name).Msg("[group].Register")
	switch name {
	case "gid":
		return nil
	case "sid":
		return nil
	case "name":
		return nil
	case "members":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"group\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGroup) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[group].Field")
	switch name {
	case "gid":
		return s.Gid()
	case "sid":
		return s.Sid()
	case "name":
		return s.Name()
	case "members":
		return s.Members()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"group\" resource")
	}
}

// Gid accessor autogenerated
func (s *mqlGroup) Gid() (int64, error) {
	res, ok := s.Cache.Load("gid")
	if !ok || !res.Valid {
		return 0, errors.New("\"group\" failed: no value provided for static field \"gid\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"group\" failed to cast field \"gid\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Sid accessor autogenerated
func (s *mqlGroup) Sid() (string, error) {
	res, ok := s.Cache.Load("sid")
	if !ok || !res.Valid {
		return "", errors.New("\"group\" failed: no value provided for static field \"sid\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"group\" failed to cast field \"sid\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlGroup) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"group\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"group\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Members accessor autogenerated
func (s *mqlGroup) Members() ([]interface{}, error) {
	res, ok := s.Cache.Load("members")
	if !ok || !res.Valid {
		if err := s.ComputeMembers(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("members")
		if !ok {
			return nil, errors.New("\"group\" calculated \"members\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "members")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"group\" failed to cast field \"members\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGroup) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[group].MqlCompute")
	switch name {
	case "gid":
		return nil
	case "sid":
		return nil
	case "name":
		return nil
	case "members":
		return s.ComputeMembers()
	default:
		return errors.New("Cannot find field '" + name + "' in \"group\" resource")
	}
}

// ComputeMembers computer autogenerated
func (s *mqlGroup) ComputeMembers() error {
	var err error
	if _, ok := s.Cache.Load("members"); ok {
		return nil
	}
	vres, err := s.GetMembers()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("members", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Groups resource interface
type Groups interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlGroups for the groups resource
type mqlGroups struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlGroups) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the groups resource
func newGroups(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlGroups{runtime.NewResource("groups")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"groups\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"groups\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized groups with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlGroups) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlGroups) Register(name string) error {
	log.Trace().Str("field", name).Msg("[groups].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"groups\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlGroups) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[groups].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"groups\" resource")
	}
}

// List accessor autogenerated
func (s *mqlGroups) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"groups\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"groups\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlGroups) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[groups].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"groups\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlGroups) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Parse resource interface
type Parse interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
}

// mqlParse for the parse resource
type mqlParse struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParse) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse resource
func newParse(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParse{runtime.NewResource("parse")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParse) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlParse) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse].Register")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParse) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse].Field")
	switch name {
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse\" resource")
	}
}

// Compute accessor autogenerated
func (s *mqlParse) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse].MqlCompute")
	switch name {
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse\" resource")
	}
}

// Time resource interface
type Time interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Now() (*time.Time, error)
	Second() (*time.Time, error)
	Minute() (*time.Time, error)
	Hour() (*time.Time, error)
	Day() (*time.Time, error)
	Today() (*time.Time, error)
	Tomorrow() (*time.Time, error)
}

// mqlTime for the time resource
type mqlTime struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTime) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the time resource
func newTime(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTime{runtime.NewResource("time")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "now":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"now\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "second":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"second\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "minute":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"minute\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "hour":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"hour\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "day":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"day\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "today":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"today\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "tomorrow":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"tomorrow\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"time\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized time with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTime) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlTime) Register(name string) error {
	log.Trace().Str("field", name).Msg("[time].Register")
	switch name {
	case "now":
		return nil
	case "second":
		return nil
	case "minute":
		return nil
	case "hour":
		return nil
	case "day":
		return nil
	case "today":
		return nil
	case "tomorrow":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"time\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTime) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[time].Field")
	switch name {
	case "now":
		return s.Now()
	case "second":
		return s.Second()
	case "minute":
		return s.Minute()
	case "hour":
		return s.Hour()
	case "day":
		return s.Day()
	case "today":
		return s.Today()
	case "tomorrow":
		return s.Tomorrow()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"time\" resource")
	}
}

// Now accessor autogenerated
func (s *mqlTime) Now() (*time.Time, error) {
	res, ok := s.Cache.Load("now")
	if !ok || !res.Valid {
		if err := s.ComputeNow(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("now")
		if !ok {
			return nil, errors.New("\"time\" calculated \"now\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "now")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"now\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Second accessor autogenerated
func (s *mqlTime) Second() (*time.Time, error) {
	res, ok := s.Cache.Load("second")
	if !ok || !res.Valid {
		if err := s.ComputeSecond(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("second")
		if !ok {
			return nil, errors.New("\"time\" calculated \"second\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "second")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"second\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Minute accessor autogenerated
func (s *mqlTime) Minute() (*time.Time, error) {
	res, ok := s.Cache.Load("minute")
	if !ok || !res.Valid {
		if err := s.ComputeMinute(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("minute")
		if !ok {
			return nil, errors.New("\"time\" calculated \"minute\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "minute")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"minute\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Hour accessor autogenerated
func (s *mqlTime) Hour() (*time.Time, error) {
	res, ok := s.Cache.Load("hour")
	if !ok || !res.Valid {
		if err := s.ComputeHour(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("hour")
		if !ok {
			return nil, errors.New("\"time\" calculated \"hour\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "hour")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"hour\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Day accessor autogenerated
func (s *mqlTime) Day() (*time.Time, error) {
	res, ok := s.Cache.Load("day")
	if !ok || !res.Valid {
		if err := s.ComputeDay(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("day")
		if !ok {
			return nil, errors.New("\"time\" calculated \"day\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "day")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"day\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Today accessor autogenerated
func (s *mqlTime) Today() (*time.Time, error) {
	res, ok := s.Cache.Load("today")
	if !ok || !res.Valid {
		if err := s.ComputeToday(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("today")
		if !ok {
			return nil, errors.New("\"time\" calculated \"today\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "today")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"today\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Tomorrow accessor autogenerated
func (s *mqlTime) Tomorrow() (*time.Time, error) {
	res, ok := s.Cache.Load("tomorrow")
	if !ok || !res.Valid {
		if err := s.ComputeTomorrow(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("tomorrow")
		if !ok {
			return nil, errors.New("\"time\" calculated \"tomorrow\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "tomorrow")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"time\" failed to cast field \"tomorrow\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTime) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[time].MqlCompute")
	switch name {
	case "now":
		return s.ComputeNow()
	case "second":
		return s.ComputeSecond()
	case "minute":
		return s.ComputeMinute()
	case "hour":
		return s.ComputeHour()
	case "day":
		return s.ComputeDay()
	case "today":
		return s.ComputeToday()
	case "tomorrow":
		return s.ComputeTomorrow()
	default:
		return errors.New("Cannot find field '" + name + "' in \"time\" resource")
	}
}

// ComputeNow computer autogenerated
func (s *mqlTime) ComputeNow() error {
	var err error
	if _, ok := s.Cache.Load("now"); ok {
		return nil
	}
	vres, err := s.GetNow()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("now", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSecond computer autogenerated
func (s *mqlTime) ComputeSecond() error {
	var err error
	if _, ok := s.Cache.Load("second"); ok {
		return nil
	}
	vres, err := s.GetSecond()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("second", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMinute computer autogenerated
func (s *mqlTime) ComputeMinute() error {
	var err error
	if _, ok := s.Cache.Load("minute"); ok {
		return nil
	}
	vres, err := s.GetMinute()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("minute", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeHour computer autogenerated
func (s *mqlTime) ComputeHour() error {
	var err error
	if _, ok := s.Cache.Load("hour"); ok {
		return nil
	}
	vres, err := s.GetHour()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("hour", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDay computer autogenerated
func (s *mqlTime) ComputeDay() error {
	var err error
	if _, ok := s.Cache.Load("day"); ok {
		return nil
	}
	vres, err := s.GetDay()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("day", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeToday computer autogenerated
func (s *mqlTime) ComputeToday() error {
	var err error
	if _, ok := s.Cache.Load("today"); ok {
		return nil
	}
	vres, err := s.GetToday()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("today", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeTomorrow computer autogenerated
func (s *mqlTime) ComputeTomorrow() error {
	var err error
	if _, ok := s.Cache.Load("tomorrow"); ok {
		return nil
	}
	vres, err := s.GetTomorrow()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("tomorrow", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Regex resource interface
type Regex interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Ipv4() (Regex, error)
	Ipv6() (Regex, error)
	Url() (Regex, error)
	Email() (Regex, error)
	Mac() (Regex, error)
	Uuid() (Regex, error)
	Emoji() (Regex, error)
	Semver() (Regex, error)
	CreditCard() (Regex, error)
}

// mqlRegex for the regex resource
type mqlRegex struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlRegex) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the regex resource
func newRegex(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlRegex{runtime.NewResource("regex")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "ipv4":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"ipv4\" argument has the wrong type (expected type \"Regex\")")
			}
		case "ipv6":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"ipv6\" argument has the wrong type (expected type \"Regex\")")
			}
		case "url":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"url\" argument has the wrong type (expected type \"Regex\")")
			}
		case "email":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"email\" argument has the wrong type (expected type \"Regex\")")
			}
		case "mac":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"mac\" argument has the wrong type (expected type \"Regex\")")
			}
		case "uuid":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"uuid\" argument has the wrong type (expected type \"Regex\")")
			}
		case "emoji":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"emoji\" argument has the wrong type (expected type \"Regex\")")
			}
		case "semver":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"semver\" argument has the wrong type (expected type \"Regex\")")
			}
		case "creditCard":
			if _, ok := val.(Regex); !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"creditCard\" argument has the wrong type (expected type \"Regex\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"regex\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized regex with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlRegex) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlRegex) Register(name string) error {
	log.Trace().Str("field", name).Msg("[regex].Register")
	switch name {
	case "ipv4":
		return nil
	case "ipv6":
		return nil
	case "url":
		return nil
	case "email":
		return nil
	case "mac":
		return nil
	case "uuid":
		return nil
	case "emoji":
		return nil
	case "semver":
		return nil
	case "creditCard":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"regex\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlRegex) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[regex].Field")
	switch name {
	case "ipv4":
		return s.Ipv4()
	case "ipv6":
		return s.Ipv6()
	case "url":
		return s.Url()
	case "email":
		return s.Email()
	case "mac":
		return s.Mac()
	case "uuid":
		return s.Uuid()
	case "emoji":
		return s.Emoji()
	case "semver":
		return s.Semver()
	case "creditCard":
		return s.CreditCard()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"regex\" resource")
	}
}

// Ipv4 accessor autogenerated
func (s *mqlRegex) Ipv4() (Regex, error) {
	res, ok := s.Cache.Load("ipv4")
	if !ok || !res.Valid {
		if err := s.ComputeIpv4(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("ipv4")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"ipv4\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "ipv4")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"ipv4\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Ipv6 accessor autogenerated
func (s *mqlRegex) Ipv6() (Regex, error) {
	res, ok := s.Cache.Load("ipv6")
	if !ok || !res.Valid {
		if err := s.ComputeIpv6(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("ipv6")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"ipv6\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "ipv6")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"ipv6\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Url accessor autogenerated
func (s *mqlRegex) Url() (Regex, error) {
	res, ok := s.Cache.Load("url")
	if !ok || !res.Valid {
		if err := s.ComputeUrl(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("url")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"url\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "url")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"url\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlRegex) Email() (Regex, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		if err := s.ComputeEmail(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("email")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"email\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "email")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"email\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Mac accessor autogenerated
func (s *mqlRegex) Mac() (Regex, error) {
	res, ok := s.Cache.Load("mac")
	if !ok || !res.Valid {
		if err := s.ComputeMac(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("mac")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"mac\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "mac")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"mac\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Uuid accessor autogenerated
func (s *mqlRegex) Uuid() (Regex, error) {
	res, ok := s.Cache.Load("uuid")
	if !ok || !res.Valid {
		if err := s.ComputeUuid(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("uuid")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"uuid\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "uuid")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"uuid\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Emoji accessor autogenerated
func (s *mqlRegex) Emoji() (Regex, error) {
	res, ok := s.Cache.Load("emoji")
	if !ok || !res.Valid {
		if err := s.ComputeEmoji(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("emoji")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"emoji\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "emoji")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"emoji\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Semver accessor autogenerated
func (s *mqlRegex) Semver() (Regex, error) {
	res, ok := s.Cache.Load("semver")
	if !ok || !res.Valid {
		if err := s.ComputeSemver(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("semver")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"semver\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "semver")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"semver\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// CreditCard accessor autogenerated
func (s *mqlRegex) CreditCard() (Regex, error) {
	res, ok := s.Cache.Load("creditCard")
	if !ok || !res.Valid {
		if err := s.ComputeCreditCard(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("creditCard")
		if !ok {
			return nil, errors.New("\"regex\" calculated \"creditCard\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "creditCard")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Regex)
	if !ok {
		return nil, fmt.Errorf("\"regex\" failed to cast field \"creditCard\" to the right type (Regex): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlRegex) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[regex].MqlCompute")
	switch name {
	case "ipv4":
		return s.ComputeIpv4()
	case "ipv6":
		return s.ComputeIpv6()
	case "url":
		return s.ComputeUrl()
	case "email":
		return s.ComputeEmail()
	case "mac":
		return s.ComputeMac()
	case "uuid":
		return s.ComputeUuid()
	case "emoji":
		return s.ComputeEmoji()
	case "semver":
		return s.ComputeSemver()
	case "creditCard":
		return s.ComputeCreditCard()
	default:
		return errors.New("Cannot find field '" + name + "' in \"regex\" resource")
	}
}

// ComputeIpv4 computer autogenerated
func (s *mqlRegex) ComputeIpv4() error {
	var err error
	if _, ok := s.Cache.Load("ipv4"); ok {
		return nil
	}
	vres, err := s.GetIpv4()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ipv4", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIpv6 computer autogenerated
func (s *mqlRegex) ComputeIpv6() error {
	var err error
	if _, ok := s.Cache.Load("ipv6"); ok {
		return nil
	}
	vres, err := s.GetIpv6()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ipv6", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUrl computer autogenerated
func (s *mqlRegex) ComputeUrl() error {
	var err error
	if _, ok := s.Cache.Load("url"); ok {
		return nil
	}
	vres, err := s.GetUrl()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("url", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEmail computer autogenerated
func (s *mqlRegex) ComputeEmail() error {
	var err error
	if _, ok := s.Cache.Load("email"); ok {
		return nil
	}
	vres, err := s.GetEmail()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("email", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMac computer autogenerated
func (s *mqlRegex) ComputeMac() error {
	var err error
	if _, ok := s.Cache.Load("mac"); ok {
		return nil
	}
	vres, err := s.GetMac()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("mac", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeUuid computer autogenerated
func (s *mqlRegex) ComputeUuid() error {
	var err error
	if _, ok := s.Cache.Load("uuid"); ok {
		return nil
	}
	vres, err := s.GetUuid()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("uuid", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEmoji computer autogenerated
func (s *mqlRegex) ComputeEmoji() error {
	var err error
	if _, ok := s.Cache.Load("emoji"); ok {
		return nil
	}
	vres, err := s.GetEmoji()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("emoji", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSemver computer autogenerated
func (s *mqlRegex) ComputeSemver() error {
	var err error
	if _, ok := s.Cache.Load("semver"); ok {
		return nil
	}
	vres, err := s.GetSemver()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("semver", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCreditCard computer autogenerated
func (s *mqlRegex) ComputeCreditCard() error {
	var err error
	if _, ok := s.Cache.Load("creditCard"); ok {
		return nil
	}
	vres, err := s.GetCreditCard()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("creditCard", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParseIni resource interface
type ParseIni interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Delimiter() (string, error)
	File() (File, error)
	Content() (string, error)
	Sections() (map[string]interface{}, error)
	Params() (map[string]interface{}, error)
}

// mqlParseIni for the parse.ini resource
type mqlParseIni struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParseIni) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.ini resource
func newParseIni(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParseIni{runtime.NewResource("parse.ini")}
	var existing ParseIni
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "delimiter":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"delimiter\" argument has the wrong type (expected type \"string\")")
			}
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "sections":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"sections\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "params":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"params\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.ini\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.ini with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParseIni) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlParseIni) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.ini].Register")
	switch name {
	case "delimiter":
		return nil
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "sections":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "sections"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "delimiter", s, "sections"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "sections", s, "params"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.ini\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParseIni) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.ini].Field")
	switch name {
	case "delimiter":
		return s.Delimiter()
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "sections":
		return s.Sections()
	case "params":
		return s.Params()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.ini\" resource")
	}
}

// Delimiter accessor autogenerated
func (s *mqlParseIni) Delimiter() (string, error) {
	res, ok := s.Cache.Load("delimiter")
	if !ok || !res.Valid {
		if err := s.ComputeDelimiter(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("delimiter")
		if !ok {
			return "", errors.New("\"parse.ini\" calculated \"delimiter\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "delimiter")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.ini\" failed to cast field \"delimiter\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlParseIni) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.ini\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.ini\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParseIni) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.ini\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Sections accessor autogenerated
func (s *mqlParseIni) Sections() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("sections")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.ini\" failed to cast field \"sections\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlParseIni) Params() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.ini\" failed to cast field \"params\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParseIni) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.ini].MqlCompute")
	switch name {
	case "delimiter":
		return s.ComputeDelimiter()
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "sections":
		return s.ComputeSections()
	case "params":
		return s.ComputeParams()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.ini\" resource")
	}
}

// ComputeDelimiter computer autogenerated
func (s *mqlParseIni) ComputeDelimiter() error {
	var err error
	if _, ok := s.Cache.Load("delimiter"); ok {
		return nil
	}
	vres, err := s.GetDelimiter()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("delimiter", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFile computer autogenerated
func (s *mqlParseIni) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParseIni) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSections computer autogenerated
func (s *mqlParseIni) ComputeSections() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("sections", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargDelimiter, err := s.Delimiter()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("sections", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetSections(vargContent, vargDelimiter)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("sections", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlParseIni) ComputeParams() error {
	var err error
	vargSections, err := s.Sections()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargSections)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParseJson resource interface
type ParseJson interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (File, error)
	Content() (string, error)
	Params() (interface{}, error)
}

// mqlParseJson for the parse.json resource
type mqlParseJson struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParseJson) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.json resource
func newParseJson(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParseJson{runtime.NewResource("parse.json")}
	var existing ParseJson
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.json\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.json\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.json\", its \"params\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.json\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.json with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParseJson) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlParseJson) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.json].Register")
	switch name {
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "params"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.json\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParseJson) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.json].Field")
	switch name {
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "params":
		return s.Params()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.json\" resource")
	}
}

// File accessor autogenerated
func (s *mqlParseJson) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.json\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.json\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParseJson) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.json\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlParseJson) Params() (interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.json\" failed to cast field \"params\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParseJson) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.json].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "params":
		return s.ComputeParams()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.json\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlParseJson) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParseJson) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlParseJson) ComputeParams() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParsePlist resource interface
type ParsePlist interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (File, error)
	Content() (string, error)
	Params() (interface{}, error)
}

// mqlParsePlist for the parse.plist resource
type mqlParsePlist struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParsePlist) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.plist resource
func newParsePlist(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParsePlist{runtime.NewResource("parse.plist")}
	var existing ParsePlist
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.plist\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.plist\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.plist\", its \"params\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.plist\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.plist with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParsePlist) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlParsePlist) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.plist].Register")
	switch name {
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "params"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.plist\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParsePlist) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.plist].Field")
	switch name {
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "params":
		return s.Params()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.plist\" resource")
	}
}

// File accessor autogenerated
func (s *mqlParsePlist) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.plist\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.plist\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParsePlist) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.plist\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlParsePlist) Params() (interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.plist\" failed to cast field \"params\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParsePlist) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.plist].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "params":
		return s.ComputeParams()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.plist\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlParsePlist) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParsePlist) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlParsePlist) ComputeParams() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParseYaml resource interface
type ParseYaml interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	File() (File, error)
	Content() (string, error)
	Params() (interface{}, error)
}

// mqlParseYaml for the parse.yaml resource
type mqlParseYaml struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParseYaml) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.yaml resource
func newParseYaml(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParseYaml{runtime.NewResource("parse.yaml")}
	var existing ParseYaml
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.yaml\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.yaml\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.yaml\", its \"params\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.yaml\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.yaml with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParseYaml) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlParseYaml) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.yaml].Register")
	switch name {
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "params"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.yaml\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParseYaml) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.yaml].Field")
	switch name {
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "params":
		return s.Params()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.yaml\" resource")
	}
}

// File accessor autogenerated
func (s *mqlParseYaml) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.yaml\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.yaml\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParseYaml) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.yaml\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlParseYaml) Params() (interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.yaml\" failed to cast field \"params\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParseYaml) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.yaml].MqlCompute")
	switch name {
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "params":
		return s.ComputeParams()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.yaml\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlParseYaml) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParseYaml) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParams computer autogenerated
func (s *mqlParseYaml) ComputeParams() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargContent)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Platform resource interface
type Platform interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Title() (string, error)
	Family() ([]interface{}, error)
	Release() (string, error)
	Version() (string, error)
	Build() (string, error)
	Fqdn() (string, error)
	Arch() (string, error)
	Kind() (string, error)
	Runtime() (string, error)
	Labels() (map[string]interface{}, error)
	VulnerabilityReport() (interface{}, error)
	RuntimeEnv() (string, error)
}

// mqlPlatform for the platform resource
type mqlPlatform struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPlatform) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the platform resource
func newPlatform(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPlatform{runtime.NewResource("platform")}
	var existing Platform
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "title":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"title\" argument has the wrong type (expected type \"string\")")
			}
		case "family":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"family\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "release":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"release\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "build":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"build\" argument has the wrong type (expected type \"string\")")
			}
		case "fqdn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"fqdn\" argument has the wrong type (expected type \"string\")")
			}
		case "arch":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"arch\" argument has the wrong type (expected type \"string\")")
			}
		case "kind":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"kind\" argument has the wrong type (expected type \"string\")")
			}
		case "runtime":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"runtime\" argument has the wrong type (expected type \"string\")")
			}
		case "labels":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"labels\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "vulnerabilityReport":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"vulnerabilityReport\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "runtimeEnv":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"runtimeEnv\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"platform\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized platform with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPlatform) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("title"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"title\". This field is required.")
	}
	if _, ok := s.Cache.Load("family"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"family\". This field is required.")
	}
	if _, ok := s.Cache.Load("release"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"release\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("build"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"build\". This field is required.")
	}
	if _, ok := s.Cache.Load("fqdn"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"fqdn\". This field is required.")
	}
	if _, ok := s.Cache.Load("arch"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"arch\". This field is required.")
	}
	if _, ok := s.Cache.Load("kind"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"kind\". This field is required.")
	}
	if _, ok := s.Cache.Load("runtime"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"runtime\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"labels\". This field is required.")
	}
	if _, ok := s.Cache.Load("runtimeEnv"); !ok {
		return errors.New("Initialized \"platform\" resource without a \"runtimeEnv\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPlatform) Register(name string) error {
	log.Trace().Str("field", name).Msg("[platform].Register")
	switch name {
	case "name":
		return nil
	case "title":
		return nil
	case "family":
		return nil
	case "release":
		return nil
	case "version":
		return nil
	case "build":
		return nil
	case "fqdn":
		return nil
	case "arch":
		return nil
	case "kind":
		return nil
	case "runtime":
		return nil
	case "labels":
		return nil
	case "vulnerabilityReport":
		return nil
	case "runtimeEnv":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPlatform) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[platform].Field")
	switch name {
	case "name":
		return s.Name()
	case "title":
		return s.Title()
	case "family":
		return s.Family()
	case "release":
		return s.Release()
	case "version":
		return s.Version()
	case "build":
		return s.Build()
	case "fqdn":
		return s.Fqdn()
	case "arch":
		return s.Arch()
	case "kind":
		return s.Kind()
	case "runtime":
		return s.Runtime()
	case "labels":
		return s.Labels()
	case "vulnerabilityReport":
		return s.VulnerabilityReport()
	case "runtimeEnv":
		return s.RuntimeEnv()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"platform\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlPlatform) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Title accessor autogenerated
func (s *mqlPlatform) Title() (string, error) {
	res, ok := s.Cache.Load("title")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"title\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"title\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Family accessor autogenerated
func (s *mqlPlatform) Family() ([]interface{}, error) {
	res, ok := s.Cache.Load("family")
	if !ok || !res.Valid {
		return nil, errors.New("\"platform\" failed: no value provided for static field \"family\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform\" failed to cast field \"family\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Release accessor autogenerated
func (s *mqlPlatform) Release() (string, error) {
	res, ok := s.Cache.Load("release")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"release\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"release\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlPlatform) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Build accessor autogenerated
func (s *mqlPlatform) Build() (string, error) {
	res, ok := s.Cache.Load("build")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"build\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"build\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Fqdn accessor autogenerated
func (s *mqlPlatform) Fqdn() (string, error) {
	res, ok := s.Cache.Load("fqdn")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"fqdn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"fqdn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Arch accessor autogenerated
func (s *mqlPlatform) Arch() (string, error) {
	res, ok := s.Cache.Load("arch")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"arch\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"arch\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Kind accessor autogenerated
func (s *mqlPlatform) Kind() (string, error) {
	res, ok := s.Cache.Load("kind")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"kind\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"kind\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Runtime accessor autogenerated
func (s *mqlPlatform) Runtime() (string, error) {
	res, ok := s.Cache.Load("runtime")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"runtime\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"runtime\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlPlatform) Labels() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"platform\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform\" failed to cast field \"labels\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// VulnerabilityReport accessor autogenerated
func (s *mqlPlatform) VulnerabilityReport() (interface{}, error) {
	res, ok := s.Cache.Load("vulnerabilityReport")
	if !ok || !res.Valid {
		if err := s.ComputeVulnerabilityReport(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("vulnerabilityReport")
		if !ok {
			return nil, errors.New("\"platform\" calculated \"vulnerabilityReport\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "vulnerabilityReport")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform\" failed to cast field \"vulnerabilityReport\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// RuntimeEnv accessor autogenerated
func (s *mqlPlatform) RuntimeEnv() (string, error) {
	res, ok := s.Cache.Load("runtimeEnv")
	if !ok || !res.Valid {
		return "", errors.New("\"platform\" failed: no value provided for static field \"runtimeEnv\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform\" failed to cast field \"runtimeEnv\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPlatform) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[platform].MqlCompute")
	switch name {
	case "name":
		return nil
	case "title":
		return nil
	case "family":
		return nil
	case "release":
		return nil
	case "version":
		return nil
	case "build":
		return nil
	case "fqdn":
		return nil
	case "arch":
		return nil
	case "kind":
		return nil
	case "runtime":
		return nil
	case "labels":
		return nil
	case "vulnerabilityReport":
		return s.ComputeVulnerabilityReport()
	case "runtimeEnv":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform\" resource")
	}
}

// ComputeVulnerabilityReport computer autogenerated
func (s *mqlPlatform) ComputeVulnerabilityReport() error {
	var err error
	if _, ok := s.Cache.Load("vulnerabilityReport"); ok {
		return nil
	}
	vres, err := s.GetVulnerabilityReport()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("vulnerabilityReport", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PlatformVirtualization resource interface
type PlatformVirtualization interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	IsContainer() (bool, error)
}

// mqlPlatformVirtualization for the platform.virtualization resource
type mqlPlatformVirtualization struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPlatformVirtualization) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the platform.virtualization resource
func newPlatformVirtualization(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPlatformVirtualization{runtime.NewResource("platform.virtualization")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "isContainer":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"platform.virtualization\", its \"isContainer\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"platform.virtualization\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized platform.virtualization with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPlatformVirtualization) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPlatformVirtualization) Register(name string) error {
	log.Trace().Str("field", name).Msg("[platform.virtualization].Register")
	switch name {
	case "isContainer":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.virtualization\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPlatformVirtualization) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[platform.virtualization].Field")
	switch name {
	case "isContainer":
		return s.IsContainer()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"platform.virtualization\" resource")
	}
}

// IsContainer accessor autogenerated
func (s *mqlPlatformVirtualization) IsContainer() (bool, error) {
	res, ok := s.Cache.Load("isContainer")
	if !ok || !res.Valid {
		if err := s.ComputeIsContainer(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("isContainer")
		if !ok {
			return false, errors.New("\"platform.virtualization\" calculated \"isContainer\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "isContainer")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"platform.virtualization\" failed to cast field \"isContainer\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPlatformVirtualization) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[platform.virtualization].MqlCompute")
	switch name {
	case "isContainer":
		return s.ComputeIsContainer()
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.virtualization\" resource")
	}
}

// ComputeIsContainer computer autogenerated
func (s *mqlPlatformVirtualization) ComputeIsContainer() error {
	var err error
	if _, ok := s.Cache.Load("isContainer"); ok {
		return nil
	}
	vres, err := s.GetIsContainer()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("isContainer", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PlatformEol resource interface
type PlatformEol interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	DocsUrl() (string, error)
	ProductUrl() (string, error)
	Date() (*time.Time, error)
}

// mqlPlatformEol for the platform.eol resource
type mqlPlatformEol struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPlatformEol) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the platform.eol resource
func newPlatformEol(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPlatformEol{runtime.NewResource("platform.eol")}
	var existing PlatformEol
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "docsUrl":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform.eol\", its \"docsUrl\" argument has the wrong type (expected type \"string\")")
			}
		case "productUrl":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"platform.eol\", its \"productUrl\" argument has the wrong type (expected type \"string\")")
			}
		case "date":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"platform.eol\", its \"date\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"platform.eol\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized platform.eol with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPlatformEol) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("docsUrl"); !ok {
		return errors.New("Initialized \"platform.eol\" resource without a \"docsUrl\". This field is required.")
	}
	if _, ok := s.Cache.Load("productUrl"); !ok {
		return errors.New("Initialized \"platform.eol\" resource without a \"productUrl\". This field is required.")
	}
	if _, ok := s.Cache.Load("date"); !ok {
		return errors.New("Initialized \"platform.eol\" resource without a \"date\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPlatformEol) Register(name string) error {
	log.Trace().Str("field", name).Msg("[platform.eol].Register")
	switch name {
	case "docsUrl":
		return nil
	case "productUrl":
		return nil
	case "date":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.eol\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPlatformEol) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[platform.eol].Field")
	switch name {
	case "docsUrl":
		return s.DocsUrl()
	case "productUrl":
		return s.ProductUrl()
	case "date":
		return s.Date()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"platform.eol\" resource")
	}
}

// DocsUrl accessor autogenerated
func (s *mqlPlatformEol) DocsUrl() (string, error) {
	res, ok := s.Cache.Load("docsUrl")
	if !ok || !res.Valid {
		return "", errors.New("\"platform.eol\" failed: no value provided for static field \"docsUrl\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform.eol\" failed to cast field \"docsUrl\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ProductUrl accessor autogenerated
func (s *mqlPlatformEol) ProductUrl() (string, error) {
	res, ok := s.Cache.Load("productUrl")
	if !ok || !res.Valid {
		return "", errors.New("\"platform.eol\" failed: no value provided for static field \"productUrl\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"platform.eol\" failed to cast field \"productUrl\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Date accessor autogenerated
func (s *mqlPlatformEol) Date() (*time.Time, error) {
	res, ok := s.Cache.Load("date")
	if !ok || !res.Valid {
		return nil, errors.New("\"platform.eol\" failed: no value provided for static field \"date\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"platform.eol\" failed to cast field \"date\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPlatformEol) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[platform.eol].MqlCompute")
	switch name {
	case "docsUrl":
		return nil
	case "productUrl":
		return nil
	case "date":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.eol\" resource")
	}
}

// PlatformAdvisories resource interface
type PlatformAdvisories interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Cvss() (AuditCvss, error)
	Stats() (interface{}, error)
	List() ([]interface{}, error)
}

// mqlPlatformAdvisories for the platform.advisories resource
type mqlPlatformAdvisories struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPlatformAdvisories) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the platform.advisories resource
func newPlatformAdvisories(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPlatformAdvisories{runtime.NewResource("platform.advisories")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "cvss":
			if _, ok := val.(AuditCvss); !ok {
				return nil, errors.New("Failed to initialize \"platform.advisories\", its \"cvss\" argument has the wrong type (expected type \"AuditCvss\")")
			}
		case "stats":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform.advisories\", its \"stats\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform.advisories\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"platform.advisories\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized platform.advisories with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPlatformAdvisories) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPlatformAdvisories) Register(name string) error {
	log.Trace().Str("field", name).Msg("[platform.advisories].Register")
	switch name {
	case "cvss":
		return nil
	case "stats":
		return nil
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.advisories\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPlatformAdvisories) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[platform.advisories].Field")
	switch name {
	case "cvss":
		return s.Cvss()
	case "stats":
		return s.Stats()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"platform.advisories\" resource")
	}
}

// Cvss accessor autogenerated
func (s *mqlPlatformAdvisories) Cvss() (AuditCvss, error) {
	res, ok := s.Cache.Load("cvss")
	if !ok || !res.Valid {
		if err := s.ComputeCvss(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("cvss")
		if !ok {
			return nil, errors.New("\"platform.advisories\" calculated \"cvss\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "cvss")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(AuditCvss)
	if !ok {
		return nil, fmt.Errorf("\"platform.advisories\" failed to cast field \"cvss\" to the right type (AuditCvss): %#v", res)
	}
	return tres, nil
}

// Stats accessor autogenerated
func (s *mqlPlatformAdvisories) Stats() (interface{}, error) {
	res, ok := s.Cache.Load("stats")
	if !ok || !res.Valid {
		if err := s.ComputeStats(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("stats")
		if !ok {
			return nil, errors.New("\"platform.advisories\" calculated \"stats\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stats")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform.advisories\" failed to cast field \"stats\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlPlatformAdvisories) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"platform.advisories\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform.advisories\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPlatformAdvisories) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[platform.advisories].MqlCompute")
	switch name {
	case "cvss":
		return s.ComputeCvss()
	case "stats":
		return s.ComputeStats()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.advisories\" resource")
	}
}

// ComputeCvss computer autogenerated
func (s *mqlPlatformAdvisories) ComputeCvss() error {
	var err error
	if _, ok := s.Cache.Load("cvss"); ok {
		return nil
	}
	vres, err := s.GetCvss()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("cvss", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeStats computer autogenerated
func (s *mqlPlatformAdvisories) ComputeStats() error {
	var err error
	if _, ok := s.Cache.Load("stats"); ok {
		return nil
	}
	vres, err := s.GetStats()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stats", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlPlatformAdvisories) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PlatformCves resource interface
type PlatformCves interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Cvss() (AuditCvss, error)
	Stats() (interface{}, error)
	List() ([]interface{}, error)
}

// mqlPlatformCves for the platform.cves resource
type mqlPlatformCves struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPlatformCves) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the platform.cves resource
func newPlatformCves(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPlatformCves{runtime.NewResource("platform.cves")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "cvss":
			if _, ok := val.(AuditCvss); !ok {
				return nil, errors.New("Failed to initialize \"platform.cves\", its \"cvss\" argument has the wrong type (expected type \"AuditCvss\")")
			}
		case "stats":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform.cves\", its \"stats\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"platform.cves\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"platform.cves\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized platform.cves with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPlatformCves) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPlatformCves) Register(name string) error {
	log.Trace().Str("field", name).Msg("[platform.cves].Register")
	switch name {
	case "cvss":
		return nil
	case "stats":
		return nil
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.cves\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPlatformCves) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[platform.cves].Field")
	switch name {
	case "cvss":
		return s.Cvss()
	case "stats":
		return s.Stats()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"platform.cves\" resource")
	}
}

// Cvss accessor autogenerated
func (s *mqlPlatformCves) Cvss() (AuditCvss, error) {
	res, ok := s.Cache.Load("cvss")
	if !ok || !res.Valid {
		if err := s.ComputeCvss(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("cvss")
		if !ok {
			return nil, errors.New("\"platform.cves\" calculated \"cvss\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "cvss")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(AuditCvss)
	if !ok {
		return nil, fmt.Errorf("\"platform.cves\" failed to cast field \"cvss\" to the right type (AuditCvss): %#v", res)
	}
	return tres, nil
}

// Stats accessor autogenerated
func (s *mqlPlatformCves) Stats() (interface{}, error) {
	res, ok := s.Cache.Load("stats")
	if !ok || !res.Valid {
		if err := s.ComputeStats(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("stats")
		if !ok {
			return nil, errors.New("\"platform.cves\" calculated \"stats\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "stats")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform.cves\" failed to cast field \"stats\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlPlatformCves) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"platform.cves\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"platform.cves\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPlatformCves) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[platform.cves].MqlCompute")
	switch name {
	case "cvss":
		return s.ComputeCvss()
	case "stats":
		return s.ComputeStats()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"platform.cves\" resource")
	}
}

// ComputeCvss computer autogenerated
func (s *mqlPlatformCves) ComputeCvss() error {
	var err error
	if _, ok := s.Cache.Load("cvss"); ok {
		return nil
	}
	vres, err := s.GetCvss()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("cvss", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeStats computer autogenerated
func (s *mqlPlatformCves) ComputeStats() error {
	var err error
	if _, ok := s.Cache.Load("stats"); ok {
		return nil
	}
	vres, err := s.GetStats()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("stats", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlPlatformCves) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// AuditCvss resource interface
type AuditCvss interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Score() (float64, error)
	Vector() (string, error)
}

// mqlAuditCvss for the audit.cvss resource
type mqlAuditCvss struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuditCvss) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the audit.cvss resource
func newAuditCvss(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuditCvss{runtime.NewResource("audit.cvss")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "score":
			if _, ok := val.(float64); !ok {
				return nil, errors.New("Failed to initialize \"audit.cvss\", its \"score\" argument has the wrong type (expected type \"float64\")")
			}
		case "vector":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.cvss\", its \"vector\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"audit.cvss\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized audit.cvss with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuditCvss) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("score"); !ok {
		return errors.New("Initialized \"audit.cvss\" resource without a \"score\". This field is required.")
	}
	if _, ok := s.Cache.Load("vector"); !ok {
		return errors.New("Initialized \"audit.cvss\" resource without a \"vector\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuditCvss) Register(name string) error {
	log.Trace().Str("field", name).Msg("[audit.cvss].Register")
	switch name {
	case "score":
		return nil
	case "vector":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.cvss\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuditCvss) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[audit.cvss].Field")
	switch name {
	case "score":
		return s.Score()
	case "vector":
		return s.Vector()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"audit.cvss\" resource")
	}
}

// Score accessor autogenerated
func (s *mqlAuditCvss) Score() (float64, error) {
	res, ok := s.Cache.Load("score")
	if !ok || !res.Valid {
		return 0.0, errors.New("\"audit.cvss\" failed: no value provided for static field \"score\"")
	}
	if res.Error != nil {
		return 0.0, res.Error
	}
	tres, ok := res.Data.(float64)
	if !ok {
		return 0.0, fmt.Errorf("\"audit.cvss\" failed to cast field \"score\" to the right type (float64): %#v", res)
	}
	return tres, nil
}

// Vector accessor autogenerated
func (s *mqlAuditCvss) Vector() (string, error) {
	res, ok := s.Cache.Load("vector")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.cvss\" failed: no value provided for static field \"vector\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.cvss\" failed to cast field \"vector\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuditCvss) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[audit.cvss].MqlCompute")
	switch name {
	case "score":
		return nil
	case "vector":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.cvss\" resource")
	}
}

// AuditAdvisory resource interface
type AuditAdvisory interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Mrn() (string, error)
	Title() (string, error)
	Description() (string, error)
	Published() (*time.Time, error)
	Modified() (*time.Time, error)
	WorstScore() (AuditCvss, error)
}

// mqlAuditAdvisory for the audit.advisory resource
type mqlAuditAdvisory struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuditAdvisory) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the audit.advisory resource
func newAuditAdvisory(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuditAdvisory{runtime.NewResource("audit.advisory")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "mrn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"mrn\" argument has the wrong type (expected type \"string\")")
			}
		case "title":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"title\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "published":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"published\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "modified":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"modified\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "worstScore":
			if _, ok := val.(AuditCvss); !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"worstScore\" argument has the wrong type (expected type \"AuditCvss\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"audit.advisory\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized audit.advisory with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuditAdvisory) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("mrn"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"mrn\". This field is required.")
	}
	if _, ok := s.Cache.Load("title"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"title\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("published"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"published\". This field is required.")
	}
	if _, ok := s.Cache.Load("modified"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"modified\". This field is required.")
	}
	if _, ok := s.Cache.Load("worstScore"); !ok {
		return errors.New("Initialized \"audit.advisory\" resource without a \"worstScore\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuditAdvisory) Register(name string) error {
	log.Trace().Str("field", name).Msg("[audit.advisory].Register")
	switch name {
	case "id":
		return nil
	case "mrn":
		return nil
	case "title":
		return nil
	case "description":
		return nil
	case "published":
		return nil
	case "modified":
		return nil
	case "worstScore":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.advisory\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuditAdvisory) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[audit.advisory].Field")
	switch name {
	case "id":
		return s.Id()
	case "mrn":
		return s.Mrn()
	case "title":
		return s.Title()
	case "description":
		return s.Description()
	case "published":
		return s.Published()
	case "modified":
		return s.Modified()
	case "worstScore":
		return s.WorstScore()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"audit.advisory\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlAuditAdvisory) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.advisory\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.advisory\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mrn accessor autogenerated
func (s *mqlAuditAdvisory) Mrn() (string, error) {
	res, ok := s.Cache.Load("mrn")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.advisory\" failed: no value provided for static field \"mrn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.advisory\" failed to cast field \"mrn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Title accessor autogenerated
func (s *mqlAuditAdvisory) Title() (string, error) {
	res, ok := s.Cache.Load("title")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.advisory\" failed: no value provided for static field \"title\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.advisory\" failed to cast field \"title\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlAuditAdvisory) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.advisory\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.advisory\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Published accessor autogenerated
func (s *mqlAuditAdvisory) Published() (*time.Time, error) {
	res, ok := s.Cache.Load("published")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.advisory\" failed: no value provided for static field \"published\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"audit.advisory\" failed to cast field \"published\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Modified accessor autogenerated
func (s *mqlAuditAdvisory) Modified() (*time.Time, error) {
	res, ok := s.Cache.Load("modified")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.advisory\" failed: no value provided for static field \"modified\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"audit.advisory\" failed to cast field \"modified\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// WorstScore accessor autogenerated
func (s *mqlAuditAdvisory) WorstScore() (AuditCvss, error) {
	res, ok := s.Cache.Load("worstScore")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.advisory\" failed: no value provided for static field \"worstScore\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(AuditCvss)
	if !ok {
		return nil, fmt.Errorf("\"audit.advisory\" failed to cast field \"worstScore\" to the right type (AuditCvss): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuditAdvisory) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[audit.advisory].MqlCompute")
	switch name {
	case "id":
		return nil
	case "mrn":
		return nil
	case "title":
		return nil
	case "description":
		return nil
	case "published":
		return nil
	case "modified":
		return nil
	case "worstScore":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.advisory\" resource")
	}
}

// AuditCve resource interface
type AuditCve interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Mrn() (string, error)
	State() (string, error)
	Summary() (string, error)
	Unscored() (bool, error)
	Published() (*time.Time, error)
	Modified() (*time.Time, error)
	WorstScore() (AuditCvss, error)
}

// mqlAuditCve for the audit.cve resource
type mqlAuditCve struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlAuditCve) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the audit.cve resource
func newAuditCve(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlAuditCve{runtime.NewResource("audit.cve")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "mrn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"mrn\" argument has the wrong type (expected type \"string\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "summary":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"summary\" argument has the wrong type (expected type \"string\")")
			}
		case "unscored":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"unscored\" argument has the wrong type (expected type \"bool\")")
			}
		case "published":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"published\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "modified":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"modified\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "worstScore":
			if _, ok := val.(AuditCvss); !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"worstScore\" argument has the wrong type (expected type \"AuditCvss\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"audit.cve\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized audit.cve with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlAuditCve) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("mrn"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"mrn\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("summary"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"summary\". This field is required.")
	}
	if _, ok := s.Cache.Load("unscored"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"unscored\". This field is required.")
	}
	if _, ok := s.Cache.Load("published"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"published\". This field is required.")
	}
	if _, ok := s.Cache.Load("modified"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"modified\". This field is required.")
	}
	if _, ok := s.Cache.Load("worstScore"); !ok {
		return errors.New("Initialized \"audit.cve\" resource without a \"worstScore\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlAuditCve) Register(name string) error {
	log.Trace().Str("field", name).Msg("[audit.cve].Register")
	switch name {
	case "id":
		return nil
	case "mrn":
		return nil
	case "state":
		return nil
	case "summary":
		return nil
	case "unscored":
		return nil
	case "published":
		return nil
	case "modified":
		return nil
	case "worstScore":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.cve\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlAuditCve) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[audit.cve].Field")
	switch name {
	case "id":
		return s.Id()
	case "mrn":
		return s.Mrn()
	case "state":
		return s.State()
	case "summary":
		return s.Summary()
	case "unscored":
		return s.Unscored()
	case "published":
		return s.Published()
	case "modified":
		return s.Modified()
	case "worstScore":
		return s.WorstScore()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"audit.cve\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlAuditCve) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.cve\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.cve\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Mrn accessor autogenerated
func (s *mqlAuditCve) Mrn() (string, error) {
	res, ok := s.Cache.Load("mrn")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.cve\" failed: no value provided for static field \"mrn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.cve\" failed to cast field \"mrn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlAuditCve) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.cve\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.cve\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Summary accessor autogenerated
func (s *mqlAuditCve) Summary() (string, error) {
	res, ok := s.Cache.Load("summary")
	if !ok || !res.Valid {
		return "", errors.New("\"audit.cve\" failed: no value provided for static field \"summary\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"audit.cve\" failed to cast field \"summary\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Unscored accessor autogenerated
func (s *mqlAuditCve) Unscored() (bool, error) {
	res, ok := s.Cache.Load("unscored")
	if !ok || !res.Valid {
		return false, errors.New("\"audit.cve\" failed: no value provided for static field \"unscored\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"audit.cve\" failed to cast field \"unscored\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Published accessor autogenerated
func (s *mqlAuditCve) Published() (*time.Time, error) {
	res, ok := s.Cache.Load("published")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.cve\" failed: no value provided for static field \"published\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"audit.cve\" failed to cast field \"published\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Modified accessor autogenerated
func (s *mqlAuditCve) Modified() (*time.Time, error) {
	res, ok := s.Cache.Load("modified")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.cve\" failed: no value provided for static field \"modified\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"audit.cve\" failed to cast field \"modified\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// WorstScore accessor autogenerated
func (s *mqlAuditCve) WorstScore() (AuditCvss, error) {
	res, ok := s.Cache.Load("worstScore")
	if !ok || !res.Valid {
		return nil, errors.New("\"audit.cve\" failed: no value provided for static field \"worstScore\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(AuditCvss)
	if !ok {
		return nil, fmt.Errorf("\"audit.cve\" failed to cast field \"worstScore\" to the right type (AuditCvss): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlAuditCve) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[audit.cve].MqlCompute")
	switch name {
	case "id":
		return nil
	case "mrn":
		return nil
	case "state":
		return nil
	case "summary":
		return nil
	case "unscored":
		return nil
	case "published":
		return nil
	case "modified":
		return nil
	case "worstScore":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"audit.cve\" resource")
	}
}

// Process resource interface
type Process interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Pid() (int64, error)
	State() (string, error)
	Executable() (string, error)
	Command() (string, error)
	Flags() (map[string]interface{}, error)
}

// mqlProcess for the process resource
type mqlProcess struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlProcess) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the process resource
func newProcess(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlProcess{runtime.NewResource("process")}
	var existing Process
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "pid":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"pid\" argument has the wrong type (expected type \"int64\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "executable":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"executable\" argument has the wrong type (expected type \"string\")")
			}
		case "command":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"command\" argument has the wrong type (expected type \"string\")")
			}
		case "flags":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"flags\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"process\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized process with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlProcess) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("pid"); !ok {
		return errors.New("Initialized \"process\" resource without a \"pid\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlProcess) Register(name string) error {
	log.Trace().Str("field", name).Msg("[process].Register")
	switch name {
	case "pid":
		return nil
	case "state":
		return nil
	case "executable":
		return nil
	case "command":
		return nil
	case "flags":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"process\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlProcess) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[process].Field")
	switch name {
	case "pid":
		return s.Pid()
	case "state":
		return s.State()
	case "executable":
		return s.Executable()
	case "command":
		return s.Command()
	case "flags":
		return s.Flags()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"process\" resource")
	}
}

// Pid accessor autogenerated
func (s *mqlProcess) Pid() (int64, error) {
	res, ok := s.Cache.Load("pid")
	if !ok || !res.Valid {
		return 0, errors.New("\"process\" failed: no value provided for static field \"pid\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"process\" failed to cast field \"pid\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlProcess) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		if err := s.ComputeState(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("state")
		if !ok {
			return "", errors.New("\"process\" calculated \"state\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "state")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"process\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Executable accessor autogenerated
func (s *mqlProcess) Executable() (string, error) {
	res, ok := s.Cache.Load("executable")
	if !ok || !res.Valid {
		if err := s.ComputeExecutable(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("executable")
		if !ok {
			return "", errors.New("\"process\" calculated \"executable\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "executable")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"process\" failed to cast field \"executable\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Command accessor autogenerated
func (s *mqlProcess) Command() (string, error) {
	res, ok := s.Cache.Load("command")
	if !ok || !res.Valid {
		if err := s.ComputeCommand(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("command")
		if !ok {
			return "", errors.New("\"process\" calculated \"command\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "command")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"process\" failed to cast field \"command\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Flags accessor autogenerated
func (s *mqlProcess) Flags() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("flags")
	if !ok || !res.Valid {
		if err := s.ComputeFlags(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("flags")
		if !ok {
			return nil, errors.New("\"process\" calculated \"flags\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "flags")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"process\" failed to cast field \"flags\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlProcess) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[process].MqlCompute")
	switch name {
	case "pid":
		return nil
	case "state":
		return s.ComputeState()
	case "executable":
		return s.ComputeExecutable()
	case "command":
		return s.ComputeCommand()
	case "flags":
		return s.ComputeFlags()
	default:
		return errors.New("Cannot find field '" + name + "' in \"process\" resource")
	}
}

// ComputeState computer autogenerated
func (s *mqlProcess) ComputeState() error {
	var err error
	if _, ok := s.Cache.Load("state"); ok {
		return nil
	}
	vres, err := s.GetState()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("state", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExecutable computer autogenerated
func (s *mqlProcess) ComputeExecutable() error {
	var err error
	if _, ok := s.Cache.Load("executable"); ok {
		return nil
	}
	vres, err := s.GetExecutable()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("executable", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCommand computer autogenerated
func (s *mqlProcess) ComputeCommand() error {
	var err error
	if _, ok := s.Cache.Load("command"); ok {
		return nil
	}
	vres, err := s.GetCommand()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("command", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeFlags computer autogenerated
func (s *mqlProcess) ComputeFlags() error {
	var err error
	if _, ok := s.Cache.Load("flags"); ok {
		return nil
	}
	vres, err := s.GetFlags()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("flags", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Processes resource interface
type Processes interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlProcesses for the processes resource
type mqlProcesses struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlProcesses) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the processes resource
func newProcesses(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlProcesses{runtime.NewResource("processes")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"processes\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"processes\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized processes with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlProcesses) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlProcesses) Register(name string) error {
	log.Trace().Str("field", name).Msg("[processes].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"processes\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlProcesses) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[processes].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"processes\" resource")
	}
}

// List accessor autogenerated
func (s *mqlProcesses) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"processes\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"processes\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlProcesses) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[processes].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"processes\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlProcesses) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Port resource interface
type Port interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Protocol() (string, error)
	Port() (int64, error)
	Address() (string, error)
	User() (User, error)
	Process() (Process, error)
	State() (string, error)
	RemoteAddress() (string, error)
	RemotePort() (int64, error)
	Tls() (Tls, error)
}

// mqlPort for the port resource
type mqlPort struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPort) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the port resource
func newPort(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPort{runtime.NewResource("port")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "protocol":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"protocol\" argument has the wrong type (expected type \"string\")")
			}
		case "port":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"port\" argument has the wrong type (expected type \"int64\")")
			}
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "user":
			if _, ok := val.(User); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"user\" argument has the wrong type (expected type \"User\")")
			}
		case "process":
			if _, ok := val.(Process); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"process\" argument has the wrong type (expected type \"Process\")")
			}
		case "state":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"state\" argument has the wrong type (expected type \"string\")")
			}
		case "remoteAddress":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"remoteAddress\" argument has the wrong type (expected type \"string\")")
			}
		case "remotePort":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"remotePort\" argument has the wrong type (expected type \"int64\")")
			}
		case "tls":
			if _, ok := val.(Tls); !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"tls\" argument has the wrong type (expected type \"Tls\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"port\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized port with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPort) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("protocol"); !ok {
		return errors.New("Initialized \"port\" resource without a \"protocol\". This field is required.")
	}
	if _, ok := s.Cache.Load("port"); !ok {
		return errors.New("Initialized \"port\" resource without a \"port\". This field is required.")
	}
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"port\" resource without a \"address\". This field is required.")
	}
	if _, ok := s.Cache.Load("user"); !ok {
		return errors.New("Initialized \"port\" resource without a \"user\". This field is required.")
	}
	if _, ok := s.Cache.Load("process"); !ok {
		return errors.New("Initialized \"port\" resource without a \"process\". This field is required.")
	}
	if _, ok := s.Cache.Load("state"); !ok {
		return errors.New("Initialized \"port\" resource without a \"state\". This field is required.")
	}
	if _, ok := s.Cache.Load("remoteAddress"); !ok {
		return errors.New("Initialized \"port\" resource without a \"remoteAddress\". This field is required.")
	}
	if _, ok := s.Cache.Load("remotePort"); !ok {
		return errors.New("Initialized \"port\" resource without a \"remotePort\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPort) Register(name string) error {
	log.Trace().Str("field", name).Msg("[port].Register")
	switch name {
	case "protocol":
		return nil
	case "port":
		return nil
	case "address":
		return nil
	case "user":
		return nil
	case "process":
		return nil
	case "state":
		return nil
	case "remoteAddress":
		return nil
	case "remotePort":
		return nil
	case "tls":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "address", s, "tls"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "port", s, "tls"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "protocol", s, "tls"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"port\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPort) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[port].Field")
	switch name {
	case "protocol":
		return s.Protocol()
	case "port":
		return s.Port()
	case "address":
		return s.Address()
	case "user":
		return s.User()
	case "process":
		return s.Process()
	case "state":
		return s.State()
	case "remoteAddress":
		return s.RemoteAddress()
	case "remotePort":
		return s.RemotePort()
	case "tls":
		return s.Tls()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"port\" resource")
	}
}

// Protocol accessor autogenerated
func (s *mqlPort) Protocol() (string, error) {
	res, ok := s.Cache.Load("protocol")
	if !ok || !res.Valid {
		return "", errors.New("\"port\" failed: no value provided for static field \"protocol\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"port\" failed to cast field \"protocol\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Port accessor autogenerated
func (s *mqlPort) Port() (int64, error) {
	res, ok := s.Cache.Load("port")
	if !ok || !res.Valid {
		return 0, errors.New("\"port\" failed: no value provided for static field \"port\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"port\" failed to cast field \"port\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Address accessor autogenerated
func (s *mqlPort) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"port\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"port\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// User accessor autogenerated
func (s *mqlPort) User() (User, error) {
	res, ok := s.Cache.Load("user")
	if !ok || !res.Valid {
		return nil, errors.New("\"port\" failed: no value provided for static field \"user\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(User)
	if !ok {
		return nil, fmt.Errorf("\"port\" failed to cast field \"user\" to the right type (User): %#v", res)
	}
	return tres, nil
}

// Process accessor autogenerated
func (s *mqlPort) Process() (Process, error) {
	res, ok := s.Cache.Load("process")
	if !ok || !res.Valid {
		return nil, errors.New("\"port\" failed: no value provided for static field \"process\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Process)
	if !ok {
		return nil, fmt.Errorf("\"port\" failed to cast field \"process\" to the right type (Process): %#v", res)
	}
	return tres, nil
}

// State accessor autogenerated
func (s *mqlPort) State() (string, error) {
	res, ok := s.Cache.Load("state")
	if !ok || !res.Valid {
		return "", errors.New("\"port\" failed: no value provided for static field \"state\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"port\" failed to cast field \"state\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RemoteAddress accessor autogenerated
func (s *mqlPort) RemoteAddress() (string, error) {
	res, ok := s.Cache.Load("remoteAddress")
	if !ok || !res.Valid {
		return "", errors.New("\"port\" failed: no value provided for static field \"remoteAddress\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"port\" failed to cast field \"remoteAddress\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// RemotePort accessor autogenerated
func (s *mqlPort) RemotePort() (int64, error) {
	res, ok := s.Cache.Load("remotePort")
	if !ok || !res.Valid {
		return 0, errors.New("\"port\" failed: no value provided for static field \"remotePort\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"port\" failed to cast field \"remotePort\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Tls accessor autogenerated
func (s *mqlPort) Tls() (Tls, error) {
	res, ok := s.Cache.Load("tls")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Tls)
	if !ok {
		return nil, fmt.Errorf("\"port\" failed to cast field \"tls\" to the right type (Tls): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPort) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[port].MqlCompute")
	switch name {
	case "protocol":
		return nil
	case "port":
		return nil
	case "address":
		return nil
	case "user":
		return nil
	case "process":
		return nil
	case "state":
		return nil
	case "remoteAddress":
		return nil
	case "remotePort":
		return nil
	case "tls":
		return s.ComputeTls()
	default:
		return errors.New("Cannot find field '" + name + "' in \"port\" resource")
	}
}

// ComputeTls computer autogenerated
func (s *mqlPort) ComputeTls() error {
	var err error
	vargAddress, err := s.Address()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("tls", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargPort, err := s.Port()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("tls", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargProtocol, err := s.Protocol()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("tls", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetTls(vargAddress, vargPort, vargProtocol)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("tls", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Ports resource interface
type Ports interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Listening() ([]interface{}, error)
	List() ([]interface{}, error)
}

// mqlPorts for the ports resource
type mqlPorts struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPorts) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the ports resource
func newPorts(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPorts{runtime.NewResource("ports")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "listening":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ports\", its \"listening\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"ports\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"ports\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized ports with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPorts) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPorts) Register(name string) error {
	log.Trace().Str("field", name).Msg("[ports].Register")
	switch name {
	case "listening":
		return nil
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"ports\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPorts) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[ports].Field")
	switch name {
	case "listening":
		return s.Listening()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"ports\" resource")
	}
}

// Listening accessor autogenerated
func (s *mqlPorts) Listening() ([]interface{}, error) {
	res, ok := s.Cache.Load("listening")
	if !ok || !res.Valid {
		if err := s.ComputeListening(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("listening")
		if !ok {
			return nil, errors.New("\"ports\" calculated \"listening\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "listening")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ports\" failed to cast field \"listening\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlPorts) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"ports\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"ports\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPorts) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[ports].MqlCompute")
	switch name {
	case "listening":
		return s.ComputeListening()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"ports\" resource")
	}
}

// ComputeListening computer autogenerated
func (s *mqlPorts) ComputeListening() error {
	var err error
	if _, ok := s.Cache.Load("listening"); ok {
		return nil
	}
	vres, err := s.GetListening()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("listening", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlPorts) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Socket resource interface
type Socket interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Protocol() (string, error)
	Port() (int64, error)
	Address() (string, error)
}

// mqlSocket for the socket resource
type mqlSocket struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlSocket) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the socket resource
func newSocket(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlSocket{runtime.NewResource("socket")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "protocol":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"socket\", its \"protocol\" argument has the wrong type (expected type \"string\")")
			}
		case "port":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"socket\", its \"port\" argument has the wrong type (expected type \"int64\")")
			}
		case "address":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"socket\", its \"address\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"socket\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized socket with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlSocket) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("protocol"); !ok {
		return errors.New("Initialized \"socket\" resource without a \"protocol\". This field is required.")
	}
	if _, ok := s.Cache.Load("port"); !ok {
		return errors.New("Initialized \"socket\" resource without a \"port\". This field is required.")
	}
	if _, ok := s.Cache.Load("address"); !ok {
		return errors.New("Initialized \"socket\" resource without a \"address\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlSocket) Register(name string) error {
	log.Trace().Str("field", name).Msg("[socket].Register")
	switch name {
	case "protocol":
		return nil
	case "port":
		return nil
	case "address":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"socket\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlSocket) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[socket].Field")
	switch name {
	case "protocol":
		return s.Protocol()
	case "port":
		return s.Port()
	case "address":
		return s.Address()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"socket\" resource")
	}
}

// Protocol accessor autogenerated
func (s *mqlSocket) Protocol() (string, error) {
	res, ok := s.Cache.Load("protocol")
	if !ok || !res.Valid {
		return "", errors.New("\"socket\" failed: no value provided for static field \"protocol\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"socket\" failed to cast field \"protocol\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Port accessor autogenerated
func (s *mqlSocket) Port() (int64, error) {
	res, ok := s.Cache.Load("port")
	if !ok || !res.Valid {
		return 0, errors.New("\"socket\" failed: no value provided for static field \"port\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"socket\" failed to cast field \"port\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Address accessor autogenerated
func (s *mqlSocket) Address() (string, error) {
	res, ok := s.Cache.Load("address")
	if !ok || !res.Valid {
		return "", errors.New("\"socket\" failed: no value provided for static field \"address\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"socket\" failed to cast field \"address\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlSocket) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[socket].MqlCompute")
	switch name {
	case "protocol":
		return nil
	case "port":
		return nil
	case "address":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"socket\" resource")
	}
}

// Tls resource interface
type Tls interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Socket() (Socket, error)
	DomainName() (string, error)
	Params() (interface{}, error)
	Versions() ([]interface{}, error)
	Ciphers() ([]interface{}, error)
	Extensions() ([]interface{}, error)
	Certificates() ([]interface{}, error)
	NonSniCertificates() ([]interface{}, error)
}

// mqlTls for the tls resource
type mqlTls struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlTls) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the tls resource
func newTls(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlTls{runtime.NewResource("tls")}
	var existing Tls
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "socket":
			if _, ok := val.(Socket); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"socket\" argument has the wrong type (expected type \"Socket\")")
			}
		case "domainName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"domainName\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"params\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "versions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"versions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "ciphers":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"ciphers\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "extensions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"extensions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "certificates":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"certificates\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "nonSniCertificates":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"nonSniCertificates\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"tls\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized tls with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlTls) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("socket"); !ok {
		return errors.New("Initialized \"tls\" resource without a \"socket\". This field is required.")
	}
	if _, ok := s.Cache.Load("domainName"); !ok {
		return errors.New("Initialized \"tls\" resource without a \"domainName\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlTls) Register(name string) error {
	log.Trace().Str("field", name).Msg("[tls].Register")
	switch name {
	case "socket":
		return nil
	case "domainName":
		return nil
	case "params":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "socket", s, "params"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "domainName", s, "params"); err != nil {
			return err
		}
		return nil
	case "versions":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "versions"); err != nil {
			return err
		}
		return nil
	case "ciphers":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "ciphers"); err != nil {
			return err
		}
		return nil
	case "extensions":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "extensions"); err != nil {
			return err
		}
		return nil
	case "certificates":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "certificates"); err != nil {
			return err
		}
		return nil
	case "nonSniCertificates":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "nonSniCertificates"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"tls\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlTls) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[tls].Field")
	switch name {
	case "socket":
		return s.Socket()
	case "domainName":
		return s.DomainName()
	case "params":
		return s.Params()
	case "versions":
		return s.Versions()
	case "ciphers":
		return s.Ciphers()
	case "extensions":
		return s.Extensions()
	case "certificates":
		return s.Certificates()
	case "nonSniCertificates":
		return s.NonSniCertificates()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"tls\" resource")
	}
}

// Socket accessor autogenerated
func (s *mqlTls) Socket() (Socket, error) {
	res, ok := s.Cache.Load("socket")
	if !ok || !res.Valid {
		return nil, errors.New("\"tls\" failed: no value provided for static field \"socket\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(Socket)
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"socket\" to the right type (Socket): %#v", res)
	}
	return tres, nil
}

// DomainName accessor autogenerated
func (s *mqlTls) DomainName() (string, error) {
	res, ok := s.Cache.Load("domainName")
	if !ok || !res.Valid {
		return "", errors.New("\"tls\" failed: no value provided for static field \"domainName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"tls\" failed to cast field \"domainName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlTls) Params() (interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"params\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Versions accessor autogenerated
func (s *mqlTls) Versions() ([]interface{}, error) {
	res, ok := s.Cache.Load("versions")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"versions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Ciphers accessor autogenerated
func (s *mqlTls) Ciphers() ([]interface{}, error) {
	res, ok := s.Cache.Load("ciphers")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"ciphers\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Extensions accessor autogenerated
func (s *mqlTls) Extensions() ([]interface{}, error) {
	res, ok := s.Cache.Load("extensions")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"extensions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Certificates accessor autogenerated
func (s *mqlTls) Certificates() ([]interface{}, error) {
	res, ok := s.Cache.Load("certificates")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"certificates\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// NonSniCertificates accessor autogenerated
func (s *mqlTls) NonSniCertificates() ([]interface{}, error) {
	res, ok := s.Cache.Load("nonSniCertificates")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"tls\" failed to cast field \"nonSniCertificates\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlTls) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[tls].MqlCompute")
	switch name {
	case "socket":
		return nil
	case "domainName":
		return nil
	case "params":
		return s.ComputeParams()
	case "versions":
		return s.ComputeVersions()
	case "ciphers":
		return s.ComputeCiphers()
	case "extensions":
		return s.ComputeExtensions()
	case "certificates":
		return s.ComputeCertificates()
	case "nonSniCertificates":
		return s.ComputeNonSniCertificates()
	default:
		return errors.New("Cannot find field '" + name + "' in \"tls\" resource")
	}
}

// ComputeParams computer autogenerated
func (s *mqlTls) ComputeParams() error {
	var err error
	vargSocket, err := s.Socket()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargDomainName, err := s.DomainName()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("params", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetParams(vargSocket, vargDomainName)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVersions computer autogenerated
func (s *mqlTls) ComputeVersions() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("versions", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetVersions(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("versions", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCiphers computer autogenerated
func (s *mqlTls) ComputeCiphers() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("ciphers", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetCiphers(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ciphers", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExtensions computer autogenerated
func (s *mqlTls) ComputeExtensions() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("extensions", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetExtensions(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("extensions", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCertificates computer autogenerated
func (s *mqlTls) ComputeCertificates() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("certificates", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetCertificates(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("certificates", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeNonSniCertificates computer autogenerated
func (s *mqlTls) ComputeNonSniCertificates() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("nonSniCertificates", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetNonSniCertificates(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("nonSniCertificates", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// DomainName resource interface
type DomainName interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Fqdn() (string, error)
	EffectiveTLDPlusOne() (string, error)
	Tld() (string, error)
	TldIcannManaged() (bool, error)
	Labels() ([]interface{}, error)
}

// mqlDomainName for the domainName resource
type mqlDomainName struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDomainName) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the domainName resource
func newDomainName(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDomainName{runtime.NewResource("domainName")}
	var existing DomainName
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "fqdn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"fqdn\" argument has the wrong type (expected type \"string\")")
			}
		case "effectiveTLDPlusOne":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"effectiveTLDPlusOne\" argument has the wrong type (expected type \"string\")")
			}
		case "tld":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"tld\" argument has the wrong type (expected type \"string\")")
			}
		case "tldIcannManaged":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"tldIcannManaged\" argument has the wrong type (expected type \"bool\")")
			}
		case "labels":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"labels\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"domainName\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized domainName with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDomainName) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("fqdn"); !ok {
		return errors.New("Initialized \"domainName\" resource without a \"fqdn\". This field is required.")
	}
	if _, ok := s.Cache.Load("effectiveTLDPlusOne"); !ok {
		return errors.New("Initialized \"domainName\" resource without a \"effectiveTLDPlusOne\". This field is required.")
	}
	if _, ok := s.Cache.Load("tld"); !ok {
		return errors.New("Initialized \"domainName\" resource without a \"tld\". This field is required.")
	}
	if _, ok := s.Cache.Load("tldIcannManaged"); !ok {
		return errors.New("Initialized \"domainName\" resource without a \"tldIcannManaged\". This field is required.")
	}
	if _, ok := s.Cache.Load("labels"); !ok {
		return errors.New("Initialized \"domainName\" resource without a \"labels\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDomainName) Register(name string) error {
	log.Trace().Str("field", name).Msg("[domainName].Register")
	switch name {
	case "fqdn":
		return nil
	case "effectiveTLDPlusOne":
		return nil
	case "tld":
		return nil
	case "tldIcannManaged":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"domainName\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDomainName) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[domainName].Field")
	switch name {
	case "fqdn":
		return s.Fqdn()
	case "effectiveTLDPlusOne":
		return s.EffectiveTLDPlusOne()
	case "tld":
		return s.Tld()
	case "tldIcannManaged":
		return s.TldIcannManaged()
	case "labels":
		return s.Labels()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"domainName\" resource")
	}
}

// Fqdn accessor autogenerated
func (s *mqlDomainName) Fqdn() (string, error) {
	res, ok := s.Cache.Load("fqdn")
	if !ok || !res.Valid {
		return "", errors.New("\"domainName\" failed: no value provided for static field \"fqdn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"domainName\" failed to cast field \"fqdn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// EffectiveTLDPlusOne accessor autogenerated
func (s *mqlDomainName) EffectiveTLDPlusOne() (string, error) {
	res, ok := s.Cache.Load("effectiveTLDPlusOne")
	if !ok || !res.Valid {
		return "", errors.New("\"domainName\" failed: no value provided for static field \"effectiveTLDPlusOne\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"domainName\" failed to cast field \"effectiveTLDPlusOne\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Tld accessor autogenerated
func (s *mqlDomainName) Tld() (string, error) {
	res, ok := s.Cache.Load("tld")
	if !ok || !res.Valid {
		return "", errors.New("\"domainName\" failed: no value provided for static field \"tld\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"domainName\" failed to cast field \"tld\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// TldIcannManaged accessor autogenerated
func (s *mqlDomainName) TldIcannManaged() (bool, error) {
	res, ok := s.Cache.Load("tldIcannManaged")
	if !ok || !res.Valid {
		return false, errors.New("\"domainName\" failed: no value provided for static field \"tldIcannManaged\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"domainName\" failed to cast field \"tldIcannManaged\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Labels accessor autogenerated
func (s *mqlDomainName) Labels() ([]interface{}, error) {
	res, ok := s.Cache.Load("labels")
	if !ok || !res.Valid {
		return nil, errors.New("\"domainName\" failed: no value provided for static field \"labels\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"domainName\" failed to cast field \"labels\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDomainName) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[domainName].MqlCompute")
	switch name {
	case "fqdn":
		return nil
	case "effectiveTLDPlusOne":
		return nil
	case "tld":
		return nil
	case "tldIcannManaged":
		return nil
	case "labels":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"domainName\" resource")
	}
}

// Dns resource interface
type Dns interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Fqdn() (string, error)
	Params() (interface{}, error)
	Records() ([]interface{}, error)
	Mx() ([]interface{}, error)
	Dkim() ([]interface{}, error)
}

// mqlDns for the dns resource
type mqlDns struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDns) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the dns resource
func newDns(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDns{runtime.NewResource("dns")}
	var existing Dns
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "fqdn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"fqdn\" argument has the wrong type (expected type \"string\")")
			}
		case "params":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"params\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "records":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"records\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "mx":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"mx\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "dkim":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"dkim\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"dns\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized dns with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDns) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("fqdn"); !ok {
		return errors.New("Initialized \"dns\" resource without a \"fqdn\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDns) Register(name string) error {
	log.Trace().Str("field", name).Msg("[dns].Register")
	switch name {
	case "fqdn":
		return nil
	case "params":
		return nil
	case "records":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "records"); err != nil {
			return err
		}
		return nil
	case "mx":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "mx"); err != nil {
			return err
		}
		return nil
	case "dkim":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "params", s, "dkim"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDns) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[dns].Field")
	switch name {
	case "fqdn":
		return s.Fqdn()
	case "params":
		return s.Params()
	case "records":
		return s.Records()
	case "mx":
		return s.Mx()
	case "dkim":
		return s.Dkim()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"dns\" resource")
	}
}

// Fqdn accessor autogenerated
func (s *mqlDns) Fqdn() (string, error) {
	res, ok := s.Cache.Load("fqdn")
	if !ok || !res.Valid {
		return "", errors.New("\"dns\" failed: no value provided for static field \"fqdn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns\" failed to cast field \"fqdn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Params accessor autogenerated
func (s *mqlDns) Params() (interface{}, error) {
	res, ok := s.Cache.Load("params")
	if !ok || !res.Valid {
		if err := s.ComputeParams(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("params")
		if !ok {
			return nil, errors.New("\"dns\" calculated \"params\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "params")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns\" failed to cast field \"params\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Records accessor autogenerated
func (s *mqlDns) Records() ([]interface{}, error) {
	res, ok := s.Cache.Load("records")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns\" failed to cast field \"records\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Mx accessor autogenerated
func (s *mqlDns) Mx() ([]interface{}, error) {
	res, ok := s.Cache.Load("mx")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns\" failed to cast field \"mx\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Dkim accessor autogenerated
func (s *mqlDns) Dkim() ([]interface{}, error) {
	res, ok := s.Cache.Load("dkim")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns\" failed to cast field \"dkim\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDns) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[dns].MqlCompute")
	switch name {
	case "fqdn":
		return nil
	case "params":
		return s.ComputeParams()
	case "records":
		return s.ComputeRecords()
	case "mx":
		return s.ComputeMx()
	case "dkim":
		return s.ComputeDkim()
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns\" resource")
	}
}

// ComputeParams computer autogenerated
func (s *mqlDns) ComputeParams() error {
	var err error
	if _, ok := s.Cache.Load("params"); ok {
		return nil
	}
	vres, err := s.GetParams()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("params", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRecords computer autogenerated
func (s *mqlDns) ComputeRecords() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("records", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetRecords(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("records", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeMx computer autogenerated
func (s *mqlDns) ComputeMx() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("mx", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetMx(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("mx", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeDkim computer autogenerated
func (s *mqlDns) ComputeDkim() error {
	var err error
	vargParams, err := s.Params()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("dkim", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetDkim(vargParams)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("dkim", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// DnsRecord resource interface
type DnsRecord interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Ttl() (int64, error)
	Class() (string, error)
	Type() (string, error)
	Rdata() ([]interface{}, error)
}

// mqlDnsRecord for the dns.record resource
type mqlDnsRecord struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDnsRecord) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the dns.record resource
func newDnsRecord(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDnsRecord{runtime.NewResource("dns.record")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "ttl":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"ttl\" argument has the wrong type (expected type \"int64\")")
			}
		case "class":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"class\" argument has the wrong type (expected type \"string\")")
			}
		case "type":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"type\" argument has the wrong type (expected type \"string\")")
			}
		case "rdata":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"rdata\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"dns.record\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized dns.record with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDnsRecord) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"dns.record\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("ttl"); !ok {
		return errors.New("Initialized \"dns.record\" resource without a \"ttl\". This field is required.")
	}
	if _, ok := s.Cache.Load("class"); !ok {
		return errors.New("Initialized \"dns.record\" resource without a \"class\". This field is required.")
	}
	if _, ok := s.Cache.Load("type"); !ok {
		return errors.New("Initialized \"dns.record\" resource without a \"type\". This field is required.")
	}
	if _, ok := s.Cache.Load("rdata"); !ok {
		return errors.New("Initialized \"dns.record\" resource without a \"rdata\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDnsRecord) Register(name string) error {
	log.Trace().Str("field", name).Msg("[dns.record].Register")
	switch name {
	case "name":
		return nil
	case "ttl":
		return nil
	case "class":
		return nil
	case "type":
		return nil
	case "rdata":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.record\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDnsRecord) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[dns.record].Field")
	switch name {
	case "name":
		return s.Name()
	case "ttl":
		return s.Ttl()
	case "class":
		return s.Class()
	case "type":
		return s.Type()
	case "rdata":
		return s.Rdata()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"dns.record\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlDnsRecord) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.record\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.record\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Ttl accessor autogenerated
func (s *mqlDnsRecord) Ttl() (int64, error) {
	res, ok := s.Cache.Load("ttl")
	if !ok || !res.Valid {
		return 0, errors.New("\"dns.record\" failed: no value provided for static field \"ttl\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"dns.record\" failed to cast field \"ttl\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Class accessor autogenerated
func (s *mqlDnsRecord) Class() (string, error) {
	res, ok := s.Cache.Load("class")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.record\" failed: no value provided for static field \"class\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.record\" failed to cast field \"class\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Type accessor autogenerated
func (s *mqlDnsRecord) Type() (string, error) {
	res, ok := s.Cache.Load("type")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.record\" failed: no value provided for static field \"type\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.record\" failed to cast field \"type\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Rdata accessor autogenerated
func (s *mqlDnsRecord) Rdata() ([]interface{}, error) {
	res, ok := s.Cache.Load("rdata")
	if !ok || !res.Valid {
		return nil, errors.New("\"dns.record\" failed: no value provided for static field \"rdata\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns.record\" failed to cast field \"rdata\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDnsRecord) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[dns.record].MqlCompute")
	switch name {
	case "name":
		return nil
	case "ttl":
		return nil
	case "class":
		return nil
	case "type":
		return nil
	case "rdata":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.record\" resource")
	}
}

// DnsMxRecord resource interface
type DnsMxRecord interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Preference() (int64, error)
	DomainName() (string, error)
}

// mqlDnsMxRecord for the dns.mxRecord resource
type mqlDnsMxRecord struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDnsMxRecord) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the dns.mxRecord resource
func newDnsMxRecord(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDnsMxRecord{runtime.NewResource("dns.mxRecord")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.mxRecord\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "preference":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"dns.mxRecord\", its \"preference\" argument has the wrong type (expected type \"int64\")")
			}
		case "domainName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.mxRecord\", its \"domainName\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"dns.mxRecord\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized dns.mxRecord with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDnsMxRecord) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"dns.mxRecord\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("preference"); !ok {
		return errors.New("Initialized \"dns.mxRecord\" resource without a \"preference\". This field is required.")
	}
	if _, ok := s.Cache.Load("domainName"); !ok {
		return errors.New("Initialized \"dns.mxRecord\" resource without a \"domainName\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDnsMxRecord) Register(name string) error {
	log.Trace().Str("field", name).Msg("[dns.mxRecord].Register")
	switch name {
	case "name":
		return nil
	case "preference":
		return nil
	case "domainName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.mxRecord\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDnsMxRecord) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[dns.mxRecord].Field")
	switch name {
	case "name":
		return s.Name()
	case "preference":
		return s.Preference()
	case "domainName":
		return s.DomainName()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"dns.mxRecord\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlDnsMxRecord) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.mxRecord\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.mxRecord\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Preference accessor autogenerated
func (s *mqlDnsMxRecord) Preference() (int64, error) {
	res, ok := s.Cache.Load("preference")
	if !ok || !res.Valid {
		return 0, errors.New("\"dns.mxRecord\" failed: no value provided for static field \"preference\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"dns.mxRecord\" failed to cast field \"preference\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// DomainName accessor autogenerated
func (s *mqlDnsMxRecord) DomainName() (string, error) {
	res, ok := s.Cache.Load("domainName")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.mxRecord\" failed: no value provided for static field \"domainName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.mxRecord\" failed to cast field \"domainName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDnsMxRecord) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[dns.mxRecord].MqlCompute")
	switch name {
	case "name":
		return nil
	case "preference":
		return nil
	case "domainName":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.mxRecord\" resource")
	}
}

// DnsDkimRecord resource interface
type DnsDkimRecord interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	DnsTxt() (string, error)
	Domain() (string, error)
	Version() (string, error)
	HashAlgorithms() ([]interface{}, error)
	KeyType() (string, error)
	Notes() (string, error)
	PublicKeyData() (string, error)
	ServiceTypes() ([]interface{}, error)
	Flags() ([]interface{}, error)
	Valid() (bool, error)
}

// mqlDnsDkimRecord for the dns.dkimRecord resource
type mqlDnsDkimRecord struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlDnsDkimRecord) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the dns.dkimRecord resource
func newDnsDkimRecord(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlDnsDkimRecord{runtime.NewResource("dns.dkimRecord")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "dnsTxt":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"dnsTxt\" argument has the wrong type (expected type \"string\")")
			}
		case "domain":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"domain\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "hashAlgorithms":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"hashAlgorithms\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "keyType":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"keyType\" argument has the wrong type (expected type \"string\")")
			}
		case "notes":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"notes\" argument has the wrong type (expected type \"string\")")
			}
		case "publicKeyData":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"publicKeyData\" argument has the wrong type (expected type \"string\")")
			}
		case "serviceTypes":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"serviceTypes\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "flags":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"flags\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "valid":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"valid\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"dns.dkimRecord\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized dns.dkimRecord with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlDnsDkimRecord) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("dnsTxt"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"dnsTxt\". This field is required.")
	}
	if _, ok := s.Cache.Load("domain"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"domain\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("hashAlgorithms"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"hashAlgorithms\". This field is required.")
	}
	if _, ok := s.Cache.Load("keyType"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"keyType\". This field is required.")
	}
	if _, ok := s.Cache.Load("notes"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"notes\". This field is required.")
	}
	if _, ok := s.Cache.Load("publicKeyData"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"publicKeyData\". This field is required.")
	}
	if _, ok := s.Cache.Load("serviceTypes"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"serviceTypes\". This field is required.")
	}
	if _, ok := s.Cache.Load("flags"); !ok {
		return errors.New("Initialized \"dns.dkimRecord\" resource without a \"flags\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlDnsDkimRecord) Register(name string) error {
	log.Trace().Str("field", name).Msg("[dns.dkimRecord].Register")
	switch name {
	case "dnsTxt":
		return nil
	case "domain":
		return nil
	case "version":
		return nil
	case "hashAlgorithms":
		return nil
	case "keyType":
		return nil
	case "notes":
		return nil
	case "publicKeyData":
		return nil
	case "serviceTypes":
		return nil
	case "flags":
		return nil
	case "valid":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.dkimRecord\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlDnsDkimRecord) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[dns.dkimRecord].Field")
	switch name {
	case "dnsTxt":
		return s.DnsTxt()
	case "domain":
		return s.Domain()
	case "version":
		return s.Version()
	case "hashAlgorithms":
		return s.HashAlgorithms()
	case "keyType":
		return s.KeyType()
	case "notes":
		return s.Notes()
	case "publicKeyData":
		return s.PublicKeyData()
	case "serviceTypes":
		return s.ServiceTypes()
	case "flags":
		return s.Flags()
	case "valid":
		return s.Valid()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"dns.dkimRecord\" resource")
	}
}

// DnsTxt accessor autogenerated
func (s *mqlDnsDkimRecord) DnsTxt() (string, error) {
	res, ok := s.Cache.Load("dnsTxt")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"dnsTxt\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"dnsTxt\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Domain accessor autogenerated
func (s *mqlDnsDkimRecord) Domain() (string, error) {
	res, ok := s.Cache.Load("domain")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"domain\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"domain\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlDnsDkimRecord) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// HashAlgorithms accessor autogenerated
func (s *mqlDnsDkimRecord) HashAlgorithms() ([]interface{}, error) {
	res, ok := s.Cache.Load("hashAlgorithms")
	if !ok || !res.Valid {
		return nil, errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"hashAlgorithms\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"hashAlgorithms\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// KeyType accessor autogenerated
func (s *mqlDnsDkimRecord) KeyType() (string, error) {
	res, ok := s.Cache.Load("keyType")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"keyType\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"keyType\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Notes accessor autogenerated
func (s *mqlDnsDkimRecord) Notes() (string, error) {
	res, ok := s.Cache.Load("notes")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"notes\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"notes\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// PublicKeyData accessor autogenerated
func (s *mqlDnsDkimRecord) PublicKeyData() (string, error) {
	res, ok := s.Cache.Load("publicKeyData")
	if !ok || !res.Valid {
		return "", errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"publicKeyData\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"publicKeyData\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// ServiceTypes accessor autogenerated
func (s *mqlDnsDkimRecord) ServiceTypes() ([]interface{}, error) {
	res, ok := s.Cache.Load("serviceTypes")
	if !ok || !res.Valid {
		return nil, errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"serviceTypes\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"serviceTypes\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Flags accessor autogenerated
func (s *mqlDnsDkimRecord) Flags() ([]interface{}, error) {
	res, ok := s.Cache.Load("flags")
	if !ok || !res.Valid {
		return nil, errors.New("\"dns.dkimRecord\" failed: no value provided for static field \"flags\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"flags\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Valid accessor autogenerated
func (s *mqlDnsDkimRecord) Valid() (bool, error) {
	res, ok := s.Cache.Load("valid")
	if !ok || !res.Valid {
		if err := s.ComputeValid(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("valid")
		if !ok {
			return false, errors.New("\"dns.dkimRecord\" calculated \"valid\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "valid")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"dns.dkimRecord\" failed to cast field \"valid\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlDnsDkimRecord) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[dns.dkimRecord].MqlCompute")
	switch name {
	case "dnsTxt":
		return nil
	case "domain":
		return nil
	case "version":
		return nil
	case "hashAlgorithms":
		return nil
	case "keyType":
		return nil
	case "notes":
		return nil
	case "publicKeyData":
		return nil
	case "serviceTypes":
		return nil
	case "flags":
		return nil
	case "valid":
		return s.ComputeValid()
	default:
		return errors.New("Cannot find field '" + name + "' in \"dns.dkimRecord\" resource")
	}
}

// ComputeValid computer autogenerated
func (s *mqlDnsDkimRecord) ComputeValid() error {
	var err error
	if _, ok := s.Cache.Load("valid"); ok {
		return nil
	}
	vres, err := s.GetValid()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("valid", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// YamlPath resource interface
type YamlPath interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Filepath() (string, error)
	Jsonpath() (string, error)
	Result() (string, error)
}

// mqlYamlPath for the yaml.path resource
type mqlYamlPath struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlYamlPath) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the yaml.path resource
func newYamlPath(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlYamlPath{runtime.NewResource("yaml.path")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "filepath":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yaml.path\", its \"filepath\" argument has the wrong type (expected type \"string\")")
			}
		case "jsonpath":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yaml.path\", its \"jsonpath\" argument has the wrong type (expected type \"string\")")
			}
		case "result":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"yaml.path\", its \"result\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"yaml.path\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized yaml.path with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlYamlPath) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("filepath"); !ok {
		return errors.New("Initialized \"yaml.path\" resource without a \"filepath\". This field is required.")
	}
	if _, ok := s.Cache.Load("jsonpath"); !ok {
		return errors.New("Initialized \"yaml.path\" resource without a \"jsonpath\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlYamlPath) Register(name string) error {
	log.Trace().Str("field", name).Msg("[yaml.path].Register")
	switch name {
	case "filepath":
		return nil
	case "jsonpath":
		return nil
	case "result":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"yaml.path\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlYamlPath) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[yaml.path].Field")
	switch name {
	case "filepath":
		return s.Filepath()
	case "jsonpath":
		return s.Jsonpath()
	case "result":
		return s.Result()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"yaml.path\" resource")
	}
}

// Filepath accessor autogenerated
func (s *mqlYamlPath) Filepath() (string, error) {
	res, ok := s.Cache.Load("filepath")
	if !ok || !res.Valid {
		return "", errors.New("\"yaml.path\" failed: no value provided for static field \"filepath\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yaml.path\" failed to cast field \"filepath\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Jsonpath accessor autogenerated
func (s *mqlYamlPath) Jsonpath() (string, error) {
	res, ok := s.Cache.Load("jsonpath")
	if !ok || !res.Valid {
		return "", errors.New("\"yaml.path\" failed: no value provided for static field \"jsonpath\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yaml.path\" failed to cast field \"jsonpath\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Result accessor autogenerated
func (s *mqlYamlPath) Result() (string, error) {
	res, ok := s.Cache.Load("result")
	if !ok || !res.Valid {
		if err := s.ComputeResult(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("result")
		if !ok {
			return "", errors.New("\"yaml.path\" calculated \"result\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "result")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"yaml.path\" failed to cast field \"result\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlYamlPath) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[yaml.path].MqlCompute")
	switch name {
	case "filepath":
		return nil
	case "jsonpath":
		return nil
	case "result":
		return s.ComputeResult()
	default:
		return errors.New("Cannot find field '" + name + "' in \"yaml.path\" resource")
	}
}

// ComputeResult computer autogenerated
func (s *mqlYamlPath) ComputeResult() error {
	var err error
	if _, ok := s.Cache.Load("result"); ok {
		return nil
	}
	vres, err := s.GetResult()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("result", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParseCertificates resource interface
type ParseCertificates interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	File() (File, error)
	Content() (string, error)
	List() ([]interface{}, error)
}

// mqlParseCertificates for the parse.certificates resource
type mqlParseCertificates struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParseCertificates) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.certificates resource
func newParseCertificates(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParseCertificates{runtime.NewResource("parse.certificates")}
	var existing ParseCertificates
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.certificates\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.certificates\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.certificates\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.certificates\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.certificates\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.certificates with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParseCertificates) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"parse.certificates\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlParseCertificates) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.certificates].Register")
	switch name {
	case "path":
		return nil
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "list":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "list"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "path", s, "list"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.certificates\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParseCertificates) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.certificates].Field")
	switch name {
	case "path":
		return s.Path()
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.certificates\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlParseCertificates) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"parse.certificates\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.certificates\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlParseCertificates) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.certificates\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.certificates\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParseCertificates) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.certificates\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlParseCertificates) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.certificates\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParseCertificates) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.certificates].MqlCompute")
	switch name {
	case "path":
		return nil
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.certificates\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlParseCertificates) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParseCertificates) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlParseCertificates) ComputeList() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargPath, err := s.Path()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetList(vargContent, vargPath)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// PkixName resource interface
type PkixName interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Dn() (string, error)
	SerialNumber() (string, error)
	CommonName() (string, error)
	Country() ([]interface{}, error)
	Organization() ([]interface{}, error)
	OrganizationalUnit() ([]interface{}, error)
	Locality() ([]interface{}, error)
	Province() ([]interface{}, error)
	StreetAddress() ([]interface{}, error)
	PostalCode() ([]interface{}, error)
	Names() (map[string]interface{}, error)
	ExtraNames() (map[string]interface{}, error)
}

// mqlPkixName for the pkix.name resource
type mqlPkixName struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPkixName) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the pkix.name resource
func newPkixName(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPkixName{runtime.NewResource("pkix.name")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "dn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"dn\" argument has the wrong type (expected type \"string\")")
			}
		case "serialNumber":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"serialNumber\" argument has the wrong type (expected type \"string\")")
			}
		case "commonName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"commonName\" argument has the wrong type (expected type \"string\")")
			}
		case "country":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"country\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "organization":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"organization\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "organizationalUnit":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"organizationalUnit\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "locality":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"locality\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "province":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"province\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "streetAddress":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"streetAddress\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "postalCode":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"postalCode\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "names":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"names\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "extraNames":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"extraNames\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"pkix.name\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized pkix.name with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPkixName) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("dn"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"dn\". This field is required.")
	}
	if _, ok := s.Cache.Load("serialNumber"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"serialNumber\". This field is required.")
	}
	if _, ok := s.Cache.Load("commonName"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"commonName\". This field is required.")
	}
	if _, ok := s.Cache.Load("country"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"country\". This field is required.")
	}
	if _, ok := s.Cache.Load("organization"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"organization\". This field is required.")
	}
	if _, ok := s.Cache.Load("organizationalUnit"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"organizationalUnit\". This field is required.")
	}
	if _, ok := s.Cache.Load("locality"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"locality\". This field is required.")
	}
	if _, ok := s.Cache.Load("province"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"province\". This field is required.")
	}
	if _, ok := s.Cache.Load("streetAddress"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"streetAddress\". This field is required.")
	}
	if _, ok := s.Cache.Load("postalCode"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"postalCode\". This field is required.")
	}
	if _, ok := s.Cache.Load("names"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"names\". This field is required.")
	}
	if _, ok := s.Cache.Load("extraNames"); !ok {
		return errors.New("Initialized \"pkix.name\" resource without a \"extraNames\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPkixName) Register(name string) error {
	log.Trace().Str("field", name).Msg("[pkix.name].Register")
	switch name {
	case "id":
		return nil
	case "dn":
		return nil
	case "serialNumber":
		return nil
	case "commonName":
		return nil
	case "country":
		return nil
	case "organization":
		return nil
	case "organizationalUnit":
		return nil
	case "locality":
		return nil
	case "province":
		return nil
	case "streetAddress":
		return nil
	case "postalCode":
		return nil
	case "names":
		return nil
	case "extraNames":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pkix.name\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPkixName) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[pkix.name].Field")
	switch name {
	case "id":
		return s.Id()
	case "dn":
		return s.Dn()
	case "serialNumber":
		return s.SerialNumber()
	case "commonName":
		return s.CommonName()
	case "country":
		return s.Country()
	case "organization":
		return s.Organization()
	case "organizationalUnit":
		return s.OrganizationalUnit()
	case "locality":
		return s.Locality()
	case "province":
		return s.Province()
	case "streetAddress":
		return s.StreetAddress()
	case "postalCode":
		return s.PostalCode()
	case "names":
		return s.Names()
	case "extraNames":
		return s.ExtraNames()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"pkix.name\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlPkixName) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.name\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.name\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Dn accessor autogenerated
func (s *mqlPkixName) Dn() (string, error) {
	res, ok := s.Cache.Load("dn")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.name\" failed: no value provided for static field \"dn\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.name\" failed to cast field \"dn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SerialNumber accessor autogenerated
func (s *mqlPkixName) SerialNumber() (string, error) {
	res, ok := s.Cache.Load("serialNumber")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.name\" failed: no value provided for static field \"serialNumber\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.name\" failed to cast field \"serialNumber\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CommonName accessor autogenerated
func (s *mqlPkixName) CommonName() (string, error) {
	res, ok := s.Cache.Load("commonName")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.name\" failed: no value provided for static field \"commonName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.name\" failed to cast field \"commonName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Country accessor autogenerated
func (s *mqlPkixName) Country() ([]interface{}, error) {
	res, ok := s.Cache.Load("country")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"country\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"country\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Organization accessor autogenerated
func (s *mqlPkixName) Organization() ([]interface{}, error) {
	res, ok := s.Cache.Load("organization")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"organization\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"organization\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// OrganizationalUnit accessor autogenerated
func (s *mqlPkixName) OrganizationalUnit() ([]interface{}, error) {
	res, ok := s.Cache.Load("organizationalUnit")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"organizationalUnit\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"organizationalUnit\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Locality accessor autogenerated
func (s *mqlPkixName) Locality() ([]interface{}, error) {
	res, ok := s.Cache.Load("locality")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"locality\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"locality\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Province accessor autogenerated
func (s *mqlPkixName) Province() ([]interface{}, error) {
	res, ok := s.Cache.Load("province")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"province\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"province\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// StreetAddress accessor autogenerated
func (s *mqlPkixName) StreetAddress() ([]interface{}, error) {
	res, ok := s.Cache.Load("streetAddress")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"streetAddress\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"streetAddress\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// PostalCode accessor autogenerated
func (s *mqlPkixName) PostalCode() ([]interface{}, error) {
	res, ok := s.Cache.Load("postalCode")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"postalCode\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"postalCode\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Names accessor autogenerated
func (s *mqlPkixName) Names() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("names")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"names\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"names\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// ExtraNames accessor autogenerated
func (s *mqlPkixName) ExtraNames() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("extraNames")
	if !ok || !res.Valid {
		return nil, errors.New("\"pkix.name\" failed: no value provided for static field \"extraNames\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"pkix.name\" failed to cast field \"extraNames\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPkixName) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[pkix.name].MqlCompute")
	switch name {
	case "id":
		return nil
	case "dn":
		return nil
	case "serialNumber":
		return nil
	case "commonName":
		return nil
	case "country":
		return nil
	case "organization":
		return nil
	case "organizationalUnit":
		return nil
	case "locality":
		return nil
	case "province":
		return nil
	case "streetAddress":
		return nil
	case "postalCode":
		return nil
	case "names":
		return nil
	case "extraNames":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pkix.name\" resource")
	}
}

// PkixExtension resource interface
type PkixExtension interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Identifier() (string, error)
	Critical() (bool, error)
	Value() (string, error)
}

// mqlPkixExtension for the pkix.extension resource
type mqlPkixExtension struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPkixExtension) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the pkix.extension resource
func newPkixExtension(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPkixExtension{runtime.NewResource("pkix.extension")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "identifier":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.extension\", its \"identifier\" argument has the wrong type (expected type \"string\")")
			}
		case "critical":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"pkix.extension\", its \"critical\" argument has the wrong type (expected type \"bool\")")
			}
		case "value":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"pkix.extension\", its \"value\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"pkix.extension\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized pkix.extension with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPkixExtension) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("identifier"); !ok {
		return errors.New("Initialized \"pkix.extension\" resource without a \"identifier\". This field is required.")
	}
	if _, ok := s.Cache.Load("critical"); !ok {
		return errors.New("Initialized \"pkix.extension\" resource without a \"critical\". This field is required.")
	}
	if _, ok := s.Cache.Load("value"); !ok {
		return errors.New("Initialized \"pkix.extension\" resource without a \"value\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPkixExtension) Register(name string) error {
	log.Trace().Str("field", name).Msg("[pkix.extension].Register")
	switch name {
	case "identifier":
		return nil
	case "critical":
		return nil
	case "value":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pkix.extension\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPkixExtension) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[pkix.extension].Field")
	switch name {
	case "identifier":
		return s.Identifier()
	case "critical":
		return s.Critical()
	case "value":
		return s.Value()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"pkix.extension\" resource")
	}
}

// Identifier accessor autogenerated
func (s *mqlPkixExtension) Identifier() (string, error) {
	res, ok := s.Cache.Load("identifier")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.extension\" failed: no value provided for static field \"identifier\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.extension\" failed to cast field \"identifier\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Critical accessor autogenerated
func (s *mqlPkixExtension) Critical() (bool, error) {
	res, ok := s.Cache.Load("critical")
	if !ok || !res.Valid {
		return false, errors.New("\"pkix.extension\" failed: no value provided for static field \"critical\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"pkix.extension\" failed to cast field \"critical\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Value accessor autogenerated
func (s *mqlPkixExtension) Value() (string, error) {
	res, ok := s.Cache.Load("value")
	if !ok || !res.Valid {
		return "", errors.New("\"pkix.extension\" failed: no value provided for static field \"value\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"pkix.extension\" failed to cast field \"value\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPkixExtension) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[pkix.extension].MqlCompute")
	switch name {
	case "identifier":
		return nil
	case "critical":
		return nil
	case "value":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"pkix.extension\" resource")
	}
}

// Certificate resource interface
type Certificate interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Pem() (string, error)
	Fingerprints() (map[string]interface{}, error)
	Serial() (string, error)
	SubjectKeyID() (string, error)
	AuthorityKeyID() (string, error)
	Subject() (PkixName, error)
	Issuer() (PkixName, error)
	Version() (int64, error)
	NotBefore() (*time.Time, error)
	NotAfter() (*time.Time, error)
	ExpiresIn() (*time.Time, error)
	Signature() (string, error)
	SigningAlgorithm() (string, error)
	IsCA() (bool, error)
	KeyUsage() ([]interface{}, error)
	ExtendedKeyUsage() ([]interface{}, error)
	Extensions() ([]interface{}, error)
	PolicyIdentifier() ([]interface{}, error)
	CrlDistributionPoints() ([]interface{}, error)
	OcspServer() ([]interface{}, error)
	IssuingCertificateUrl() ([]interface{}, error)
	IsRevoked() (bool, error)
	RevokedAt() (*time.Time, error)
	IsVerified() (bool, error)
}

// mqlCertificate for the certificate resource
type mqlCertificate struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlCertificate) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the certificate resource
func newCertificate(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlCertificate{runtime.NewResource("certificate")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "pem":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"pem\" argument has the wrong type (expected type \"string\")")
			}
		case "fingerprints":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"fingerprints\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "serial":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"serial\" argument has the wrong type (expected type \"string\")")
			}
		case "subjectKeyID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"subjectKeyID\" argument has the wrong type (expected type \"string\")")
			}
		case "authorityKeyID":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"authorityKeyID\" argument has the wrong type (expected type \"string\")")
			}
		case "subject":
			if _, ok := val.(PkixName); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"subject\" argument has the wrong type (expected type \"PkixName\")")
			}
		case "issuer":
			if _, ok := val.(PkixName); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"issuer\" argument has the wrong type (expected type \"PkixName\")")
			}
		case "version":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"version\" argument has the wrong type (expected type \"int64\")")
			}
		case "notBefore":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"notBefore\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "notAfter":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"notAfter\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "expiresIn":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"expiresIn\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "signature":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"signature\" argument has the wrong type (expected type \"string\")")
			}
		case "signingAlgorithm":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"signingAlgorithm\" argument has the wrong type (expected type \"string\")")
			}
		case "isCA":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"isCA\" argument has the wrong type (expected type \"bool\")")
			}
		case "keyUsage":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"keyUsage\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "extendedKeyUsage":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"extendedKeyUsage\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "extensions":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"extensions\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "policyIdentifier":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"policyIdentifier\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "crlDistributionPoints":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"crlDistributionPoints\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "ocspServer":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"ocspServer\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "issuingCertificateUrl":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"issuingCertificateUrl\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "isRevoked":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"isRevoked\" argument has the wrong type (expected type \"bool\")")
			}
		case "revokedAt":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"revokedAt\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "isVerified":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"isVerified\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"certificate\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized certificate with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlCertificate) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("pem"); !ok {
		return errors.New("Initialized \"certificate\" resource without a \"pem\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlCertificate) Register(name string) error {
	log.Trace().Str("field", name).Msg("[certificate].Register")
	switch name {
	case "pem":
		return nil
	case "fingerprints":
		return nil
	case "serial":
		return nil
	case "subjectKeyID":
		return nil
	case "authorityKeyID":
		return nil
	case "subject":
		return nil
	case "issuer":
		return nil
	case "version":
		return nil
	case "notBefore":
		return nil
	case "notAfter":
		return nil
	case "expiresIn":
		return nil
	case "signature":
		return nil
	case "signingAlgorithm":
		return nil
	case "isCA":
		return nil
	case "keyUsage":
		return nil
	case "extendedKeyUsage":
		return nil
	case "extensions":
		return nil
	case "policyIdentifier":
		return nil
	case "crlDistributionPoints":
		return nil
	case "ocspServer":
		return nil
	case "issuingCertificateUrl":
		return nil
	case "isRevoked":
		return nil
	case "revokedAt":
		return nil
	case "isVerified":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"certificate\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlCertificate) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[certificate].Field")
	switch name {
	case "pem":
		return s.Pem()
	case "fingerprints":
		return s.Fingerprints()
	case "serial":
		return s.Serial()
	case "subjectKeyID":
		return s.SubjectKeyID()
	case "authorityKeyID":
		return s.AuthorityKeyID()
	case "subject":
		return s.Subject()
	case "issuer":
		return s.Issuer()
	case "version":
		return s.Version()
	case "notBefore":
		return s.NotBefore()
	case "notAfter":
		return s.NotAfter()
	case "expiresIn":
		return s.ExpiresIn()
	case "signature":
		return s.Signature()
	case "signingAlgorithm":
		return s.SigningAlgorithm()
	case "isCA":
		return s.IsCA()
	case "keyUsage":
		return s.KeyUsage()
	case "extendedKeyUsage":
		return s.ExtendedKeyUsage()
	case "extensions":
		return s.Extensions()
	case "policyIdentifier":
		return s.PolicyIdentifier()
	case "crlDistributionPoints":
		return s.CrlDistributionPoints()
	case "ocspServer":
		return s.OcspServer()
	case "issuingCertificateUrl":
		return s.IssuingCertificateUrl()
	case "isRevoked":
		return s.IsRevoked()
	case "revokedAt":
		return s.RevokedAt()
	case "isVerified":
		return s.IsVerified()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"certificate\" resource")
	}
}

// Pem accessor autogenerated
func (s *mqlCertificate) Pem() (string, error) {
	res, ok := s.Cache.Load("pem")
	if !ok || !res.Valid {
		return "", errors.New("\"certificate\" failed: no value provided for static field \"pem\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"pem\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Fingerprints accessor autogenerated
func (s *mqlCertificate) Fingerprints() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("fingerprints")
	if !ok || !res.Valid {
		if err := s.ComputeFingerprints(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("fingerprints")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"fingerprints\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "fingerprints")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"fingerprints\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Serial accessor autogenerated
func (s *mqlCertificate) Serial() (string, error) {
	res, ok := s.Cache.Load("serial")
	if !ok || !res.Valid {
		if err := s.ComputeSerial(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("serial")
		if !ok {
			return "", errors.New("\"certificate\" calculated \"serial\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "serial")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"serial\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SubjectKeyID accessor autogenerated
func (s *mqlCertificate) SubjectKeyID() (string, error) {
	res, ok := s.Cache.Load("subjectKeyID")
	if !ok || !res.Valid {
		if err := s.ComputeSubjectKeyID(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("subjectKeyID")
		if !ok {
			return "", errors.New("\"certificate\" calculated \"subjectKeyID\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "subjectKeyID")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"subjectKeyID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// AuthorityKeyID accessor autogenerated
func (s *mqlCertificate) AuthorityKeyID() (string, error) {
	res, ok := s.Cache.Load("authorityKeyID")
	if !ok || !res.Valid {
		if err := s.ComputeAuthorityKeyID(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("authorityKeyID")
		if !ok {
			return "", errors.New("\"certificate\" calculated \"authorityKeyID\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "authorityKeyID")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"authorityKeyID\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Subject accessor autogenerated
func (s *mqlCertificate) Subject() (PkixName, error) {
	res, ok := s.Cache.Load("subject")
	if !ok || !res.Valid {
		if err := s.ComputeSubject(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("subject")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"subject\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "subject")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(PkixName)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"subject\" to the right type (PkixName): %#v", res)
	}
	return tres, nil
}

// Issuer accessor autogenerated
func (s *mqlCertificate) Issuer() (PkixName, error) {
	res, ok := s.Cache.Load("issuer")
	if !ok || !res.Valid {
		if err := s.ComputeIssuer(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("issuer")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"issuer\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "issuer")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(PkixName)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"issuer\" to the right type (PkixName): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlCertificate) Version() (int64, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		if err := s.ComputeVersion(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("version")
		if !ok {
			return 0, errors.New("\"certificate\" calculated \"version\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "version")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"certificate\" failed to cast field \"version\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// NotBefore accessor autogenerated
func (s *mqlCertificate) NotBefore() (*time.Time, error) {
	res, ok := s.Cache.Load("notBefore")
	if !ok || !res.Valid {
		if err := s.ComputeNotBefore(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("notBefore")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"notBefore\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "notBefore")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"notBefore\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// NotAfter accessor autogenerated
func (s *mqlCertificate) NotAfter() (*time.Time, error) {
	res, ok := s.Cache.Load("notAfter")
	if !ok || !res.Valid {
		if err := s.ComputeNotAfter(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("notAfter")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"notAfter\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "notAfter")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"notAfter\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// ExpiresIn accessor autogenerated
func (s *mqlCertificate) ExpiresIn() (*time.Time, error) {
	res, ok := s.Cache.Load("expiresIn")
	if !ok || !res.Valid {
		if err := s.ComputeExpiresIn(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("expiresIn")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"expiresIn\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "expiresIn")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"expiresIn\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Signature accessor autogenerated
func (s *mqlCertificate) Signature() (string, error) {
	res, ok := s.Cache.Load("signature")
	if !ok || !res.Valid {
		if err := s.ComputeSignature(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("signature")
		if !ok {
			return "", errors.New("\"certificate\" calculated \"signature\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "signature")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"signature\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// SigningAlgorithm accessor autogenerated
func (s *mqlCertificate) SigningAlgorithm() (string, error) {
	res, ok := s.Cache.Load("signingAlgorithm")
	if !ok || !res.Valid {
		if err := s.ComputeSigningAlgorithm(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("signingAlgorithm")
		if !ok {
			return "", errors.New("\"certificate\" calculated \"signingAlgorithm\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "signingAlgorithm")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"certificate\" failed to cast field \"signingAlgorithm\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// IsCA accessor autogenerated
func (s *mqlCertificate) IsCA() (bool, error) {
	res, ok := s.Cache.Load("isCA")
	if !ok || !res.Valid {
		if err := s.ComputeIsCA(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("isCA")
		if !ok {
			return false, errors.New("\"certificate\" calculated \"isCA\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "isCA")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"certificate\" failed to cast field \"isCA\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// KeyUsage accessor autogenerated
func (s *mqlCertificate) KeyUsage() ([]interface{}, error) {
	res, ok := s.Cache.Load("keyUsage")
	if !ok || !res.Valid {
		if err := s.ComputeKeyUsage(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("keyUsage")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"keyUsage\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "keyUsage")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"keyUsage\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// ExtendedKeyUsage accessor autogenerated
func (s *mqlCertificate) ExtendedKeyUsage() ([]interface{}, error) {
	res, ok := s.Cache.Load("extendedKeyUsage")
	if !ok || !res.Valid {
		if err := s.ComputeExtendedKeyUsage(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("extendedKeyUsage")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"extendedKeyUsage\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "extendedKeyUsage")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"extendedKeyUsage\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Extensions accessor autogenerated
func (s *mqlCertificate) Extensions() ([]interface{}, error) {
	res, ok := s.Cache.Load("extensions")
	if !ok || !res.Valid {
		if err := s.ComputeExtensions(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("extensions")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"extensions\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "extensions")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"extensions\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// PolicyIdentifier accessor autogenerated
func (s *mqlCertificate) PolicyIdentifier() ([]interface{}, error) {
	res, ok := s.Cache.Load("policyIdentifier")
	if !ok || !res.Valid {
		if err := s.ComputePolicyIdentifier(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("policyIdentifier")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"policyIdentifier\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "policyIdentifier")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"policyIdentifier\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// CrlDistributionPoints accessor autogenerated
func (s *mqlCertificate) CrlDistributionPoints() ([]interface{}, error) {
	res, ok := s.Cache.Load("crlDistributionPoints")
	if !ok || !res.Valid {
		if err := s.ComputeCrlDistributionPoints(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("crlDistributionPoints")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"crlDistributionPoints\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "crlDistributionPoints")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"crlDistributionPoints\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// OcspServer accessor autogenerated
func (s *mqlCertificate) OcspServer() ([]interface{}, error) {
	res, ok := s.Cache.Load("ocspServer")
	if !ok || !res.Valid {
		if err := s.ComputeOcspServer(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("ocspServer")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"ocspServer\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "ocspServer")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"ocspServer\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// IssuingCertificateUrl accessor autogenerated
func (s *mqlCertificate) IssuingCertificateUrl() ([]interface{}, error) {
	res, ok := s.Cache.Load("issuingCertificateUrl")
	if !ok || !res.Valid {
		if err := s.ComputeIssuingCertificateUrl(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("issuingCertificateUrl")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"issuingCertificateUrl\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "issuingCertificateUrl")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"issuingCertificateUrl\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// IsRevoked accessor autogenerated
func (s *mqlCertificate) IsRevoked() (bool, error) {
	res, ok := s.Cache.Load("isRevoked")
	if !ok || !res.Valid {
		if err := s.ComputeIsRevoked(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("isRevoked")
		if !ok {
			return false, errors.New("\"certificate\" calculated \"isRevoked\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "isRevoked")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"certificate\" failed to cast field \"isRevoked\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// RevokedAt accessor autogenerated
func (s *mqlCertificate) RevokedAt() (*time.Time, error) {
	res, ok := s.Cache.Load("revokedAt")
	if !ok || !res.Valid {
		if err := s.ComputeRevokedAt(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("revokedAt")
		if !ok {
			return nil, errors.New("\"certificate\" calculated \"revokedAt\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "revokedAt")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"certificate\" failed to cast field \"revokedAt\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// IsVerified accessor autogenerated
func (s *mqlCertificate) IsVerified() (bool, error) {
	res, ok := s.Cache.Load("isVerified")
	if !ok || !res.Valid {
		if err := s.ComputeIsVerified(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("isVerified")
		if !ok {
			return false, errors.New("\"certificate\" calculated \"isVerified\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "isVerified")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"certificate\" failed to cast field \"isVerified\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlCertificate) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[certificate].MqlCompute")
	switch name {
	case "pem":
		return nil
	case "fingerprints":
		return s.ComputeFingerprints()
	case "serial":
		return s.ComputeSerial()
	case "subjectKeyID":
		return s.ComputeSubjectKeyID()
	case "authorityKeyID":
		return s.ComputeAuthorityKeyID()
	case "subject":
		return s.ComputeSubject()
	case "issuer":
		return s.ComputeIssuer()
	case "version":
		return s.ComputeVersion()
	case "notBefore":
		return s.ComputeNotBefore()
	case "notAfter":
		return s.ComputeNotAfter()
	case "expiresIn":
		return s.ComputeExpiresIn()
	case "signature":
		return s.ComputeSignature()
	case "signingAlgorithm":
		return s.ComputeSigningAlgorithm()
	case "isCA":
		return s.ComputeIsCA()
	case "keyUsage":
		return s.ComputeKeyUsage()
	case "extendedKeyUsage":
		return s.ComputeExtendedKeyUsage()
	case "extensions":
		return s.ComputeExtensions()
	case "policyIdentifier":
		return s.ComputePolicyIdentifier()
	case "crlDistributionPoints":
		return s.ComputeCrlDistributionPoints()
	case "ocspServer":
		return s.ComputeOcspServer()
	case "issuingCertificateUrl":
		return s.ComputeIssuingCertificateUrl()
	case "isRevoked":
		return s.ComputeIsRevoked()
	case "revokedAt":
		return s.ComputeRevokedAt()
	case "isVerified":
		return s.ComputeIsVerified()
	default:
		return errors.New("Cannot find field '" + name + "' in \"certificate\" resource")
	}
}

// ComputeFingerprints computer autogenerated
func (s *mqlCertificate) ComputeFingerprints() error {
	var err error
	if _, ok := s.Cache.Load("fingerprints"); ok {
		return nil
	}
	vres, err := s.GetFingerprints()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("fingerprints", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSerial computer autogenerated
func (s *mqlCertificate) ComputeSerial() error {
	var err error
	if _, ok := s.Cache.Load("serial"); ok {
		return nil
	}
	vres, err := s.GetSerial()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("serial", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSubjectKeyID computer autogenerated
func (s *mqlCertificate) ComputeSubjectKeyID() error {
	var err error
	if _, ok := s.Cache.Load("subjectKeyID"); ok {
		return nil
	}
	vres, err := s.GetSubjectKeyID()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("subjectKeyID", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeAuthorityKeyID computer autogenerated
func (s *mqlCertificate) ComputeAuthorityKeyID() error {
	var err error
	if _, ok := s.Cache.Load("authorityKeyID"); ok {
		return nil
	}
	vres, err := s.GetAuthorityKeyID()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("authorityKeyID", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSubject computer autogenerated
func (s *mqlCertificate) ComputeSubject() error {
	var err error
	if _, ok := s.Cache.Load("subject"); ok {
		return nil
	}
	vres, err := s.GetSubject()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("subject", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIssuer computer autogenerated
func (s *mqlCertificate) ComputeIssuer() error {
	var err error
	if _, ok := s.Cache.Load("issuer"); ok {
		return nil
	}
	vres, err := s.GetIssuer()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("issuer", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVersion computer autogenerated
func (s *mqlCertificate) ComputeVersion() error {
	var err error
	if _, ok := s.Cache.Load("version"); ok {
		return nil
	}
	vres, err := s.GetVersion()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("version", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeNotBefore computer autogenerated
func (s *mqlCertificate) ComputeNotBefore() error {
	var err error
	if _, ok := s.Cache.Load("notBefore"); ok {
		return nil
	}
	vres, err := s.GetNotBefore()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("notBefore", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeNotAfter computer autogenerated
func (s *mqlCertificate) ComputeNotAfter() error {
	var err error
	if _, ok := s.Cache.Load("notAfter"); ok {
		return nil
	}
	vres, err := s.GetNotAfter()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("notAfter", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExpiresIn computer autogenerated
func (s *mqlCertificate) ComputeExpiresIn() error {
	var err error
	if _, ok := s.Cache.Load("expiresIn"); ok {
		return nil
	}
	vres, err := s.GetExpiresIn()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("expiresIn", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSignature computer autogenerated
func (s *mqlCertificate) ComputeSignature() error {
	var err error
	if _, ok := s.Cache.Load("signature"); ok {
		return nil
	}
	vres, err := s.GetSignature()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("signature", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeSigningAlgorithm computer autogenerated
func (s *mqlCertificate) ComputeSigningAlgorithm() error {
	var err error
	if _, ok := s.Cache.Load("signingAlgorithm"); ok {
		return nil
	}
	vres, err := s.GetSigningAlgorithm()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("signingAlgorithm", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIsCA computer autogenerated
func (s *mqlCertificate) ComputeIsCA() error {
	var err error
	if _, ok := s.Cache.Load("isCA"); ok {
		return nil
	}
	vres, err := s.GetIsCA()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("isCA", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeKeyUsage computer autogenerated
func (s *mqlCertificate) ComputeKeyUsage() error {
	var err error
	if _, ok := s.Cache.Load("keyUsage"); ok {
		return nil
	}
	vres, err := s.GetKeyUsage()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("keyUsage", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExtendedKeyUsage computer autogenerated
func (s *mqlCertificate) ComputeExtendedKeyUsage() error {
	var err error
	if _, ok := s.Cache.Load("extendedKeyUsage"); ok {
		return nil
	}
	vres, err := s.GetExtendedKeyUsage()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("extendedKeyUsage", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeExtensions computer autogenerated
func (s *mqlCertificate) ComputeExtensions() error {
	var err error
	if _, ok := s.Cache.Load("extensions"); ok {
		return nil
	}
	vres, err := s.GetExtensions()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("extensions", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputePolicyIdentifier computer autogenerated
func (s *mqlCertificate) ComputePolicyIdentifier() error {
	var err error
	if _, ok := s.Cache.Load("policyIdentifier"); ok {
		return nil
	}
	vres, err := s.GetPolicyIdentifier()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("policyIdentifier", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeCrlDistributionPoints computer autogenerated
func (s *mqlCertificate) ComputeCrlDistributionPoints() error {
	var err error
	if _, ok := s.Cache.Load("crlDistributionPoints"); ok {
		return nil
	}
	vres, err := s.GetCrlDistributionPoints()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("crlDistributionPoints", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOcspServer computer autogenerated
func (s *mqlCertificate) ComputeOcspServer() error {
	var err error
	if _, ok := s.Cache.Load("ocspServer"); ok {
		return nil
	}
	vres, err := s.GetOcspServer()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("ocspServer", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIssuingCertificateUrl computer autogenerated
func (s *mqlCertificate) ComputeIssuingCertificateUrl() error {
	var err error
	if _, ok := s.Cache.Load("issuingCertificateUrl"); ok {
		return nil
	}
	vres, err := s.GetIssuingCertificateUrl()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("issuingCertificateUrl", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIsRevoked computer autogenerated
func (s *mqlCertificate) ComputeIsRevoked() error {
	var err error
	if _, ok := s.Cache.Load("isRevoked"); ok {
		return nil
	}
	vres, err := s.GetIsRevoked()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("isRevoked", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeRevokedAt computer autogenerated
func (s *mqlCertificate) ComputeRevokedAt() error {
	var err error
	if _, ok := s.Cache.Load("revokedAt"); ok {
		return nil
	}
	vres, err := s.GetRevokedAt()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("revokedAt", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeIsVerified computer autogenerated
func (s *mqlCertificate) ComputeIsVerified() error {
	var err error
	if _, ok := s.Cache.Load("isVerified"); ok {
		return nil
	}
	vres, err := s.GetIsVerified()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("isVerified", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Privatekey resource interface
type Privatekey interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Pem() (string, error)
	Path() (string, error)
	Encrypted() (bool, error)
}

// mqlPrivatekey for the privatekey resource
type mqlPrivatekey struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPrivatekey) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the privatekey resource
func newPrivatekey(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPrivatekey{runtime.NewResource("privatekey")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "pem":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"privatekey\", its \"pem\" argument has the wrong type (expected type \"string\")")
			}
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"privatekey\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "encrypted":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"privatekey\", its \"encrypted\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"privatekey\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized privatekey with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPrivatekey) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("pem"); !ok {
		return errors.New("Initialized \"privatekey\" resource without a \"pem\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPrivatekey) Register(name string) error {
	log.Trace().Str("field", name).Msg("[privatekey].Register")
	switch name {
	case "pem":
		return nil
	case "path":
		return nil
	case "encrypted":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"privatekey\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPrivatekey) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[privatekey].Field")
	switch name {
	case "pem":
		return s.Pem()
	case "path":
		return s.Path()
	case "encrypted":
		return s.Encrypted()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"privatekey\" resource")
	}
}

// Pem accessor autogenerated
func (s *mqlPrivatekey) Pem() (string, error) {
	res, ok := s.Cache.Load("pem")
	if !ok || !res.Valid {
		return "", errors.New("\"privatekey\" failed: no value provided for static field \"pem\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"privatekey\" failed to cast field \"pem\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Path accessor autogenerated
func (s *mqlPrivatekey) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		if err := s.ComputePath(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("path")
		if !ok {
			return "", errors.New("\"privatekey\" calculated \"path\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "path")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"privatekey\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Encrypted accessor autogenerated
func (s *mqlPrivatekey) Encrypted() (bool, error) {
	res, ok := s.Cache.Load("encrypted")
	if !ok || !res.Valid {
		if err := s.ComputeEncrypted(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("encrypted")
		if !ok {
			return false, errors.New("\"privatekey\" calculated \"encrypted\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "encrypted")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"privatekey\" failed to cast field \"encrypted\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPrivatekey) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[privatekey].MqlCompute")
	switch name {
	case "pem":
		return nil
	case "path":
		return s.ComputePath()
	case "encrypted":
		return s.ComputeEncrypted()
	default:
		return errors.New("Cannot find field '" + name + "' in \"privatekey\" resource")
	}
}

// ComputePath computer autogenerated
func (s *mqlPrivatekey) ComputePath() error {
	var err error
	if _, ok := s.Cache.Load("path"); ok {
		return nil
	}
	vres, err := s.GetPath()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("path", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeEncrypted computer autogenerated
func (s *mqlPrivatekey) ComputeEncrypted() error {
	var err error
	if _, ok := s.Cache.Load("encrypted"); ok {
		return nil
	}
	vres, err := s.GetEncrypted()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("encrypted", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ParseOpenpgp resource interface
type ParseOpenpgp interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Path() (string, error)
	File() (File, error)
	Content() (string, error)
	List() ([]interface{}, error)
}

// mqlParseOpenpgp for the parse.openpgp resource
type mqlParseOpenpgp struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlParseOpenpgp) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the parse.openpgp resource
func newParseOpenpgp(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlParseOpenpgp{runtime.NewResource("parse.openpgp")}
	var existing ParseOpenpgp
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "path":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.openpgp\", its \"path\" argument has the wrong type (expected type \"string\")")
			}
		case "file":
			if _, ok := val.(File); !ok {
				return nil, errors.New("Failed to initialize \"parse.openpgp\", its \"file\" argument has the wrong type (expected type \"File\")")
			}
		case "content":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"parse.openpgp\", its \"content\" argument has the wrong type (expected type \"string\")")
			}
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"parse.openpgp\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"parse.openpgp\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized parse.openpgp with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlParseOpenpgp) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("path"); !ok {
		return errors.New("Initialized \"parse.openpgp\" resource without a \"path\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlParseOpenpgp) Register(name string) error {
	log.Trace().Str("field", name).Msg("[parse.openpgp].Register")
	switch name {
	case "path":
		return nil
	case "file":
		return nil
	case "content":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "file", s, "content"); err != nil {
			return err
		}
		return nil
	case "list":
		var err error
		if err = s.MotorRuntime.WatchAndCompute(s, "content", s, "list"); err != nil {
			return err
		}

		if err = s.MotorRuntime.WatchAndCompute(s, "path", s, "list"); err != nil {
			return err
		}
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.openpgp\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlParseOpenpgp) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[parse.openpgp].Field")
	switch name {
	case "path":
		return s.Path()
	case "file":
		return s.File()
	case "content":
		return s.Content()
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"parse.openpgp\" resource")
	}
}

// Path accessor autogenerated
func (s *mqlParseOpenpgp) Path() (string, error) {
	res, ok := s.Cache.Load("path")
	if !ok || !res.Valid {
		return "", errors.New("\"parse.openpgp\" failed: no value provided for static field \"path\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.openpgp\" failed to cast field \"path\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// File accessor autogenerated
func (s *mqlParseOpenpgp) File() (File, error) {
	res, ok := s.Cache.Load("file")
	if !ok || !res.Valid {
		if err := s.ComputeFile(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("file")
		if !ok {
			return nil, errors.New("\"parse.openpgp\" calculated \"file\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "file")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(File)
	if !ok {
		return nil, fmt.Errorf("\"parse.openpgp\" failed to cast field \"file\" to the right type (File): %#v", res)
	}
	return tres, nil
}

// Content accessor autogenerated
func (s *mqlParseOpenpgp) Content() (string, error) {
	res, ok := s.Cache.Load("content")
	if !ok || !res.Valid {
		return "", resources.NotReadyError{}
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"parse.openpgp\" failed to cast field \"content\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// List accessor autogenerated
func (s *mqlParseOpenpgp) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		return nil, resources.NotReadyError{}
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"parse.openpgp\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlParseOpenpgp) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[parse.openpgp].MqlCompute")
	switch name {
	case "path":
		return nil
	case "file":
		return s.ComputeFile()
	case "content":
		return s.ComputeContent()
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"parse.openpgp\" resource")
	}
}

// ComputeFile computer autogenerated
func (s *mqlParseOpenpgp) ComputeFile() error {
	var err error
	if _, ok := s.Cache.Load("file"); ok {
		return nil
	}
	vres, err := s.GetFile()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("file", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeContent computer autogenerated
func (s *mqlParseOpenpgp) ComputeContent() error {
	var err error
	vargFile, err := s.File()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("content", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetContent(vargFile)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("content", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeList computer autogenerated
func (s *mqlParseOpenpgp) ComputeList() error {
	var err error
	vargContent, err := s.Content()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vargPath, err := s.Path()
	if err != nil {
		if _, ok := err.(resources.NotReadyError); ok {
			return err
		}
		s.Cache.Store("list", &resources.CacheEntry{Valid: true, Error: err, Timestamp: time.Now().Unix()})
		return nil
	}
	vres, err := s.GetList(vargContent, vargPath)
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OpenpgpEntity resource interface
type OpenpgpEntity interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	PrimaryPublicKey() (OpenpgpPublicKey, error)
	Identities() ([]interface{}, error)
}

// mqlOpenpgpEntity for the openpgp.entity resource
type mqlOpenpgpEntity struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOpenpgpEntity) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the openpgp.entity resource
func newOpenpgpEntity(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOpenpgpEntity{runtime.NewResource("openpgp.entity")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "primaryPublicKey":
			if _, ok := val.(OpenpgpPublicKey); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.entity\", its \"primaryPublicKey\" argument has the wrong type (expected type \"OpenpgpPublicKey\")")
			}
		case "identities":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.entity\", its \"identities\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"openpgp.entity\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized openpgp.entity with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOpenpgpEntity) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("primaryPublicKey"); !ok {
		return errors.New("Initialized \"openpgp.entity\" resource without a \"primaryPublicKey\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlOpenpgpEntity) Register(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.entity].Register")
	switch name {
	case "primaryPublicKey":
		return nil
	case "identities":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.entity\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOpenpgpEntity) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[openpgp.entity].Field")
	switch name {
	case "primaryPublicKey":
		return s.PrimaryPublicKey()
	case "identities":
		return s.Identities()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"openpgp.entity\" resource")
	}
}

// PrimaryPublicKey accessor autogenerated
func (s *mqlOpenpgpEntity) PrimaryPublicKey() (OpenpgpPublicKey, error) {
	res, ok := s.Cache.Load("primaryPublicKey")
	if !ok || !res.Valid {
		return nil, errors.New("\"openpgp.entity\" failed: no value provided for static field \"primaryPublicKey\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(OpenpgpPublicKey)
	if !ok {
		return nil, fmt.Errorf("\"openpgp.entity\" failed to cast field \"primaryPublicKey\" to the right type (OpenpgpPublicKey): %#v", res)
	}
	return tres, nil
}

// Identities accessor autogenerated
func (s *mqlOpenpgpEntity) Identities() ([]interface{}, error) {
	res, ok := s.Cache.Load("identities")
	if !ok || !res.Valid {
		if err := s.ComputeIdentities(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("identities")
		if !ok {
			return nil, errors.New("\"openpgp.entity\" calculated \"identities\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "identities")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"openpgp.entity\" failed to cast field \"identities\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOpenpgpEntity) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.entity].MqlCompute")
	switch name {
	case "primaryPublicKey":
		return nil
	case "identities":
		return s.ComputeIdentities()
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.entity\" resource")
	}
}

// ComputeIdentities computer autogenerated
func (s *mqlOpenpgpEntity) ComputeIdentities() error {
	var err error
	if _, ok := s.Cache.Load("identities"); ok {
		return nil
	}
	vres, err := s.GetIdentities()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("identities", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OpenpgpPublicKey resource interface
type OpenpgpPublicKey interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Id() (string, error)
	Version() (int64, error)
	Fingerprint() (string, error)
	KeyAlgorithm() (string, error)
	BitLength() (int64, error)
	CreationTime() (*time.Time, error)
}

// mqlOpenpgpPublicKey for the openpgp.publicKey resource
type mqlOpenpgpPublicKey struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOpenpgpPublicKey) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the openpgp.publicKey resource
func newOpenpgpPublicKey(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOpenpgpPublicKey{runtime.NewResource("openpgp.publicKey")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"version\" argument has the wrong type (expected type \"int64\")")
			}
		case "fingerprint":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"fingerprint\" argument has the wrong type (expected type \"string\")")
			}
		case "keyAlgorithm":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"keyAlgorithm\" argument has the wrong type (expected type \"string\")")
			}
		case "bitLength":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"bitLength\" argument has the wrong type (expected type \"int64\")")
			}
		case "creationTime":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"creationTime\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"openpgp.publicKey\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized openpgp.publicKey with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOpenpgpPublicKey) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("fingerprint"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"fingerprint\". This field is required.")
	}
	if _, ok := s.Cache.Load("keyAlgorithm"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"keyAlgorithm\". This field is required.")
	}
	if _, ok := s.Cache.Load("bitLength"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"bitLength\". This field is required.")
	}
	if _, ok := s.Cache.Load("creationTime"); !ok {
		return errors.New("Initialized \"openpgp.publicKey\" resource without a \"creationTime\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlOpenpgpPublicKey) Register(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.publicKey].Register")
	switch name {
	case "id":
		return nil
	case "version":
		return nil
	case "fingerprint":
		return nil
	case "keyAlgorithm":
		return nil
	case "bitLength":
		return nil
	case "creationTime":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.publicKey\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOpenpgpPublicKey) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[openpgp.publicKey].Field")
	switch name {
	case "id":
		return s.Id()
	case "version":
		return s.Version()
	case "fingerprint":
		return s.Fingerprint()
	case "keyAlgorithm":
		return s.KeyAlgorithm()
	case "bitLength":
		return s.BitLength()
	case "creationTime":
		return s.CreationTime()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"openpgp.publicKey\" resource")
	}
}

// Id accessor autogenerated
func (s *mqlOpenpgpPublicKey) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlOpenpgpPublicKey) Version() (int64, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return 0, errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"version\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Fingerprint accessor autogenerated
func (s *mqlOpenpgpPublicKey) Fingerprint() (string, error) {
	res, ok := s.Cache.Load("fingerprint")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"fingerprint\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"fingerprint\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// KeyAlgorithm accessor autogenerated
func (s *mqlOpenpgpPublicKey) KeyAlgorithm() (string, error) {
	res, ok := s.Cache.Load("keyAlgorithm")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"keyAlgorithm\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"keyAlgorithm\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// BitLength accessor autogenerated
func (s *mqlOpenpgpPublicKey) BitLength() (int64, error) {
	res, ok := s.Cache.Load("bitLength")
	if !ok || !res.Valid {
		return 0, errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"bitLength\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"bitLength\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// CreationTime accessor autogenerated
func (s *mqlOpenpgpPublicKey) CreationTime() (*time.Time, error) {
	res, ok := s.Cache.Load("creationTime")
	if !ok || !res.Valid {
		return nil, errors.New("\"openpgp.publicKey\" failed: no value provided for static field \"creationTime\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"openpgp.publicKey\" failed to cast field \"creationTime\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOpenpgpPublicKey) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.publicKey].MqlCompute")
	switch name {
	case "id":
		return nil
	case "version":
		return nil
	case "fingerprint":
		return nil
	case "keyAlgorithm":
		return nil
	case "bitLength":
		return nil
	case "creationTime":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.publicKey\" resource")
	}
}

// OpenpgpIdentity resource interface
type OpenpgpIdentity interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Fingerprint() (string, error)
	Id() (string, error)
	Name() (string, error)
	Email() (string, error)
	Comment() (string, error)
	Signatures() ([]interface{}, error)
}

// mqlOpenpgpIdentity for the openpgp.identity resource
type mqlOpenpgpIdentity struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOpenpgpIdentity) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the openpgp.identity resource
func newOpenpgpIdentity(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOpenpgpIdentity{runtime.NewResource("openpgp.identity")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "fingerprint":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"fingerprint\" argument has the wrong type (expected type \"string\")")
			}
		case "id":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"id\" argument has the wrong type (expected type \"string\")")
			}
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "email":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"email\" argument has the wrong type (expected type \"string\")")
			}
		case "comment":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"comment\" argument has the wrong type (expected type \"string\")")
			}
		case "signatures":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"signatures\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"openpgp.identity\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized openpgp.identity with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOpenpgpIdentity) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("fingerprint"); !ok {
		return errors.New("Initialized \"openpgp.identity\" resource without a \"fingerprint\". This field is required.")
	}
	if _, ok := s.Cache.Load("id"); !ok {
		return errors.New("Initialized \"openpgp.identity\" resource without a \"id\". This field is required.")
	}
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"openpgp.identity\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("email"); !ok {
		return errors.New("Initialized \"openpgp.identity\" resource without a \"email\". This field is required.")
	}
	if _, ok := s.Cache.Load("comment"); !ok {
		return errors.New("Initialized \"openpgp.identity\" resource without a \"comment\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlOpenpgpIdentity) Register(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.identity].Register")
	switch name {
	case "fingerprint":
		return nil
	case "id":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "comment":
		return nil
	case "signatures":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.identity\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOpenpgpIdentity) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[openpgp.identity].Field")
	switch name {
	case "fingerprint":
		return s.Fingerprint()
	case "id":
		return s.Id()
	case "name":
		return s.Name()
	case "email":
		return s.Email()
	case "comment":
		return s.Comment()
	case "signatures":
		return s.Signatures()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"openpgp.identity\" resource")
	}
}

// Fingerprint accessor autogenerated
func (s *mqlOpenpgpIdentity) Fingerprint() (string, error) {
	res, ok := s.Cache.Load("fingerprint")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.identity\" failed: no value provided for static field \"fingerprint\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.identity\" failed to cast field \"fingerprint\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Id accessor autogenerated
func (s *mqlOpenpgpIdentity) Id() (string, error) {
	res, ok := s.Cache.Load("id")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.identity\" failed: no value provided for static field \"id\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.identity\" failed to cast field \"id\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Name accessor autogenerated
func (s *mqlOpenpgpIdentity) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.identity\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.identity\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Email accessor autogenerated
func (s *mqlOpenpgpIdentity) Email() (string, error) {
	res, ok := s.Cache.Load("email")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.identity\" failed: no value provided for static field \"email\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.identity\" failed to cast field \"email\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Comment accessor autogenerated
func (s *mqlOpenpgpIdentity) Comment() (string, error) {
	res, ok := s.Cache.Load("comment")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.identity\" failed: no value provided for static field \"comment\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.identity\" failed to cast field \"comment\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Signatures accessor autogenerated
func (s *mqlOpenpgpIdentity) Signatures() ([]interface{}, error) {
	res, ok := s.Cache.Load("signatures")
	if !ok || !res.Valid {
		if err := s.ComputeSignatures(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("signatures")
		if !ok {
			return nil, errors.New("\"openpgp.identity\" calculated \"signatures\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "signatures")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"openpgp.identity\" failed to cast field \"signatures\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOpenpgpIdentity) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.identity].MqlCompute")
	switch name {
	case "fingerprint":
		return nil
	case "id":
		return nil
	case "name":
		return nil
	case "email":
		return nil
	case "comment":
		return nil
	case "signatures":
		return s.ComputeSignatures()
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.identity\" resource")
	}
}

// ComputeSignatures computer autogenerated
func (s *mqlOpenpgpIdentity) ComputeSignatures() error {
	var err error
	if _, ok := s.Cache.Load("signatures"); ok {
		return nil
	}
	vres, err := s.GetSignatures()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("signatures", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// OpenpgpSignature resource interface
type OpenpgpSignature interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Fingerprint() (string, error)
	IdentityName() (string, error)
	Hash() (string, error)
	Version() (int64, error)
	SignatureType() (string, error)
	KeyAlgorithm() (string, error)
	CreationTime() (*time.Time, error)
	LifetimeSecs() (int64, error)
	ExpiresIn() (*time.Time, error)
	KeyLifetimeSecs() (int64, error)
	KeyExpiresIn() (*time.Time, error)
}

// mqlOpenpgpSignature for the openpgp.signature resource
type mqlOpenpgpSignature struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlOpenpgpSignature) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the openpgp.signature resource
func newOpenpgpSignature(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlOpenpgpSignature{runtime.NewResource("openpgp.signature")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "fingerprint":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"fingerprint\" argument has the wrong type (expected type \"string\")")
			}
		case "identityName":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"identityName\" argument has the wrong type (expected type \"string\")")
			}
		case "hash":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"hash\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"version\" argument has the wrong type (expected type \"int64\")")
			}
		case "signatureType":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"signatureType\" argument has the wrong type (expected type \"string\")")
			}
		case "keyAlgorithm":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"keyAlgorithm\" argument has the wrong type (expected type \"string\")")
			}
		case "creationTime":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"creationTime\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "lifetimeSecs":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"lifetimeSecs\" argument has the wrong type (expected type \"int64\")")
			}
		case "expiresIn":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"expiresIn\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "keyLifetimeSecs":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"keyLifetimeSecs\" argument has the wrong type (expected type \"int64\")")
			}
		case "keyExpiresIn":
			if _, ok := val.(*time.Time); !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"keyExpiresIn\" argument has the wrong type (expected type \"*time.Time\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"openpgp.signature\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized openpgp.signature with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlOpenpgpSignature) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("fingerprint"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"fingerprint\". This field is required.")
	}
	if _, ok := s.Cache.Load("identityName"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"identityName\". This field is required.")
	}
	if _, ok := s.Cache.Load("hash"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"hash\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("signatureType"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"signatureType\". This field is required.")
	}
	if _, ok := s.Cache.Load("keyAlgorithm"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"keyAlgorithm\". This field is required.")
	}
	if _, ok := s.Cache.Load("creationTime"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"creationTime\". This field is required.")
	}
	if _, ok := s.Cache.Load("lifetimeSecs"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"lifetimeSecs\". This field is required.")
	}
	if _, ok := s.Cache.Load("expiresIn"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"expiresIn\". This field is required.")
	}
	if _, ok := s.Cache.Load("keyLifetimeSecs"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"keyLifetimeSecs\". This field is required.")
	}
	if _, ok := s.Cache.Load("keyExpiresIn"); !ok {
		return errors.New("Initialized \"openpgp.signature\" resource without a \"keyExpiresIn\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlOpenpgpSignature) Register(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.signature].Register")
	switch name {
	case "fingerprint":
		return nil
	case "identityName":
		return nil
	case "hash":
		return nil
	case "version":
		return nil
	case "signatureType":
		return nil
	case "keyAlgorithm":
		return nil
	case "creationTime":
		return nil
	case "lifetimeSecs":
		return nil
	case "expiresIn":
		return nil
	case "keyLifetimeSecs":
		return nil
	case "keyExpiresIn":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.signature\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlOpenpgpSignature) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[openpgp.signature].Field")
	switch name {
	case "fingerprint":
		return s.Fingerprint()
	case "identityName":
		return s.IdentityName()
	case "hash":
		return s.Hash()
	case "version":
		return s.Version()
	case "signatureType":
		return s.SignatureType()
	case "keyAlgorithm":
		return s.KeyAlgorithm()
	case "creationTime":
		return s.CreationTime()
	case "lifetimeSecs":
		return s.LifetimeSecs()
	case "expiresIn":
		return s.ExpiresIn()
	case "keyLifetimeSecs":
		return s.KeyLifetimeSecs()
	case "keyExpiresIn":
		return s.KeyExpiresIn()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"openpgp.signature\" resource")
	}
}

// Fingerprint accessor autogenerated
func (s *mqlOpenpgpSignature) Fingerprint() (string, error) {
	res, ok := s.Cache.Load("fingerprint")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.signature\" failed: no value provided for static field \"fingerprint\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.signature\" failed to cast field \"fingerprint\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// IdentityName accessor autogenerated
func (s *mqlOpenpgpSignature) IdentityName() (string, error) {
	res, ok := s.Cache.Load("identityName")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.signature\" failed: no value provided for static field \"identityName\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.signature\" failed to cast field \"identityName\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Hash accessor autogenerated
func (s *mqlOpenpgpSignature) Hash() (string, error) {
	res, ok := s.Cache.Load("hash")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.signature\" failed: no value provided for static field \"hash\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.signature\" failed to cast field \"hash\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlOpenpgpSignature) Version() (int64, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return 0, errors.New("\"openpgp.signature\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"openpgp.signature\" failed to cast field \"version\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// SignatureType accessor autogenerated
func (s *mqlOpenpgpSignature) SignatureType() (string, error) {
	res, ok := s.Cache.Load("signatureType")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.signature\" failed: no value provided for static field \"signatureType\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.signature\" failed to cast field \"signatureType\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// KeyAlgorithm accessor autogenerated
func (s *mqlOpenpgpSignature) KeyAlgorithm() (string, error) {
	res, ok := s.Cache.Load("keyAlgorithm")
	if !ok || !res.Valid {
		return "", errors.New("\"openpgp.signature\" failed: no value provided for static field \"keyAlgorithm\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"openpgp.signature\" failed to cast field \"keyAlgorithm\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// CreationTime accessor autogenerated
func (s *mqlOpenpgpSignature) CreationTime() (*time.Time, error) {
	res, ok := s.Cache.Load("creationTime")
	if !ok || !res.Valid {
		return nil, errors.New("\"openpgp.signature\" failed: no value provided for static field \"creationTime\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"openpgp.signature\" failed to cast field \"creationTime\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// LifetimeSecs accessor autogenerated
func (s *mqlOpenpgpSignature) LifetimeSecs() (int64, error) {
	res, ok := s.Cache.Load("lifetimeSecs")
	if !ok || !res.Valid {
		return 0, errors.New("\"openpgp.signature\" failed: no value provided for static field \"lifetimeSecs\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"openpgp.signature\" failed to cast field \"lifetimeSecs\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// ExpiresIn accessor autogenerated
func (s *mqlOpenpgpSignature) ExpiresIn() (*time.Time, error) {
	res, ok := s.Cache.Load("expiresIn")
	if !ok || !res.Valid {
		return nil, errors.New("\"openpgp.signature\" failed: no value provided for static field \"expiresIn\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"openpgp.signature\" failed to cast field \"expiresIn\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// KeyLifetimeSecs accessor autogenerated
func (s *mqlOpenpgpSignature) KeyLifetimeSecs() (int64, error) {
	res, ok := s.Cache.Load("keyLifetimeSecs")
	if !ok || !res.Valid {
		return 0, errors.New("\"openpgp.signature\" failed: no value provided for static field \"keyLifetimeSecs\"")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"openpgp.signature\" failed to cast field \"keyLifetimeSecs\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// KeyExpiresIn accessor autogenerated
func (s *mqlOpenpgpSignature) KeyExpiresIn() (*time.Time, error) {
	res, ok := s.Cache.Load("keyExpiresIn")
	if !ok || !res.Valid {
		return nil, errors.New("\"openpgp.signature\" failed: no value provided for static field \"keyExpiresIn\"")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(*time.Time)
	if !ok {
		return nil, fmt.Errorf("\"openpgp.signature\" failed to cast field \"keyExpiresIn\" to the right type (*time.Time): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlOpenpgpSignature) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[openpgp.signature].MqlCompute")
	switch name {
	case "fingerprint":
		return nil
	case "identityName":
		return nil
	case "hash":
		return nil
	case "version":
		return nil
	case "signatureType":
		return nil
	case "keyAlgorithm":
		return nil
	case "creationTime":
		return nil
	case "lifetimeSecs":
		return nil
	case "expiresIn":
		return nil
	case "keyLifetimeSecs":
		return nil
	case "keyExpiresIn":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"openpgp.signature\" resource")
	}
}

// Uuid resource interface
type Uuid interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Value() (string, error)
	Urn() (string, error)
	Version() (int64, error)
	Variant() (string, error)
}

// mqlUuid for the uuid resource
type mqlUuid struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlUuid) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the uuid resource
func newUuid(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlUuid{runtime.NewResource("uuid")}
	var existing Uuid
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "value":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"uuid\", its \"value\" argument has the wrong type (expected type \"string\")")
			}
		case "urn":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"uuid\", its \"urn\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(int64); !ok {
				return nil, errors.New("Failed to initialize \"uuid\", its \"version\" argument has the wrong type (expected type \"int64\")")
			}
		case "variant":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"uuid\", its \"variant\" argument has the wrong type (expected type \"string\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"uuid\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized uuid with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlUuid) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("value"); !ok {
		return errors.New("Initialized \"uuid\" resource without a \"value\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlUuid) Register(name string) error {
	log.Trace().Str("field", name).Msg("[uuid].Register")
	switch name {
	case "value":
		return nil
	case "urn":
		return nil
	case "version":
		return nil
	case "variant":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"uuid\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlUuid) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[uuid].Field")
	switch name {
	case "value":
		return s.Value()
	case "urn":
		return s.Urn()
	case "version":
		return s.Version()
	case "variant":
		return s.Variant()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"uuid\" resource")
	}
}

// Value accessor autogenerated
func (s *mqlUuid) Value() (string, error) {
	res, ok := s.Cache.Load("value")
	if !ok || !res.Valid {
		return "", errors.New("\"uuid\" failed: no value provided for static field \"value\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"uuid\" failed to cast field \"value\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Urn accessor autogenerated
func (s *mqlUuid) Urn() (string, error) {
	res, ok := s.Cache.Load("urn")
	if !ok || !res.Valid {
		if err := s.ComputeUrn(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("urn")
		if !ok {
			return "", errors.New("\"uuid\" calculated \"urn\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "urn")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"uuid\" failed to cast field \"urn\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlUuid) Version() (int64, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		if err := s.ComputeVersion(); err != nil {
			return 0, err
		}
		res, ok = s.Cache.Load("version")
		if !ok {
			return 0, errors.New("\"uuid\" calculated \"version\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "version")
	}
	if res.Error != nil {
		return 0, res.Error
	}
	tres, ok := res.Data.(int64)
	if !ok {
		return 0, fmt.Errorf("\"uuid\" failed to cast field \"version\" to the right type (int64): %#v", res)
	}
	return tres, nil
}

// Variant accessor autogenerated
func (s *mqlUuid) Variant() (string, error) {
	res, ok := s.Cache.Load("variant")
	if !ok || !res.Valid {
		if err := s.ComputeVariant(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("variant")
		if !ok {
			return "", errors.New("\"uuid\" calculated \"variant\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "variant")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"uuid\" failed to cast field \"variant\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlUuid) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[uuid].MqlCompute")
	switch name {
	case "value":
		return nil
	case "urn":
		return s.ComputeUrn()
	case "version":
		return s.ComputeVersion()
	case "variant":
		return s.ComputeVariant()
	default:
		return errors.New("Cannot find field '" + name + "' in \"uuid\" resource")
	}
}

// ComputeUrn computer autogenerated
func (s *mqlUuid) ComputeUrn() error {
	var err error
	if _, ok := s.Cache.Load("urn"); ok {
		return nil
	}
	vres, err := s.GetUrn()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("urn", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVersion computer autogenerated
func (s *mqlUuid) ComputeVersion() error {
	var err error
	if _, ok := s.Cache.Load("version"); ok {
		return nil
	}
	vres, err := s.GetVersion()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("version", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeVariant computer autogenerated
func (s *mqlUuid) ComputeVariant() error {
	var err error
	if _, ok := s.Cache.Load("variant"); ok {
		return nil
	}
	vres, err := s.GetVariant()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("variant", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Socketstats resource interface
type Socketstats interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	OpenPorts() ([]interface{}, error)
}

// mqlSocketstats for the socketstats resource
type mqlSocketstats struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlSocketstats) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the socketstats resource
func newSocketstats(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlSocketstats{runtime.NewResource("socketstats")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "openPorts":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"socketstats\", its \"openPorts\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"socketstats\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized socketstats with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlSocketstats) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlSocketstats) Register(name string) error {
	log.Trace().Str("field", name).Msg("[socketstats].Register")
	switch name {
	case "openPorts":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"socketstats\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlSocketstats) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[socketstats].Field")
	switch name {
	case "openPorts":
		return s.OpenPorts()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"socketstats\" resource")
	}
}

// OpenPorts accessor autogenerated
func (s *mqlSocketstats) OpenPorts() ([]interface{}, error) {
	res, ok := s.Cache.Load("openPorts")
	if !ok || !res.Valid {
		if err := s.ComputeOpenPorts(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("openPorts")
		if !ok {
			return nil, errors.New("\"socketstats\" calculated \"openPorts\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "openPorts")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"socketstats\" failed to cast field \"openPorts\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlSocketstats) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[socketstats].MqlCompute")
	switch name {
	case "openPorts":
		return s.ComputeOpenPorts()
	default:
		return errors.New("Cannot find field '" + name + "' in \"socketstats\" resource")
	}
}

// ComputeOpenPorts computer autogenerated
func (s *mqlSocketstats) ComputeOpenPorts() error {
	var err error
	if _, ok := s.Cache.Load("openPorts"); ok {
		return nil
	}
	vres, err := s.GetOpenPorts()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("openPorts", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Kernel resource interface
type Kernel interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Info() (interface{}, error)
	Parameters() (map[string]interface{}, error)
	Modules() ([]interface{}, error)
	Installed() ([]interface{}, error)
}

// mqlKernel for the kernel resource
type mqlKernel struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlKernel) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the kernel resource
func newKernel(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlKernel{runtime.NewResource("kernel")}
	var existing Kernel
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "info":
			if _, ok := val.(interface{}); !ok {
				return nil, errors.New("Failed to initialize \"kernel\", its \"info\" argument has the wrong type (expected type \"interface{}\")")
			}
		case "parameters":
			if _, ok := val.(map[string]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"kernel\", its \"parameters\" argument has the wrong type (expected type \"map[string]interface{}\")")
			}
		case "modules":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"kernel\", its \"modules\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "installed":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"kernel\", its \"installed\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"kernel\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized kernel with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlKernel) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlKernel) Register(name string) error {
	log.Trace().Str("field", name).Msg("[kernel].Register")
	switch name {
	case "info":
		return nil
	case "parameters":
		return nil
	case "modules":
		return nil
	case "installed":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"kernel\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlKernel) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[kernel].Field")
	switch name {
	case "info":
		return s.Info()
	case "parameters":
		return s.Parameters()
	case "modules":
		return s.Modules()
	case "installed":
		return s.Installed()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"kernel\" resource")
	}
}

// Info accessor autogenerated
func (s *mqlKernel) Info() (interface{}, error) {
	res, ok := s.Cache.Load("info")
	if !ok || !res.Valid {
		if err := s.ComputeInfo(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("info")
		if !ok {
			return nil, errors.New("\"kernel\" calculated \"info\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "info")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(interface{})
	if !ok {
		return nil, fmt.Errorf("\"kernel\" failed to cast field \"info\" to the right type (interface{}): %#v", res)
	}
	return tres, nil
}

// Parameters accessor autogenerated
func (s *mqlKernel) Parameters() (map[string]interface{}, error) {
	res, ok := s.Cache.Load("parameters")
	if !ok || !res.Valid {
		if err := s.ComputeParameters(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("parameters")
		if !ok {
			return nil, errors.New("\"kernel\" calculated \"parameters\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "parameters")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("\"kernel\" failed to cast field \"parameters\" to the right type (map[string]interface{}): %#v", res)
	}
	return tres, nil
}

// Modules accessor autogenerated
func (s *mqlKernel) Modules() ([]interface{}, error) {
	res, ok := s.Cache.Load("modules")
	if !ok || !res.Valid {
		if err := s.ComputeModules(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("modules")
		if !ok {
			return nil, errors.New("\"kernel\" calculated \"modules\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "modules")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"kernel\" failed to cast field \"modules\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Installed accessor autogenerated
func (s *mqlKernel) Installed() ([]interface{}, error) {
	res, ok := s.Cache.Load("installed")
	if !ok || !res.Valid {
		if err := s.ComputeInstalled(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("installed")
		if !ok {
			return nil, errors.New("\"kernel\" calculated \"installed\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "installed")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"kernel\" failed to cast field \"installed\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlKernel) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[kernel].MqlCompute")
	switch name {
	case "info":
		return s.ComputeInfo()
	case "parameters":
		return s.ComputeParameters()
	case "modules":
		return s.ComputeModules()
	case "installed":
		return s.ComputeInstalled()
	default:
		return errors.New("Cannot find field '" + name + "' in \"kernel\" resource")
	}
}

// ComputeInfo computer autogenerated
func (s *mqlKernel) ComputeInfo() error {
	var err error
	if _, ok := s.Cache.Load("info"); ok {
		return nil
	}
	vres, err := s.GetInfo()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("info", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeParameters computer autogenerated
func (s *mqlKernel) ComputeParameters() error {
	var err error
	if _, ok := s.Cache.Load("parameters"); ok {
		return nil
	}
	vres, err := s.GetParameters()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("parameters", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeModules computer autogenerated
func (s *mqlKernel) ComputeModules() error {
	var err error
	if _, ok := s.Cache.Load("modules"); ok {
		return nil
	}
	vres, err := s.GetModules()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("modules", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeInstalled computer autogenerated
func (s *mqlKernel) ComputeInstalled() error {
	var err error
	if _, ok := s.Cache.Load("installed"); ok {
		return nil
	}
	vres, err := s.GetInstalled()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("installed", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// KernelModule resource interface
type KernelModule interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Size() (string, error)
	Loaded() (bool, error)
}

// mqlKernelModule for the kernel.module resource
type mqlKernelModule struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlKernelModule) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the kernel.module resource
func newKernelModule(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlKernelModule{runtime.NewResource("kernel.module")}
	var existing KernelModule
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"kernel.module\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "size":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"kernel.module\", its \"size\" argument has the wrong type (expected type \"string\")")
			}
		case "loaded":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"kernel.module\", its \"loaded\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"kernel.module\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized kernel.module with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlKernelModule) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"kernel.module\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("size"); !ok {
		return errors.New("Initialized \"kernel.module\" resource without a \"size\". This field is required.")
	}
	if _, ok := s.Cache.Load("loaded"); !ok {
		return errors.New("Initialized \"kernel.module\" resource without a \"loaded\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlKernelModule) Register(name string) error {
	log.Trace().Str("field", name).Msg("[kernel.module].Register")
	switch name {
	case "name":
		return nil
	case "size":
		return nil
	case "loaded":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"kernel.module\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlKernelModule) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[kernel.module].Field")
	switch name {
	case "name":
		return s.Name()
	case "size":
		return s.Size()
	case "loaded":
		return s.Loaded()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"kernel.module\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlKernelModule) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"kernel.module\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"kernel.module\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Size accessor autogenerated
func (s *mqlKernelModule) Size() (string, error) {
	res, ok := s.Cache.Load("size")
	if !ok || !res.Valid {
		return "", errors.New("\"kernel.module\" failed: no value provided for static field \"size\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"kernel.module\" failed to cast field \"size\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Loaded accessor autogenerated
func (s *mqlKernelModule) Loaded() (bool, error) {
	res, ok := s.Cache.Load("loaded")
	if !ok || !res.Valid {
		return false, errors.New("\"kernel.module\" failed: no value provided for static field \"loaded\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"kernel.module\" failed to cast field \"loaded\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlKernelModule) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[kernel.module].MqlCompute")
	switch name {
	case "name":
		return nil
	case "size":
		return nil
	case "loaded":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"kernel.module\" resource")
	}
}

// Package resource interface
type Package interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	Name() (string, error)
	Version() (string, error)
	Arch() (string, error)
	Epoch() (string, error)
	Format() (string, error)
	Status() (string, error)
	Description() (string, error)
	Origin() (string, error)
	Available() (string, error)
	Installed() (bool, error)
	Outdated() (bool, error)
}

// mqlPackage for the package resource
type mqlPackage struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPackage) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the package resource
func newPackage(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPackage{runtime.NewResource("package")}
	var existing Package
	args, existing, err = res.init(args)
	if err != nil {
		return nil, err
	}
	if existing != nil {
		return existing, nil
	}

	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "name":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"name\" argument has the wrong type (expected type \"string\")")
			}
		case "version":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"version\" argument has the wrong type (expected type \"string\")")
			}
		case "arch":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"arch\" argument has the wrong type (expected type \"string\")")
			}
		case "epoch":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"epoch\" argument has the wrong type (expected type \"string\")")
			}
		case "format":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"format\" argument has the wrong type (expected type \"string\")")
			}
		case "status":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"status\" argument has the wrong type (expected type \"string\")")
			}
		case "description":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"description\" argument has the wrong type (expected type \"string\")")
			}
		case "origin":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"origin\" argument has the wrong type (expected type \"string\")")
			}
		case "available":
			if _, ok := val.(string); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"available\" argument has the wrong type (expected type \"string\")")
			}
		case "installed":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"installed\" argument has the wrong type (expected type \"bool\")")
			}
		case "outdated":
			if _, ok := val.(bool); !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"outdated\" argument has the wrong type (expected type \"bool\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"package\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized package with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPackage) Validate() error {
	// required arguments
	if _, ok := s.Cache.Load("name"); !ok {
		return errors.New("Initialized \"package\" resource without a \"name\". This field is required.")
	}
	if _, ok := s.Cache.Load("version"); !ok {
		return errors.New("Initialized \"package\" resource without a \"version\". This field is required.")
	}
	if _, ok := s.Cache.Load("arch"); !ok {
		return errors.New("Initialized \"package\" resource without a \"arch\". This field is required.")
	}
	if _, ok := s.Cache.Load("epoch"); !ok {
		return errors.New("Initialized \"package\" resource without a \"epoch\". This field is required.")
	}
	if _, ok := s.Cache.Load("format"); !ok {
		return errors.New("Initialized \"package\" resource without a \"format\". This field is required.")
	}
	if _, ok := s.Cache.Load("description"); !ok {
		return errors.New("Initialized \"package\" resource without a \"description\". This field is required.")
	}
	if _, ok := s.Cache.Load("available"); !ok {
		return errors.New("Initialized \"package\" resource without a \"available\". This field is required.")
	}
	if _, ok := s.Cache.Load("installed"); !ok {
		return errors.New("Initialized \"package\" resource without a \"installed\". This field is required.")
	}

	return nil
}

// Register accessor autogenerated
func (s *mqlPackage) Register(name string) error {
	log.Trace().Str("field", name).Msg("[package].Register")
	switch name {
	case "name":
		return nil
	case "version":
		return nil
	case "arch":
		return nil
	case "epoch":
		return nil
	case "format":
		return nil
	case "status":
		return nil
	case "description":
		return nil
	case "origin":
		return nil
	case "available":
		return nil
	case "installed":
		return nil
	case "outdated":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"package\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPackage) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[package].Field")
	switch name {
	case "name":
		return s.Name()
	case "version":
		return s.Version()
	case "arch":
		return s.Arch()
	case "epoch":
		return s.Epoch()
	case "format":
		return s.Format()
	case "status":
		return s.Status()
	case "description":
		return s.Description()
	case "origin":
		return s.Origin()
	case "available":
		return s.Available()
	case "installed":
		return s.Installed()
	case "outdated":
		return s.Outdated()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"package\" resource")
	}
}

// Name accessor autogenerated
func (s *mqlPackage) Name() (string, error) {
	res, ok := s.Cache.Load("name")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"name\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"name\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Version accessor autogenerated
func (s *mqlPackage) Version() (string, error) {
	res, ok := s.Cache.Load("version")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"version\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"version\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Arch accessor autogenerated
func (s *mqlPackage) Arch() (string, error) {
	res, ok := s.Cache.Load("arch")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"arch\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"arch\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Epoch accessor autogenerated
func (s *mqlPackage) Epoch() (string, error) {
	res, ok := s.Cache.Load("epoch")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"epoch\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"epoch\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Format accessor autogenerated
func (s *mqlPackage) Format() (string, error) {
	res, ok := s.Cache.Load("format")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"format\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"format\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Status accessor autogenerated
func (s *mqlPackage) Status() (string, error) {
	res, ok := s.Cache.Load("status")
	if !ok || !res.Valid {
		if err := s.ComputeStatus(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("status")
		if !ok {
			return "", errors.New("\"package\" calculated \"status\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "status")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"status\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Description accessor autogenerated
func (s *mqlPackage) Description() (string, error) {
	res, ok := s.Cache.Load("description")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"description\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"description\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Origin accessor autogenerated
func (s *mqlPackage) Origin() (string, error) {
	res, ok := s.Cache.Load("origin")
	if !ok || !res.Valid {
		if err := s.ComputeOrigin(); err != nil {
			return "", err
		}
		res, ok = s.Cache.Load("origin")
		if !ok {
			return "", errors.New("\"package\" calculated \"origin\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "origin")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"origin\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Available accessor autogenerated
func (s *mqlPackage) Available() (string, error) {
	res, ok := s.Cache.Load("available")
	if !ok || !res.Valid {
		return "", errors.New("\"package\" failed: no value provided for static field \"available\"")
	}
	if res.Error != nil {
		return "", res.Error
	}
	tres, ok := res.Data.(string)
	if !ok {
		return "", fmt.Errorf("\"package\" failed to cast field \"available\" to the right type (string): %#v", res)
	}
	return tres, nil
}

// Installed accessor autogenerated
func (s *mqlPackage) Installed() (bool, error) {
	res, ok := s.Cache.Load("installed")
	if !ok || !res.Valid {
		return false, errors.New("\"package\" failed: no value provided for static field \"installed\"")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"package\" failed to cast field \"installed\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Outdated accessor autogenerated
func (s *mqlPackage) Outdated() (bool, error) {
	res, ok := s.Cache.Load("outdated")
	if !ok || !res.Valid {
		if err := s.ComputeOutdated(); err != nil {
			return false, err
		}
		res, ok = s.Cache.Load("outdated")
		if !ok {
			return false, errors.New("\"package\" calculated \"outdated\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "outdated")
	}
	if res.Error != nil {
		return false, res.Error
	}
	tres, ok := res.Data.(bool)
	if !ok {
		return false, fmt.Errorf("\"package\" failed to cast field \"outdated\" to the right type (bool): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPackage) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[package].MqlCompute")
	switch name {
	case "name":
		return nil
	case "version":
		return nil
	case "arch":
		return nil
	case "epoch":
		return nil
	case "format":
		return nil
	case "status":
		return s.ComputeStatus()
	case "description":
		return nil
	case "origin":
		return s.ComputeOrigin()
	case "available":
		return nil
	case "installed":
		return nil
	case "outdated":
		return s.ComputeOutdated()
	default:
		return errors.New("Cannot find field '" + name + "' in \"package\" resource")
	}
}

// ComputeStatus computer autogenerated
func (s *mqlPackage) ComputeStatus() error {
	var err error
	if _, ok := s.Cache.Load("status"); ok {
		return nil
	}
	vres, err := s.GetStatus()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("status", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOrigin computer autogenerated
func (s *mqlPackage) ComputeOrigin() error {
	var err error
	if _, ok := s.Cache.Load("origin"); ok {
		return nil
	}
	vres, err := s.GetOrigin()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("origin", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// ComputeOutdated computer autogenerated
func (s *mqlPackage) ComputeOutdated() error {
	var err error
	if _, ok := s.Cache.Load("outdated"); ok {
		return nil
	}
	vres, err := s.GetOutdated()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("outdated", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

// Packages resource interface
type Packages interface {
	MqlResource() (*resources.Resource)
	MqlCompute(string) error
	Field(string) (interface{}, error)
	Register(string) error
	Validate() error
	List() ([]interface{}, error)
}

// mqlPackages for the packages resource
type mqlPackages struct {
	*resources.Resource
}

// MqlResource to retrieve the underlying resource info
func (s *mqlPackages) MqlResource() *resources.Resource {
	return s.Resource
}

// create a new instance of the packages resource
func newPackages(runtime *resources.Runtime, args *resources.Args) (interface{}, error) {
	// User hooks
	var err error
	res := mqlPackages{runtime.NewResource("packages")}
	// assign all named fields
	var id string

	now := time.Now().Unix()
	for name, val := range *args {
		if val == nil {
			res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
			continue
		}

		switch name {
		case "list":
			if _, ok := val.([]interface{}); !ok {
				return nil, errors.New("Failed to initialize \"packages\", its \"list\" argument has the wrong type (expected type \"[]interface{}\")")
			}
		case "__id":
			idVal, ok := val.(string)
			if !ok {
				return nil, errors.New("Failed to initialize \"packages\", its \"__id\" argument has the wrong type (expected type \"string\")")
			}
			id = idVal
		default:
			return nil, errors.New("Initialized packages with unknown argument " + name)
		}
		res.Cache.Store(name, &resources.CacheEntry{Data: val, Valid: true, Timestamp: now})
	}

	// Get the ID
	if id == "" {
		res.Resource.Id, err = res.id()
		if err != nil {
			return nil, err
		}
	} else {
		res.Resource.Id = id
	}

	return &res, nil
}

func (s *mqlPackages) Validate() error {
	// required arguments
	// no required fields found

	return nil
}

// Register accessor autogenerated
func (s *mqlPackages) Register(name string) error {
	log.Trace().Str("field", name).Msg("[packages].Register")
	switch name {
	case "list":
		return nil
	default:
		return errors.New("Cannot find field '" + name + "' in \"packages\" resource")
	}
}

// Field accessor autogenerated
func (s *mqlPackages) Field(name string) (interface{}, error) {
	log.Trace().Str("field", name).Msg("[packages].Field")
	switch name {
	case "list":
		return s.List()
	default:
		return nil, fmt.Errorf("Cannot find field '" + name + "' in \"packages\" resource")
	}
}

// List accessor autogenerated
func (s *mqlPackages) List() ([]interface{}, error) {
	res, ok := s.Cache.Load("list")
	if !ok || !res.Valid {
		if err := s.ComputeList(); err != nil {
			return nil, err
		}
		res, ok = s.Cache.Load("list")
		if !ok {
			return nil, errors.New("\"packages\" calculated \"list\" but didn't find its value in cache.")
		}
		s.MotorRuntime.Trigger(s, "list")
	}
	if res.Error != nil {
		return nil, res.Error
	}
	tres, ok := res.Data.([]interface{})
	if !ok {
		return nil, fmt.Errorf("\"packages\" failed to cast field \"list\" to the right type ([]interface{}): %#v", res)
	}
	return tres, nil
}

// Compute accessor autogenerated
func (s *mqlPackages) MqlCompute(name string) error {
	log.Trace().Str("field", name).Msg("[packages].MqlCompute")
	switch name {
	case "list":
		return s.ComputeList()
	default:
		return errors.New("Cannot find field '" + name + "' in \"packages\" resource")
	}
}

// ComputeList computer autogenerated
func (s *mqlPackages) ComputeList() error {
	var err error
	if _, ok := s.Cache.Load("list"); ok {
		return nil
	}
	vres, err := s.GetList()
	if _, ok := err.(resources.NotReadyError); ok {
		return err
	}
	s.Cache.Store("list", &resources.CacheEntry{Data: vres, Valid: true, Error: err, Timestamp: time.Now().Unix()})
	return nil
}

