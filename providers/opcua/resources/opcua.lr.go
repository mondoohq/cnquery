// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/llx"
	"go.mondoo.com/cnquery/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"opcua": {
			// to override args, implement: initOpcua(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpcua,
		},
		"opcua.server": {
			Init: initOpcuaServer,
			Create: createOpcuaServer,
		},
		"opcua.namespace": {
			// to override args, implement: initOpcuaNamespace(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpcuaNamespace,
		},
		"opcua.node": {
			// to override args, implement: initOpcuaNode(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpcuaNode,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources[id]; ok {
				return x, nil
			}
			runtime.Resources[id] = res
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"opcua.namespaces": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcua).GetNamespaces()).ToDataRes(types.Array(types.Resource("opcua.namespace")))
	},
	"opcua.root": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcua).GetRoot()).ToDataRes(types.Resource("opcua.node"))
	},
	"opcua.nodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcua).GetNodes()).ToDataRes(types.Array(types.Resource("opcua.node")))
	},
	"opcua.server.node": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaServer).GetNode()).ToDataRes(types.Resource("opcua.node"))
	},
	"opcua.server.buildInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaServer).GetBuildInfo()).ToDataRes(types.Dict)
	},
	"opcua.server.currentTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaServer).GetCurrentTime()).ToDataRes(types.Time)
	},
	"opcua.server.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaServer).GetStartTime()).ToDataRes(types.Time)
	},
	"opcua.server.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaServer).GetState()).ToDataRes(types.String)
	},
	"opcua.namespace.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNamespace).GetId()).ToDataRes(types.Int)
	},
	"opcua.namespace.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNamespace).GetName()).ToDataRes(types.String)
	},
	"opcua.node.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetId()).ToDataRes(types.String)
	},
	"opcua.node.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetName()).ToDataRes(types.String)
	},
	"opcua.node.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetNamespace()).ToDataRes(types.Resource("opcua.namespace"))
	},
	"opcua.node.class": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetClass()).ToDataRes(types.String)
	},
	"opcua.node.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetDescription()).ToDataRes(types.String)
	},
	"opcua.node.writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetWriteable()).ToDataRes(types.Bool)
	},
	"opcua.node.dataType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetDataType()).ToDataRes(types.String)
	},
	"opcua.node.min": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetMin()).ToDataRes(types.String)
	},
	"opcua.node.max": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetMax()).ToDataRes(types.String)
	},
	"opcua.node.unit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetUnit()).ToDataRes(types.String)
	},
	"opcua.node.accessLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetAccessLevel()).ToDataRes(types.String)
	},
	"opcua.node.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetProperties()).ToDataRes(types.Array(types.Resource("opcua.node")))
	},
	"opcua.node.components": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetComponents()).ToDataRes(types.Array(types.Resource("opcua.node")))
	},
	"opcua.node.organizes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpcuaNode).GetOrganizes()).ToDataRes(types.Array(types.Resource("opcua.node")))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"opcua.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpcua).__id, ok = v.Value.(string)
			return
		},
	"opcua.namespaces": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcua).Namespaces, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"opcua.root": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcua).Root, ok = plugin.RawToTValue[*mqlOpcuaNode](v.Value, v.Error)
		return
	},
	"opcua.nodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcua).Nodes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"opcua.server.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpcuaServer).__id, ok = v.Value.(string)
			return
		},
	"opcua.server.node": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaServer).Node, ok = plugin.RawToTValue[*mqlOpcuaNode](v.Value, v.Error)
		return
	},
	"opcua.server.buildInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaServer).BuildInfo, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"opcua.server.currentTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaServer).CurrentTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"opcua.server.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaServer).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"opcua.server.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaServer).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.namespace.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpcuaNamespace).__id, ok = v.Value.(string)
			return
		},
	"opcua.namespace.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNamespace).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"opcua.namespace.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNamespace).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpcuaNode).__id, ok = v.Value.(string)
			return
		},
	"opcua.node.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Namespace, ok = plugin.RawToTValue[*mqlOpcuaNamespace](v.Value, v.Error)
		return
	},
	"opcua.node.class": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Class, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"opcua.node.dataType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).DataType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.min": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Min, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.max": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Max, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.unit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Unit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.accessLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).AccessLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"opcua.node.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Properties, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"opcua.node.components": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Components, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"opcua.node.organizes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpcuaNode).Organizes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[opcua] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[opcua] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlOpcua for the opcua resource
type mqlOpcua struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpcuaInternal it will be used here
	Namespaces plugin.TValue[[]interface{}]
	Root plugin.TValue[*mqlOpcuaNode]
	Nodes plugin.TValue[[]interface{}]
}

// createOpcua creates a new instance of this resource
func createOpcua(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpcua{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("opcua", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpcua) MqlName() string {
	return "opcua"
}

func (c *mqlOpcua) MqlID() string {
	return c.__id
}

func (c *mqlOpcua) GetNamespaces() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Namespaces, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua", c.__id, "namespaces")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.namespaces()
	})
}

func (c *mqlOpcua) GetRoot() *plugin.TValue[*mqlOpcuaNode] {
	return plugin.GetOrCompute[*mqlOpcuaNode](&c.Root, func() (*mqlOpcuaNode, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua", c.__id, "root")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlOpcuaNode), nil
			}
		}

		return c.root()
	})
}

func (c *mqlOpcua) GetNodes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Nodes, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua", c.__id, "nodes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.nodes()
	})
}

// mqlOpcuaServer for the opcua.server resource
type mqlOpcuaServer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpcuaServerInternal it will be used here
	Node plugin.TValue[*mqlOpcuaNode]
	BuildInfo plugin.TValue[interface{}]
	CurrentTime plugin.TValue[*time.Time]
	StartTime plugin.TValue[*time.Time]
	State plugin.TValue[string]
}

// createOpcuaServer creates a new instance of this resource
func createOpcuaServer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpcuaServer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("opcua.server", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpcuaServer) MqlName() string {
	return "opcua.server"
}

func (c *mqlOpcuaServer) MqlID() string {
	return c.__id
}

func (c *mqlOpcuaServer) GetNode() *plugin.TValue[*mqlOpcuaNode] {
	return &c.Node
}

func (c *mqlOpcuaServer) GetBuildInfo() *plugin.TValue[interface{}] {
	return &c.BuildInfo
}

func (c *mqlOpcuaServer) GetCurrentTime() *plugin.TValue[*time.Time] {
	return &c.CurrentTime
}

func (c *mqlOpcuaServer) GetStartTime() *plugin.TValue[*time.Time] {
	return &c.StartTime
}

func (c *mqlOpcuaServer) GetState() *plugin.TValue[string] {
	return &c.State
}

// mqlOpcuaNamespace for the opcua.namespace resource
type mqlOpcuaNamespace struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpcuaNamespaceInternal it will be used here
	Id plugin.TValue[int64]
	Name plugin.TValue[string]
}

// createOpcuaNamespace creates a new instance of this resource
func createOpcuaNamespace(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpcuaNamespace{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("opcua.namespace", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpcuaNamespace) MqlName() string {
	return "opcua.namespace"
}

func (c *mqlOpcuaNamespace) MqlID() string {
	return c.__id
}

func (c *mqlOpcuaNamespace) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlOpcuaNamespace) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlOpcuaNode for the opcua.node resource
type mqlOpcuaNode struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlOpcuaNodeInternal
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Namespace plugin.TValue[*mqlOpcuaNamespace]
	Class plugin.TValue[string]
	Description plugin.TValue[string]
	Writeable plugin.TValue[bool]
	DataType plugin.TValue[string]
	Min plugin.TValue[string]
	Max plugin.TValue[string]
	Unit plugin.TValue[string]
	AccessLevel plugin.TValue[string]
	Properties plugin.TValue[[]interface{}]
	Components plugin.TValue[[]interface{}]
	Organizes plugin.TValue[[]interface{}]
}

// createOpcuaNode creates a new instance of this resource
func createOpcuaNode(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpcuaNode{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("opcua.node", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpcuaNode) MqlName() string {
	return "opcua.node"
}

func (c *mqlOpcuaNode) MqlID() string {
	return c.__id
}

func (c *mqlOpcuaNode) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlOpcuaNode) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlOpcuaNode) GetNamespace() *plugin.TValue[*mqlOpcuaNamespace] {
	return plugin.GetOrCompute[*mqlOpcuaNamespace](&c.Namespace, func() (*mqlOpcuaNamespace, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua.node", c.__id, "namespace")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlOpcuaNamespace), nil
			}
		}

		return c.namespace()
	})
}

func (c *mqlOpcuaNode) GetClass() *plugin.TValue[string] {
	return &c.Class
}

func (c *mqlOpcuaNode) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlOpcuaNode) GetWriteable() *plugin.TValue[bool] {
	return &c.Writeable
}

func (c *mqlOpcuaNode) GetDataType() *plugin.TValue[string] {
	return &c.DataType
}

func (c *mqlOpcuaNode) GetMin() *plugin.TValue[string] {
	return &c.Min
}

func (c *mqlOpcuaNode) GetMax() *plugin.TValue[string] {
	return &c.Max
}

func (c *mqlOpcuaNode) GetUnit() *plugin.TValue[string] {
	return &c.Unit
}

func (c *mqlOpcuaNode) GetAccessLevel() *plugin.TValue[string] {
	return &c.AccessLevel
}

func (c *mqlOpcuaNode) GetProperties() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Properties, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua.node", c.__id, "properties")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.properties()
	})
}

func (c *mqlOpcuaNode) GetComponents() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Components, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua.node", c.__id, "components")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.components()
	})
}

func (c *mqlOpcuaNode) GetOrganizes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Organizes, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("opcua.node", c.__id, "organizes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.organizes()
	})
}
