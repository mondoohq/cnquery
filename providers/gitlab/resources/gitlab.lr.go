// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"github.com/rs/zerolog/log"
	"go.mondoo.com/mql/v13/llx"
	"go.mondoo.com/mql/v13/providers-sdk/v1/plugin"
	"go.mondoo.com/mql/v13/types"
)

// The MQL type names exposed as public consts for ease of reference.
const (
	ResourceGitlabUser                   string = "gitlab.user"
	ResourceGitlabMember                 string = "gitlab.member"
	ResourceGitlabGroup                  string = "gitlab.group"
	ResourceGitlabProject                string = "gitlab.project"
	ResourceGitlabProjectApprovalRule    string = "gitlab.project.approvalRule"
	ResourceGitlabProjectApprovalSetting string = "gitlab.project.approvalSetting"
	ResourceGitlabProjectProtectedBranch string = "gitlab.project.protectedBranch"
	ResourceGitlabProjectFile            string = "gitlab.project.file"
	ResourceGitlabProjectWebhook         string = "gitlab.project.webhook"
	ResourceGitlabProjectMergeRequest    string = "gitlab.project.mergeRequest"
	ResourceGitlabProjectIssue           string = "gitlab.project.issue"
	ResourceGitlabProjectRelease         string = "gitlab.project.release"
	ResourceGitlabProjectVariable        string = "gitlab.project.variable"
	ResourceGitlabProjectMilestone       string = "gitlab.project.milestone"
	ResourceGitlabProjectLabel           string = "gitlab.project.label"
	ResourceGitlabGroupLabel             string = "gitlab.group.label"
	ResourceGitlabProjectPipeline        string = "gitlab.project.pipeline"
	ResourceGitlabProjectRunner          string = "gitlab.project.runner"
	ResourceGitlabProjectPushRule        string = "gitlab.project.pushRule"
	ResourceGitlabGroupPushRule          string = "gitlab.group.pushRule"
	ResourceGitlabProjectAccessToken     string = "gitlab.project.accessToken"
	ResourceGitlabGroupAccessToken       string = "gitlab.group.accessToken"
	ResourceGitlabProjectDeployKey       string = "gitlab.project.deployKey"
	ResourceGitlabProjectDeployToken     string = "gitlab.project.deployToken"
	ResourceGitlabGroupDeployToken       string = "gitlab.group.deployToken"
	ResourceGitlabGroupProtectedBranch   string = "gitlab.group.protectedBranch"
	ResourceGitlabProjectSecuritySetting string = "gitlab.project.securitySetting"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory{
		"gitlab.user": {
			// to override args, implement: initGitlabUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabUser,
		},
		"gitlab.member": {
			// to override args, implement: initGitlabMember(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabMember,
		},
		"gitlab.group": {
			Init:   initGitlabGroup,
			Create: createGitlabGroup,
		},
		"gitlab.project": {
			Init:   initGitlabProject,
			Create: createGitlabProject,
		},
		"gitlab.project.approvalRule": {
			// to override args, implement: initGitlabProjectApprovalRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectApprovalRule,
		},
		"gitlab.project.approvalSetting": {
			// to override args, implement: initGitlabProjectApprovalSetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectApprovalSetting,
		},
		"gitlab.project.protectedBranch": {
			// to override args, implement: initGitlabProjectProtectedBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectProtectedBranch,
		},
		"gitlab.project.file": {
			// to override args, implement: initGitlabProjectFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectFile,
		},
		"gitlab.project.webhook": {
			// to override args, implement: initGitlabProjectWebhook(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectWebhook,
		},
		"gitlab.project.mergeRequest": {
			// to override args, implement: initGitlabProjectMergeRequest(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectMergeRequest,
		},
		"gitlab.project.issue": {
			// to override args, implement: initGitlabProjectIssue(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectIssue,
		},
		"gitlab.project.release": {
			// to override args, implement: initGitlabProjectRelease(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectRelease,
		},
		"gitlab.project.variable": {
			// to override args, implement: initGitlabProjectVariable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectVariable,
		},
		"gitlab.project.milestone": {
			// to override args, implement: initGitlabProjectMilestone(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectMilestone,
		},
		"gitlab.project.label": {
			// to override args, implement: initGitlabProjectLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectLabel,
		},
		"gitlab.group.label": {
			// to override args, implement: initGitlabGroupLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabGroupLabel,
		},
		"gitlab.project.pipeline": {
			// to override args, implement: initGitlabProjectPipeline(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectPipeline,
		},
		"gitlab.project.runner": {
			// to override args, implement: initGitlabProjectRunner(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectRunner,
		},
		"gitlab.project.pushRule": {
			// to override args, implement: initGitlabProjectPushRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectPushRule,
		},
		"gitlab.group.pushRule": {
			// to override args, implement: initGitlabGroupPushRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabGroupPushRule,
		},
		"gitlab.project.accessToken": {
			// to override args, implement: initGitlabProjectAccessToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectAccessToken,
		},
		"gitlab.group.accessToken": {
			// to override args, implement: initGitlabGroupAccessToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabGroupAccessToken,
		},
		"gitlab.project.deployKey": {
			// to override args, implement: initGitlabProjectDeployKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectDeployKey,
		},
		"gitlab.project.deployToken": {
			// to override args, implement: initGitlabProjectDeployToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectDeployToken,
		},
		"gitlab.group.deployToken": {
			// to override args, implement: initGitlabGroupDeployToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabGroupDeployToken,
		},
		"gitlab.group.protectedBranch": {
			// to override args, implement: initGitlabGroupProtectedBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabGroupProtectedBranch,
		},
		"gitlab.project.securitySetting": {
			// to override args, implement: initGitlabProjectSecuritySetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitlabProjectSecuritySetting,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			mqlId := res.MqlID()
			if mqlId == "" {
				log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
			}
			id := name + "\x00" + mqlId
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"gitlab.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetId()).ToDataRes(types.Int)
	},
	"gitlab.user.username": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetUsername()).ToDataRes(types.String)
	},
	"gitlab.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetName()).ToDataRes(types.String)
	},
	"gitlab.user.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetState()).ToDataRes(types.String)
	},
	"gitlab.user.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetEmail()).ToDataRes(types.String)
	},
	"gitlab.user.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.user.avatarURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetAvatarURL()).ToDataRes(types.String)
	},
	"gitlab.user.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.user.jobTitle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetJobTitle()).ToDataRes(types.String)
	},
	"gitlab.user.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetOrganization()).ToDataRes(types.String)
	},
	"gitlab.user.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetLocation()).ToDataRes(types.String)
	},
	"gitlab.user.locked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetLocked()).ToDataRes(types.Bool)
	},
	"gitlab.user.bot": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetBot()).ToDataRes(types.Bool)
	},
	"gitlab.user.twoFactorEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabUser).GetTwoFactorEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.member.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabMember).GetId()).ToDataRes(types.Int)
	},
	"gitlab.member.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabMember).GetUser()).ToDataRes(types.Resource("gitlab.user"))
	},
	"gitlab.member.role": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabMember).GetRole()).ToDataRes(types.String)
	},
	"gitlab.group.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetName()).ToDataRes(types.String)
	},
	"gitlab.group.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetPath()).ToDataRes(types.String)
	},
	"gitlab.group.fullName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetFullName()).ToDataRes(types.String)
	},
	"gitlab.group.fullPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetFullPath()).ToDataRes(types.String)
	},
	"gitlab.group.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.group.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.group.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.group.visibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetVisibility()).ToDataRes(types.String)
	},
	"gitlab.group.requireTwoFactorAuthentication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetRequireTwoFactorAuthentication()).ToDataRes(types.Bool)
	},
	"gitlab.group.preventForkingOutsideGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetPreventForkingOutsideGroup()).ToDataRes(types.Bool)
	},
	"gitlab.group.emailsDisabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetEmailsDisabled()).ToDataRes(types.Bool)
	},
	"gitlab.group.mentionsDisabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetMentionsDisabled()).ToDataRes(types.Bool)
	},
	"gitlab.group.requestAccessEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetRequestAccessEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.group.markedForDeletionOn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetMarkedForDeletionOn()).ToDataRes(types.Time)
	},
	"gitlab.group.projects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetProjects()).ToDataRes(types.Array(types.Resource("gitlab.project")))
	},
	"gitlab.group.allowedEmailDomainsList": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetAllowedEmailDomainsList()).ToDataRes(types.String)
	},
	"gitlab.group.lfsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetLfsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.group.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetMembers()).ToDataRes(types.Array(types.Resource("gitlab.member")))
	},
	"gitlab.group.subgroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetSubgroups()).ToDataRes(types.Array(types.Resource("gitlab.group")))
	},
	"gitlab.group.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetLabels()).ToDataRes(types.Array(types.Resource("gitlab.group.label")))
	},
	"gitlab.group.pushRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetPushRules()).ToDataRes(types.Resource("gitlab.group.pushRule"))
	},
	"gitlab.group.accessTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetAccessTokens()).ToDataRes(types.Array(types.Resource("gitlab.group.accessToken")))
	},
	"gitlab.group.deployTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetDeployTokens()).ToDataRes(types.Array(types.Resource("gitlab.group.deployToken")))
	},
	"gitlab.group.protectedBranches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroup).GetProtectedBranches()).ToDataRes(types.Array(types.Resource("gitlab.group.protectedBranch")))
	},
	"gitlab.project.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.fullName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetFullName()).ToDataRes(types.String)
	},
	"gitlab.project.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetPath()).ToDataRes(types.String)
	},
	"gitlab.project.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.defaultBranch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetDefaultBranch()).ToDataRes(types.String)
	},
	"gitlab.project.visibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetVisibility()).ToDataRes(types.String)
	},
	"gitlab.project.archived": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetArchived()).ToDataRes(types.Bool)
	},
	"gitlab.project.mirror": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetMirror()).ToDataRes(types.Bool)
	},
	"gitlab.project.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.project.emailsDisabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetEmailsDisabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.allowMergeOnSkippedPipeline": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetAllowMergeOnSkippedPipeline()).ToDataRes(types.Bool)
	},
	"gitlab.project.onlyAllowMergeIfPipelineSucceeds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetOnlyAllowMergeIfPipelineSucceeds()).ToDataRes(types.Bool)
	},
	"gitlab.project.onlyAllowMergeIfAllDiscussionsAreResolved": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetOnlyAllowMergeIfAllDiscussionsAreResolved()).ToDataRes(types.Bool)
	},
	"gitlab.project.issuesEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetIssuesEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.mergeRequestsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetMergeRequestsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.wikiEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetWikiEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.snippetsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetSnippetsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.containerRegistryEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetContainerRegistryEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.serviceDeskEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetServiceDeskEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.packagesEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetPackagesEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.autoDevopsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetAutoDevopsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.requirementsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetRequirementsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetApprovalRules()).ToDataRes(types.Array(types.Resource("gitlab.project.approvalRule")))
	},
	"gitlab.project.mergeMethod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetMergeMethod()).ToDataRes(types.String)
	},
	"gitlab.project.approvalSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetApprovalSettings()).ToDataRes(types.Resource("gitlab.project.approvalSetting"))
	},
	"gitlab.project.protectedBranches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetProtectedBranches()).ToDataRes(types.Array(types.Resource("gitlab.project.protectedBranch")))
	},
	"gitlab.project.projectMembers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetProjectMembers()).ToDataRes(types.Array(types.Resource("gitlab.member")))
	},
	"gitlab.project.projectFiles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetProjectFiles()).ToDataRes(types.Array(types.Resource("gitlab.project.file")))
	},
	"gitlab.project.webhooks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetWebhooks()).ToDataRes(types.Array(types.Resource("gitlab.project.webhook")))
	},
	"gitlab.project.jobsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetJobsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.emptyRepo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetEmptyRepo()).ToDataRes(types.Bool)
	},
	"gitlab.project.sharedRunnersEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetSharedRunnersEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.groupRunnersEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetGroupRunnersEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.removeSourceBranchAfterMerge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetRemoveSourceBranchAfterMerge()).ToDataRes(types.Bool)
	},
	"gitlab.project.lfsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetLfsEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.autocloseReferencedIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetAutocloseReferencedIssues()).ToDataRes(types.Bool)
	},
	"gitlab.project.forksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetForksCount()).ToDataRes(types.Int)
	},
	"gitlab.project.starCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetStarCount()).ToDataRes(types.Int)
	},
	"gitlab.project.lastActivityAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetLastActivityAt()).ToDataRes(types.Time)
	},
	"gitlab.project.mergeRequests": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetMergeRequests()).ToDataRes(types.Array(types.Resource("gitlab.project.mergeRequest")))
	},
	"gitlab.project.issues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetIssues()).ToDataRes(types.Array(types.Resource("gitlab.project.issue")))
	},
	"gitlab.project.releases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetReleases()).ToDataRes(types.Array(types.Resource("gitlab.project.release")))
	},
	"gitlab.project.variables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetVariables()).ToDataRes(types.Array(types.Resource("gitlab.project.variable")))
	},
	"gitlab.project.milestones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetMilestones()).ToDataRes(types.Array(types.Resource("gitlab.project.milestone")))
	},
	"gitlab.project.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetLabels()).ToDataRes(types.Array(types.Resource("gitlab.project.label")))
	},
	"gitlab.project.pipelines": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetPipelines()).ToDataRes(types.Array(types.Resource("gitlab.project.pipeline")))
	},
	"gitlab.project.runners": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetRunners()).ToDataRes(types.Array(types.Resource("gitlab.project.runner")))
	},
	"gitlab.project.pushRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetPushRules()).ToDataRes(types.Resource("gitlab.project.pushRule"))
	},
	"gitlab.project.accessTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetAccessTokens()).ToDataRes(types.Array(types.Resource("gitlab.project.accessToken")))
	},
	"gitlab.project.deployKeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetDeployKeys()).ToDataRes(types.Array(types.Resource("gitlab.project.deployKey")))
	},
	"gitlab.project.deployTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetDeployTokens()).ToDataRes(types.Array(types.Resource("gitlab.project.deployToken")))
	},
	"gitlab.project.securitySettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProject).GetSecuritySettings()).ToDataRes(types.Resource("gitlab.project.securitySetting"))
	},
	"gitlab.project.approvalRule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalRule).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.approvalRule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalRule).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.approvalRule.approvalsRequired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalRule).GetApprovalsRequired()).ToDataRes(types.Int)
	},
	"gitlab.project.approvalSetting.approvalsBeforeMerge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetApprovalsBeforeMerge()).ToDataRes(types.Int)
	},
	"gitlab.project.approvalSetting.resetApprovalsOnPush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetResetApprovalsOnPush()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalSetting.disableOverridingApproversPerMergeRequest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetDisableOverridingApproversPerMergeRequest()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalSetting.mergeRequestsAuthorApproval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetMergeRequestsAuthorApproval()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalSetting.mergeRequestsDisableCommittersApproval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetMergeRequestsDisableCommittersApproval()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalSetting.requirePasswordToApprove": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetRequirePasswordToApprove()).ToDataRes(types.Bool)
	},
	"gitlab.project.approvalSetting.selectiveCodeOwnerRemovals": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectApprovalSetting).GetSelectiveCodeOwnerRemovals()).ToDataRes(types.Bool)
	},
	"gitlab.project.protectedBranch.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectProtectedBranch).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.protectedBranch.allowForcePush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectProtectedBranch).GetAllowForcePush()).ToDataRes(types.Bool)
	},
	"gitlab.project.protectedBranch.defaultBranch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectProtectedBranch).GetDefaultBranch()).ToDataRes(types.Bool)
	},
	"gitlab.project.protectedBranch.codeOwnerApproval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectProtectedBranch).GetCodeOwnerApproval()).ToDataRes(types.Bool)
	},
	"gitlab.project.file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectFile).GetPath()).ToDataRes(types.String)
	},
	"gitlab.project.file.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectFile).GetType()).ToDataRes(types.String)
	},
	"gitlab.project.file.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectFile).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.file.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectFile).GetContent()).ToDataRes(types.String)
	},
	"gitlab.project.webhook.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectWebhook).GetUrl()).ToDataRes(types.String)
	},
	"gitlab.project.webhook.sslVerification": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectWebhook).GetSslVerification()).ToDataRes(types.Bool)
	},
	"gitlab.project.mergeRequest.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.mergeRequest.internalId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetInternalId()).ToDataRes(types.Int)
	},
	"gitlab.project.mergeRequest.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetTitle()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetState()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.sourceBranch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetSourceBranch()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.targetBranch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetTargetBranch()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetAuthor()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.mergeRequest.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.mergeRequest.mergedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetMergedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.mergeRequest.draft": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetDraft()).ToDataRes(types.Bool)
	},
	"gitlab.project.mergeRequest.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.project.mergeRequest.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetLabels()).ToDataRes(types.Array(types.String))
	},
	"gitlab.project.mergeRequest.milestone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMergeRequest).GetMilestone()).ToDataRes(types.Resource("gitlab.project.milestone"))
	},
	"gitlab.project.issue.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.issue.internalId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetInternalId()).ToDataRes(types.Int)
	},
	"gitlab.project.issue.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetTitle()).ToDataRes(types.String)
	},
	"gitlab.project.issue.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetState()).ToDataRes(types.String)
	},
	"gitlab.project.issue.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.issue.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetAuthor()).ToDataRes(types.String)
	},
	"gitlab.project.issue.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.issue.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.issue.closedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetClosedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.issue.dueDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetDueDate()).ToDataRes(types.Time)
	},
	"gitlab.project.issue.confidential": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetConfidential()).ToDataRes(types.Bool)
	},
	"gitlab.project.issue.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.project.issue.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetLabels()).ToDataRes(types.Array(types.String))
	},
	"gitlab.project.issue.milestone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectIssue).GetMilestone()).ToDataRes(types.Resource("gitlab.project.milestone"))
	},
	"gitlab.project.release.tagName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetTagName()).ToDataRes(types.String)
	},
	"gitlab.project.release.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.release.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.release.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.release.releasedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetReleasedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.release.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRelease).GetAuthor()).ToDataRes(types.String)
	},
	"gitlab.project.variable.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetKey()).ToDataRes(types.String)
	},
	"gitlab.project.variable.variableType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetVariableType()).ToDataRes(types.String)
	},
	"gitlab.project.variable.protected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetProtected()).ToDataRes(types.Bool)
	},
	"gitlab.project.variable.masked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetMasked()).ToDataRes(types.Bool)
	},
	"gitlab.project.variable.hidden": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetHidden()).ToDataRes(types.Bool)
	},
	"gitlab.project.variable.raw": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetRaw()).ToDataRes(types.Bool)
	},
	"gitlab.project.variable.environmentScope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetEnvironmentScope()).ToDataRes(types.String)
	},
	"gitlab.project.variable.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectVariable).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.milestone.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.milestone.internalId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetInternalId()).ToDataRes(types.Int)
	},
	"gitlab.project.milestone.projectId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetProjectId()).ToDataRes(types.Int)
	},
	"gitlab.project.milestone.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetTitle()).ToDataRes(types.String)
	},
	"gitlab.project.milestone.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.milestone.dueDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetDueDate()).ToDataRes(types.Time)
	},
	"gitlab.project.milestone.startDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetStartDate()).ToDataRes(types.Time)
	},
	"gitlab.project.milestone.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetState()).ToDataRes(types.String)
	},
	"gitlab.project.milestone.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.milestone.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.milestone.expired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectMilestone).GetExpired()).ToDataRes(types.Bool)
	},
	"gitlab.project.label.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.label.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.label.color": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetColor()).ToDataRes(types.String)
	},
	"gitlab.project.label.textColor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetTextColor()).ToDataRes(types.String)
	},
	"gitlab.project.label.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.label.descriptionHtml": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetDescriptionHtml()).ToDataRes(types.String)
	},
	"gitlab.project.label.openIssuesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetOpenIssuesCount()).ToDataRes(types.Int)
	},
	"gitlab.project.label.closedIssuesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetClosedIssuesCount()).ToDataRes(types.Int)
	},
	"gitlab.project.label.openMergeRequestsCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetOpenMergeRequestsCount()).ToDataRes(types.Int)
	},
	"gitlab.project.label.subscribed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetSubscribed()).ToDataRes(types.Bool)
	},
	"gitlab.project.label.priority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetPriority()).ToDataRes(types.Int)
	},
	"gitlab.project.label.isProjectLabel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectLabel).GetIsProjectLabel()).ToDataRes(types.Bool)
	},
	"gitlab.group.label.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.label.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetName()).ToDataRes(types.String)
	},
	"gitlab.group.label.color": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetColor()).ToDataRes(types.String)
	},
	"gitlab.group.label.textColor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetTextColor()).ToDataRes(types.String)
	},
	"gitlab.group.label.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.group.label.descriptionHtml": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetDescriptionHtml()).ToDataRes(types.String)
	},
	"gitlab.group.label.openIssuesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetOpenIssuesCount()).ToDataRes(types.Int)
	},
	"gitlab.group.label.closedIssuesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetClosedIssuesCount()).ToDataRes(types.Int)
	},
	"gitlab.group.label.openMergeRequestsCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetOpenMergeRequestsCount()).ToDataRes(types.Int)
	},
	"gitlab.group.label.subscribed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetSubscribed()).ToDataRes(types.Bool)
	},
	"gitlab.group.label.priority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetPriority()).ToDataRes(types.Int)
	},
	"gitlab.group.label.isProjectLabel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupLabel).GetIsProjectLabel()).ToDataRes(types.Bool)
	},
	"gitlab.project.pipeline.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.pipeline.internalId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetInternalId()).ToDataRes(types.Int)
	},
	"gitlab.project.pipeline.projectId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetProjectId()).ToDataRes(types.Int)
	},
	"gitlab.project.pipeline.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetStatus()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetSource()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.ref": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetRef()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetSha()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.webURL": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetWebURL()).ToDataRes(types.String)
	},
	"gitlab.project.pipeline.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.pipeline.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPipeline).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.runner.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.runner.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetDescription()).ToDataRes(types.String)
	},
	"gitlab.project.runner.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.runner.runnerType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetRunnerType()).ToDataRes(types.String)
	},
	"gitlab.project.runner.paused": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetPaused()).ToDataRes(types.Bool)
	},
	"gitlab.project.runner.isShared": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetIsShared()).ToDataRes(types.Bool)
	},
	"gitlab.project.runner.online": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetOnline()).ToDataRes(types.Bool)
	},
	"gitlab.project.runner.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectRunner).GetStatus()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.pushRule.commitMessageRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetCommitMessageRegex()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.commitMessageNegativeRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetCommitMessageNegativeRegex()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.branchNameRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetBranchNameRegex()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.denyDeleteTag": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetDenyDeleteTag()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.memberCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetMemberCheck()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.preventSecrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetPreventSecrets()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.authorEmailRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetAuthorEmailRegex()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.fileNameRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetFileNameRegex()).ToDataRes(types.String)
	},
	"gitlab.project.pushRule.maxFileSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetMaxFileSize()).ToDataRes(types.Int)
	},
	"gitlab.project.pushRule.commitCommitterCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetCommitCommitterCheck()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.commitCommitterNameCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetCommitCommitterNameCheck()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.rejectUnsignedCommits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetRejectUnsignedCommits()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.rejectNonDCOCommits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetRejectNonDCOCommits()).ToDataRes(types.Bool)
	},
	"gitlab.project.pushRule.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectPushRule).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.group.pushRule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.pushRule.commitMessageRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetCommitMessageRegex()).ToDataRes(types.String)
	},
	"gitlab.group.pushRule.commitMessageNegativeRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetCommitMessageNegativeRegex()).ToDataRes(types.String)
	},
	"gitlab.group.pushRule.branchNameRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetBranchNameRegex()).ToDataRes(types.String)
	},
	"gitlab.group.pushRule.denyDeleteTag": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetDenyDeleteTag()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.memberCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetMemberCheck()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.preventSecrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetPreventSecrets()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.authorEmailRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetAuthorEmailRegex()).ToDataRes(types.String)
	},
	"gitlab.group.pushRule.fileNameRegex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetFileNameRegex()).ToDataRes(types.String)
	},
	"gitlab.group.pushRule.maxFileSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetMaxFileSize()).ToDataRes(types.Int)
	},
	"gitlab.group.pushRule.commitCommitterCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetCommitCommitterCheck()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.commitCommitterNameCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetCommitCommitterNameCheck()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.rejectUnsignedCommits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetRejectUnsignedCommits()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.rejectNonDCOCommits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetRejectNonDCOCommits()).ToDataRes(types.Bool)
	},
	"gitlab.group.pushRule.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupPushRule).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.accessToken.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.accessToken.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.accessToken.revoked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetRevoked()).ToDataRes(types.Bool)
	},
	"gitlab.project.accessToken.active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetActive()).ToDataRes(types.Bool)
	},
	"gitlab.project.accessToken.scopes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetScopes()).ToDataRes(types.Array(types.String))
	},
	"gitlab.project.accessToken.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.accessToken.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetExpiresAt()).ToDataRes(types.Time)
	},
	"gitlab.project.accessToken.lastUsedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetLastUsedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.accessToken.accessLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectAccessToken).GetAccessLevel()).ToDataRes(types.Int)
	},
	"gitlab.group.accessToken.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.accessToken.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetName()).ToDataRes(types.String)
	},
	"gitlab.group.accessToken.revoked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetRevoked()).ToDataRes(types.Bool)
	},
	"gitlab.group.accessToken.active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetActive()).ToDataRes(types.Bool)
	},
	"gitlab.group.accessToken.scopes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetScopes()).ToDataRes(types.Array(types.String))
	},
	"gitlab.group.accessToken.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.group.accessToken.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetExpiresAt()).ToDataRes(types.Time)
	},
	"gitlab.group.accessToken.lastUsedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetLastUsedAt()).ToDataRes(types.Time)
	},
	"gitlab.group.accessToken.accessLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupAccessToken).GetAccessLevel()).ToDataRes(types.Int)
	},
	"gitlab.project.deployKey.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.deployKey.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetTitle()).ToDataRes(types.String)
	},
	"gitlab.project.deployKey.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetKey()).ToDataRes(types.String)
	},
	"gitlab.project.deployKey.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetFingerprint()).ToDataRes(types.String)
	},
	"gitlab.project.deployKey.fingerprintSHA256": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetFingerprintSHA256()).ToDataRes(types.String)
	},
	"gitlab.project.deployKey.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetCreatedAt()).ToDataRes(types.Time)
	},
	"gitlab.project.deployKey.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetExpiresAt()).ToDataRes(types.Time)
	},
	"gitlab.project.deployKey.canPush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployKey).GetCanPush()).ToDataRes(types.Bool)
	},
	"gitlab.project.deployToken.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetId()).ToDataRes(types.Int)
	},
	"gitlab.project.deployToken.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetName()).ToDataRes(types.String)
	},
	"gitlab.project.deployToken.username": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetUsername()).ToDataRes(types.String)
	},
	"gitlab.project.deployToken.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetExpiresAt()).ToDataRes(types.Time)
	},
	"gitlab.project.deployToken.revoked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetRevoked()).ToDataRes(types.Bool)
	},
	"gitlab.project.deployToken.expired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetExpired()).ToDataRes(types.Bool)
	},
	"gitlab.project.deployToken.scopes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectDeployToken).GetScopes()).ToDataRes(types.Array(types.String))
	},
	"gitlab.group.deployToken.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.deployToken.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetName()).ToDataRes(types.String)
	},
	"gitlab.group.deployToken.username": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetUsername()).ToDataRes(types.String)
	},
	"gitlab.group.deployToken.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetExpiresAt()).ToDataRes(types.Time)
	},
	"gitlab.group.deployToken.revoked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetRevoked()).ToDataRes(types.Bool)
	},
	"gitlab.group.deployToken.expired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetExpired()).ToDataRes(types.Bool)
	},
	"gitlab.group.deployToken.scopes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupDeployToken).GetScopes()).ToDataRes(types.Array(types.String))
	},
	"gitlab.group.protectedBranch.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupProtectedBranch).GetId()).ToDataRes(types.Int)
	},
	"gitlab.group.protectedBranch.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupProtectedBranch).GetName()).ToDataRes(types.String)
	},
	"gitlab.group.protectedBranch.allowForcePush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupProtectedBranch).GetAllowForcePush()).ToDataRes(types.Bool)
	},
	"gitlab.group.protectedBranch.codeOwnerApprovalRequired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabGroupProtectedBranch).GetCodeOwnerApprovalRequired()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.autoFixContainerScanning": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetAutoFixContainerScanning()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.autoFixDAST": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetAutoFixDAST()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.autoFixDependencyScanning": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetAutoFixDependencyScanning()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.autoFixSAST": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetAutoFixSAST()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.continuousVulnerabilityScansEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetContinuousVulnerabilityScansEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.containerScanningForRegistryEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetContainerScanningForRegistryEnabled()).ToDataRes(types.Bool)
	},
	"gitlab.project.securitySetting.secretPushProtectionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitlabProjectSecuritySetting).GetSecretPushProtectionEnabled()).ToDataRes(types.Bool)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool{
	"gitlab.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).__id, ok = v.Value.(string)
		return
	},
	"gitlab.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.user.username": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Username, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.avatarURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).AvatarURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.user.jobTitle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).JobTitle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Organization, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.user.locked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Locked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.user.bot": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).Bot, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.user.twoFactorEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabUser).TwoFactorEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.member.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabMember).__id, ok = v.Value.(string)
		return
	},
	"gitlab.member.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabMember).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.member.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabMember).User, ok = plugin.RawToTValue[*mqlGitlabUser](v.Value, v.Error)
		return
	},
	"gitlab.member.role": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabMember).Role, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.fullName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).FullName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.fullPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).FullPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.visibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Visibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.requireTwoFactorAuthentication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).RequireTwoFactorAuthentication, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.preventForkingOutsideGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).PreventForkingOutsideGroup, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.emailsDisabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).EmailsDisabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.mentionsDisabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).MentionsDisabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.requestAccessEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).RequestAccessEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.markedForDeletionOn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).MarkedForDeletionOn, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.projects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Projects, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.allowedEmailDomainsList": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).AllowedEmailDomainsList, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.lfsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).LfsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Members, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.subgroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Subgroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).PushRules, ok = plugin.RawToTValue[*mqlGitlabGroupPushRule](v.Value, v.Error)
		return
	},
	"gitlab.group.accessTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).AccessTokens, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.deployTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).DeployTokens, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.protectedBranches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroup).ProtectedBranches, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.fullName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).FullName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.defaultBranch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).DefaultBranch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.visibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Visibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.archived": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Archived, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.mirror": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Mirror, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.emailsDisabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).EmailsDisabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.allowMergeOnSkippedPipeline": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).AllowMergeOnSkippedPipeline, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.onlyAllowMergeIfPipelineSucceeds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).OnlyAllowMergeIfPipelineSucceeds, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.onlyAllowMergeIfAllDiscussionsAreResolved": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).OnlyAllowMergeIfAllDiscussionsAreResolved, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.issuesEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).IssuesEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequestsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).MergeRequestsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.wikiEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).WikiEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.snippetsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).SnippetsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.containerRegistryEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ContainerRegistryEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.serviceDeskEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ServiceDeskEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.packagesEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).PackagesEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.autoDevopsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).AutoDevopsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.requirementsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).RequirementsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ApprovalRules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeMethod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).MergeMethod, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ApprovalSettings, ok = plugin.RawToTValue[*mqlGitlabProjectApprovalSetting](v.Value, v.Error)
		return
	},
	"gitlab.project.protectedBranches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ProtectedBranches, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.projectMembers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ProjectMembers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.projectFiles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ProjectFiles, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.webhooks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Webhooks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.jobsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).JobsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.emptyRepo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).EmptyRepo, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.sharedRunnersEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).SharedRunnersEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.groupRunnersEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).GroupRunnersEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.removeSourceBranchAfterMerge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).RemoveSourceBranchAfterMerge, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.lfsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).LfsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.autocloseReferencedIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).AutocloseReferencedIssues, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.forksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).ForksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.starCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).StarCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.lastActivityAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).LastActivityAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequests": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).MergeRequests, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.issues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Issues, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.releases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Releases, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.variables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Variables, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.milestones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Milestones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.pipelines": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Pipelines, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.runners": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).Runners, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).PushRules, ok = plugin.RawToTValue[*mqlGitlabProjectPushRule](v.Value, v.Error)
		return
	},
	"gitlab.project.accessTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).AccessTokens, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).DeployKeys, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.deployTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).DeployTokens, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProject).SecuritySettings, ok = plugin.RawToTValue[*mqlGitlabProjectSecuritySetting](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalRule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalRule).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.approvalRule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalRule).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalRule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalRule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalRule.approvalsRequired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalRule).ApprovalsRequired, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.approvalSetting.approvalsBeforeMerge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).ApprovalsBeforeMerge, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.resetApprovalsOnPush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).ResetApprovalsOnPush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.disableOverridingApproversPerMergeRequest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).DisableOverridingApproversPerMergeRequest, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.mergeRequestsAuthorApproval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).MergeRequestsAuthorApproval, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.mergeRequestsDisableCommittersApproval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).MergeRequestsDisableCommittersApproval, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.requirePasswordToApprove": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).RequirePasswordToApprove, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.approvalSetting.selectiveCodeOwnerRemovals": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectApprovalSetting).SelectiveCodeOwnerRemovals, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.protectedBranch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectProtectedBranch).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.protectedBranch.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectProtectedBranch).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.protectedBranch.allowForcePush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectProtectedBranch).AllowForcePush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.protectedBranch.defaultBranch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectProtectedBranch).DefaultBranch, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.protectedBranch.codeOwnerApproval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectProtectedBranch).CodeOwnerApproval, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.file.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectFile).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.file.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectFile).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.file.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectFile).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.file.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectFile).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.file.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectFile).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.webhook.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectWebhook).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.webhook.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectWebhook).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.webhook.sslVerification": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectWebhook).SslVerification, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.mergeRequest.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.internalId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).InternalId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.sourceBranch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).SourceBranch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.targetBranch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).TargetBranch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Author, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.mergedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).MergedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.draft": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Draft, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.mergeRequest.milestone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMergeRequest).Milestone, ok = plugin.RawToTValue[*mqlGitlabProjectMilestone](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.issue.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.internalId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).InternalId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Author, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.closedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).ClosedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.dueDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).DueDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.confidential": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Confidential, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.issue.milestone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectIssue).Milestone, ok = plugin.RawToTValue[*mqlGitlabProjectMilestone](v.Value, v.Error)
		return
	},
	"gitlab.project.release.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.release.tagName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).TagName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.release.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.release.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.release.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.release.releasedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).ReleasedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.release.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRelease).Author, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.variable.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.variableType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).VariableType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.protected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Protected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.masked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Masked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.hidden": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Hidden, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.raw": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Raw, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.environmentScope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).EnvironmentScope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.variable.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectVariable).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.milestone.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.internalId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).InternalId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.projectId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).ProjectId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.dueDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).DueDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.startDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).StartDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.milestone.expired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectMilestone).Expired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.label.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.label.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.label.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.label.color": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Color, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.label.textColor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).TextColor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.label.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.label.descriptionHtml": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).DescriptionHtml, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.label.openIssuesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).OpenIssuesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.label.closedIssuesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).ClosedIssuesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.label.openMergeRequestsCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).OpenMergeRequestsCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.label.subscribed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Subscribed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.label.priority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).Priority, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.label.isProjectLabel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectLabel).IsProjectLabel, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.label.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.label.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.label.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.label.color": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Color, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.label.textColor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).TextColor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.label.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.label.descriptionHtml": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).DescriptionHtml, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.label.openIssuesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).OpenIssuesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.label.closedIssuesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).ClosedIssuesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.label.openMergeRequestsCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).OpenMergeRequestsCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.label.subscribed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Subscribed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.label.priority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).Priority, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.label.isProjectLabel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupLabel).IsProjectLabel, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.pipeline.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.internalId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).InternalId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.projectId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).ProjectId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Source, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.ref": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Ref, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.webURL": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).WebURL, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.pipeline.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPipeline).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.runner.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.runnerType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).RunnerType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.paused": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Paused, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.isShared": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).IsShared, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.online": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Online, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.runner.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectRunner).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.pushRule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.commitMessageRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).CommitMessageRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.commitMessageNegativeRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).CommitMessageNegativeRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.branchNameRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).BranchNameRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.denyDeleteTag": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).DenyDeleteTag, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.memberCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).MemberCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.preventSecrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).PreventSecrets, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.authorEmailRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).AuthorEmailRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.fileNameRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).FileNameRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.maxFileSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).MaxFileSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.commitCommitterCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).CommitCommitterCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.commitCommitterNameCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).CommitCommitterNameCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.rejectUnsignedCommits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).RejectUnsignedCommits, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.rejectNonDCOCommits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).RejectNonDCOCommits, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.pushRule.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectPushRule).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.pushRule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.commitMessageRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).CommitMessageRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.commitMessageNegativeRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).CommitMessageNegativeRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.branchNameRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).BranchNameRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.denyDeleteTag": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).DenyDeleteTag, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.memberCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).MemberCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.preventSecrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).PreventSecrets, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.authorEmailRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).AuthorEmailRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.fileNameRegex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).FileNameRegex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.maxFileSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).MaxFileSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.commitCommitterCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).CommitCommitterCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.commitCommitterNameCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).CommitCommitterNameCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.rejectUnsignedCommits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).RejectUnsignedCommits, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.rejectNonDCOCommits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).RejectNonDCOCommits, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.pushRule.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupPushRule).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.accessToken.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.revoked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).Revoked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.scopes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).Scopes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.lastUsedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).LastUsedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.accessToken.accessLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectAccessToken).AccessLevel, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.accessToken.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.revoked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).Revoked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.scopes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).Scopes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.lastUsedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).LastUsedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.accessToken.accessLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupAccessToken).AccessLevel, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.deployKey.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.fingerprintSHA256": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).FingerprintSHA256, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.deployKey.canPush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployKey).CanPush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.deployToken.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.username": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Username, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.revoked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Revoked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.expired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Expired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.deployToken.scopes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectDeployToken).Scopes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.deployToken.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.username": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Username, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.revoked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Revoked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.expired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Expired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.deployToken.scopes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupDeployToken).Scopes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"gitlab.group.protectedBranch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupProtectedBranch).__id, ok = v.Value.(string)
		return
	},
	"gitlab.group.protectedBranch.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupProtectedBranch).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"gitlab.group.protectedBranch.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupProtectedBranch).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"gitlab.group.protectedBranch.allowForcePush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupProtectedBranch).AllowForcePush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.group.protectedBranch.codeOwnerApprovalRequired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabGroupProtectedBranch).CodeOwnerApprovalRequired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).__id, ok = v.Value.(string)
		return
	},
	"gitlab.project.securitySetting.autoFixContainerScanning": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).AutoFixContainerScanning, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.autoFixDAST": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).AutoFixDAST, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.autoFixDependencyScanning": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).AutoFixDependencyScanning, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.autoFixSAST": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).AutoFixSAST, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.continuousVulnerabilityScansEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).ContinuousVulnerabilityScansEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.containerScanningForRegistryEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).ContainerScanningForRegistryEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"gitlab.project.securitySetting.secretPushProtectionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitlabProjectSecuritySetting).SecretPushProtectionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName()+"."+field]
	if !ok {
		return errors.New("[gitlab] cannot set '" + field + "' in resource '" + resource.MqlName() + "', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[gitlab] cannot set '" + field + "' in resource '" + resource.MqlName() + "', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlGitlabUser for the gitlab.user resource
type mqlGitlabUser struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabUserInternal it will be used here
	Id               plugin.TValue[int64]
	Username         plugin.TValue[string]
	Name             plugin.TValue[string]
	State            plugin.TValue[string]
	Email            plugin.TValue[string]
	WebURL           plugin.TValue[string]
	AvatarURL        plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	JobTitle         plugin.TValue[string]
	Organization     plugin.TValue[string]
	Location         plugin.TValue[string]
	Locked           plugin.TValue[bool]
	Bot              plugin.TValue[bool]
	TwoFactorEnabled plugin.TValue[bool]
}

// createGitlabUser creates a new instance of this resource
func createGitlabUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabUser) MqlName() string {
	return "gitlab.user"
}

func (c *mqlGitlabUser) MqlID() string {
	return c.__id
}

func (c *mqlGitlabUser) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabUser) GetUsername() *plugin.TValue[string] {
	return &c.Username
}

func (c *mqlGitlabUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabUser) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGitlabUser) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlGitlabUser) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabUser) GetAvatarURL() *plugin.TValue[string] {
	return &c.AvatarURL
}

func (c *mqlGitlabUser) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabUser) GetJobTitle() *plugin.TValue[string] {
	return &c.JobTitle
}

func (c *mqlGitlabUser) GetOrganization() *plugin.TValue[string] {
	return &c.Organization
}

func (c *mqlGitlabUser) GetLocation() *plugin.TValue[string] {
	return &c.Location
}

func (c *mqlGitlabUser) GetLocked() *plugin.TValue[bool] {
	return &c.Locked
}

func (c *mqlGitlabUser) GetBot() *plugin.TValue[bool] {
	return &c.Bot
}

func (c *mqlGitlabUser) GetTwoFactorEnabled() *plugin.TValue[bool] {
	return &c.TwoFactorEnabled
}

// mqlGitlabMember for the gitlab.member resource
type mqlGitlabMember struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabMemberInternal it will be used here
	Id   plugin.TValue[int64]
	User plugin.TValue[*mqlGitlabUser]
	Role plugin.TValue[string]
}

// createGitlabMember creates a new instance of this resource
func createGitlabMember(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabMember{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.member", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabMember) MqlName() string {
	return "gitlab.member"
}

func (c *mqlGitlabMember) MqlID() string {
	return c.__id
}

func (c *mqlGitlabMember) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabMember) GetUser() *plugin.TValue[*mqlGitlabUser] {
	return &c.User
}

func (c *mqlGitlabMember) GetRole() *plugin.TValue[string] {
	return &c.Role
}

// mqlGitlabGroup for the gitlab.group resource
type mqlGitlabGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupInternal it will be used here
	Id                             plugin.TValue[int64]
	Name                           plugin.TValue[string]
	Path                           plugin.TValue[string]
	FullName                       plugin.TValue[string]
	FullPath                       plugin.TValue[string]
	CreatedAt                      plugin.TValue[*time.Time]
	Description                    plugin.TValue[string]
	WebURL                         plugin.TValue[string]
	Visibility                     plugin.TValue[string]
	RequireTwoFactorAuthentication plugin.TValue[bool]
	PreventForkingOutsideGroup     plugin.TValue[bool]
	EmailsDisabled                 plugin.TValue[bool]
	MentionsDisabled               plugin.TValue[bool]
	RequestAccessEnabled           plugin.TValue[bool]
	MarkedForDeletionOn            plugin.TValue[*time.Time]
	Projects                       plugin.TValue[[]any]
	AllowedEmailDomainsList        plugin.TValue[string]
	LfsEnabled                     plugin.TValue[bool]
	Members                        plugin.TValue[[]any]
	Subgroups                      plugin.TValue[[]any]
	Labels                         plugin.TValue[[]any]
	PushRules                      plugin.TValue[*mqlGitlabGroupPushRule]
	AccessTokens                   plugin.TValue[[]any]
	DeployTokens                   plugin.TValue[[]any]
	ProtectedBranches              plugin.TValue[[]any]
}

// createGitlabGroup creates a new instance of this resource
func createGitlabGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroup) MqlName() string {
	return "gitlab.group"
}

func (c *mqlGitlabGroup) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroup) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabGroup) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlGitlabGroup) GetFullName() *plugin.TValue[string] {
	return &c.FullName
}

func (c *mqlGitlabGroup) GetFullPath() *plugin.TValue[string] {
	return &c.FullPath
}

func (c *mqlGitlabGroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabGroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabGroup) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabGroup) GetVisibility() *plugin.TValue[string] {
	return &c.Visibility
}

func (c *mqlGitlabGroup) GetRequireTwoFactorAuthentication() *plugin.TValue[bool] {
	return &c.RequireTwoFactorAuthentication
}

func (c *mqlGitlabGroup) GetPreventForkingOutsideGroup() *plugin.TValue[bool] {
	return &c.PreventForkingOutsideGroup
}

func (c *mqlGitlabGroup) GetEmailsDisabled() *plugin.TValue[bool] {
	return &c.EmailsDisabled
}

func (c *mqlGitlabGroup) GetMentionsDisabled() *plugin.TValue[bool] {
	return &c.MentionsDisabled
}

func (c *mqlGitlabGroup) GetRequestAccessEnabled() *plugin.TValue[bool] {
	return &c.RequestAccessEnabled
}

func (c *mqlGitlabGroup) GetMarkedForDeletionOn() *plugin.TValue[*time.Time] {
	return &c.MarkedForDeletionOn
}

func (c *mqlGitlabGroup) GetProjects() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Projects, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "projects")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.projects()
	})
}

func (c *mqlGitlabGroup) GetAllowedEmailDomainsList() *plugin.TValue[string] {
	return &c.AllowedEmailDomainsList
}

func (c *mqlGitlabGroup) GetLfsEnabled() *plugin.TValue[bool] {
	return &c.LfsEnabled
}

func (c *mqlGitlabGroup) GetMembers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Members, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "members")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.members()
	})
}

func (c *mqlGitlabGroup) GetSubgroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Subgroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "subgroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.subgroups()
	})
}

func (c *mqlGitlabGroup) GetLabels() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Labels, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "labels")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.labels()
	})
}

func (c *mqlGitlabGroup) GetPushRules() *plugin.TValue[*mqlGitlabGroupPushRule] {
	return plugin.GetOrCompute[*mqlGitlabGroupPushRule](&c.PushRules, func() (*mqlGitlabGroupPushRule, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "pushRules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabGroupPushRule), nil
			}
		}

		return c.pushRules()
	})
}

func (c *mqlGitlabGroup) GetAccessTokens() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AccessTokens, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "accessTokens")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.accessTokens()
	})
}

func (c *mqlGitlabGroup) GetDeployTokens() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DeployTokens, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "deployTokens")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployTokens()
	})
}

func (c *mqlGitlabGroup) GetProtectedBranches() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ProtectedBranches, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.group", c.__id, "protectedBranches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.protectedBranches()
	})
}

// mqlGitlabProject for the gitlab.project resource
type mqlGitlabProject struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectInternal it will be used here
	Id                                        plugin.TValue[int64]
	Name                                      plugin.TValue[string]
	FullName                                  plugin.TValue[string]
	Path                                      plugin.TValue[string]
	CreatedAt                                 plugin.TValue[*time.Time]
	Description                               plugin.TValue[string]
	DefaultBranch                             plugin.TValue[string]
	Visibility                                plugin.TValue[string]
	Archived                                  plugin.TValue[bool]
	Mirror                                    plugin.TValue[bool]
	WebURL                                    plugin.TValue[string]
	EmailsDisabled                            plugin.TValue[bool]
	AllowMergeOnSkippedPipeline               plugin.TValue[bool]
	OnlyAllowMergeIfPipelineSucceeds          plugin.TValue[bool]
	OnlyAllowMergeIfAllDiscussionsAreResolved plugin.TValue[bool]
	IssuesEnabled                             plugin.TValue[bool]
	MergeRequestsEnabled                      plugin.TValue[bool]
	WikiEnabled                               plugin.TValue[bool]
	SnippetsEnabled                           plugin.TValue[bool]
	ContainerRegistryEnabled                  plugin.TValue[bool]
	ServiceDeskEnabled                        plugin.TValue[bool]
	PackagesEnabled                           plugin.TValue[bool]
	AutoDevopsEnabled                         plugin.TValue[bool]
	RequirementsEnabled                       plugin.TValue[bool]
	ApprovalRules                             plugin.TValue[[]any]
	MergeMethod                               plugin.TValue[string]
	ApprovalSettings                          plugin.TValue[*mqlGitlabProjectApprovalSetting]
	ProtectedBranches                         plugin.TValue[[]any]
	ProjectMembers                            plugin.TValue[[]any]
	ProjectFiles                              plugin.TValue[[]any]
	Webhooks                                  plugin.TValue[[]any]
	JobsEnabled                               plugin.TValue[bool]
	EmptyRepo                                 plugin.TValue[bool]
	SharedRunnersEnabled                      plugin.TValue[bool]
	GroupRunnersEnabled                       plugin.TValue[bool]
	RemoveSourceBranchAfterMerge              plugin.TValue[bool]
	LfsEnabled                                plugin.TValue[bool]
	AutocloseReferencedIssues                 plugin.TValue[bool]
	ForksCount                                plugin.TValue[int64]
	StarCount                                 plugin.TValue[int64]
	LastActivityAt                            plugin.TValue[*time.Time]
	MergeRequests                             plugin.TValue[[]any]
	Issues                                    plugin.TValue[[]any]
	Releases                                  plugin.TValue[[]any]
	Variables                                 plugin.TValue[[]any]
	Milestones                                plugin.TValue[[]any]
	Labels                                    plugin.TValue[[]any]
	Pipelines                                 plugin.TValue[[]any]
	Runners                                   plugin.TValue[[]any]
	PushRules                                 plugin.TValue[*mqlGitlabProjectPushRule]
	AccessTokens                              plugin.TValue[[]any]
	DeployKeys                                plugin.TValue[[]any]
	DeployTokens                              plugin.TValue[[]any]
	SecuritySettings                          plugin.TValue[*mqlGitlabProjectSecuritySetting]
}

// createGitlabProject creates a new instance of this resource
func createGitlabProject(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProject{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProject) MqlName() string {
	return "gitlab.project"
}

func (c *mqlGitlabProject) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProject) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProject) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProject) GetFullName() *plugin.TValue[string] {
	return &c.FullName
}

func (c *mqlGitlabProject) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlGitlabProject) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProject) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProject) GetDefaultBranch() *plugin.TValue[string] {
	return &c.DefaultBranch
}

func (c *mqlGitlabProject) GetVisibility() *plugin.TValue[string] {
	return &c.Visibility
}

func (c *mqlGitlabProject) GetArchived() *plugin.TValue[bool] {
	return &c.Archived
}

func (c *mqlGitlabProject) GetMirror() *plugin.TValue[bool] {
	return &c.Mirror
}

func (c *mqlGitlabProject) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabProject) GetEmailsDisabled() *plugin.TValue[bool] {
	return &c.EmailsDisabled
}

func (c *mqlGitlabProject) GetAllowMergeOnSkippedPipeline() *plugin.TValue[bool] {
	return &c.AllowMergeOnSkippedPipeline
}

func (c *mqlGitlabProject) GetOnlyAllowMergeIfPipelineSucceeds() *plugin.TValue[bool] {
	return &c.OnlyAllowMergeIfPipelineSucceeds
}

func (c *mqlGitlabProject) GetOnlyAllowMergeIfAllDiscussionsAreResolved() *plugin.TValue[bool] {
	return &c.OnlyAllowMergeIfAllDiscussionsAreResolved
}

func (c *mqlGitlabProject) GetIssuesEnabled() *plugin.TValue[bool] {
	return &c.IssuesEnabled
}

func (c *mqlGitlabProject) GetMergeRequestsEnabled() *plugin.TValue[bool] {
	return &c.MergeRequestsEnabled
}

func (c *mqlGitlabProject) GetWikiEnabled() *plugin.TValue[bool] {
	return &c.WikiEnabled
}

func (c *mqlGitlabProject) GetSnippetsEnabled() *plugin.TValue[bool] {
	return &c.SnippetsEnabled
}

func (c *mqlGitlabProject) GetContainerRegistryEnabled() *plugin.TValue[bool] {
	return &c.ContainerRegistryEnabled
}

func (c *mqlGitlabProject) GetServiceDeskEnabled() *plugin.TValue[bool] {
	return &c.ServiceDeskEnabled
}

func (c *mqlGitlabProject) GetPackagesEnabled() *plugin.TValue[bool] {
	return &c.PackagesEnabled
}

func (c *mqlGitlabProject) GetAutoDevopsEnabled() *plugin.TValue[bool] {
	return &c.AutoDevopsEnabled
}

func (c *mqlGitlabProject) GetRequirementsEnabled() *plugin.TValue[bool] {
	return &c.RequirementsEnabled
}

func (c *mqlGitlabProject) GetApprovalRules() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ApprovalRules, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "approvalRules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.approvalRules()
	})
}

func (c *mqlGitlabProject) GetMergeMethod() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.MergeMethod, func() (string, error) {
		return c.mergeMethod()
	})
}

func (c *mqlGitlabProject) GetApprovalSettings() *plugin.TValue[*mqlGitlabProjectApprovalSetting] {
	return plugin.GetOrCompute[*mqlGitlabProjectApprovalSetting](&c.ApprovalSettings, func() (*mqlGitlabProjectApprovalSetting, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "approvalSettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabProjectApprovalSetting), nil
			}
		}

		return c.approvalSettings()
	})
}

func (c *mqlGitlabProject) GetProtectedBranches() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ProtectedBranches, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "protectedBranches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.protectedBranches()
	})
}

func (c *mqlGitlabProject) GetProjectMembers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ProjectMembers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "projectMembers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.projectMembers()
	})
}

func (c *mqlGitlabProject) GetProjectFiles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ProjectFiles, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "projectFiles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.projectFiles()
	})
}

func (c *mqlGitlabProject) GetWebhooks() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Webhooks, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "webhooks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.webhooks()
	})
}

func (c *mqlGitlabProject) GetJobsEnabled() *plugin.TValue[bool] {
	return &c.JobsEnabled
}

func (c *mqlGitlabProject) GetEmptyRepo() *plugin.TValue[bool] {
	return &c.EmptyRepo
}

func (c *mqlGitlabProject) GetSharedRunnersEnabled() *plugin.TValue[bool] {
	return &c.SharedRunnersEnabled
}

func (c *mqlGitlabProject) GetGroupRunnersEnabled() *plugin.TValue[bool] {
	return &c.GroupRunnersEnabled
}

func (c *mqlGitlabProject) GetRemoveSourceBranchAfterMerge() *plugin.TValue[bool] {
	return &c.RemoveSourceBranchAfterMerge
}

func (c *mqlGitlabProject) GetLfsEnabled() *plugin.TValue[bool] {
	return &c.LfsEnabled
}

func (c *mqlGitlabProject) GetAutocloseReferencedIssues() *plugin.TValue[bool] {
	return &c.AutocloseReferencedIssues
}

func (c *mqlGitlabProject) GetForksCount() *plugin.TValue[int64] {
	return &c.ForksCount
}

func (c *mqlGitlabProject) GetStarCount() *plugin.TValue[int64] {
	return &c.StarCount
}

func (c *mqlGitlabProject) GetLastActivityAt() *plugin.TValue[*time.Time] {
	return &c.LastActivityAt
}

func (c *mqlGitlabProject) GetMergeRequests() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.MergeRequests, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "mergeRequests")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.mergeRequests()
	})
}

func (c *mqlGitlabProject) GetIssues() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Issues, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "issues")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.issues()
	})
}

func (c *mqlGitlabProject) GetReleases() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Releases, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "releases")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.releases()
	})
}

func (c *mqlGitlabProject) GetVariables() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Variables, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "variables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.variables()
	})
}

func (c *mqlGitlabProject) GetMilestones() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Milestones, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "milestones")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.milestones()
	})
}

func (c *mqlGitlabProject) GetLabels() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Labels, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "labels")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.labels()
	})
}

func (c *mqlGitlabProject) GetPipelines() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Pipelines, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "pipelines")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.pipelines()
	})
}

func (c *mqlGitlabProject) GetRunners() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Runners, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "runners")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.runners()
	})
}

func (c *mqlGitlabProject) GetPushRules() *plugin.TValue[*mqlGitlabProjectPushRule] {
	return plugin.GetOrCompute[*mqlGitlabProjectPushRule](&c.PushRules, func() (*mqlGitlabProjectPushRule, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "pushRules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabProjectPushRule), nil
			}
		}

		return c.pushRules()
	})
}

func (c *mqlGitlabProject) GetAccessTokens() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AccessTokens, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "accessTokens")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.accessTokens()
	})
}

func (c *mqlGitlabProject) GetDeployKeys() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DeployKeys, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "deployKeys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployKeys()
	})
}

func (c *mqlGitlabProject) GetDeployTokens() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DeployTokens, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "deployTokens")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployTokens()
	})
}

func (c *mqlGitlabProject) GetSecuritySettings() *plugin.TValue[*mqlGitlabProjectSecuritySetting] {
	return plugin.GetOrCompute[*mqlGitlabProjectSecuritySetting](&c.SecuritySettings, func() (*mqlGitlabProjectSecuritySetting, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project", c.__id, "securitySettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabProjectSecuritySetting), nil
			}
		}

		return c.securitySettings()
	})
}

// mqlGitlabProjectApprovalRule for the gitlab.project.approvalRule resource
type mqlGitlabProjectApprovalRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectApprovalRuleInternal it will be used here
	Id                plugin.TValue[int64]
	Name              plugin.TValue[string]
	ApprovalsRequired plugin.TValue[int64]
}

// createGitlabProjectApprovalRule creates a new instance of this resource
func createGitlabProjectApprovalRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectApprovalRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.approvalRule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectApprovalRule) MqlName() string {
	return "gitlab.project.approvalRule"
}

func (c *mqlGitlabProjectApprovalRule) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectApprovalRule) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectApprovalRule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectApprovalRule) GetApprovalsRequired() *plugin.TValue[int64] {
	return &c.ApprovalsRequired
}

// mqlGitlabProjectApprovalSetting for the gitlab.project.approvalSetting resource
type mqlGitlabProjectApprovalSetting struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectApprovalSettingInternal it will be used here
	ApprovalsBeforeMerge                      plugin.TValue[int64]
	ResetApprovalsOnPush                      plugin.TValue[bool]
	DisableOverridingApproversPerMergeRequest plugin.TValue[bool]
	MergeRequestsAuthorApproval               plugin.TValue[bool]
	MergeRequestsDisableCommittersApproval    plugin.TValue[bool]
	RequirePasswordToApprove                  plugin.TValue[bool]
	SelectiveCodeOwnerRemovals                plugin.TValue[bool]
}

// createGitlabProjectApprovalSetting creates a new instance of this resource
func createGitlabProjectApprovalSetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectApprovalSetting{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.approvalSetting", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectApprovalSetting) MqlName() string {
	return "gitlab.project.approvalSetting"
}

func (c *mqlGitlabProjectApprovalSetting) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectApprovalSetting) GetApprovalsBeforeMerge() *plugin.TValue[int64] {
	return &c.ApprovalsBeforeMerge
}

func (c *mqlGitlabProjectApprovalSetting) GetResetApprovalsOnPush() *plugin.TValue[bool] {
	return &c.ResetApprovalsOnPush
}

func (c *mqlGitlabProjectApprovalSetting) GetDisableOverridingApproversPerMergeRequest() *plugin.TValue[bool] {
	return &c.DisableOverridingApproversPerMergeRequest
}

func (c *mqlGitlabProjectApprovalSetting) GetMergeRequestsAuthorApproval() *plugin.TValue[bool] {
	return &c.MergeRequestsAuthorApproval
}

func (c *mqlGitlabProjectApprovalSetting) GetMergeRequestsDisableCommittersApproval() *plugin.TValue[bool] {
	return &c.MergeRequestsDisableCommittersApproval
}

func (c *mqlGitlabProjectApprovalSetting) GetRequirePasswordToApprove() *plugin.TValue[bool] {
	return &c.RequirePasswordToApprove
}

func (c *mqlGitlabProjectApprovalSetting) GetSelectiveCodeOwnerRemovals() *plugin.TValue[bool] {
	return &c.SelectiveCodeOwnerRemovals
}

// mqlGitlabProjectProtectedBranch for the gitlab.project.protectedBranch resource
type mqlGitlabProjectProtectedBranch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectProtectedBranchInternal it will be used here
	Name              plugin.TValue[string]
	AllowForcePush    plugin.TValue[bool]
	DefaultBranch     plugin.TValue[bool]
	CodeOwnerApproval plugin.TValue[bool]
}

// createGitlabProjectProtectedBranch creates a new instance of this resource
func createGitlabProjectProtectedBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectProtectedBranch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.protectedBranch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectProtectedBranch) MqlName() string {
	return "gitlab.project.protectedBranch"
}

func (c *mqlGitlabProjectProtectedBranch) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectProtectedBranch) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectProtectedBranch) GetAllowForcePush() *plugin.TValue[bool] {
	return &c.AllowForcePush
}

func (c *mqlGitlabProjectProtectedBranch) GetDefaultBranch() *plugin.TValue[bool] {
	return &c.DefaultBranch
}

func (c *mqlGitlabProjectProtectedBranch) GetCodeOwnerApproval() *plugin.TValue[bool] {
	return &c.CodeOwnerApproval
}

// mqlGitlabProjectFile for the gitlab.project.file resource
type mqlGitlabProjectFile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectFileInternal it will be used here
	Path    plugin.TValue[string]
	Type    plugin.TValue[string]
	Name    plugin.TValue[string]
	Content plugin.TValue[string]
}

// createGitlabProjectFile creates a new instance of this resource
func createGitlabProjectFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectFile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.file", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectFile) MqlName() string {
	return "gitlab.project.file"
}

func (c *mqlGitlabProjectFile) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlGitlabProjectFile) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlGitlabProjectFile) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectFile) GetContent() *plugin.TValue[string] {
	return &c.Content
}

// mqlGitlabProjectWebhook for the gitlab.project.webhook resource
type mqlGitlabProjectWebhook struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectWebhookInternal it will be used here
	Url             plugin.TValue[string]
	SslVerification plugin.TValue[bool]
}

// createGitlabProjectWebhook creates a new instance of this resource
func createGitlabProjectWebhook(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectWebhook{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.webhook", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectWebhook) MqlName() string {
	return "gitlab.project.webhook"
}

func (c *mqlGitlabProjectWebhook) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectWebhook) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGitlabProjectWebhook) GetSslVerification() *plugin.TValue[bool] {
	return &c.SslVerification
}

// mqlGitlabProjectMergeRequest for the gitlab.project.mergeRequest resource
type mqlGitlabProjectMergeRequest struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectMergeRequestInternal it will be used here
	Id           plugin.TValue[int64]
	InternalId   plugin.TValue[int64]
	Title        plugin.TValue[string]
	State        plugin.TValue[string]
	Description  plugin.TValue[string]
	SourceBranch plugin.TValue[string]
	TargetBranch plugin.TValue[string]
	Author       plugin.TValue[string]
	CreatedAt    plugin.TValue[*time.Time]
	UpdatedAt    plugin.TValue[*time.Time]
	MergedAt     plugin.TValue[*time.Time]
	Draft        plugin.TValue[bool]
	WebURL       plugin.TValue[string]
	Labels       plugin.TValue[[]any]
	Milestone    plugin.TValue[*mqlGitlabProjectMilestone]
}

// createGitlabProjectMergeRequest creates a new instance of this resource
func createGitlabProjectMergeRequest(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectMergeRequest{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.mergeRequest", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectMergeRequest) MqlName() string {
	return "gitlab.project.mergeRequest"
}

func (c *mqlGitlabProjectMergeRequest) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectMergeRequest) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectMergeRequest) GetInternalId() *plugin.TValue[int64] {
	return &c.InternalId
}

func (c *mqlGitlabProjectMergeRequest) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGitlabProjectMergeRequest) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGitlabProjectMergeRequest) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectMergeRequest) GetSourceBranch() *plugin.TValue[string] {
	return &c.SourceBranch
}

func (c *mqlGitlabProjectMergeRequest) GetTargetBranch() *plugin.TValue[string] {
	return &c.TargetBranch
}

func (c *mqlGitlabProjectMergeRequest) GetAuthor() *plugin.TValue[string] {
	return &c.Author
}

func (c *mqlGitlabProjectMergeRequest) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectMergeRequest) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGitlabProjectMergeRequest) GetMergedAt() *plugin.TValue[*time.Time] {
	return &c.MergedAt
}

func (c *mqlGitlabProjectMergeRequest) GetDraft() *plugin.TValue[bool] {
	return &c.Draft
}

func (c *mqlGitlabProjectMergeRequest) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabProjectMergeRequest) GetLabels() *plugin.TValue[[]any] {
	return &c.Labels
}

func (c *mqlGitlabProjectMergeRequest) GetMilestone() *plugin.TValue[*mqlGitlabProjectMilestone] {
	return plugin.GetOrCompute[*mqlGitlabProjectMilestone](&c.Milestone, func() (*mqlGitlabProjectMilestone, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project.mergeRequest", c.__id, "milestone")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabProjectMilestone), nil
			}
		}

		return c.milestone()
	})
}

// mqlGitlabProjectIssue for the gitlab.project.issue resource
type mqlGitlabProjectIssue struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectIssueInternal it will be used here
	Id           plugin.TValue[int64]
	InternalId   plugin.TValue[int64]
	Title        plugin.TValue[string]
	State        plugin.TValue[string]
	Description  plugin.TValue[string]
	Author       plugin.TValue[string]
	CreatedAt    plugin.TValue[*time.Time]
	UpdatedAt    plugin.TValue[*time.Time]
	ClosedAt     plugin.TValue[*time.Time]
	DueDate      plugin.TValue[*time.Time]
	Confidential plugin.TValue[bool]
	WebURL       plugin.TValue[string]
	Labels       plugin.TValue[[]any]
	Milestone    plugin.TValue[*mqlGitlabProjectMilestone]
}

// createGitlabProjectIssue creates a new instance of this resource
func createGitlabProjectIssue(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectIssue{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.issue", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectIssue) MqlName() string {
	return "gitlab.project.issue"
}

func (c *mqlGitlabProjectIssue) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectIssue) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectIssue) GetInternalId() *plugin.TValue[int64] {
	return &c.InternalId
}

func (c *mqlGitlabProjectIssue) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGitlabProjectIssue) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGitlabProjectIssue) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectIssue) GetAuthor() *plugin.TValue[string] {
	return &c.Author
}

func (c *mqlGitlabProjectIssue) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectIssue) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGitlabProjectIssue) GetClosedAt() *plugin.TValue[*time.Time] {
	return &c.ClosedAt
}

func (c *mqlGitlabProjectIssue) GetDueDate() *plugin.TValue[*time.Time] {
	return &c.DueDate
}

func (c *mqlGitlabProjectIssue) GetConfidential() *plugin.TValue[bool] {
	return &c.Confidential
}

func (c *mqlGitlabProjectIssue) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabProjectIssue) GetLabels() *plugin.TValue[[]any] {
	return &c.Labels
}

func (c *mqlGitlabProjectIssue) GetMilestone() *plugin.TValue[*mqlGitlabProjectMilestone] {
	return plugin.GetOrCompute[*mqlGitlabProjectMilestone](&c.Milestone, func() (*mqlGitlabProjectMilestone, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("gitlab.project.issue", c.__id, "milestone")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGitlabProjectMilestone), nil
			}
		}

		return c.milestone()
	})
}

// mqlGitlabProjectRelease for the gitlab.project.release resource
type mqlGitlabProjectRelease struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectReleaseInternal it will be used here
	TagName     plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	CreatedAt   plugin.TValue[*time.Time]
	ReleasedAt  plugin.TValue[*time.Time]
	Author      plugin.TValue[string]
}

// createGitlabProjectRelease creates a new instance of this resource
func createGitlabProjectRelease(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectRelease{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.release", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectRelease) MqlName() string {
	return "gitlab.project.release"
}

func (c *mqlGitlabProjectRelease) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectRelease) GetTagName() *plugin.TValue[string] {
	return &c.TagName
}

func (c *mqlGitlabProjectRelease) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectRelease) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectRelease) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectRelease) GetReleasedAt() *plugin.TValue[*time.Time] {
	return &c.ReleasedAt
}

func (c *mqlGitlabProjectRelease) GetAuthor() *plugin.TValue[string] {
	return &c.Author
}

// mqlGitlabProjectVariable for the gitlab.project.variable resource
type mqlGitlabProjectVariable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectVariableInternal it will be used here
	Key              plugin.TValue[string]
	VariableType     plugin.TValue[string]
	Protected        plugin.TValue[bool]
	Masked           plugin.TValue[bool]
	Hidden           plugin.TValue[bool]
	Raw              plugin.TValue[bool]
	EnvironmentScope plugin.TValue[string]
	Description      plugin.TValue[string]
}

// createGitlabProjectVariable creates a new instance of this resource
func createGitlabProjectVariable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectVariable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.variable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectVariable) MqlName() string {
	return "gitlab.project.variable"
}

func (c *mqlGitlabProjectVariable) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectVariable) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlGitlabProjectVariable) GetVariableType() *plugin.TValue[string] {
	return &c.VariableType
}

func (c *mqlGitlabProjectVariable) GetProtected() *plugin.TValue[bool] {
	return &c.Protected
}

func (c *mqlGitlabProjectVariable) GetMasked() *plugin.TValue[bool] {
	return &c.Masked
}

func (c *mqlGitlabProjectVariable) GetHidden() *plugin.TValue[bool] {
	return &c.Hidden
}

func (c *mqlGitlabProjectVariable) GetRaw() *plugin.TValue[bool] {
	return &c.Raw
}

func (c *mqlGitlabProjectVariable) GetEnvironmentScope() *plugin.TValue[string] {
	return &c.EnvironmentScope
}

func (c *mqlGitlabProjectVariable) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

// mqlGitlabProjectMilestone for the gitlab.project.milestone resource
type mqlGitlabProjectMilestone struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectMilestoneInternal it will be used here
	Id          plugin.TValue[int64]
	InternalId  plugin.TValue[int64]
	ProjectId   plugin.TValue[int64]
	Title       plugin.TValue[string]
	Description plugin.TValue[string]
	DueDate     plugin.TValue[*time.Time]
	StartDate   plugin.TValue[*time.Time]
	State       plugin.TValue[string]
	UpdatedAt   plugin.TValue[*time.Time]
	CreatedAt   plugin.TValue[*time.Time]
	Expired     plugin.TValue[bool]
}

// createGitlabProjectMilestone creates a new instance of this resource
func createGitlabProjectMilestone(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectMilestone{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.milestone", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectMilestone) MqlName() string {
	return "gitlab.project.milestone"
}

func (c *mqlGitlabProjectMilestone) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectMilestone) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectMilestone) GetInternalId() *plugin.TValue[int64] {
	return &c.InternalId
}

func (c *mqlGitlabProjectMilestone) GetProjectId() *plugin.TValue[int64] {
	return &c.ProjectId
}

func (c *mqlGitlabProjectMilestone) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGitlabProjectMilestone) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectMilestone) GetDueDate() *plugin.TValue[*time.Time] {
	return &c.DueDate
}

func (c *mqlGitlabProjectMilestone) GetStartDate() *plugin.TValue[*time.Time] {
	return &c.StartDate
}

func (c *mqlGitlabProjectMilestone) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGitlabProjectMilestone) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGitlabProjectMilestone) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectMilestone) GetExpired() *plugin.TValue[bool] {
	return &c.Expired
}

// mqlGitlabProjectLabel for the gitlab.project.label resource
type mqlGitlabProjectLabel struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectLabelInternal it will be used here
	Id                     plugin.TValue[int64]
	Name                   plugin.TValue[string]
	Color                  plugin.TValue[string]
	TextColor              plugin.TValue[string]
	Description            plugin.TValue[string]
	DescriptionHtml        plugin.TValue[string]
	OpenIssuesCount        plugin.TValue[int64]
	ClosedIssuesCount      plugin.TValue[int64]
	OpenMergeRequestsCount plugin.TValue[int64]
	Subscribed             plugin.TValue[bool]
	Priority               plugin.TValue[int64]
	IsProjectLabel         plugin.TValue[bool]
}

// createGitlabProjectLabel creates a new instance of this resource
func createGitlabProjectLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectLabel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.label", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectLabel) MqlName() string {
	return "gitlab.project.label"
}

func (c *mqlGitlabProjectLabel) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectLabel) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectLabel) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectLabel) GetColor() *plugin.TValue[string] {
	return &c.Color
}

func (c *mqlGitlabProjectLabel) GetTextColor() *plugin.TValue[string] {
	return &c.TextColor
}

func (c *mqlGitlabProjectLabel) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectLabel) GetDescriptionHtml() *plugin.TValue[string] {
	return &c.DescriptionHtml
}

func (c *mqlGitlabProjectLabel) GetOpenIssuesCount() *plugin.TValue[int64] {
	return &c.OpenIssuesCount
}

func (c *mqlGitlabProjectLabel) GetClosedIssuesCount() *plugin.TValue[int64] {
	return &c.ClosedIssuesCount
}

func (c *mqlGitlabProjectLabel) GetOpenMergeRequestsCount() *plugin.TValue[int64] {
	return &c.OpenMergeRequestsCount
}

func (c *mqlGitlabProjectLabel) GetSubscribed() *plugin.TValue[bool] {
	return &c.Subscribed
}

func (c *mqlGitlabProjectLabel) GetPriority() *plugin.TValue[int64] {
	return &c.Priority
}

func (c *mqlGitlabProjectLabel) GetIsProjectLabel() *plugin.TValue[bool] {
	return &c.IsProjectLabel
}

// mqlGitlabGroupLabel for the gitlab.group.label resource
type mqlGitlabGroupLabel struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupLabelInternal it will be used here
	Id                     plugin.TValue[int64]
	Name                   plugin.TValue[string]
	Color                  plugin.TValue[string]
	TextColor              plugin.TValue[string]
	Description            plugin.TValue[string]
	DescriptionHtml        plugin.TValue[string]
	OpenIssuesCount        plugin.TValue[int64]
	ClosedIssuesCount      plugin.TValue[int64]
	OpenMergeRequestsCount plugin.TValue[int64]
	Subscribed             plugin.TValue[bool]
	Priority               plugin.TValue[int64]
	IsProjectLabel         plugin.TValue[bool]
}

// createGitlabGroupLabel creates a new instance of this resource
func createGitlabGroupLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroupLabel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group.label", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroupLabel) MqlName() string {
	return "gitlab.group.label"
}

func (c *mqlGitlabGroupLabel) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroupLabel) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroupLabel) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabGroupLabel) GetColor() *plugin.TValue[string] {
	return &c.Color
}

func (c *mqlGitlabGroupLabel) GetTextColor() *plugin.TValue[string] {
	return &c.TextColor
}

func (c *mqlGitlabGroupLabel) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabGroupLabel) GetDescriptionHtml() *plugin.TValue[string] {
	return &c.DescriptionHtml
}

func (c *mqlGitlabGroupLabel) GetOpenIssuesCount() *plugin.TValue[int64] {
	return &c.OpenIssuesCount
}

func (c *mqlGitlabGroupLabel) GetClosedIssuesCount() *plugin.TValue[int64] {
	return &c.ClosedIssuesCount
}

func (c *mqlGitlabGroupLabel) GetOpenMergeRequestsCount() *plugin.TValue[int64] {
	return &c.OpenMergeRequestsCount
}

func (c *mqlGitlabGroupLabel) GetSubscribed() *plugin.TValue[bool] {
	return &c.Subscribed
}

func (c *mqlGitlabGroupLabel) GetPriority() *plugin.TValue[int64] {
	return &c.Priority
}

func (c *mqlGitlabGroupLabel) GetIsProjectLabel() *plugin.TValue[bool] {
	return &c.IsProjectLabel
}

// mqlGitlabProjectPipeline for the gitlab.project.pipeline resource
type mqlGitlabProjectPipeline struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectPipelineInternal it will be used here
	Id         plugin.TValue[int64]
	InternalId plugin.TValue[int64]
	ProjectId  plugin.TValue[int64]
	Status     plugin.TValue[string]
	Source     plugin.TValue[string]
	Ref        plugin.TValue[string]
	Sha        plugin.TValue[string]
	Name       plugin.TValue[string]
	WebURL     plugin.TValue[string]
	CreatedAt  plugin.TValue[*time.Time]
	UpdatedAt  plugin.TValue[*time.Time]
}

// createGitlabProjectPipeline creates a new instance of this resource
func createGitlabProjectPipeline(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectPipeline{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.pipeline", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectPipeline) MqlName() string {
	return "gitlab.project.pipeline"
}

func (c *mqlGitlabProjectPipeline) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectPipeline) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectPipeline) GetInternalId() *plugin.TValue[int64] {
	return &c.InternalId
}

func (c *mqlGitlabProjectPipeline) GetProjectId() *plugin.TValue[int64] {
	return &c.ProjectId
}

func (c *mqlGitlabProjectPipeline) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlGitlabProjectPipeline) GetSource() *plugin.TValue[string] {
	return &c.Source
}

func (c *mqlGitlabProjectPipeline) GetRef() *plugin.TValue[string] {
	return &c.Ref
}

func (c *mqlGitlabProjectPipeline) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGitlabProjectPipeline) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectPipeline) GetWebURL() *plugin.TValue[string] {
	return &c.WebURL
}

func (c *mqlGitlabProjectPipeline) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectPipeline) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

// mqlGitlabProjectRunner for the gitlab.project.runner resource
type mqlGitlabProjectRunner struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectRunnerInternal it will be used here
	Id          plugin.TValue[int64]
	Description plugin.TValue[string]
	Name        plugin.TValue[string]
	RunnerType  plugin.TValue[string]
	Paused      plugin.TValue[bool]
	IsShared    plugin.TValue[bool]
	Online      plugin.TValue[bool]
	Status      plugin.TValue[string]
}

// createGitlabProjectRunner creates a new instance of this resource
func createGitlabProjectRunner(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectRunner{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.runner", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectRunner) MqlName() string {
	return "gitlab.project.runner"
}

func (c *mqlGitlabProjectRunner) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectRunner) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectRunner) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGitlabProjectRunner) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectRunner) GetRunnerType() *plugin.TValue[string] {
	return &c.RunnerType
}

func (c *mqlGitlabProjectRunner) GetPaused() *plugin.TValue[bool] {
	return &c.Paused
}

func (c *mqlGitlabProjectRunner) GetIsShared() *plugin.TValue[bool] {
	return &c.IsShared
}

func (c *mqlGitlabProjectRunner) GetOnline() *plugin.TValue[bool] {
	return &c.Online
}

func (c *mqlGitlabProjectRunner) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

// mqlGitlabProjectPushRule for the gitlab.project.pushRule resource
type mqlGitlabProjectPushRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectPushRuleInternal it will be used here
	Id                         plugin.TValue[int64]
	CommitMessageRegex         plugin.TValue[string]
	CommitMessageNegativeRegex plugin.TValue[string]
	BranchNameRegex            plugin.TValue[string]
	DenyDeleteTag              plugin.TValue[bool]
	MemberCheck                plugin.TValue[bool]
	PreventSecrets             plugin.TValue[bool]
	AuthorEmailRegex           plugin.TValue[string]
	FileNameRegex              plugin.TValue[string]
	MaxFileSize                plugin.TValue[int64]
	CommitCommitterCheck       plugin.TValue[bool]
	CommitCommitterNameCheck   plugin.TValue[bool]
	RejectUnsignedCommits      plugin.TValue[bool]
	RejectNonDCOCommits        plugin.TValue[bool]
	CreatedAt                  plugin.TValue[*time.Time]
}

// createGitlabProjectPushRule creates a new instance of this resource
func createGitlabProjectPushRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectPushRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.pushRule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectPushRule) MqlName() string {
	return "gitlab.project.pushRule"
}

func (c *mqlGitlabProjectPushRule) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectPushRule) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectPushRule) GetCommitMessageRegex() *plugin.TValue[string] {
	return &c.CommitMessageRegex
}

func (c *mqlGitlabProjectPushRule) GetCommitMessageNegativeRegex() *plugin.TValue[string] {
	return &c.CommitMessageNegativeRegex
}

func (c *mqlGitlabProjectPushRule) GetBranchNameRegex() *plugin.TValue[string] {
	return &c.BranchNameRegex
}

func (c *mqlGitlabProjectPushRule) GetDenyDeleteTag() *plugin.TValue[bool] {
	return &c.DenyDeleteTag
}

func (c *mqlGitlabProjectPushRule) GetMemberCheck() *plugin.TValue[bool] {
	return &c.MemberCheck
}

func (c *mqlGitlabProjectPushRule) GetPreventSecrets() *plugin.TValue[bool] {
	return &c.PreventSecrets
}

func (c *mqlGitlabProjectPushRule) GetAuthorEmailRegex() *plugin.TValue[string] {
	return &c.AuthorEmailRegex
}

func (c *mqlGitlabProjectPushRule) GetFileNameRegex() *plugin.TValue[string] {
	return &c.FileNameRegex
}

func (c *mqlGitlabProjectPushRule) GetMaxFileSize() *plugin.TValue[int64] {
	return &c.MaxFileSize
}

func (c *mqlGitlabProjectPushRule) GetCommitCommitterCheck() *plugin.TValue[bool] {
	return &c.CommitCommitterCheck
}

func (c *mqlGitlabProjectPushRule) GetCommitCommitterNameCheck() *plugin.TValue[bool] {
	return &c.CommitCommitterNameCheck
}

func (c *mqlGitlabProjectPushRule) GetRejectUnsignedCommits() *plugin.TValue[bool] {
	return &c.RejectUnsignedCommits
}

func (c *mqlGitlabProjectPushRule) GetRejectNonDCOCommits() *plugin.TValue[bool] {
	return &c.RejectNonDCOCommits
}

func (c *mqlGitlabProjectPushRule) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlGitlabGroupPushRule for the gitlab.group.pushRule resource
type mqlGitlabGroupPushRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupPushRuleInternal it will be used here
	Id                         plugin.TValue[int64]
	CommitMessageRegex         plugin.TValue[string]
	CommitMessageNegativeRegex plugin.TValue[string]
	BranchNameRegex            plugin.TValue[string]
	DenyDeleteTag              plugin.TValue[bool]
	MemberCheck                plugin.TValue[bool]
	PreventSecrets             plugin.TValue[bool]
	AuthorEmailRegex           plugin.TValue[string]
	FileNameRegex              plugin.TValue[string]
	MaxFileSize                plugin.TValue[int64]
	CommitCommitterCheck       plugin.TValue[bool]
	CommitCommitterNameCheck   plugin.TValue[bool]
	RejectUnsignedCommits      plugin.TValue[bool]
	RejectNonDCOCommits        plugin.TValue[bool]
	CreatedAt                  plugin.TValue[*time.Time]
}

// createGitlabGroupPushRule creates a new instance of this resource
func createGitlabGroupPushRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroupPushRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group.pushRule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroupPushRule) MqlName() string {
	return "gitlab.group.pushRule"
}

func (c *mqlGitlabGroupPushRule) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroupPushRule) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroupPushRule) GetCommitMessageRegex() *plugin.TValue[string] {
	return &c.CommitMessageRegex
}

func (c *mqlGitlabGroupPushRule) GetCommitMessageNegativeRegex() *plugin.TValue[string] {
	return &c.CommitMessageNegativeRegex
}

func (c *mqlGitlabGroupPushRule) GetBranchNameRegex() *plugin.TValue[string] {
	return &c.BranchNameRegex
}

func (c *mqlGitlabGroupPushRule) GetDenyDeleteTag() *plugin.TValue[bool] {
	return &c.DenyDeleteTag
}

func (c *mqlGitlabGroupPushRule) GetMemberCheck() *plugin.TValue[bool] {
	return &c.MemberCheck
}

func (c *mqlGitlabGroupPushRule) GetPreventSecrets() *plugin.TValue[bool] {
	return &c.PreventSecrets
}

func (c *mqlGitlabGroupPushRule) GetAuthorEmailRegex() *plugin.TValue[string] {
	return &c.AuthorEmailRegex
}

func (c *mqlGitlabGroupPushRule) GetFileNameRegex() *plugin.TValue[string] {
	return &c.FileNameRegex
}

func (c *mqlGitlabGroupPushRule) GetMaxFileSize() *plugin.TValue[int64] {
	return &c.MaxFileSize
}

func (c *mqlGitlabGroupPushRule) GetCommitCommitterCheck() *plugin.TValue[bool] {
	return &c.CommitCommitterCheck
}

func (c *mqlGitlabGroupPushRule) GetCommitCommitterNameCheck() *plugin.TValue[bool] {
	return &c.CommitCommitterNameCheck
}

func (c *mqlGitlabGroupPushRule) GetRejectUnsignedCommits() *plugin.TValue[bool] {
	return &c.RejectUnsignedCommits
}

func (c *mqlGitlabGroupPushRule) GetRejectNonDCOCommits() *plugin.TValue[bool] {
	return &c.RejectNonDCOCommits
}

func (c *mqlGitlabGroupPushRule) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlGitlabProjectAccessToken for the gitlab.project.accessToken resource
type mqlGitlabProjectAccessToken struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectAccessTokenInternal it will be used here
	Id          plugin.TValue[int64]
	Name        plugin.TValue[string]
	Revoked     plugin.TValue[bool]
	Active      plugin.TValue[bool]
	Scopes      plugin.TValue[[]any]
	CreatedAt   plugin.TValue[*time.Time]
	ExpiresAt   plugin.TValue[*time.Time]
	LastUsedAt  plugin.TValue[*time.Time]
	AccessLevel plugin.TValue[int64]
}

// createGitlabProjectAccessToken creates a new instance of this resource
func createGitlabProjectAccessToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectAccessToken{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.accessToken", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectAccessToken) MqlName() string {
	return "gitlab.project.accessToken"
}

func (c *mqlGitlabProjectAccessToken) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectAccessToken) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectAccessToken) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectAccessToken) GetRevoked() *plugin.TValue[bool] {
	return &c.Revoked
}

func (c *mqlGitlabProjectAccessToken) GetActive() *plugin.TValue[bool] {
	return &c.Active
}

func (c *mqlGitlabProjectAccessToken) GetScopes() *plugin.TValue[[]any] {
	return &c.Scopes
}

func (c *mqlGitlabProjectAccessToken) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectAccessToken) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

func (c *mqlGitlabProjectAccessToken) GetLastUsedAt() *plugin.TValue[*time.Time] {
	return &c.LastUsedAt
}

func (c *mqlGitlabProjectAccessToken) GetAccessLevel() *plugin.TValue[int64] {
	return &c.AccessLevel
}

// mqlGitlabGroupAccessToken for the gitlab.group.accessToken resource
type mqlGitlabGroupAccessToken struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupAccessTokenInternal it will be used here
	Id          plugin.TValue[int64]
	Name        plugin.TValue[string]
	Revoked     plugin.TValue[bool]
	Active      plugin.TValue[bool]
	Scopes      plugin.TValue[[]any]
	CreatedAt   plugin.TValue[*time.Time]
	ExpiresAt   plugin.TValue[*time.Time]
	LastUsedAt  plugin.TValue[*time.Time]
	AccessLevel plugin.TValue[int64]
}

// createGitlabGroupAccessToken creates a new instance of this resource
func createGitlabGroupAccessToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroupAccessToken{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group.accessToken", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroupAccessToken) MqlName() string {
	return "gitlab.group.accessToken"
}

func (c *mqlGitlabGroupAccessToken) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroupAccessToken) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroupAccessToken) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabGroupAccessToken) GetRevoked() *plugin.TValue[bool] {
	return &c.Revoked
}

func (c *mqlGitlabGroupAccessToken) GetActive() *plugin.TValue[bool] {
	return &c.Active
}

func (c *mqlGitlabGroupAccessToken) GetScopes() *plugin.TValue[[]any] {
	return &c.Scopes
}

func (c *mqlGitlabGroupAccessToken) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabGroupAccessToken) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

func (c *mqlGitlabGroupAccessToken) GetLastUsedAt() *plugin.TValue[*time.Time] {
	return &c.LastUsedAt
}

func (c *mqlGitlabGroupAccessToken) GetAccessLevel() *plugin.TValue[int64] {
	return &c.AccessLevel
}

// mqlGitlabProjectDeployKey for the gitlab.project.deployKey resource
type mqlGitlabProjectDeployKey struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectDeployKeyInternal it will be used here
	Id                plugin.TValue[int64]
	Title             plugin.TValue[string]
	Key               plugin.TValue[string]
	Fingerprint       plugin.TValue[string]
	FingerprintSHA256 plugin.TValue[string]
	CreatedAt         plugin.TValue[*time.Time]
	ExpiresAt         plugin.TValue[*time.Time]
	CanPush           plugin.TValue[bool]
}

// createGitlabProjectDeployKey creates a new instance of this resource
func createGitlabProjectDeployKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectDeployKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.deployKey", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectDeployKey) MqlName() string {
	return "gitlab.project.deployKey"
}

func (c *mqlGitlabProjectDeployKey) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectDeployKey) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectDeployKey) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGitlabProjectDeployKey) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlGitlabProjectDeployKey) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlGitlabProjectDeployKey) GetFingerprintSHA256() *plugin.TValue[string] {
	return &c.FingerprintSHA256
}

func (c *mqlGitlabProjectDeployKey) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGitlabProjectDeployKey) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

func (c *mqlGitlabProjectDeployKey) GetCanPush() *plugin.TValue[bool] {
	return &c.CanPush
}

// mqlGitlabProjectDeployToken for the gitlab.project.deployToken resource
type mqlGitlabProjectDeployToken struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectDeployTokenInternal it will be used here
	Id        plugin.TValue[int64]
	Name      plugin.TValue[string]
	Username  plugin.TValue[string]
	ExpiresAt plugin.TValue[*time.Time]
	Revoked   plugin.TValue[bool]
	Expired   plugin.TValue[bool]
	Scopes    plugin.TValue[[]any]
}

// createGitlabProjectDeployToken creates a new instance of this resource
func createGitlabProjectDeployToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectDeployToken{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.deployToken", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectDeployToken) MqlName() string {
	return "gitlab.project.deployToken"
}

func (c *mqlGitlabProjectDeployToken) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectDeployToken) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabProjectDeployToken) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabProjectDeployToken) GetUsername() *plugin.TValue[string] {
	return &c.Username
}

func (c *mqlGitlabProjectDeployToken) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

func (c *mqlGitlabProjectDeployToken) GetRevoked() *plugin.TValue[bool] {
	return &c.Revoked
}

func (c *mqlGitlabProjectDeployToken) GetExpired() *plugin.TValue[bool] {
	return &c.Expired
}

func (c *mqlGitlabProjectDeployToken) GetScopes() *plugin.TValue[[]any] {
	return &c.Scopes
}

// mqlGitlabGroupDeployToken for the gitlab.group.deployToken resource
type mqlGitlabGroupDeployToken struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupDeployTokenInternal it will be used here
	Id        plugin.TValue[int64]
	Name      plugin.TValue[string]
	Username  plugin.TValue[string]
	ExpiresAt plugin.TValue[*time.Time]
	Revoked   plugin.TValue[bool]
	Expired   plugin.TValue[bool]
	Scopes    plugin.TValue[[]any]
}

// createGitlabGroupDeployToken creates a new instance of this resource
func createGitlabGroupDeployToken(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroupDeployToken{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group.deployToken", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroupDeployToken) MqlName() string {
	return "gitlab.group.deployToken"
}

func (c *mqlGitlabGroupDeployToken) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroupDeployToken) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroupDeployToken) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabGroupDeployToken) GetUsername() *plugin.TValue[string] {
	return &c.Username
}

func (c *mqlGitlabGroupDeployToken) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

func (c *mqlGitlabGroupDeployToken) GetRevoked() *plugin.TValue[bool] {
	return &c.Revoked
}

func (c *mqlGitlabGroupDeployToken) GetExpired() *plugin.TValue[bool] {
	return &c.Expired
}

func (c *mqlGitlabGroupDeployToken) GetScopes() *plugin.TValue[[]any] {
	return &c.Scopes
}

// mqlGitlabGroupProtectedBranch for the gitlab.group.protectedBranch resource
type mqlGitlabGroupProtectedBranch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabGroupProtectedBranchInternal it will be used here
	Id                        plugin.TValue[int64]
	Name                      plugin.TValue[string]
	AllowForcePush            plugin.TValue[bool]
	CodeOwnerApprovalRequired plugin.TValue[bool]
}

// createGitlabGroupProtectedBranch creates a new instance of this resource
func createGitlabGroupProtectedBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabGroupProtectedBranch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.group.protectedBranch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabGroupProtectedBranch) MqlName() string {
	return "gitlab.group.protectedBranch"
}

func (c *mqlGitlabGroupProtectedBranch) MqlID() string {
	return c.__id
}

func (c *mqlGitlabGroupProtectedBranch) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGitlabGroupProtectedBranch) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitlabGroupProtectedBranch) GetAllowForcePush() *plugin.TValue[bool] {
	return &c.AllowForcePush
}

func (c *mqlGitlabGroupProtectedBranch) GetCodeOwnerApprovalRequired() *plugin.TValue[bool] {
	return &c.CodeOwnerApprovalRequired
}

// mqlGitlabProjectSecuritySetting for the gitlab.project.securitySetting resource
type mqlGitlabProjectSecuritySetting struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitlabProjectSecuritySettingInternal it will be used here
	AutoFixContainerScanning            plugin.TValue[bool]
	AutoFixDAST                         plugin.TValue[bool]
	AutoFixDependencyScanning           plugin.TValue[bool]
	AutoFixSAST                         plugin.TValue[bool]
	ContinuousVulnerabilityScansEnabled plugin.TValue[bool]
	ContainerScanningForRegistryEnabled plugin.TValue[bool]
	SecretPushProtectionEnabled         plugin.TValue[bool]
}

// createGitlabProjectSecuritySetting creates a new instance of this resource
func createGitlabProjectSecuritySetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitlabProjectSecuritySetting{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("gitlab.project.securitySetting", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitlabProjectSecuritySetting) MqlName() string {
	return "gitlab.project.securitySetting"
}

func (c *mqlGitlabProjectSecuritySetting) MqlID() string {
	return c.__id
}

func (c *mqlGitlabProjectSecuritySetting) GetAutoFixContainerScanning() *plugin.TValue[bool] {
	return &c.AutoFixContainerScanning
}

func (c *mqlGitlabProjectSecuritySetting) GetAutoFixDAST() *plugin.TValue[bool] {
	return &c.AutoFixDAST
}

func (c *mqlGitlabProjectSecuritySetting) GetAutoFixDependencyScanning() *plugin.TValue[bool] {
	return &c.AutoFixDependencyScanning
}

func (c *mqlGitlabProjectSecuritySetting) GetAutoFixSAST() *plugin.TValue[bool] {
	return &c.AutoFixSAST
}

func (c *mqlGitlabProjectSecuritySetting) GetContinuousVulnerabilityScansEnabled() *plugin.TValue[bool] {
	return &c.ContinuousVulnerabilityScansEnabled
}

func (c *mqlGitlabProjectSecuritySetting) GetContainerScanningForRegistryEnabled() *plugin.TValue[bool] {
	return &c.ContainerScanningForRegistryEnabled
}

func (c *mqlGitlabProjectSecuritySetting) GetSecretPushProtectionEnabled() *plugin.TValue[bool] {
	return &c.SecretPushProtectionEnabled
}
