// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"github.com/rs/zerolog/log"
	"go.mondoo.com/cnquery/v12/llx"
	"go.mondoo.com/cnquery/v12/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v12/types"
)

// The MQL type names exposed as public consts for ease of reference.
const (
	ResourceNmap                   string = "nmap"
	ResourceNmapNetwork            string = "nmap.network"
	ResourceNmapHost               string = "nmap.host"
	ResourceNmapPort               string = "nmap.port"
	ResourceNmapVersionInformation string = "nmap.versionInformation"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory{
		"nmap": {
			// to override args, implement: initNmap(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createNmap,
		},
		"nmap.network": {
			// to override args, implement: initNmapNetwork(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createNmapNetwork,
		},
		"nmap.host": {
			Init:   initNmapHost,
			Create: createNmapHost,
		},
		"nmap.port": {
			// to override args, implement: initNmapPort(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createNmapPort,
		},
		"nmap.versionInformation": {
			// to override args, implement: initNmapVersionInformation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createNmapVersionInformation,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			mqlId := res.MqlID()
			if mqlId == "" {
				log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
			}
			id := name + "\x00" + mqlId
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"nmap.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmap).GetVersion()).ToDataRes(types.Resource("nmap.versionInformation"))
	},
	"nmap.network.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapNetwork).GetTarget()).ToDataRes(types.String)
	},
	"nmap.network.hosts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapNetwork).GetHosts()).ToDataRes(types.Array(types.Resource("nmap.host")))
	},
	"nmap.network.warnings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapNetwork).GetWarnings()).ToDataRes(types.Array(types.String))
	},
	"nmap.host.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetName()).ToDataRes(types.String)
	},
	"nmap.host.distance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetDistance()).ToDataRes(types.Dict)
	},
	"nmap.host.os": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetOs()).ToDataRes(types.Dict)
	},
	"nmap.host.endTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetEndTime()).ToDataRes(types.Time)
	},
	"nmap.host.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetComment()).ToDataRes(types.String)
	},
	"nmap.host.trace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetTrace()).ToDataRes(types.Dict)
	},
	"nmap.host.addresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetAddresses()).ToDataRes(types.Array(types.Dict))
	},
	"nmap.host.hostnames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetHostnames()).ToDataRes(types.Array(types.Dict))
	},
	"nmap.host.ports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetPorts()).ToDataRes(types.Array(types.Resource("nmap.port")))
	},
	"nmap.host.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapHost).GetState()).ToDataRes(types.String)
	},
	"nmap.port.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetPort()).ToDataRes(types.Int)
	},
	"nmap.port.service": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetService()).ToDataRes(types.String)
	},
	"nmap.port.method": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetMethod()).ToDataRes(types.String)
	},
	"nmap.port.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetProtocol()).ToDataRes(types.String)
	},
	"nmap.port.product": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetProduct()).ToDataRes(types.String)
	},
	"nmap.port.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetVersion()).ToDataRes(types.String)
	},
	"nmap.port.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapPort).GetState()).ToDataRes(types.String)
	},
	"nmap.versionInformation.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapVersionInformation).GetVersion()).ToDataRes(types.String)
	},
	"nmap.versionInformation.platform": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapVersionInformation).GetPlatform()).ToDataRes(types.String)
	},
	"nmap.versionInformation.compiledWith": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapVersionInformation).GetCompiledWith()).ToDataRes(types.Array(types.String))
	},
	"nmap.versionInformation.compiledWithout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapVersionInformation).GetCompiledWithout()).ToDataRes(types.Array(types.String))
	},
	"nmap.versionInformation.nsockEngines": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNmapVersionInformation).GetNsockEngines()).ToDataRes(types.Array(types.String))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool{
	"nmap.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmap).__id, ok = v.Value.(string)
		return
	},
	"nmap.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmap).Version, ok = plugin.RawToTValue[*mqlNmapVersionInformation](v.Value, v.Error)
		return
	},
	"nmap.network.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapNetwork).__id, ok = v.Value.(string)
		return
	},
	"nmap.network.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapNetwork).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.network.hosts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapNetwork).Hosts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.network.warnings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapNetwork).Warnings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.host.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).__id, ok = v.Value.(string)
		return
	},
	"nmap.host.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.host.distance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Distance, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"nmap.host.os": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Os, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"nmap.host.endTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).EndTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"nmap.host.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.host.trace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Trace, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"nmap.host.addresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Addresses, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.host.hostnames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Hostnames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.host.ports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).Ports, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.host.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapHost).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).__id, ok = v.Value.(string)
		return
	},
	"nmap.port.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"nmap.port.service": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Service, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.method": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Method, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.product": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Product, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.port.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapPort).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.versionInformation.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).__id, ok = v.Value.(string)
		return
	},
	"nmap.versionInformation.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.versionInformation.platform": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).Platform, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"nmap.versionInformation.compiledWith": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).CompiledWith, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.versionInformation.compiledWithout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).CompiledWithout, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"nmap.versionInformation.nsockEngines": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNmapVersionInformation).NsockEngines, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName()+"."+field]
	if !ok {
		return errors.New("[nmap] cannot set '" + field + "' in resource '" + resource.MqlName() + "', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[nmap] cannot set '" + field + "' in resource '" + resource.MqlName() + "', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlNmap for the nmap resource
type mqlNmap struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlNmapInternal it will be used here
	Version plugin.TValue[*mqlNmapVersionInformation]
}

// createNmap creates a new instance of this resource
func createNmap(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNmap{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("nmap", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNmap) MqlName() string {
	return "nmap"
}

func (c *mqlNmap) MqlID() string {
	return c.__id
}

func (c *mqlNmap) GetVersion() *plugin.TValue[*mqlNmapVersionInformation] {
	return plugin.GetOrCompute[*mqlNmapVersionInformation](&c.Version, func() (*mqlNmapVersionInformation, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("nmap", c.__id, "version")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlNmapVersionInformation), nil
			}
		}

		return c.version()
	})
}

// mqlNmapNetwork for the nmap.network resource
type mqlNmapNetwork struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlNmapNetworkInternal
	Target   plugin.TValue[string]
	Hosts    plugin.TValue[[]any]
	Warnings plugin.TValue[[]any]
}

// createNmapNetwork creates a new instance of this resource
func createNmapNetwork(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNmapNetwork{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("nmap.network", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNmapNetwork) MqlName() string {
	return "nmap.network"
}

func (c *mqlNmapNetwork) MqlID() string {
	return c.__id
}

func (c *mqlNmapNetwork) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlNmapNetwork) GetHosts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Hosts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("nmap.network", c.__id, "hosts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.hosts()
	})
}

func (c *mqlNmapNetwork) GetWarnings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Warnings, func() ([]any, error) {
		return c.warnings()
	})
}

// mqlNmapHost for the nmap.host resource
type mqlNmapHost struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlNmapHostInternal
	Name      plugin.TValue[string]
	Distance  plugin.TValue[any]
	Os        plugin.TValue[any]
	EndTime   plugin.TValue[*time.Time]
	Comment   plugin.TValue[string]
	Trace     plugin.TValue[any]
	Addresses plugin.TValue[[]any]
	Hostnames plugin.TValue[[]any]
	Ports     plugin.TValue[[]any]
	State     plugin.TValue[string]
}

// createNmapHost creates a new instance of this resource
func createNmapHost(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNmapHost{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("nmap.host", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNmapHost) MqlName() string {
	return "nmap.host"
}

func (c *mqlNmapHost) MqlID() string {
	return c.__id
}

func (c *mqlNmapHost) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlNmapHost) GetDistance() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Distance, func() (any, error) {
		return c.distance()
	})
}

func (c *mqlNmapHost) GetOs() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Os, func() (any, error) {
		return c.os()
	})
}

func (c *mqlNmapHost) GetEndTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.EndTime, func() (*time.Time, error) {
		return c.endTime()
	})
}

func (c *mqlNmapHost) GetComment() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Comment, func() (string, error) {
		return c.comment()
	})
}

func (c *mqlNmapHost) GetTrace() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Trace, func() (any, error) {
		return c.trace()
	})
}

func (c *mqlNmapHost) GetAddresses() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Addresses, func() ([]any, error) {
		return c.addresses()
	})
}

func (c *mqlNmapHost) GetHostnames() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Hostnames, func() ([]any, error) {
		return c.hostnames()
	})
}

func (c *mqlNmapHost) GetPorts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Ports, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("nmap.host", c.__id, "ports")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ports()
	})
}

func (c *mqlNmapHost) GetState() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.State, func() (string, error) {
		return c.state()
	})
}

// mqlNmapPort for the nmap.port resource
type mqlNmapPort struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlNmapPortInternal it will be used here
	Port     plugin.TValue[int64]
	Service  plugin.TValue[string]
	Method   plugin.TValue[string]
	Protocol plugin.TValue[string]
	Product  plugin.TValue[string]
	Version  plugin.TValue[string]
	State    plugin.TValue[string]
}

// createNmapPort creates a new instance of this resource
func createNmapPort(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNmapPort{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("nmap.port", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNmapPort) MqlName() string {
	return "nmap.port"
}

func (c *mqlNmapPort) MqlID() string {
	return c.__id
}

func (c *mqlNmapPort) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlNmapPort) GetService() *plugin.TValue[string] {
	return &c.Service
}

func (c *mqlNmapPort) GetMethod() *plugin.TValue[string] {
	return &c.Method
}

func (c *mqlNmapPort) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlNmapPort) GetProduct() *plugin.TValue[string] {
	return &c.Product
}

func (c *mqlNmapPort) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlNmapPort) GetState() *plugin.TValue[string] {
	return &c.State
}

// mqlNmapVersionInformation for the nmap.versionInformation resource
type mqlNmapVersionInformation struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlNmapVersionInformationInternal it will be used here
	Version         plugin.TValue[string]
	Platform        plugin.TValue[string]
	CompiledWith    plugin.TValue[[]any]
	CompiledWithout plugin.TValue[[]any]
	NsockEngines    plugin.TValue[[]any]
}

// createNmapVersionInformation creates a new instance of this resource
func createNmapVersionInformation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNmapVersionInformation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("nmap.versionInformation", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNmapVersionInformation) MqlName() string {
	return "nmap.versionInformation"
}

func (c *mqlNmapVersionInformation) MqlID() string {
	return c.__id
}

func (c *mqlNmapVersionInformation) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlNmapVersionInformation) GetPlatform() *plugin.TValue[string] {
	return &c.Platform
}

func (c *mqlNmapVersionInformation) GetCompiledWith() *plugin.TValue[[]any] {
	return &c.CompiledWith
}

func (c *mqlNmapVersionInformation) GetCompiledWithout() *plugin.TValue[[]any] {
	return &c.CompiledWithout
}

func (c *mqlNmapVersionInformation) GetNsockEngines() *plugin.TValue[[]any] {
	return &c.NsockEngines
}
