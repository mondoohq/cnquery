// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"github.com/rs/zerolog/log"
	"go.mondoo.com/mql/v13/llx"
	"go.mondoo.com/mql/v13/providers-sdk/v1/plugin"
	"go.mondoo.com/mql/v13/types"
)

// The MQL type names exposed as public consts for ease of reference.
const (
	ResourceGithub                           string = "github"
	ResourceGitCommit                        string = "git.commit"
	ResourceGitCommitAuthor                  string = "git.commitAuthor"
	ResourceGitGpgSignature                  string = "git.gpgSignature"
	ResourceGithubOrganization               string = "github.organization"
	ResourceGithubOrganizationCustomProperty string = "github.organization.customProperty"
	ResourceGithubUser                       string = "github.user"
	ResourceGithubTeam                       string = "github.team"
	ResourceGithubCollaborator               string = "github.collaborator"
	ResourceGithubPackage                    string = "github.package"
	ResourceGithubPackages                   string = "github.packages"
	ResourceGithubRepository                 string = "github.repository"
	ResourceGithubRepositorySbom             string = "github.repository.sbom"
	ResourceGithubRepositorySbomPackage      string = "github.repository.sbom.package"
	ResourceGithubRepositorySbomRelationship string = "github.repository.sbom.relationship"
	ResourceGithubLicense                    string = "github.license"
	ResourceGithubFile                       string = "github.file"
	ResourceGithubRelease                    string = "github.release"
	ResourceGithubWebhook                    string = "github.webhook"
	ResourceGithubWorkflow                   string = "github.workflow"
	ResourceGithubBranch                     string = "github.branch"
	ResourceGithubBranchprotection           string = "github.branchprotection"
	ResourceGithubCommit                     string = "github.commit"
	ResourceGithubMergeRequest               string = "github.mergeRequest"
	ResourceGithubReview                     string = "github.review"
	ResourceGithubInstallation               string = "github.installation"
	ResourceGithubGist                       string = "github.gist"
	ResourceGithubGistfile                   string = "github.gistfile"
	ResourceGithubMilestone                  string = "github.milestone"
	ResourceGithubIssue                      string = "github.issue"
	ResourceGithubDependabotAlert            string = "github.dependabotAlert"
	ResourceGithubSecretScanningAlert        string = "github.secretScanningAlert"
	ResourceGithubCodeScanningAlert          string = "github.codeScanningAlert"
	ResourceGithubAuditLogEntry              string = "github.auditLogEntry"
	ResourceGithubRunner                     string = "github.runner"
	ResourceGithubRunnerLabel                string = "github.runnerLabel"
	ResourceGithubEnvironment                string = "github.environment"
	ResourceGithubEnvironmentProtectionRule  string = "github.environmentProtectionRule"
	ResourceGithubDeployment                 string = "github.deployment"
	ResourceGithubDeploymentStatus           string = "github.deploymentStatus"
	ResourceFinding                          string = "finding"
	ResourceFindingDetail                    string = "finding.detail"
	ResourceFindingSource                    string = "finding.source"
	ResourceFindingSeverity                  string = "finding.severity"
	ResourceFindingReference                 string = "finding.reference"
	ResourceFindingAffects                   string = "finding.affects"
	ResourceFindingComponent                 string = "finding.component"
	ResourceFindingFileComponent             string = "finding.fileComponent"
	ResourceFindingEvidence                  string = "finding.evidence"
	ResourceFindingFile                      string = "finding.file"
	ResourceFindingUser                      string = "finding.user"
	ResourceFindingProcess                   string = "finding.process"
	ResourceFindingContainer                 string = "finding.container"
	ResourceFindingKubernetes                string = "finding.kubernetes"
	ResourceFindingKubernetesPod             string = "finding.kubernetes.pod"
	ResourceFindingKubernetesNode            string = "finding.kubernetes.node"
	ResourceFindingRegistryKey               string = "finding.registryKey"
	ResourceFindingConnection                string = "finding.connection"
	ResourceFindingAttackTactic              string = "finding.attackTactic"
	ResourceFindingAttackTechnique           string = "finding.attackTechnique"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory{
		"github": {
			// to override args, implement: initGithub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithub,
		},
		"git.commit": {
			// to override args, implement: initGitCommit(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitCommit,
		},
		"git.commitAuthor": {
			// to override args, implement: initGitCommitAuthor(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitCommitAuthor,
		},
		"git.gpgSignature": {
			// to override args, implement: initGitGpgSignature(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGitGpgSignature,
		},
		"github.organization": {
			Init:   initGithubOrganization,
			Create: createGithubOrganization,
		},
		"github.organization.customProperty": {
			// to override args, implement: initGithubOrganizationCustomProperty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubOrganizationCustomProperty,
		},
		"github.user": {
			Init:   initGithubUser,
			Create: createGithubUser,
		},
		"github.team": {
			// to override args, implement: initGithubTeam(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubTeam,
		},
		"github.collaborator": {
			// to override args, implement: initGithubCollaborator(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubCollaborator,
		},
		"github.package": {
			// to override args, implement: initGithubPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubPackage,
		},
		"github.packages": {
			// to override args, implement: initGithubPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubPackages,
		},
		"github.repository": {
			Init:   initGithubRepository,
			Create: createGithubRepository,
		},
		"github.repository.sbom": {
			// to override args, implement: initGithubRepositorySbom(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRepositorySbom,
		},
		"github.repository.sbom.package": {
			// to override args, implement: initGithubRepositorySbomPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRepositorySbomPackage,
		},
		"github.repository.sbom.relationship": {
			// to override args, implement: initGithubRepositorySbomRelationship(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRepositorySbomRelationship,
		},
		"github.license": {
			// to override args, implement: initGithubLicense(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubLicense,
		},
		"github.file": {
			// to override args, implement: initGithubFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubFile,
		},
		"github.release": {
			// to override args, implement: initGithubRelease(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRelease,
		},
		"github.webhook": {
			// to override args, implement: initGithubWebhook(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubWebhook,
		},
		"github.workflow": {
			// to override args, implement: initGithubWorkflow(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubWorkflow,
		},
		"github.branch": {
			// to override args, implement: initGithubBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubBranch,
		},
		"github.branchprotection": {
			// to override args, implement: initGithubBranchprotection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubBranchprotection,
		},
		"github.commit": {
			// to override args, implement: initGithubCommit(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubCommit,
		},
		"github.mergeRequest": {
			// to override args, implement: initGithubMergeRequest(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubMergeRequest,
		},
		"github.review": {
			// to override args, implement: initGithubReview(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubReview,
		},
		"github.installation": {
			// to override args, implement: initGithubInstallation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubInstallation,
		},
		"github.gist": {
			// to override args, implement: initGithubGist(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubGist,
		},
		"github.gistfile": {
			// to override args, implement: initGithubGistfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubGistfile,
		},
		"github.milestone": {
			// to override args, implement: initGithubMilestone(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubMilestone,
		},
		"github.issue": {
			// to override args, implement: initGithubIssue(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubIssue,
		},
		"github.dependabotAlert": {
			// to override args, implement: initGithubDependabotAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubDependabotAlert,
		},
		"github.secretScanningAlert": {
			// to override args, implement: initGithubSecretScanningAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubSecretScanningAlert,
		},
		"github.codeScanningAlert": {
			// to override args, implement: initGithubCodeScanningAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubCodeScanningAlert,
		},
		"github.auditLogEntry": {
			// to override args, implement: initGithubAuditLogEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubAuditLogEntry,
		},
		"github.runner": {
			// to override args, implement: initGithubRunner(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRunner,
		},
		"github.runnerLabel": {
			// to override args, implement: initGithubRunnerLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubRunnerLabel,
		},
		"github.environment": {
			// to override args, implement: initGithubEnvironment(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubEnvironment,
		},
		"github.environmentProtectionRule": {
			// to override args, implement: initGithubEnvironmentProtectionRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubEnvironmentProtectionRule,
		},
		"github.deployment": {
			// to override args, implement: initGithubDeployment(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubDeployment,
		},
		"github.deploymentStatus": {
			// to override args, implement: initGithubDeploymentStatus(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGithubDeploymentStatus,
		},
		"finding": {
			// to override args, implement: initFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFinding,
		},
		"finding.detail": {
			// to override args, implement: initFindingDetail(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingDetail,
		},
		"finding.source": {
			// to override args, implement: initFindingSource(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingSource,
		},
		"finding.severity": {
			// to override args, implement: initFindingSeverity(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingSeverity,
		},
		"finding.reference": {
			// to override args, implement: initFindingReference(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingReference,
		},
		"finding.affects": {
			// to override args, implement: initFindingAffects(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingAffects,
		},
		"finding.component": {
			// to override args, implement: initFindingComponent(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingComponent,
		},
		"finding.fileComponent": {
			// to override args, implement: initFindingFileComponent(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingFileComponent,
		},
		"finding.evidence": {
			// to override args, implement: initFindingEvidence(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingEvidence,
		},
		"finding.file": {
			// to override args, implement: initFindingFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingFile,
		},
		"finding.user": {
			// to override args, implement: initFindingUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingUser,
		},
		"finding.process": {
			// to override args, implement: initFindingProcess(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingProcess,
		},
		"finding.container": {
			// to override args, implement: initFindingContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingContainer,
		},
		"finding.kubernetes": {
			// to override args, implement: initFindingKubernetes(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingKubernetes,
		},
		"finding.kubernetes.pod": {
			// to override args, implement: initFindingKubernetesPod(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingKubernetesPod,
		},
		"finding.kubernetes.node": {
			// to override args, implement: initFindingKubernetesNode(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingKubernetesNode,
		},
		"finding.registryKey": {
			// to override args, implement: initFindingRegistryKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingRegistryKey,
		},
		"finding.connection": {
			// to override args, implement: initFindingConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingConnection,
		},
		"finding.attackTactic": {
			// to override args, implement: initFindingAttackTactic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingAttackTactic,
		},
		"finding.attackTechnique": {
			// to override args, implement: initFindingAttackTechnique(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFindingAttackTechnique,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			mqlId := res.MqlID()
			if mqlId == "" {
				log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
			}
			id := name + "\x00" + mqlId
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"git.commit.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommit).GetSha()).ToDataRes(types.String)
	},
	"git.commit.message": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommit).GetMessage()).ToDataRes(types.String)
	},
	"git.commit.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommit).GetAuthor()).ToDataRes(types.Resource("git.commitAuthor"))
	},
	"git.commit.committer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommit).GetCommitter()).ToDataRes(types.Resource("git.commitAuthor"))
	},
	"git.commit.signatureVerification": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommit).GetSignatureVerification()).ToDataRes(types.Resource("git.gpgSignature"))
	},
	"git.commitAuthor.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommitAuthor).GetSha()).ToDataRes(types.String)
	},
	"git.commitAuthor.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommitAuthor).GetName()).ToDataRes(types.String)
	},
	"git.commitAuthor.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommitAuthor).GetEmail()).ToDataRes(types.String)
	},
	"git.commitAuthor.date": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitCommitAuthor).GetDate()).ToDataRes(types.Time)
	},
	"git.gpgSignature.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitGpgSignature).GetSha()).ToDataRes(types.String)
	},
	"git.gpgSignature.reason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitGpgSignature).GetReason()).ToDataRes(types.String)
	},
	"git.gpgSignature.verified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitGpgSignature).GetVerified()).ToDataRes(types.Bool)
	},
	"git.gpgSignature.payload": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitGpgSignature).GetPayload()).ToDataRes(types.String)
	},
	"git.gpgSignature.signature": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGitGpgSignature).GetSignature()).ToDataRes(types.String)
	},
	"github.organization.login": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetLogin()).ToDataRes(types.String)
	},
	"github.organization.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetId()).ToDataRes(types.Int)
	},
	"github.organization.nodeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetNodeId()).ToDataRes(types.String)
	},
	"github.organization.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetName()).ToDataRes(types.String)
	},
	"github.organization.company": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetCompany()).ToDataRes(types.String)
	},
	"github.organization.blog": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetBlog()).ToDataRes(types.String)
	},
	"github.organization.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetLocation()).ToDataRes(types.String)
	},
	"github.organization.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetEmail()).ToDataRes(types.String)
	},
	"github.organization.twitterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetTwitterUsername()).ToDataRes(types.String)
	},
	"github.organization.avatarUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetAvatarUrl()).ToDataRes(types.String)
	},
	"github.organization.followers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetFollowers()).ToDataRes(types.Int)
	},
	"github.organization.following": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetFollowing()).ToDataRes(types.Int)
	},
	"github.organization.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetDescription()).ToDataRes(types.String)
	},
	"github.organization.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.organization.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.organization.totalPrivateRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetTotalPrivateRepos()).ToDataRes(types.Int)
	},
	"github.organization.totalPublicRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetTotalPublicRepos()).ToDataRes(types.Int)
	},
	"github.organization.ownedPrivateRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetOwnedPrivateRepos()).ToDataRes(types.Int)
	},
	"github.organization.privateGists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetPrivateGists()).ToDataRes(types.Int)
	},
	"github.organization.diskUsage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetDiskUsage()).ToDataRes(types.Int)
	},
	"github.organization.collaborators": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetCollaborators()).ToDataRes(types.Int)
	},
	"github.organization.billingEmail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetBillingEmail()).ToDataRes(types.String)
	},
	"github.organization.plan": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetPlan()).ToDataRes(types.Dict)
	},
	"github.organization.twoFactorRequirementEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetTwoFactorRequirementEnabled()).ToDataRes(types.Bool)
	},
	"github.organization.isVerified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetIsVerified()).ToDataRes(types.Bool)
	},
	"github.organization.defaultRepositoryPermission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetDefaultRepositoryPermission()).ToDataRes(types.String)
	},
	"github.organization.membersCanCreateRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreateRepositories()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreatePublicRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreatePublicRepositories()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreatePrivateRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreatePrivateRepositories()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreateInternalRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreateInternalRepositories()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreatePages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreatePages()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreatePublicPages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreatePublicPages()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanCreatePrivatePages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanCreatePrivatePages()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanForkPrivateRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanForkPrivateRepos()).ToDataRes(types.Bool)
	},
	"github.organization.dependabotAlertsEnabledForNewRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetDependabotAlertsEnabledForNewRepos()).ToDataRes(types.Bool)
	},
	"github.organization.dependabotSecurityUpdatesEnabledForNewRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetDependabotSecurityUpdatesEnabledForNewRepos()).ToDataRes(types.Bool)
	},
	"github.organization.advancedSecurityEnabledForNewRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetAdvancedSecurityEnabledForNewRepos()).ToDataRes(types.Bool)
	},
	"github.organization.secretScanningEnabledForNewRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetSecretScanningEnabledForNewRepos()).ToDataRes(types.Bool)
	},
	"github.organization.secretScanningPushProtectionEnabledForNewRepos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetSecretScanningPushProtectionEnabledForNewRepos()).ToDataRes(types.Bool)
	},
	"github.organization.secretScanningValidityChecksEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetSecretScanningValidityChecksEnabled()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanDeleteRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanDeleteRepositories()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanChangeRepoVisibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanChangeRepoVisibility()).ToDataRes(types.Bool)
	},
	"github.organization.membersCanDeleteIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembersCanDeleteIssues()).ToDataRes(types.Bool)
	},
	"github.organization.readersCanCreateDiscussions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetReadersCanCreateDiscussions()).ToDataRes(types.Bool)
	},
	"github.organization.owners": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetOwners()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.organization.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetMembers()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.organization.teams": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetTeams()).ToDataRes(types.Array(types.Resource("github.team")))
	},
	"github.organization.repositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetRepositories()).ToDataRes(types.Array(types.Resource("github.repository")))
	},
	"github.organization.installations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetInstallations()).ToDataRes(types.Array(types.Resource("github.installation")))
	},
	"github.organization.webhooks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetWebhooks()).ToDataRes(types.Array(types.Resource("github.webhook")))
	},
	"github.organization.packages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetPackages()).ToDataRes(types.Array(types.Resource("github.package")))
	},
	"github.organization.hasOrganizationProjects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetHasOrganizationProjects()).ToDataRes(types.Bool)
	},
	"github.organization.hasRepositoryProjects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetHasRepositoryProjects()).ToDataRes(types.Bool)
	},
	"github.organization.customProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetCustomProperties()).ToDataRes(types.Array(types.Resource("github.organization.customProperty")))
	},
	"github.organization.auditLog": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetAuditLog()).ToDataRes(types.Array(types.Resource("github.auditLogEntry")))
	},
	"github.organization.runners": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganization).GetRunners()).ToDataRes(types.Array(types.Resource("github.runner")))
	},
	"github.organization.customProperty.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetName()).ToDataRes(types.String)
	},
	"github.organization.customProperty.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetDescription()).ToDataRes(types.String)
	},
	"github.organization.customProperty.sourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetSourceType()).ToDataRes(types.String)
	},
	"github.organization.customProperty.valueType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetValueType()).ToDataRes(types.String)
	},
	"github.organization.customProperty.required": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetRequired()).ToDataRes(types.Bool)
	},
	"github.organization.customProperty.defaultValue": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetDefaultValue()).ToDataRes(types.String)
	},
	"github.organization.customProperty.allowedValues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetAllowedValues()).ToDataRes(types.Array(types.String))
	},
	"github.organization.customProperty.valuesEditableBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubOrganizationCustomProperty).GetValuesEditableBy()).ToDataRes(types.String)
	},
	"github.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetId()).ToDataRes(types.Int)
	},
	"github.user.login": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetLogin()).ToDataRes(types.String)
	},
	"github.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetName()).ToDataRes(types.String)
	},
	"github.user.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetEmail()).ToDataRes(types.String)
	},
	"github.user.bio": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetBio()).ToDataRes(types.String)
	},
	"github.user.blog": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetBlog()).ToDataRes(types.String)
	},
	"github.user.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetLocation()).ToDataRes(types.String)
	},
	"github.user.avatarUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetAvatarUrl()).ToDataRes(types.String)
	},
	"github.user.followers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetFollowers()).ToDataRes(types.Int)
	},
	"github.user.following": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetFollowing()).ToDataRes(types.Int)
	},
	"github.user.twitterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetTwitterUsername()).ToDataRes(types.String)
	},
	"github.user.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.user.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.user.suspendedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetSuspendedAt()).ToDataRes(types.Time)
	},
	"github.user.company": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetCompany()).ToDataRes(types.String)
	},
	"github.user.hireable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetHireable()).ToDataRes(types.Bool)
	},
	"github.user.siteAdmin": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetSiteAdmin()).ToDataRes(types.Bool)
	},
	"github.user.repositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetRepositories()).ToDataRes(types.Array(types.Resource("github.repository")))
	},
	"github.user.gists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubUser).GetGists()).ToDataRes(types.Array(types.Resource("github.gist")))
	},
	"github.team.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetId()).ToDataRes(types.Int)
	},
	"github.team.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetName()).ToDataRes(types.String)
	},
	"github.team.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetDescription()).ToDataRes(types.String)
	},
	"github.team.slug": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetSlug()).ToDataRes(types.String)
	},
	"github.team.privacy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetPrivacy()).ToDataRes(types.String)
	},
	"github.team.defaultPermission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetDefaultPermission()).ToDataRes(types.String)
	},
	"github.team.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetMembers()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.team.repositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetRepositories()).ToDataRes(types.Array(types.Resource("github.repository")))
	},
	"github.team.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubTeam).GetOrganization()).ToDataRes(types.Resource("github.organization"))
	},
	"github.collaborator.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCollaborator).GetId()).ToDataRes(types.Int)
	},
	"github.collaborator.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCollaborator).GetUser()).ToDataRes(types.Resource("github.user"))
	},
	"github.collaborator.permissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCollaborator).GetPermissions()).ToDataRes(types.Array(types.String))
	},
	"github.package.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetId()).ToDataRes(types.Int)
	},
	"github.package.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetName()).ToDataRes(types.String)
	},
	"github.package.packageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetPackageType()).ToDataRes(types.String)
	},
	"github.package.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.package.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.package.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.package.versionCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetVersionCount()).ToDataRes(types.Int)
	},
	"github.package.visibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetVisibility()).ToDataRes(types.String)
	},
	"github.package.repository": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackage).GetRepository()).ToDataRes(types.Resource("github.repository"))
	},
	"github.packages.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackages).GetPublic()).ToDataRes(types.Array(types.Resource("github.package")))
	},
	"github.packages.private": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackages).GetPrivate()).ToDataRes(types.Array(types.Resource("github.package")))
	},
	"github.packages.internal": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackages).GetInternal()).ToDataRes(types.Array(types.Resource("github.package")))
	},
	"github.packages.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubPackages).GetList()).ToDataRes(types.Array(types.Resource("github.package")))
	},
	"github.repository.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetId()).ToDataRes(types.Int)
	},
	"github.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetName()).ToDataRes(types.String)
	},
	"github.repository.fullName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetFullName()).ToDataRes(types.String)
	},
	"github.repository.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDescription()).ToDataRes(types.String)
	},
	"github.repository.cloneUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCloneUrl()).ToDataRes(types.String)
	},
	"github.repository.sshUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetSshUrl()).ToDataRes(types.String)
	},
	"github.repository.homepage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHomepage()).ToDataRes(types.String)
	},
	"github.repository.topics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetTopics()).ToDataRes(types.Array(types.String))
	},
	"github.repository.language": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetLanguage()).ToDataRes(types.String)
	},
	"github.repository.watchersCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetWatchersCount()).ToDataRes(types.Int)
	},
	"github.repository.forksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetForksCount()).ToDataRes(types.Int)
	},
	"github.repository.stargazersCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetStargazersCount()).ToDataRes(types.Int)
	},
	"github.repository.openIssuesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetOpenIssuesCount()).ToDataRes(types.Int)
	},
	"github.repository.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.repository.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.repository.pushedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetPushedAt()).ToDataRes(types.Time)
	},
	"github.repository.archived": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetArchived()).ToDataRes(types.Bool)
	},
	"github.repository.disabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDisabled()).ToDataRes(types.Bool)
	},
	"github.repository.private": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetPrivate()).ToDataRes(types.Bool)
	},
	"github.repository.isFork": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetIsFork()).ToDataRes(types.Bool)
	},
	"github.repository.visibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetVisibility()).ToDataRes(types.String)
	},
	"github.repository.allowAutoMerge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllowAutoMerge()).ToDataRes(types.Bool)
	},
	"github.repository.allowForking": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllowForking()).ToDataRes(types.Bool)
	},
	"github.repository.allowMergeCommit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllowMergeCommit()).ToDataRes(types.Bool)
	},
	"github.repository.allowRebaseMerge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllowRebaseMerge()).ToDataRes(types.Bool)
	},
	"github.repository.allowSquashMerge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllowSquashMerge()).ToDataRes(types.Bool)
	},
	"github.repository.hasIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasIssues()).ToDataRes(types.Bool)
	},
	"github.repository.hasProjects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasProjects()).ToDataRes(types.Bool)
	},
	"github.repository.hasWiki": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasWiki()).ToDataRes(types.Bool)
	},
	"github.repository.hasPages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasPages()).ToDataRes(types.Bool)
	},
	"github.repository.hasDownloads": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasDownloads()).ToDataRes(types.Bool)
	},
	"github.repository.hasDiscussions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetHasDiscussions()).ToDataRes(types.Bool)
	},
	"github.repository.isTemplate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetIsTemplate()).ToDataRes(types.Bool)
	},
	"github.repository.customProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCustomProperties()).ToDataRes(types.Dict)
	},
	"github.repository.openMergeRequests": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetOpenMergeRequests()).ToDataRes(types.Array(types.Resource("github.mergeRequest")))
	},
	"github.repository.closedMergeRequests": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetClosedMergeRequests()).ToDataRes(types.Array(types.Resource("github.mergeRequest")))
	},
	"github.repository.allMergeRequests": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAllMergeRequests()).ToDataRes(types.Array(types.Resource("github.mergeRequest")))
	},
	"github.repository.branches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetBranches()).ToDataRes(types.Array(types.Resource("github.branch")))
	},
	"github.repository.defaultBranchName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDefaultBranchName()).ToDataRes(types.String)
	},
	"github.repository.defaultBranch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDefaultBranch()).ToDataRes(types.Resource("github.branch"))
	},
	"github.repository.commits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCommits()).ToDataRes(types.Array(types.Resource("github.commit")))
	},
	"github.repository.contributors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetContributors()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.repository.collaborators": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCollaborators()).ToDataRes(types.Array(types.Resource("github.collaborator")))
	},
	"github.repository.adminCollaborators": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetAdminCollaborators()).ToDataRes(types.Array(types.Resource("github.collaborator")))
	},
	"github.repository.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetFiles()).ToDataRes(types.Array(types.Resource("github.file")))
	},
	"github.repository.releases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetReleases()).ToDataRes(types.Array(types.Resource("github.release")))
	},
	"github.repository.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.repository.webhooks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetWebhooks()).ToDataRes(types.Array(types.Resource("github.webhook")))
	},
	"github.repository.workflows": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetWorkflows()).ToDataRes(types.Array(types.Resource("github.workflow")))
	},
	"github.repository.forks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetForks()).ToDataRes(types.Array(types.Resource("github.repository")))
	},
	"github.repository.stargazers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetStargazers()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.repository.openIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetOpenIssues()).ToDataRes(types.Array(types.Resource("github.issue")))
	},
	"github.repository.closedIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetClosedIssues()).ToDataRes(types.Array(types.Resource("github.issue")))
	},
	"github.repository.milestones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetMilestones()).ToDataRes(types.Array(types.Resource("github.milestone")))
	},
	"github.repository.license": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetLicense()).ToDataRes(types.Resource("github.license"))
	},
	"github.repository.codeOfConductFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCodeOfConductFile()).ToDataRes(types.Resource("github.file"))
	},
	"github.repository.supportFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetSupportFile()).ToDataRes(types.Resource("github.file"))
	},
	"github.repository.securityFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetSecurityFile()).ToDataRes(types.Resource("github.file"))
	},
	"github.repository.dependabotAlerts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDependabotAlerts()).ToDataRes(types.Array(types.Resource("github.dependabotAlert")))
	},
	"github.repository.secretScanningAlerts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetSecretScanningAlerts()).ToDataRes(types.Array(types.Resource("github.secretScanningAlert")))
	},
	"github.repository.codeScanningAlerts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetCodeScanningAlerts()).ToDataRes(types.Array(types.Resource("github.codeScanningAlert")))
	},
	"github.repository.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetFindings()).ToDataRes(types.Array(types.Resource("finding")))
	},
	"github.repository.runners": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetRunners()).ToDataRes(types.Array(types.Resource("github.runner")))
	},
	"github.repository.environments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetEnvironments()).ToDataRes(types.Array(types.Resource("github.environment")))
	},
	"github.repository.deployments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetDeployments()).ToDataRes(types.Array(types.Resource("github.deployment")))
	},
	"github.repository.sbom": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepository).GetSbom()).ToDataRes(types.Resource("github.repository.sbom"))
	},
	"github.repository.sbom.spdxId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetSpdxId()).ToDataRes(types.String)
	},
	"github.repository.sbom.spdxVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetSpdxVersion()).ToDataRes(types.String)
	},
	"github.repository.sbom.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetName()).ToDataRes(types.String)
	},
	"github.repository.sbom.dataLicense": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetDataLicense()).ToDataRes(types.String)
	},
	"github.repository.sbom.documentNamespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetDocumentNamespace()).ToDataRes(types.String)
	},
	"github.repository.sbom.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetComment()).ToDataRes(types.String)
	},
	"github.repository.sbom.creationInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetCreationInfo()).ToDataRes(types.Dict)
	},
	"github.repository.sbom.packages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetPackages()).ToDataRes(types.Array(types.Resource("github.repository.sbom.package")))
	},
	"github.repository.sbom.relationships": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbom).GetRelationships()).ToDataRes(types.Array(types.Resource("github.repository.sbom.relationship")))
	},
	"github.repository.sbom.package.spdxId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetSpdxId()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetName()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.versionInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetVersionInfo()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.downloadLocation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetDownloadLocation()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.filesAnalyzed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetFilesAnalyzed()).ToDataRes(types.Bool)
	},
	"github.repository.sbom.package.licenseConcluded": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetLicenseConcluded()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.licenseDeclared": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetLicenseDeclared()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.supplier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetSupplier()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.copyrightText": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetCopyrightText()).ToDataRes(types.String)
	},
	"github.repository.sbom.package.externalRefs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomPackage).GetExternalRefs()).ToDataRes(types.Array(types.Dict))
	},
	"github.repository.sbom.relationship.relationshipType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomRelationship).GetRelationshipType()).ToDataRes(types.String)
	},
	"github.repository.sbom.relationship.spdxElementId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomRelationship).GetSpdxElementId()).ToDataRes(types.String)
	},
	"github.repository.sbom.relationship.relatedSpdxElement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRepositorySbomRelationship).GetRelatedSpdxElement()).ToDataRes(types.String)
	},
	"github.license.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubLicense).GetKey()).ToDataRes(types.String)
	},
	"github.license.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubLicense).GetName()).ToDataRes(types.String)
	},
	"github.license.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubLicense).GetUrl()).ToDataRes(types.String)
	},
	"github.license.spdxId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubLicense).GetSpdxId()).ToDataRes(types.String)
	},
	"github.file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetPath()).ToDataRes(types.String)
	},
	"github.file.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetName()).ToDataRes(types.String)
	},
	"github.file.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetType()).ToDataRes(types.String)
	},
	"github.file.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetSha()).ToDataRes(types.String)
	},
	"github.file.isBinary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetIsBinary()).ToDataRes(types.Bool)
	},
	"github.file.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetFiles()).ToDataRes(types.Array(types.Resource("github.file")))
	},
	"github.file.ownerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetOwnerName()).ToDataRes(types.String)
	},
	"github.file.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetRepoName()).ToDataRes(types.String)
	},
	"github.file.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetContent()).ToDataRes(types.String)
	},
	"github.file.downloadUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetDownloadUrl()).ToDataRes(types.String)
	},
	"github.file.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubFile).GetExists()).ToDataRes(types.Bool)
	},
	"github.release.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetUrl()).ToDataRes(types.String)
	},
	"github.release.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetName()).ToDataRes(types.String)
	},
	"github.release.tagName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetTagName()).ToDataRes(types.String)
	},
	"github.release.preRelease": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetPreRelease()).ToDataRes(types.Bool)
	},
	"github.release.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.release.publishedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetPublishedAt()).ToDataRes(types.Time)
	},
	"github.release.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRelease).GetAuthor()).ToDataRes(types.Resource("github.user"))
	},
	"github.webhook.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetId()).ToDataRes(types.Int)
	},
	"github.webhook.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetName()).ToDataRes(types.String)
	},
	"github.webhook.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetUrl()).ToDataRes(types.String)
	},
	"github.webhook.events": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetEvents()).ToDataRes(types.Array(types.String))
	},
	"github.webhook.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetConfig()).ToDataRes(types.Dict)
	},
	"github.webhook.active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWebhook).GetActive()).ToDataRes(types.Bool)
	},
	"github.workflow.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetId()).ToDataRes(types.Int)
	},
	"github.workflow.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetName()).ToDataRes(types.String)
	},
	"github.workflow.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetPath()).ToDataRes(types.String)
	},
	"github.workflow.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetState()).ToDataRes(types.String)
	},
	"github.workflow.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.workflow.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.workflow.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetFile()).ToDataRes(types.Resource("github.file"))
	},
	"github.workflow.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubWorkflow).GetConfiguration()).ToDataRes(types.Dict)
	},
	"github.branch.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetName()).ToDataRes(types.String)
	},
	"github.branch.isProtected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetIsProtected()).ToDataRes(types.Bool)
	},
	"github.branch.headCommit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetHeadCommit()).ToDataRes(types.Resource("github.commit"))
	},
	"github.branch.headCommitSha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetHeadCommitSha()).ToDataRes(types.String)
	},
	"github.branch.protectionRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetProtectionRules()).ToDataRes(types.Resource("github.branchprotection"))
	},
	"github.branch.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetRepoName()).ToDataRes(types.String)
	},
	"github.branch.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.branch.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranch).GetIsDefault()).ToDataRes(types.Bool)
	},
	"github.branchprotection.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetId()).ToDataRes(types.String)
	},
	"github.branchprotection.requiredStatusChecks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRequiredStatusChecks()).ToDataRes(types.Dict)
	},
	"github.branchprotection.requiredPullRequestReviews": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRequiredPullRequestReviews()).ToDataRes(types.Dict)
	},
	"github.branchprotection.requiredConversationResolution": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRequiredConversationResolution()).ToDataRes(types.Dict)
	},
	"github.branchprotection.requiredSignatures": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRequiredSignatures()).ToDataRes(types.Bool)
	},
	"github.branchprotection.requireLinearHistory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRequireLinearHistory()).ToDataRes(types.Dict)
	},
	"github.branchprotection.enforceAdmins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetEnforceAdmins()).ToDataRes(types.Dict)
	},
	"github.branchprotection.restrictions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetRestrictions()).ToDataRes(types.Dict)
	},
	"github.branchprotection.allowForcePushes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetAllowForcePushes()).ToDataRes(types.Dict)
	},
	"github.branchprotection.allowDeletions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubBranchprotection).GetAllowDeletions()).ToDataRes(types.Dict)
	},
	"github.commit.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetOwner()).ToDataRes(types.String)
	},
	"github.commit.repository": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetRepository()).ToDataRes(types.String)
	},
	"github.commit.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetSha()).ToDataRes(types.String)
	},
	"github.commit.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetUrl()).ToDataRes(types.String)
	},
	"github.commit.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetAuthor()).ToDataRes(types.Resource("github.user"))
	},
	"github.commit.committer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetCommitter()).ToDataRes(types.Resource("github.user"))
	},
	"github.commit.commit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetCommit()).ToDataRes(types.Resource("git.commit"))
	},
	"github.commit.stats": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetStats()).ToDataRes(types.Dict)
	},
	"github.commit.authoredDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetAuthoredDate()).ToDataRes(types.Time)
	},
	"github.commit.committedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCommit).GetCommittedDate()).ToDataRes(types.Time)
	},
	"github.mergeRequest.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetId()).ToDataRes(types.Int)
	},
	"github.mergeRequest.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetNumber()).ToDataRes(types.Int)
	},
	"github.mergeRequest.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetState()).ToDataRes(types.String)
	},
	"github.mergeRequest.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.mergeRequest.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetLabels()).ToDataRes(types.Array(types.Dict))
	},
	"github.mergeRequest.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetTitle()).ToDataRes(types.String)
	},
	"github.mergeRequest.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.mergeRequest.assignees": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetAssignees()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.mergeRequest.commits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetCommits()).ToDataRes(types.Array(types.Resource("github.commit")))
	},
	"github.mergeRequest.reviews": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetReviews()).ToDataRes(types.Array(types.Resource("github.review")))
	},
	"github.mergeRequest.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetRepoName()).ToDataRes(types.String)
	},
	"github.mergeRequest.milestone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetMilestone()).ToDataRes(types.Resource("github.milestone"))
	},
	"github.mergeRequest.mergedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMergeRequest).GetMergedAt()).ToDataRes(types.Time)
	},
	"github.review.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubReview).GetUrl()).ToDataRes(types.String)
	},
	"github.review.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubReview).GetState()).ToDataRes(types.String)
	},
	"github.review.authorAssociation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubReview).GetAuthorAssociation()).ToDataRes(types.String)
	},
	"github.review.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubReview).GetUser()).ToDataRes(types.Resource("github.user"))
	},
	"github.installation.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubInstallation).GetId()).ToDataRes(types.Int)
	},
	"github.installation.appId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubInstallation).GetAppId()).ToDataRes(types.Int)
	},
	"github.installation.appSlug": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubInstallation).GetAppSlug()).ToDataRes(types.String)
	},
	"github.installation.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubInstallation).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.installation.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubInstallation).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.gist.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetId()).ToDataRes(types.String)
	},
	"github.gist.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetDescription()).ToDataRes(types.String)
	},
	"github.gist.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.gist.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.gist.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.gist.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetPublic()).ToDataRes(types.Bool)
	},
	"github.gist.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGist).GetFiles()).ToDataRes(types.Array(types.Resource("github.gistfile")))
	},
	"github.gistfile.gistId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetGistId()).ToDataRes(types.String)
	},
	"github.gistfile.filename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetFilename()).ToDataRes(types.String)
	},
	"github.gistfile.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetType()).ToDataRes(types.String)
	},
	"github.gistfile.language": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetLanguage()).ToDataRes(types.String)
	},
	"github.gistfile.rawUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetRawUrl()).ToDataRes(types.String)
	},
	"github.gistfile.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetSize()).ToDataRes(types.Int)
	},
	"github.gistfile.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubGistfile).GetContent()).ToDataRes(types.String)
	},
	"github.milestone.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetId()).ToDataRes(types.Int)
	},
	"github.milestone.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetNumber()).ToDataRes(types.Int)
	},
	"github.milestone.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetTitle()).ToDataRes(types.String)
	},
	"github.milestone.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetDescription()).ToDataRes(types.String)
	},
	"github.milestone.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetState()).ToDataRes(types.String)
	},
	"github.milestone.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetUrl()).ToDataRes(types.String)
	},
	"github.milestone.htmlUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetHtmlUrl()).ToDataRes(types.String)
	},
	"github.milestone.creator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetCreator()).ToDataRes(types.Resource("github.user"))
	},
	"github.milestone.openIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetOpenIssues()).ToDataRes(types.Int)
	},
	"github.milestone.closedIssues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetClosedIssues()).ToDataRes(types.Int)
	},
	"github.milestone.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.milestone.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.milestone.closedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetClosedAt()).ToDataRes(types.Time)
	},
	"github.milestone.dueOn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubMilestone).GetDueOn()).ToDataRes(types.Time)
	},
	"github.issue.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetId()).ToDataRes(types.Int)
	},
	"github.issue.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetNumber()).ToDataRes(types.Int)
	},
	"github.issue.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetTitle()).ToDataRes(types.String)
	},
	"github.issue.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetState()).ToDataRes(types.String)
	},
	"github.issue.body": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetBody()).ToDataRes(types.String)
	},
	"github.issue.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetUrl()).ToDataRes(types.String)
	},
	"github.issue.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.issue.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.issue.closedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetClosedAt()).ToDataRes(types.Time)
	},
	"github.issue.assignees": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetAssignees()).ToDataRes(types.Array(types.Resource("github.user")))
	},
	"github.issue.closedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetClosedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.issue.draft": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetDraft()).ToDataRes(types.Bool)
	},
	"github.issue.locked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetLocked()).ToDataRes(types.Bool)
	},
	"github.issue.milestone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubIssue).GetMilestone()).ToDataRes(types.Resource("github.milestone"))
	},
	"github.dependabotAlert.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetNumber()).ToDataRes(types.Int)
	},
	"github.dependabotAlert.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetState()).ToDataRes(types.String)
	},
	"github.dependabotAlert.dependency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetDependency()).ToDataRes(types.Dict)
	},
	"github.dependabotAlert.securityAdvisory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetSecurityAdvisory()).ToDataRes(types.Dict)
	},
	"github.dependabotAlert.securityVulnerability": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetSecurityVulnerability()).ToDataRes(types.Dict)
	},
	"github.dependabotAlert.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetUrl()).ToDataRes(types.String)
	},
	"github.dependabotAlert.htmlUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetHtmlUrl()).ToDataRes(types.String)
	},
	"github.dependabotAlert.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.dependabotAlert.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.dependabotAlert.dismissedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetDismissedAt()).ToDataRes(types.Time)
	},
	"github.dependabotAlert.fixedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetFixedAt()).ToDataRes(types.Time)
	},
	"github.dependabotAlert.autoDismissedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetAutoDismissedAt()).ToDataRes(types.Time)
	},
	"github.dependabotAlert.dismissedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetDismissedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.dependabotAlert.dismissedReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetDismissedReason()).ToDataRes(types.String)
	},
	"github.dependabotAlert.dismissedComment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDependabotAlert).GetDismissedComment()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetNumber()).ToDataRes(types.Int)
	},
	"github.secretScanningAlert.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetState()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.resolution": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetResolution()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.secretType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetSecretType()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.secretTypeDisplayName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetSecretTypeDisplayName()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.secret": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetSecret()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.validity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetValidity()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.publiclyLeaked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetPubliclyLeaked()).ToDataRes(types.Bool)
	},
	"github.secretScanningAlert.multiRepo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetMultiRepo()).ToDataRes(types.Bool)
	},
	"github.secretScanningAlert.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetUrl()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.htmlUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetHtmlUrl()).ToDataRes(types.String)
	},
	"github.secretScanningAlert.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.secretScanningAlert.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.secretScanningAlert.resolvedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetResolvedAt()).ToDataRes(types.Time)
	},
	"github.secretScanningAlert.resolvedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetResolvedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.secretScanningAlert.pushProtectionBypassed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetPushProtectionBypassed()).ToDataRes(types.Bool)
	},
	"github.secretScanningAlert.pushProtectionBypassedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetPushProtectionBypassedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.secretScanningAlert.pushProtectionBypassedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetPushProtectionBypassedAt()).ToDataRes(types.Time)
	},
	"github.secretScanningAlert.resolutionComment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubSecretScanningAlert).GetResolutionComment()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.number": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetNumber()).ToDataRes(types.Int)
	},
	"github.codeScanningAlert.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetState()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.rule": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetRule()).ToDataRes(types.Dict)
	},
	"github.codeScanningAlert.tool": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetTool()).ToDataRes(types.Dict)
	},
	"github.codeScanningAlert.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetUrl()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.htmlUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetHtmlUrl()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.codeScanningAlert.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.codeScanningAlert.fixedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetFixedAt()).ToDataRes(types.Time)
	},
	"github.codeScanningAlert.closedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetClosedAt()).ToDataRes(types.Time)
	},
	"github.codeScanningAlert.closedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetClosedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.codeScanningAlert.dismissedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetDismissedAt()).ToDataRes(types.Time)
	},
	"github.codeScanningAlert.dismissedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetDismissedBy()).ToDataRes(types.Resource("github.user"))
	},
	"github.codeScanningAlert.dismissedReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetDismissedReason()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.dismissedComment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetDismissedComment()).ToDataRes(types.String)
	},
	"github.codeScanningAlert.mostRecentInstance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubCodeScanningAlert).GetMostRecentInstance()).ToDataRes(types.Dict)
	},
	"github.auditLogEntry.documentId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetDocumentId()).ToDataRes(types.String)
	},
	"github.auditLogEntry.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetAction()).ToDataRes(types.String)
	},
	"github.auditLogEntry.actor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetActor()).ToDataRes(types.String)
	},
	"github.auditLogEntry.actorId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetActorId()).ToDataRes(types.Int)
	},
	"github.auditLogEntry.actorLocation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetActorLocation()).ToDataRes(types.String)
	},
	"github.auditLogEntry.business": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetBusiness()).ToDataRes(types.String)
	},
	"github.auditLogEntry.businessId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetBusinessId()).ToDataRes(types.Int)
	},
	"github.auditLogEntry.org": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetOrg()).ToDataRes(types.String)
	},
	"github.auditLogEntry.orgId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetOrgId()).ToDataRes(types.Int)
	},
	"github.auditLogEntry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetUser()).ToDataRes(types.String)
	},
	"github.auditLogEntry.userId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetUserId()).ToDataRes(types.Int)
	},
	"github.auditLogEntry.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.auditLogEntry.timestamp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetTimestamp()).ToDataRes(types.Time)
	},
	"github.auditLogEntry.externalIdentityNameId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetExternalIdentityNameId()).ToDataRes(types.String)
	},
	"github.auditLogEntry.externalIdentityUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetExternalIdentityUsername()).ToDataRes(types.String)
	},
	"github.auditLogEntry.hashedToken": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetHashedToken()).ToDataRes(types.String)
	},
	"github.auditLogEntry.tokenId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetTokenId()).ToDataRes(types.Int)
	},
	"github.auditLogEntry.tokenScopes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetTokenScopes()).ToDataRes(types.String)
	},
	"github.auditLogEntry.data": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetData()).ToDataRes(types.Dict)
	},
	"github.auditLogEntry.additionalFields": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubAuditLogEntry).GetAdditionalFields()).ToDataRes(types.Dict)
	},
	"github.runner.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetId()).ToDataRes(types.Int)
	},
	"github.runner.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetName()).ToDataRes(types.String)
	},
	"github.runner.os": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetOs()).ToDataRes(types.String)
	},
	"github.runner.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetStatus()).ToDataRes(types.String)
	},
	"github.runner.busy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetBusy()).ToDataRes(types.Bool)
	},
	"github.runner.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunner).GetLabels()).ToDataRes(types.Array(types.Resource("github.runnerLabel")))
	},
	"github.runnerLabel.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunnerLabel).GetId()).ToDataRes(types.Int)
	},
	"github.runnerLabel.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunnerLabel).GetName()).ToDataRes(types.String)
	},
	"github.runnerLabel.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubRunnerLabel).GetType()).ToDataRes(types.String)
	},
	"github.environment.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetId()).ToDataRes(types.Int)
	},
	"github.environment.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetName()).ToDataRes(types.String)
	},
	"github.environment.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetUrl()).ToDataRes(types.String)
	},
	"github.environment.htmlUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetHtmlUrl()).ToDataRes(types.String)
	},
	"github.environment.waitTimer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetWaitTimer()).ToDataRes(types.Int)
	},
	"github.environment.canAdminsBypass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetCanAdminsBypass()).ToDataRes(types.Bool)
	},
	"github.environment.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.environment.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.environment.protectedBranches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetProtectedBranches()).ToDataRes(types.Bool)
	},
	"github.environment.customBranchPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetCustomBranchPolicies()).ToDataRes(types.Bool)
	},
	"github.environment.protectionRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironment).GetProtectionRules()).ToDataRes(types.Array(types.Resource("github.environmentProtectionRule")))
	},
	"github.environmentProtectionRule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironmentProtectionRule).GetId()).ToDataRes(types.Int)
	},
	"github.environmentProtectionRule.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironmentProtectionRule).GetType()).ToDataRes(types.String)
	},
	"github.environmentProtectionRule.waitTimer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironmentProtectionRule).GetWaitTimer()).ToDataRes(types.Int)
	},
	"github.environmentProtectionRule.preventSelfReview": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironmentProtectionRule).GetPreventSelfReview()).ToDataRes(types.Bool)
	},
	"github.environmentProtectionRule.reviewers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubEnvironmentProtectionRule).GetReviewers()).ToDataRes(types.Array(types.Dict))
	},
	"github.deployment.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetId()).ToDataRes(types.Int)
	},
	"github.deployment.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetRepoName()).ToDataRes(types.String)
	},
	"github.deployment.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetOwner()).ToDataRes(types.Resource("github.user"))
	},
	"github.deployment.sha": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetSha()).ToDataRes(types.String)
	},
	"github.deployment.ref": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetRef()).ToDataRes(types.String)
	},
	"github.deployment.task": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetTask()).ToDataRes(types.String)
	},
	"github.deployment.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetEnvironment()).ToDataRes(types.String)
	},
	"github.deployment.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetDescription()).ToDataRes(types.String)
	},
	"github.deployment.creator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetCreator()).ToDataRes(types.Resource("github.user"))
	},
	"github.deployment.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.deployment.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.deployment.payload": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetPayload()).ToDataRes(types.Dict)
	},
	"github.deployment.statusesUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetStatusesUrl()).ToDataRes(types.String)
	},
	"github.deployment.latestStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeployment).GetLatestStatus()).ToDataRes(types.Resource("github.deploymentStatus"))
	},
	"github.deploymentStatus.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetId()).ToDataRes(types.Int)
	},
	"github.deploymentStatus.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetState()).ToDataRes(types.String)
	},
	"github.deploymentStatus.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetDescription()).ToDataRes(types.String)
	},
	"github.deploymentStatus.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetEnvironment()).ToDataRes(types.String)
	},
	"github.deploymentStatus.creator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetCreator()).ToDataRes(types.Resource("github.user"))
	},
	"github.deploymentStatus.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetCreatedAt()).ToDataRes(types.Time)
	},
	"github.deploymentStatus.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"github.deploymentStatus.targetUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetTargetUrl()).ToDataRes(types.String)
	},
	"github.deploymentStatus.logUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetLogUrl()).ToDataRes(types.String)
	},
	"github.deploymentStatus.environmentUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGithubDeploymentStatus).GetEnvironmentUrl()).ToDataRes(types.String)
	},
	"finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetId()).ToDataRes(types.String)
	},
	"finding.ref": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetRef()).ToDataRes(types.String)
	},
	"finding.mrn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetMrn()).ToDataRes(types.String)
	},
	"finding.groupId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetGroupId()).ToDataRes(types.String)
	},
	"finding.summary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetSummary()).ToDataRes(types.String)
	},
	"finding.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetDetails()).ToDataRes(types.Resource("finding.detail"))
	},
	"finding.firstSeenAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetFirstSeenAt()).ToDataRes(types.Time)
	},
	"finding.lastSeenAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetLastSeenAt()).ToDataRes(types.Time)
	},
	"finding.remediatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetRemediatedAt()).ToDataRes(types.Time)
	},
	"finding.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetStatus()).ToDataRes(types.String)
	},
	"finding.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetSource()).ToDataRes(types.Resource("finding.source"))
	},
	"finding.affects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetAffects()).ToDataRes(types.Array(types.Resource("finding.affects")))
	},
	"finding.evidences": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetEvidences()).ToDataRes(types.Array(types.Resource("finding.evidence")))
	},
	"finding.remediations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFinding).GetRemediations()).ToDataRes(types.Array(types.Dict))
	},
	"finding.detail.category": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetCategory()).ToDataRes(types.String)
	},
	"finding.detail.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetSeverity()).ToDataRes(types.Resource("finding.severity"))
	},
	"finding.detail.confidence": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetConfidence()).ToDataRes(types.String)
	},
	"finding.detail.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetDescription()).ToDataRes(types.String)
	},
	"finding.detail.references": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetReferences()).ToDataRes(types.Array(types.Resource("finding.reference")))
	},
	"finding.detail.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingDetail).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.source.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSource).GetName()).ToDataRes(types.String)
	},
	"finding.source.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSource).GetUrl()).ToDataRes(types.String)
	},
	"finding.severity.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetSource()).ToDataRes(types.Resource("finding.source"))
	},
	"finding.severity.score": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetScore()).ToDataRes(types.Float)
	},
	"finding.severity.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetSeverity()).ToDataRes(types.String)
	},
	"finding.severity.vector": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetVector()).ToDataRes(types.String)
	},
	"finding.severity.method": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetMethod()).ToDataRes(types.String)
	},
	"finding.severity.rating": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingSeverity).GetRating()).ToDataRes(types.String)
	},
	"finding.reference.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingReference).GetId()).ToDataRes(types.String)
	},
	"finding.reference.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingReference).GetName()).ToDataRes(types.String)
	},
	"finding.reference.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingReference).GetUrl()).ToDataRes(types.String)
	},
	"finding.reference.referenceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingReference).GetReferenceType()).ToDataRes(types.String)
	},
	"finding.reference.metadata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingReference).GetMetadata()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.affects.component": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAffects).GetComponent()).ToDataRes(types.Resource("finding.component"))
	},
	"finding.affects.subComponents": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAffects).GetSubComponents()).ToDataRes(types.Array(types.Resource("finding.component")))
	},
	"finding.component.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingComponent).GetId()).ToDataRes(types.String)
	},
	"finding.component.identifiers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingComponent).GetIdentifiers()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.component.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingComponent).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.component.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingComponent).GetFile()).ToDataRes(types.Resource("finding.fileComponent"))
	},
	"finding.fileComponent.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFileComponent).GetPath()).ToDataRes(types.String)
	},
	"finding.fileComponent.hash": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFileComponent).GetHash()).ToDataRes(types.String)
	},
	"finding.fileComponent.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFileComponent).GetFormat()).ToDataRes(types.String)
	},
	"finding.fileComponent.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFileComponent).GetSize()).ToDataRes(types.Int)
	},
	"finding.evidence.tactic": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetTactic()).ToDataRes(types.Resource("finding.attackTactic"))
	},
	"finding.evidence.technique": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetTechnique()).ToDataRes(types.Resource("finding.attackTechnique"))
	},
	"finding.evidence.confidence": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetConfidence()).ToDataRes(types.String)
	},
	"finding.evidence.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetUser()).ToDataRes(types.Resource("finding.user"))
	},
	"finding.evidence.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetFile()).ToDataRes(types.Resource("finding.file"))
	},
	"finding.evidence.process": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetProcess()).ToDataRes(types.Resource("finding.process"))
	},
	"finding.evidence.container": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetContainer()).ToDataRes(types.Resource("finding.container"))
	},
	"finding.evidence.kubernetes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetKubernetes()).ToDataRes(types.Resource("finding.kubernetes"))
	},
	"finding.evidence.registryKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetRegistryKey()).ToDataRes(types.Resource("finding.registryKey"))
	},
	"finding.evidence.connection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetConnection()).ToDataRes(types.Resource("finding.connection"))
	},
	"finding.evidence.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingEvidence).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFile).GetPath()).ToDataRes(types.String)
	},
	"finding.file.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFile).GetSize()).ToDataRes(types.Int)
	},
	"finding.file.md5": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFile).GetMd5()).ToDataRes(types.String)
	},
	"finding.file.sha256": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFile).GetSha256()).ToDataRes(types.String)
	},
	"finding.file.contents": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingFile).GetContents()).ToDataRes(types.String)
	},
	"finding.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingUser).GetId()).ToDataRes(types.String)
	},
	"finding.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingUser).GetName()).ToDataRes(types.String)
	},
	"finding.user.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingUser).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"finding.process.cmdline": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetCmdline()).ToDataRes(types.String)
	},
	"finding.process.binary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetBinary()).ToDataRes(types.Resource("finding.file"))
	},
	"finding.process.script": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetScript()).ToDataRes(types.Resource("finding.file"))
	},
	"finding.process.pid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetPid()).ToDataRes(types.Int)
	},
	"finding.process.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetUser()).ToDataRes(types.Resource("finding.user"))
	},
	"finding.process.parent": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingProcess).GetParent()).ToDataRes(types.Resource("finding.process"))
	},
	"finding.container.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingContainer).GetName()).ToDataRes(types.String)
	},
	"finding.container.imageUri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingContainer).GetImageUri()).ToDataRes(types.String)
	},
	"finding.container.digest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingContainer).GetDigest()).ToDataRes(types.String)
	},
	"finding.kubernetes.pods": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetes).GetPods()).ToDataRes(types.Array(types.Resource("finding.kubernetes.pod")))
	},
	"finding.kubernetes.nodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetes).GetNodes()).ToDataRes(types.Array(types.Resource("finding.kubernetes.node")))
	},
	"finding.kubernetes.pod.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetesPod).GetName()).ToDataRes(types.String)
	},
	"finding.kubernetes.pod.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetesPod).GetNamespace()).ToDataRes(types.String)
	},
	"finding.kubernetes.pod.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetesPod).GetContainers()).ToDataRes(types.Array(types.Resource("finding.container")))
	},
	"finding.kubernetes.node.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetesNode).GetName()).ToDataRes(types.String)
	},
	"finding.kubernetes.node.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingKubernetesNode).GetId()).ToDataRes(types.String)
	},
	"finding.registryKey.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingRegistryKey).GetPath()).ToDataRes(types.String)
	},
	"finding.registryKey.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingRegistryKey).GetName()).ToDataRes(types.String)
	},
	"finding.registryKey.data": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingRegistryKey).GetData()).ToDataRes(types.String)
	},
	"finding.connection.destinationAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingConnection).GetDestinationAddress()).ToDataRes(types.String)
	},
	"finding.connection.destinationPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingConnection).GetDestinationPort()).ToDataRes(types.Int)
	},
	"finding.connection.sourceAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingConnection).GetSourceAddress()).ToDataRes(types.String)
	},
	"finding.connection.sourcePort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingConnection).GetSourcePort()).ToDataRes(types.Int)
	},
	"finding.connection.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingConnection).GetProtocol()).ToDataRes(types.String)
	},
	"finding.attackTactic.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTactic).GetId()).ToDataRes(types.String)
	},
	"finding.attackTactic.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTactic).GetName()).ToDataRes(types.String)
	},
	"finding.attackTactic.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTactic).GetDescription()).ToDataRes(types.String)
	},
	"finding.attackTechnique.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTechnique).GetId()).ToDataRes(types.String)
	},
	"finding.attackTechnique.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTechnique).GetName()).ToDataRes(types.String)
	},
	"finding.attackTechnique.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*MqlFindingAttackTechnique).GetDescription()).ToDataRes(types.String)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool{
	"github.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithub).__id, ok = v.Value.(string)
		return
	},
	"git.commit.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).__id, ok = v.Value.(string)
		return
	},
	"git.commit.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.commit.message": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).Message, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.commit.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).Author, ok = plugin.RawToTValue[*mqlGitCommitAuthor](v.Value, v.Error)
		return
	},
	"git.commit.committer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).Committer, ok = plugin.RawToTValue[*mqlGitCommitAuthor](v.Value, v.Error)
		return
	},
	"git.commit.signatureVerification": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommit).SignatureVerification, ok = plugin.RawToTValue[*mqlGitGpgSignature](v.Value, v.Error)
		return
	},
	"git.commitAuthor.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommitAuthor).__id, ok = v.Value.(string)
		return
	},
	"git.commitAuthor.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommitAuthor).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.commitAuthor.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommitAuthor).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.commitAuthor.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommitAuthor).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.commitAuthor.date": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitCommitAuthor).Date, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"git.gpgSignature.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).__id, ok = v.Value.(string)
		return
	},
	"git.gpgSignature.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.gpgSignature.reason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).Reason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.gpgSignature.verified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).Verified, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"git.gpgSignature.payload": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).Payload, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"git.gpgSignature.signature": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGitGpgSignature).Signature, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).__id, ok = v.Value.(string)
		return
	},
	"github.organization.login": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Login, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.nodeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).NodeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.company": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Company, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.blog": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Blog, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.twitterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).TwitterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.avatarUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).AvatarUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.followers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Followers, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.following": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Following, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.organization.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.organization.totalPrivateRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).TotalPrivateRepos, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.totalPublicRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).TotalPublicRepos, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.ownedPrivateRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).OwnedPrivateRepos, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.privateGists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).PrivateGists, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.diskUsage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).DiskUsage, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.collaborators": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Collaborators, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.organization.billingEmail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).BillingEmail, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.plan": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Plan, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.organization.twoFactorRequirementEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).TwoFactorRequirementEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.isVerified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).IsVerified, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.defaultRepositoryPermission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).DefaultRepositoryPermission, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreateRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreateRepositories, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreatePublicRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreatePublicRepositories, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreatePrivateRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreatePrivateRepositories, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreateInternalRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreateInternalRepositories, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreatePages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreatePages, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreatePublicPages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreatePublicPages, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanCreatePrivatePages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanCreatePrivatePages, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanForkPrivateRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanForkPrivateRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.dependabotAlertsEnabledForNewRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).DependabotAlertsEnabledForNewRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.dependabotSecurityUpdatesEnabledForNewRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).DependabotSecurityUpdatesEnabledForNewRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.advancedSecurityEnabledForNewRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).AdvancedSecurityEnabledForNewRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.secretScanningEnabledForNewRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).SecretScanningEnabledForNewRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.secretScanningPushProtectionEnabledForNewRepos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).SecretScanningPushProtectionEnabledForNewRepos, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.secretScanningValidityChecksEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).SecretScanningValidityChecksEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanDeleteRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanDeleteRepositories, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanChangeRepoVisibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanChangeRepoVisibility, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.membersCanDeleteIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).MembersCanDeleteIssues, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.readersCanCreateDiscussions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).ReadersCanCreateDiscussions, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.owners": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Owners, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Members, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.teams": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Teams, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.repositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Repositories, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.installations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Installations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.webhooks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Webhooks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.packages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Packages, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.hasOrganizationProjects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).HasOrganizationProjects, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.hasRepositoryProjects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).HasRepositoryProjects, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.customProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).CustomProperties, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.auditLog": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).AuditLog, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.runners": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganization).Runners, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).__id, ok = v.Value.(string)
		return
	},
	"github.organization.customProperty.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.sourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).SourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.valueType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).ValueType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.required": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).Required, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.defaultValue": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).DefaultValue, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.allowedValues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).AllowedValues, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.organization.customProperty.valuesEditableBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubOrganizationCustomProperty).ValuesEditableBy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).__id, ok = v.Value.(string)
		return
	},
	"github.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.user.login": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Login, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.bio": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Bio, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.blog": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Blog, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.avatarUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).AvatarUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.followers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Followers, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.user.following": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Following, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.user.twitterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).TwitterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.user.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.user.suspendedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).SuspendedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.user.company": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Company, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.user.hireable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Hireable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.user.siteAdmin": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).SiteAdmin, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.user.repositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Repositories, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.user.gists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubUser).Gists, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.team.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).__id, ok = v.Value.(string)
		return
	},
	"github.team.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.team.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.team.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.team.slug": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Slug, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.team.privacy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Privacy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.team.defaultPermission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).DefaultPermission, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.team.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Members, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.team.repositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Repositories, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.team.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubTeam).Organization, ok = plugin.RawToTValue[*mqlGithubOrganization](v.Value, v.Error)
		return
	},
	"github.collaborator.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCollaborator).__id, ok = v.Value.(string)
		return
	},
	"github.collaborator.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCollaborator).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.collaborator.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCollaborator).User, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.collaborator.permissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCollaborator).Permissions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.package.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).__id, ok = v.Value.(string)
		return
	},
	"github.package.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.package.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.package.packageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).PackageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.package.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.package.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.package.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.package.versionCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).VersionCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.package.visibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).Visibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.package.repository": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackage).Repository, ok = plugin.RawToTValue[*mqlGithubRepository](v.Value, v.Error)
		return
	},
	"github.packages.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackages).__id, ok = v.Value.(string)
		return
	},
	"github.packages.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackages).Public, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.packages.private": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackages).Private, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.packages.internal": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackages).Internal, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.packages.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubPackages).List, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).__id, ok = v.Value.(string)
		return
	},
	"github.repository.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.fullName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).FullName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.cloneUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).CloneUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sshUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).SshUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.homepage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Homepage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.topics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Topics, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.language": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Language, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.watchersCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).WatchersCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.repository.forksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).ForksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.repository.stargazersCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).StargazersCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.repository.openIssuesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).OpenIssuesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.repository.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.repository.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.repository.pushedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).PushedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.repository.archived": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Archived, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.disabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Disabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.private": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Private, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.isFork": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).IsFork, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.visibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Visibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.allowAutoMerge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllowAutoMerge, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.allowForking": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllowForking, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.allowMergeCommit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllowMergeCommit, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.allowRebaseMerge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllowRebaseMerge, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.allowSquashMerge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllowSquashMerge, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasIssues, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasProjects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasProjects, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasWiki": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasWiki, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasPages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasPages, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasDownloads": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasDownloads, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.hasDiscussions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).HasDiscussions, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.isTemplate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).IsTemplate, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.customProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).CustomProperties, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.repository.openMergeRequests": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).OpenMergeRequests, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.closedMergeRequests": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).ClosedMergeRequests, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.allMergeRequests": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AllMergeRequests, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.branches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Branches, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.defaultBranchName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).DefaultBranchName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.defaultBranch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).DefaultBranch, ok = plugin.RawToTValue[*mqlGithubBranch](v.Value, v.Error)
		return
	},
	"github.repository.commits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Commits, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.contributors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Contributors, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.collaborators": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Collaborators, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.adminCollaborators": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).AdminCollaborators, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Files, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.releases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Releases, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.repository.webhooks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Webhooks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.workflows": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Workflows, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.forks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Forks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.stargazers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Stargazers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.openIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).OpenIssues, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.closedIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).ClosedIssues, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.milestones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Milestones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.license": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).License, ok = plugin.RawToTValue[*mqlGithubLicense](v.Value, v.Error)
		return
	},
	"github.repository.codeOfConductFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).CodeOfConductFile, ok = plugin.RawToTValue[*mqlGithubFile](v.Value, v.Error)
		return
	},
	"github.repository.supportFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).SupportFile, ok = plugin.RawToTValue[*mqlGithubFile](v.Value, v.Error)
		return
	},
	"github.repository.securityFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).SecurityFile, ok = plugin.RawToTValue[*mqlGithubFile](v.Value, v.Error)
		return
	},
	"github.repository.dependabotAlerts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).DependabotAlerts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.secretScanningAlerts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).SecretScanningAlerts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.codeScanningAlerts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).CodeScanningAlerts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Findings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.runners": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Runners, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.environments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Environments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.deployments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Deployments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.sbom": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepository).Sbom, ok = plugin.RawToTValue[*mqlGithubRepositorySbom](v.Value, v.Error)
		return
	},
	"github.repository.sbom.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).__id, ok = v.Value.(string)
		return
	},
	"github.repository.sbom.spdxId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).SpdxId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.spdxVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).SpdxVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.dataLicense": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).DataLicense, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.documentNamespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).DocumentNamespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.creationInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).CreationInfo, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.repository.sbom.packages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).Packages, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.sbom.relationships": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbom).Relationships, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).__id, ok = v.Value.(string)
		return
	},
	"github.repository.sbom.package.spdxId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).SpdxId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.versionInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).VersionInfo, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.downloadLocation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).DownloadLocation, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.filesAnalyzed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).FilesAnalyzed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.licenseConcluded": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).LicenseConcluded, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.licenseDeclared": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).LicenseDeclared, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.supplier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).Supplier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.copyrightText": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).CopyrightText, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.package.externalRefs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomPackage).ExternalRefs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.repository.sbom.relationship.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomRelationship).__id, ok = v.Value.(string)
		return
	},
	"github.repository.sbom.relationship.relationshipType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomRelationship).RelationshipType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.relationship.spdxElementId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomRelationship).SpdxElementId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.repository.sbom.relationship.relatedSpdxElement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRepositorySbomRelationship).RelatedSpdxElement, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.license.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubLicense).__id, ok = v.Value.(string)
		return
	},
	"github.license.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubLicense).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.license.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubLicense).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.license.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubLicense).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.license.spdxId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubLicense).SpdxId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).__id, ok = v.Value.(string)
		return
	},
	"github.file.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.isBinary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).IsBinary, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.file.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Files, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.file.ownerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).OwnerName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.downloadUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).DownloadUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.file.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubFile).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.release.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).__id, ok = v.Value.(string)
		return
	},
	"github.release.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.release.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.release.tagName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).TagName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.release.preRelease": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).PreRelease, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.release.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.release.publishedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).PublishedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.release.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRelease).Author, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.webhook.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).__id, ok = v.Value.(string)
		return
	},
	"github.webhook.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.webhook.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.webhook.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.webhook.events": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Events, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.webhook.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Config, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.webhook.active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWebhook).Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.workflow.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).__id, ok = v.Value.(string)
		return
	},
	"github.workflow.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.workflow.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.workflow.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.workflow.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.workflow.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.workflow.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.workflow.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).File, ok = plugin.RawToTValue[*mqlGithubFile](v.Value, v.Error)
		return
	},
	"github.workflow.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubWorkflow).Configuration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).__id, ok = v.Value.(string)
		return
	},
	"github.branch.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.branch.isProtected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).IsProtected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.branch.headCommit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).HeadCommit, ok = plugin.RawToTValue[*mqlGithubCommit](v.Value, v.Error)
		return
	},
	"github.branch.headCommitSha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).HeadCommitSha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.branch.protectionRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).ProtectionRules, ok = plugin.RawToTValue[*mqlGithubBranchprotection](v.Value, v.Error)
		return
	},
	"github.branch.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.branch.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.branch.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranch).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.branchprotection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).__id, ok = v.Value.(string)
		return
	},
	"github.branchprotection.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.branchprotection.requiredStatusChecks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).RequiredStatusChecks, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.requiredPullRequestReviews": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).RequiredPullRequestReviews, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.requiredConversationResolution": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).RequiredConversationResolution, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.requiredSignatures": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).RequiredSignatures, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.branchprotection.requireLinearHistory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).RequireLinearHistory, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.enforceAdmins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).EnforceAdmins, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.restrictions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).Restrictions, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.allowForcePushes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).AllowForcePushes, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.branchprotection.allowDeletions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubBranchprotection).AllowDeletions, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.commit.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).__id, ok = v.Value.(string)
		return
	},
	"github.commit.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Owner, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.commit.repository": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Repository, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.commit.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.commit.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.commit.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Author, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.commit.committer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Committer, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.commit.commit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Commit, ok = plugin.RawToTValue[*mqlGitCommit](v.Value, v.Error)
		return
	},
	"github.commit.stats": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).Stats, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.commit.authoredDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).AuthoredDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.commit.committedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCommit).CommittedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.mergeRequest.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).__id, ok = v.Value.(string)
		return
	},
	"github.mergeRequest.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.mergeRequest.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.mergeRequest.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.mergeRequest.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.mergeRequest.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.mergeRequest.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.mergeRequest.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.mergeRequest.assignees": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Assignees, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.mergeRequest.commits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Commits, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.mergeRequest.reviews": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Reviews, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.mergeRequest.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.mergeRequest.milestone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).Milestone, ok = plugin.RawToTValue[*mqlGithubMilestone](v.Value, v.Error)
		return
	},
	"github.mergeRequest.mergedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMergeRequest).MergedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.review.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubReview).__id, ok = v.Value.(string)
		return
	},
	"github.review.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubReview).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.review.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubReview).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.review.authorAssociation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubReview).AuthorAssociation, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.review.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubReview).User, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.installation.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).__id, ok = v.Value.(string)
		return
	},
	"github.installation.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.installation.appId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).AppId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.installation.appSlug": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).AppSlug, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.installation.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.installation.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubInstallation).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.gist.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).__id, ok = v.Value.(string)
		return
	},
	"github.gist.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gist.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gist.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.gist.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.gist.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.gist.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.gist.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGist).Files, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.gistfile.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).__id, ok = v.Value.(string)
		return
	},
	"github.gistfile.gistId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).GistId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gistfile.filename": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).Filename, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gistfile.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gistfile.language": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).Language, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gistfile.rawUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).RawUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.gistfile.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.gistfile.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubGistfile).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).__id, ok = v.Value.(string)
		return
	},
	"github.milestone.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.milestone.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.milestone.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.htmlUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).HtmlUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.milestone.creator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).Creator, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.milestone.openIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).OpenIssues, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.milestone.closedIssues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).ClosedIssues, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.milestone.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.milestone.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.milestone.closedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).ClosedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.milestone.dueOn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubMilestone).DueOn, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.issue.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).__id, ok = v.Value.(string)
		return
	},
	"github.issue.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.issue.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.issue.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.issue.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.issue.body": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Body, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.issue.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.issue.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.issue.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.issue.closedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).ClosedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.issue.assignees": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Assignees, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.issue.closedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).ClosedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.issue.draft": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Draft, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.issue.locked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Locked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.issue.milestone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubIssue).Milestone, ok = plugin.RawToTValue[*mqlGithubMilestone](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).__id, ok = v.Value.(string)
		return
	},
	"github.dependabotAlert.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.dependency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).Dependency, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.securityAdvisory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).SecurityAdvisory, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.securityVulnerability": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).SecurityVulnerability, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.htmlUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).HtmlUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.dismissedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).DismissedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.fixedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).FixedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.autoDismissedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).AutoDismissedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.dismissedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).DismissedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.dismissedReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).DismissedReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.dependabotAlert.dismissedComment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDependabotAlert).DismissedComment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).__id, ok = v.Value.(string)
		return
	},
	"github.secretScanningAlert.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.resolution": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).Resolution, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.secretType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).SecretType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.secretTypeDisplayName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).SecretTypeDisplayName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.secret": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).Secret, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.validity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).Validity, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.publiclyLeaked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).PubliclyLeaked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.multiRepo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).MultiRepo, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.htmlUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).HtmlUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.resolvedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).ResolvedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.resolvedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).ResolvedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.pushProtectionBypassed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).PushProtectionBypassed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.pushProtectionBypassedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).PushProtectionBypassedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.pushProtectionBypassedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).PushProtectionBypassedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.secretScanningAlert.resolutionComment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubSecretScanningAlert).ResolutionComment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).__id, ok = v.Value.(string)
		return
	},
	"github.codeScanningAlert.number": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).Number, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.rule": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).Rule, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.tool": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).Tool, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.htmlUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).HtmlUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.fixedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).FixedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.closedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).ClosedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.closedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).ClosedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.dismissedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).DismissedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.dismissedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).DismissedBy, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.dismissedReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).DismissedReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.dismissedComment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).DismissedComment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.codeScanningAlert.mostRecentInstance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubCodeScanningAlert).MostRecentInstance, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).__id, ok = v.Value.(string)
		return
	},
	"github.auditLogEntry.documentId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).DocumentId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Action, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.actor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Actor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.actorId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).ActorId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.actorLocation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).ActorLocation, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.business": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Business, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.businessId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).BusinessId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.org": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Org, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.orgId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).OrgId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).User, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.userId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).UserId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.timestamp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Timestamp, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.externalIdentityNameId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).ExternalIdentityNameId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.externalIdentityUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).ExternalIdentityUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.hashedToken": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).HashedToken, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.tokenId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).TokenId, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.tokenScopes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).TokenScopes, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.data": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).Data, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.auditLogEntry.additionalFields": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubAuditLogEntry).AdditionalFields, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.runner.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).__id, ok = v.Value.(string)
		return
	},
	"github.runner.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.runner.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.runner.os": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Os, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.runner.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.runner.busy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Busy, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.runner.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunner).Labels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.runnerLabel.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunnerLabel).__id, ok = v.Value.(string)
		return
	},
	"github.runnerLabel.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunnerLabel).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.runnerLabel.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunnerLabel).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.runnerLabel.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubRunnerLabel).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.environment.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).__id, ok = v.Value.(string)
		return
	},
	"github.environment.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.environment.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.environment.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.environment.htmlUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).HtmlUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.environment.waitTimer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).WaitTimer, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.environment.canAdminsBypass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).CanAdminsBypass, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.environment.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.environment.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.environment.protectedBranches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).ProtectedBranches, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.environment.customBranchPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).CustomBranchPolicies, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.environment.protectionRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironment).ProtectionRules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.environmentProtectionRule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).__id, ok = v.Value.(string)
		return
	},
	"github.environmentProtectionRule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.environmentProtectionRule.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.environmentProtectionRule.waitTimer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).WaitTimer, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.environmentProtectionRule.preventSelfReview": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).PreventSelfReview, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"github.environmentProtectionRule.reviewers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubEnvironmentProtectionRule).Reviewers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"github.deployment.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).__id, ok = v.Value.(string)
		return
	},
	"github.deployment.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.deployment.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Owner, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.deployment.sha": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Sha, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.ref": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Ref, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.task": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Task, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Environment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.creator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Creator, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.deployment.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.deployment.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.deployment.payload": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).Payload, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"github.deployment.statusesUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).StatusesUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deployment.latestStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeployment).LatestStatus, ok = plugin.RawToTValue[*mqlGithubDeploymentStatus](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).__id, ok = v.Value.(string)
		return
	},
	"github.deploymentStatus.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).Id, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).Environment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.creator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).Creator, ok = plugin.RawToTValue[*mqlGithubUser](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.targetUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).TargetUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.logUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).LogUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"github.deploymentStatus.environmentUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGithubDeploymentStatus).EnvironmentUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).__id, ok = v.Value.(string)
		return
	},
	"finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.ref": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Ref, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.mrn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Mrn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.groupId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).GroupId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.summary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Summary, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Details, ok = plugin.RawToTValue[*MqlFindingDetail](v.Value, v.Error)
		return
	},
	"finding.firstSeenAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).FirstSeenAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"finding.lastSeenAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).LastSeenAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"finding.remediatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).RemediatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"finding.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Source, ok = plugin.RawToTValue[*MqlFindingSource](v.Value, v.Error)
		return
	},
	"finding.affects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Affects, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.evidences": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Evidences, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.remediations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFinding).Remediations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.detail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).__id, ok = v.Value.(string)
		return
	},
	"finding.detail.category": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).Category, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.detail.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).Severity, ok = plugin.RawToTValue[*MqlFindingSeverity](v.Value, v.Error)
		return
	},
	"finding.detail.confidence": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).Confidence, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.detail.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.detail.references": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).References, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.detail.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingDetail).Properties, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.source.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSource).__id, ok = v.Value.(string)
		return
	},
	"finding.source.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSource).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.source.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSource).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.severity.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).__id, ok = v.Value.(string)
		return
	},
	"finding.severity.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Source, ok = plugin.RawToTValue[*MqlFindingSource](v.Value, v.Error)
		return
	},
	"finding.severity.score": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Score, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"finding.severity.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Severity, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.severity.vector": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Vector, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.severity.method": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Method, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.severity.rating": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingSeverity).Rating, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.reference.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).__id, ok = v.Value.(string)
		return
	},
	"finding.reference.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.reference.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.reference.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.reference.referenceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).ReferenceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.reference.metadata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingReference).Metadata, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.affects.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAffects).__id, ok = v.Value.(string)
		return
	},
	"finding.affects.component": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAffects).Component, ok = plugin.RawToTValue[*MqlFindingComponent](v.Value, v.Error)
		return
	},
	"finding.affects.subComponents": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAffects).SubComponents, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.component.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingComponent).__id, ok = v.Value.(string)
		return
	},
	"finding.component.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingComponent).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.component.identifiers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingComponent).Identifiers, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.component.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingComponent).Properties, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.component.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingComponent).File, ok = plugin.RawToTValue[*MqlFindingFileComponent](v.Value, v.Error)
		return
	},
	"finding.fileComponent.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFileComponent).__id, ok = v.Value.(string)
		return
	},
	"finding.fileComponent.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFileComponent).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.fileComponent.hash": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFileComponent).Hash, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.fileComponent.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFileComponent).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.fileComponent.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFileComponent).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"finding.evidence.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).__id, ok = v.Value.(string)
		return
	},
	"finding.evidence.tactic": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Tactic, ok = plugin.RawToTValue[*MqlFindingAttackTactic](v.Value, v.Error)
		return
	},
	"finding.evidence.technique": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Technique, ok = plugin.RawToTValue[*MqlFindingAttackTechnique](v.Value, v.Error)
		return
	},
	"finding.evidence.confidence": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Confidence, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.evidence.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).User, ok = plugin.RawToTValue[*MqlFindingUser](v.Value, v.Error)
		return
	},
	"finding.evidence.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).File, ok = plugin.RawToTValue[*MqlFindingFile](v.Value, v.Error)
		return
	},
	"finding.evidence.process": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Process, ok = plugin.RawToTValue[*MqlFindingProcess](v.Value, v.Error)
		return
	},
	"finding.evidence.container": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Container, ok = plugin.RawToTValue[*MqlFindingContainer](v.Value, v.Error)
		return
	},
	"finding.evidence.kubernetes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Kubernetes, ok = plugin.RawToTValue[*MqlFindingKubernetes](v.Value, v.Error)
		return
	},
	"finding.evidence.registryKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).RegistryKey, ok = plugin.RawToTValue[*MqlFindingRegistryKey](v.Value, v.Error)
		return
	},
	"finding.evidence.connection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Connection, ok = plugin.RawToTValue[*MqlFindingConnection](v.Value, v.Error)
		return
	},
	"finding.evidence.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingEvidence).Properties, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.file.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).__id, ok = v.Value.(string)
		return
	},
	"finding.file.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.file.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"finding.file.md5": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).Md5, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.file.sha256": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).Sha256, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.file.contents": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingFile).Contents, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingUser).__id, ok = v.Value.(string)
		return
	},
	"finding.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingUser).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.user.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingUser).Properties, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"finding.process.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).__id, ok = v.Value.(string)
		return
	},
	"finding.process.cmdline": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).Cmdline, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.process.binary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).Binary, ok = plugin.RawToTValue[*MqlFindingFile](v.Value, v.Error)
		return
	},
	"finding.process.script": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).Script, ok = plugin.RawToTValue[*MqlFindingFile](v.Value, v.Error)
		return
	},
	"finding.process.pid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).Pid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"finding.process.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).User, ok = plugin.RawToTValue[*MqlFindingUser](v.Value, v.Error)
		return
	},
	"finding.process.parent": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingProcess).Parent, ok = plugin.RawToTValue[*MqlFindingProcess](v.Value, v.Error)
		return
	},
	"finding.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingContainer).__id, ok = v.Value.(string)
		return
	},
	"finding.container.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingContainer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.container.imageUri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingContainer).ImageUri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.container.digest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingContainer).Digest, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.kubernetes.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetes).__id, ok = v.Value.(string)
		return
	},
	"finding.kubernetes.pods": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetes).Pods, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.kubernetes.nodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetes).Nodes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.kubernetes.pod.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesPod).__id, ok = v.Value.(string)
		return
	},
	"finding.kubernetes.pod.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesPod).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.kubernetes.pod.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesPod).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.kubernetes.pod.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesPod).Containers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"finding.kubernetes.node.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesNode).__id, ok = v.Value.(string)
		return
	},
	"finding.kubernetes.node.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesNode).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.kubernetes.node.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingKubernetesNode).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.registryKey.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingRegistryKey).__id, ok = v.Value.(string)
		return
	},
	"finding.registryKey.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingRegistryKey).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.registryKey.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingRegistryKey).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.registryKey.data": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingRegistryKey).Data, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.connection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).__id, ok = v.Value.(string)
		return
	},
	"finding.connection.destinationAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).DestinationAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.connection.destinationPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).DestinationPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"finding.connection.sourceAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).SourceAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.connection.sourcePort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).SourcePort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"finding.connection.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingConnection).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTactic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTactic).__id, ok = v.Value.(string)
		return
	},
	"finding.attackTactic.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTactic).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTactic.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTactic).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTactic.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTactic).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTechnique.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTechnique).__id, ok = v.Value.(string)
		return
	},
	"finding.attackTechnique.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTechnique).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTechnique.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTechnique).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"finding.attackTechnique.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*MqlFindingAttackTechnique).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName()+"."+field]
	if !ok {
		return errors.New("[github] cannot set '" + field + "' in resource '" + resource.MqlName() + "', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[github] cannot set '" + field + "' in resource '" + resource.MqlName() + "', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlGithub for the github resource
type mqlGithub struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubInternal
}

// createGithub creates a new instance of this resource
func createGithub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithub) MqlName() string {
	return "github"
}

func (c *mqlGithub) MqlID() string {
	return c.__id
}

// mqlGitCommit for the git.commit resource
type mqlGitCommit struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitCommitInternal it will be used here
	Sha                   plugin.TValue[string]
	Message               plugin.TValue[string]
	Author                plugin.TValue[*mqlGitCommitAuthor]
	Committer             plugin.TValue[*mqlGitCommitAuthor]
	SignatureVerification plugin.TValue[*mqlGitGpgSignature]
}

// createGitCommit creates a new instance of this resource
func createGitCommit(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitCommit{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("git.commit", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitCommit) MqlName() string {
	return "git.commit"
}

func (c *mqlGitCommit) MqlID() string {
	return c.__id
}

func (c *mqlGitCommit) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGitCommit) GetMessage() *plugin.TValue[string] {
	return &c.Message
}

func (c *mqlGitCommit) GetAuthor() *plugin.TValue[*mqlGitCommitAuthor] {
	return &c.Author
}

func (c *mqlGitCommit) GetCommitter() *plugin.TValue[*mqlGitCommitAuthor] {
	return &c.Committer
}

func (c *mqlGitCommit) GetSignatureVerification() *plugin.TValue[*mqlGitGpgSignature] {
	return &c.SignatureVerification
}

// mqlGitCommitAuthor for the git.commitAuthor resource
type mqlGitCommitAuthor struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitCommitAuthorInternal it will be used here
	Sha   plugin.TValue[string]
	Name  plugin.TValue[string]
	Email plugin.TValue[string]
	Date  plugin.TValue[*time.Time]
}

// createGitCommitAuthor creates a new instance of this resource
func createGitCommitAuthor(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitCommitAuthor{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("git.commitAuthor", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitCommitAuthor) MqlName() string {
	return "git.commitAuthor"
}

func (c *mqlGitCommitAuthor) MqlID() string {
	return c.__id
}

func (c *mqlGitCommitAuthor) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGitCommitAuthor) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGitCommitAuthor) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlGitCommitAuthor) GetDate() *plugin.TValue[*time.Time] {
	return &c.Date
}

// mqlGitGpgSignature for the git.gpgSignature resource
type mqlGitGpgSignature struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGitGpgSignatureInternal it will be used here
	Sha       plugin.TValue[string]
	Reason    plugin.TValue[string]
	Verified  plugin.TValue[bool]
	Payload   plugin.TValue[string]
	Signature plugin.TValue[string]
}

// createGitGpgSignature creates a new instance of this resource
func createGitGpgSignature(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGitGpgSignature{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("git.gpgSignature", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGitGpgSignature) MqlName() string {
	return "git.gpgSignature"
}

func (c *mqlGitGpgSignature) MqlID() string {
	return c.__id
}

func (c *mqlGitGpgSignature) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGitGpgSignature) GetReason() *plugin.TValue[string] {
	return &c.Reason
}

func (c *mqlGitGpgSignature) GetVerified() *plugin.TValue[bool] {
	return &c.Verified
}

func (c *mqlGitGpgSignature) GetPayload() *plugin.TValue[string] {
	return &c.Payload
}

func (c *mqlGitGpgSignature) GetSignature() *plugin.TValue[string] {
	return &c.Signature
}

// mqlGithubOrganization for the github.organization resource
type mqlGithubOrganization struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubOrganizationInternal
	Login                                          plugin.TValue[string]
	Id                                             plugin.TValue[int64]
	NodeId                                         plugin.TValue[string]
	Name                                           plugin.TValue[string]
	Company                                        plugin.TValue[string]
	Blog                                           plugin.TValue[string]
	Location                                       plugin.TValue[string]
	Email                                          plugin.TValue[string]
	TwitterUsername                                plugin.TValue[string]
	AvatarUrl                                      plugin.TValue[string]
	Followers                                      plugin.TValue[int64]
	Following                                      plugin.TValue[int64]
	Description                                    plugin.TValue[string]
	CreatedAt                                      plugin.TValue[*time.Time]
	UpdatedAt                                      plugin.TValue[*time.Time]
	TotalPrivateRepos                              plugin.TValue[int64]
	TotalPublicRepos                               plugin.TValue[int64]
	OwnedPrivateRepos                              plugin.TValue[int64]
	PrivateGists                                   plugin.TValue[int64]
	DiskUsage                                      plugin.TValue[int64]
	Collaborators                                  plugin.TValue[int64]
	BillingEmail                                   plugin.TValue[string]
	Plan                                           plugin.TValue[any]
	TwoFactorRequirementEnabled                    plugin.TValue[bool]
	IsVerified                                     plugin.TValue[bool]
	DefaultRepositoryPermission                    plugin.TValue[string]
	MembersCanCreateRepositories                   plugin.TValue[bool]
	MembersCanCreatePublicRepositories             plugin.TValue[bool]
	MembersCanCreatePrivateRepositories            plugin.TValue[bool]
	MembersCanCreateInternalRepositories           plugin.TValue[bool]
	MembersCanCreatePages                          plugin.TValue[bool]
	MembersCanCreatePublicPages                    plugin.TValue[bool]
	MembersCanCreatePrivatePages                   plugin.TValue[bool]
	MembersCanForkPrivateRepos                     plugin.TValue[bool]
	DependabotAlertsEnabledForNewRepos             plugin.TValue[bool]
	DependabotSecurityUpdatesEnabledForNewRepos    plugin.TValue[bool]
	AdvancedSecurityEnabledForNewRepos             plugin.TValue[bool]
	SecretScanningEnabledForNewRepos               plugin.TValue[bool]
	SecretScanningPushProtectionEnabledForNewRepos plugin.TValue[bool]
	SecretScanningValidityChecksEnabled            plugin.TValue[bool]
	MembersCanDeleteRepositories                   plugin.TValue[bool]
	MembersCanChangeRepoVisibility                 plugin.TValue[bool]
	MembersCanDeleteIssues                         plugin.TValue[bool]
	ReadersCanCreateDiscussions                    plugin.TValue[bool]
	Owners                                         plugin.TValue[[]any]
	Members                                        plugin.TValue[[]any]
	Teams                                          plugin.TValue[[]any]
	Repositories                                   plugin.TValue[[]any]
	Installations                                  plugin.TValue[[]any]
	Webhooks                                       plugin.TValue[[]any]
	Packages                                       plugin.TValue[[]any]
	HasOrganizationProjects                        plugin.TValue[bool]
	HasRepositoryProjects                          plugin.TValue[bool]
	CustomProperties                               plugin.TValue[[]any]
	AuditLog                                       plugin.TValue[[]any]
	Runners                                        plugin.TValue[[]any]
}

// createGithubOrganization creates a new instance of this resource
func createGithubOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubOrganization{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.organization", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubOrganization) MqlName() string {
	return "github.organization"
}

func (c *mqlGithubOrganization) MqlID() string {
	return c.__id
}

func (c *mqlGithubOrganization) GetLogin() *plugin.TValue[string] {
	return &c.Login
}

func (c *mqlGithubOrganization) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubOrganization) GetNodeId() *plugin.TValue[string] {
	return &c.NodeId
}

func (c *mqlGithubOrganization) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubOrganization) GetCompany() *plugin.TValue[string] {
	return &c.Company
}

func (c *mqlGithubOrganization) GetBlog() *plugin.TValue[string] {
	return &c.Blog
}

func (c *mqlGithubOrganization) GetLocation() *plugin.TValue[string] {
	return &c.Location
}

func (c *mqlGithubOrganization) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlGithubOrganization) GetTwitterUsername() *plugin.TValue[string] {
	return &c.TwitterUsername
}

func (c *mqlGithubOrganization) GetAvatarUrl() *plugin.TValue[string] {
	return &c.AvatarUrl
}

func (c *mqlGithubOrganization) GetFollowers() *plugin.TValue[int64] {
	return &c.Followers
}

func (c *mqlGithubOrganization) GetFollowing() *plugin.TValue[int64] {
	return &c.Following
}

func (c *mqlGithubOrganization) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubOrganization) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubOrganization) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubOrganization) GetTotalPrivateRepos() *plugin.TValue[int64] {
	return &c.TotalPrivateRepos
}

func (c *mqlGithubOrganization) GetTotalPublicRepos() *plugin.TValue[int64] {
	return &c.TotalPublicRepos
}

func (c *mqlGithubOrganization) GetOwnedPrivateRepos() *plugin.TValue[int64] {
	return &c.OwnedPrivateRepos
}

func (c *mqlGithubOrganization) GetPrivateGists() *plugin.TValue[int64] {
	return &c.PrivateGists
}

func (c *mqlGithubOrganization) GetDiskUsage() *plugin.TValue[int64] {
	return &c.DiskUsage
}

func (c *mqlGithubOrganization) GetCollaborators() *plugin.TValue[int64] {
	return &c.Collaborators
}

func (c *mqlGithubOrganization) GetBillingEmail() *plugin.TValue[string] {
	return &c.BillingEmail
}

func (c *mqlGithubOrganization) GetPlan() *plugin.TValue[any] {
	return &c.Plan
}

func (c *mqlGithubOrganization) GetTwoFactorRequirementEnabled() *plugin.TValue[bool] {
	return &c.TwoFactorRequirementEnabled
}

func (c *mqlGithubOrganization) GetIsVerified() *plugin.TValue[bool] {
	return &c.IsVerified
}

func (c *mqlGithubOrganization) GetDefaultRepositoryPermission() *plugin.TValue[string] {
	return &c.DefaultRepositoryPermission
}

func (c *mqlGithubOrganization) GetMembersCanCreateRepositories() *plugin.TValue[bool] {
	return &c.MembersCanCreateRepositories
}

func (c *mqlGithubOrganization) GetMembersCanCreatePublicRepositories() *plugin.TValue[bool] {
	return &c.MembersCanCreatePublicRepositories
}

func (c *mqlGithubOrganization) GetMembersCanCreatePrivateRepositories() *plugin.TValue[bool] {
	return &c.MembersCanCreatePrivateRepositories
}

func (c *mqlGithubOrganization) GetMembersCanCreateInternalRepositories() *plugin.TValue[bool] {
	return &c.MembersCanCreateInternalRepositories
}

func (c *mqlGithubOrganization) GetMembersCanCreatePages() *plugin.TValue[bool] {
	return &c.MembersCanCreatePages
}

func (c *mqlGithubOrganization) GetMembersCanCreatePublicPages() *plugin.TValue[bool] {
	return &c.MembersCanCreatePublicPages
}

func (c *mqlGithubOrganization) GetMembersCanCreatePrivatePages() *plugin.TValue[bool] {
	return &c.MembersCanCreatePrivatePages
}

func (c *mqlGithubOrganization) GetMembersCanForkPrivateRepos() *plugin.TValue[bool] {
	return &c.MembersCanForkPrivateRepos
}

func (c *mqlGithubOrganization) GetDependabotAlertsEnabledForNewRepos() *plugin.TValue[bool] {
	return &c.DependabotAlertsEnabledForNewRepos
}

func (c *mqlGithubOrganization) GetDependabotSecurityUpdatesEnabledForNewRepos() *plugin.TValue[bool] {
	return &c.DependabotSecurityUpdatesEnabledForNewRepos
}

func (c *mqlGithubOrganization) GetAdvancedSecurityEnabledForNewRepos() *plugin.TValue[bool] {
	return &c.AdvancedSecurityEnabledForNewRepos
}

func (c *mqlGithubOrganization) GetSecretScanningEnabledForNewRepos() *plugin.TValue[bool] {
	return &c.SecretScanningEnabledForNewRepos
}

func (c *mqlGithubOrganization) GetSecretScanningPushProtectionEnabledForNewRepos() *plugin.TValue[bool] {
	return &c.SecretScanningPushProtectionEnabledForNewRepos
}

func (c *mqlGithubOrganization) GetSecretScanningValidityChecksEnabled() *plugin.TValue[bool] {
	return &c.SecretScanningValidityChecksEnabled
}

func (c *mqlGithubOrganization) GetMembersCanDeleteRepositories() *plugin.TValue[bool] {
	return &c.MembersCanDeleteRepositories
}

func (c *mqlGithubOrganization) GetMembersCanChangeRepoVisibility() *plugin.TValue[bool] {
	return &c.MembersCanChangeRepoVisibility
}

func (c *mqlGithubOrganization) GetMembersCanDeleteIssues() *plugin.TValue[bool] {
	return &c.MembersCanDeleteIssues
}

func (c *mqlGithubOrganization) GetReadersCanCreateDiscussions() *plugin.TValue[bool] {
	return &c.ReadersCanCreateDiscussions
}

func (c *mqlGithubOrganization) GetOwners() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Owners, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "owners")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.owners()
	})
}

func (c *mqlGithubOrganization) GetMembers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Members, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "members")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.members()
	})
}

func (c *mqlGithubOrganization) GetTeams() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Teams, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "teams")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.teams()
	})
}

func (c *mqlGithubOrganization) GetRepositories() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Repositories, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "repositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.repositories()
	})
}

func (c *mqlGithubOrganization) GetInstallations() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Installations, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "installations")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.installations()
	})
}

func (c *mqlGithubOrganization) GetWebhooks() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Webhooks, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "webhooks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.webhooks()
	})
}

func (c *mqlGithubOrganization) GetPackages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Packages, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "packages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.packages()
	})
}

func (c *mqlGithubOrganization) GetHasOrganizationProjects() *plugin.TValue[bool] {
	return &c.HasOrganizationProjects
}

func (c *mqlGithubOrganization) GetHasRepositoryProjects() *plugin.TValue[bool] {
	return &c.HasRepositoryProjects
}

func (c *mqlGithubOrganization) GetCustomProperties() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CustomProperties, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "customProperties")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.customProperties()
	})
}

func (c *mqlGithubOrganization) GetAuditLog() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AuditLog, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "auditLog")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.auditLog()
	})
}

func (c *mqlGithubOrganization) GetRunners() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Runners, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.organization", c.__id, "runners")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.runners()
	})
}

// mqlGithubOrganizationCustomProperty for the github.organization.customProperty resource
type mqlGithubOrganizationCustomProperty struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubOrganizationCustomPropertyInternal it will be used here
	Name             plugin.TValue[string]
	Description      plugin.TValue[string]
	SourceType       plugin.TValue[string]
	ValueType        plugin.TValue[string]
	Required         plugin.TValue[bool]
	DefaultValue     plugin.TValue[string]
	AllowedValues    plugin.TValue[[]any]
	ValuesEditableBy plugin.TValue[string]
}

// createGithubOrganizationCustomProperty creates a new instance of this resource
func createGithubOrganizationCustomProperty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubOrganizationCustomProperty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.organization.customProperty", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubOrganizationCustomProperty) MqlName() string {
	return "github.organization.customProperty"
}

func (c *mqlGithubOrganizationCustomProperty) MqlID() string {
	return c.__id
}

func (c *mqlGithubOrganizationCustomProperty) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubOrganizationCustomProperty) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubOrganizationCustomProperty) GetSourceType() *plugin.TValue[string] {
	return &c.SourceType
}

func (c *mqlGithubOrganizationCustomProperty) GetValueType() *plugin.TValue[string] {
	return &c.ValueType
}

func (c *mqlGithubOrganizationCustomProperty) GetRequired() *plugin.TValue[bool] {
	return &c.Required
}

func (c *mqlGithubOrganizationCustomProperty) GetDefaultValue() *plugin.TValue[string] {
	return &c.DefaultValue
}

func (c *mqlGithubOrganizationCustomProperty) GetAllowedValues() *plugin.TValue[[]any] {
	return &c.AllowedValues
}

func (c *mqlGithubOrganizationCustomProperty) GetValuesEditableBy() *plugin.TValue[string] {
	return &c.ValuesEditableBy
}

// mqlGithubUser for the github.user resource
type mqlGithubUser struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubUserInternal
	Id              plugin.TValue[int64]
	Login           plugin.TValue[string]
	Name            plugin.TValue[string]
	Email           plugin.TValue[string]
	Bio             plugin.TValue[string]
	Blog            plugin.TValue[string]
	Location        plugin.TValue[string]
	AvatarUrl       plugin.TValue[string]
	Followers       plugin.TValue[int64]
	Following       plugin.TValue[int64]
	TwitterUsername plugin.TValue[string]
	CreatedAt       plugin.TValue[*time.Time]
	UpdatedAt       plugin.TValue[*time.Time]
	SuspendedAt     plugin.TValue[*time.Time]
	Company         plugin.TValue[string]
	Hireable        plugin.TValue[bool]
	SiteAdmin       plugin.TValue[bool]
	Repositories    plugin.TValue[[]any]
	Gists           plugin.TValue[[]any]
}

// createGithubUser creates a new instance of this resource
func createGithubUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubUser) MqlName() string {
	return "github.user"
}

func (c *mqlGithubUser) MqlID() string {
	return c.__id
}

func (c *mqlGithubUser) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubUser) GetLogin() *plugin.TValue[string] {
	return &c.Login
}

func (c *mqlGithubUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubUser) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlGithubUser) GetBio() *plugin.TValue[string] {
	return &c.Bio
}

func (c *mqlGithubUser) GetBlog() *plugin.TValue[string] {
	return &c.Blog
}

func (c *mqlGithubUser) GetLocation() *plugin.TValue[string] {
	return &c.Location
}

func (c *mqlGithubUser) GetAvatarUrl() *plugin.TValue[string] {
	return &c.AvatarUrl
}

func (c *mqlGithubUser) GetFollowers() *plugin.TValue[int64] {
	return &c.Followers
}

func (c *mqlGithubUser) GetFollowing() *plugin.TValue[int64] {
	return &c.Following
}

func (c *mqlGithubUser) GetTwitterUsername() *plugin.TValue[string] {
	return &c.TwitterUsername
}

func (c *mqlGithubUser) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubUser) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubUser) GetSuspendedAt() *plugin.TValue[*time.Time] {
	return &c.SuspendedAt
}

func (c *mqlGithubUser) GetCompany() *plugin.TValue[string] {
	return &c.Company
}

func (c *mqlGithubUser) GetHireable() *plugin.TValue[bool] {
	return &c.Hireable
}

func (c *mqlGithubUser) GetSiteAdmin() *plugin.TValue[bool] {
	return &c.SiteAdmin
}

func (c *mqlGithubUser) GetRepositories() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Repositories, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.user", c.__id, "repositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.repositories()
	})
}

func (c *mqlGithubUser) GetGists() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Gists, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.user", c.__id, "gists")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.gists()
	})
}

// mqlGithubTeam for the github.team resource
type mqlGithubTeam struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubTeamInternal it will be used here
	Id                plugin.TValue[int64]
	Name              plugin.TValue[string]
	Description       plugin.TValue[string]
	Slug              plugin.TValue[string]
	Privacy           plugin.TValue[string]
	DefaultPermission plugin.TValue[string]
	Members           plugin.TValue[[]any]
	Repositories      plugin.TValue[[]any]
	Organization      plugin.TValue[*mqlGithubOrganization]
}

// createGithubTeam creates a new instance of this resource
func createGithubTeam(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubTeam{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.team", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubTeam) MqlName() string {
	return "github.team"
}

func (c *mqlGithubTeam) MqlID() string {
	return c.__id
}

func (c *mqlGithubTeam) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubTeam) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubTeam) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubTeam) GetSlug() *plugin.TValue[string] {
	return &c.Slug
}

func (c *mqlGithubTeam) GetPrivacy() *plugin.TValue[string] {
	return &c.Privacy
}

func (c *mqlGithubTeam) GetDefaultPermission() *plugin.TValue[string] {
	return &c.DefaultPermission
}

func (c *mqlGithubTeam) GetMembers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Members, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.team", c.__id, "members")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.members()
	})
}

func (c *mqlGithubTeam) GetRepositories() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Repositories, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.team", c.__id, "repositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.repositories()
	})
}

func (c *mqlGithubTeam) GetOrganization() *plugin.TValue[*mqlGithubOrganization] {
	return &c.Organization
}

// mqlGithubCollaborator for the github.collaborator resource
type mqlGithubCollaborator struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubCollaboratorInternal it will be used here
	Id          plugin.TValue[int64]
	User        plugin.TValue[*mqlGithubUser]
	Permissions plugin.TValue[[]any]
}

// createGithubCollaborator creates a new instance of this resource
func createGithubCollaborator(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubCollaborator{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.collaborator", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubCollaborator) MqlName() string {
	return "github.collaborator"
}

func (c *mqlGithubCollaborator) MqlID() string {
	return c.__id
}

func (c *mqlGithubCollaborator) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubCollaborator) GetUser() *plugin.TValue[*mqlGithubUser] {
	return &c.User
}

func (c *mqlGithubCollaborator) GetPermissions() *plugin.TValue[[]any] {
	return &c.Permissions
}

// mqlGithubPackage for the github.package resource
type mqlGithubPackage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubPackageInternal
	Id           plugin.TValue[int64]
	Name         plugin.TValue[string]
	PackageType  plugin.TValue[string]
	Owner        plugin.TValue[*mqlGithubUser]
	CreatedAt    plugin.TValue[*time.Time]
	UpdatedAt    plugin.TValue[*time.Time]
	VersionCount plugin.TValue[int64]
	Visibility   plugin.TValue[string]
	Repository   plugin.TValue[*mqlGithubRepository]
}

// createGithubPackage creates a new instance of this resource
func createGithubPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubPackage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.package", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubPackage) MqlName() string {
	return "github.package"
}

func (c *mqlGithubPackage) MqlID() string {
	return c.__id
}

func (c *mqlGithubPackage) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubPackage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubPackage) GetPackageType() *plugin.TValue[string] {
	return &c.PackageType
}

func (c *mqlGithubPackage) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubPackage) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubPackage) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubPackage) GetVersionCount() *plugin.TValue[int64] {
	return &c.VersionCount
}

func (c *mqlGithubPackage) GetVisibility() *plugin.TValue[string] {
	return &c.Visibility
}

func (c *mqlGithubPackage) GetRepository() *plugin.TValue[*mqlGithubRepository] {
	return plugin.GetOrCompute[*mqlGithubRepository](&c.Repository, func() (*mqlGithubRepository, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.package", c.__id, "repository")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubRepository), nil
			}
		}

		return c.repository()
	})
}

// mqlGithubPackages for the github.packages resource
type mqlGithubPackages struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubPackagesInternal it will be used here
	Public   plugin.TValue[[]any]
	Private  plugin.TValue[[]any]
	Internal plugin.TValue[[]any]
	List     plugin.TValue[[]any]
}

// createGithubPackages creates a new instance of this resource
func createGithubPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubPackages{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.packages", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubPackages) MqlName() string {
	return "github.packages"
}

func (c *mqlGithubPackages) MqlID() string {
	return c.__id
}

func (c *mqlGithubPackages) GetPublic() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Public, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.packages", c.__id, "public")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.public()
	})
}

func (c *mqlGithubPackages) GetPrivate() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Private, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.packages", c.__id, "private")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.private()
	})
}

func (c *mqlGithubPackages) GetInternal() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Internal, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.packages", c.__id, "internal")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.internal()
	})
}

func (c *mqlGithubPackages) GetList() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.List, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.packages", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.list()
	})
}

// mqlGithubRepository for the github.repository resource
type mqlGithubRepository struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubRepositoryInternal
	Id                   plugin.TValue[int64]
	Name                 plugin.TValue[string]
	FullName             plugin.TValue[string]
	Description          plugin.TValue[string]
	CloneUrl             plugin.TValue[string]
	SshUrl               plugin.TValue[string]
	Homepage             plugin.TValue[string]
	Topics               plugin.TValue[[]any]
	Language             plugin.TValue[string]
	WatchersCount        plugin.TValue[int64]
	ForksCount           plugin.TValue[int64]
	StargazersCount      plugin.TValue[int64]
	OpenIssuesCount      plugin.TValue[int64]
	CreatedAt            plugin.TValue[*time.Time]
	UpdatedAt            plugin.TValue[*time.Time]
	PushedAt             plugin.TValue[*time.Time]
	Archived             plugin.TValue[bool]
	Disabled             plugin.TValue[bool]
	Private              plugin.TValue[bool]
	IsFork               plugin.TValue[bool]
	Visibility           plugin.TValue[string]
	AllowAutoMerge       plugin.TValue[bool]
	AllowForking         plugin.TValue[bool]
	AllowMergeCommit     plugin.TValue[bool]
	AllowRebaseMerge     plugin.TValue[bool]
	AllowSquashMerge     plugin.TValue[bool]
	HasIssues            plugin.TValue[bool]
	HasProjects          plugin.TValue[bool]
	HasWiki              plugin.TValue[bool]
	HasPages             plugin.TValue[bool]
	HasDownloads         plugin.TValue[bool]
	HasDiscussions       plugin.TValue[bool]
	IsTemplate           plugin.TValue[bool]
	CustomProperties     plugin.TValue[any]
	OpenMergeRequests    plugin.TValue[[]any]
	ClosedMergeRequests  plugin.TValue[[]any]
	AllMergeRequests     plugin.TValue[[]any]
	Branches             plugin.TValue[[]any]
	DefaultBranchName    plugin.TValue[string]
	DefaultBranch        plugin.TValue[*mqlGithubBranch]
	Commits              plugin.TValue[[]any]
	Contributors         plugin.TValue[[]any]
	Collaborators        plugin.TValue[[]any]
	AdminCollaborators   plugin.TValue[[]any]
	Files                plugin.TValue[[]any]
	Releases             plugin.TValue[[]any]
	Owner                plugin.TValue[*mqlGithubUser]
	Webhooks             plugin.TValue[[]any]
	Workflows            plugin.TValue[[]any]
	Forks                plugin.TValue[[]any]
	Stargazers           plugin.TValue[[]any]
	OpenIssues           plugin.TValue[[]any]
	ClosedIssues         plugin.TValue[[]any]
	Milestones           plugin.TValue[[]any]
	License              plugin.TValue[*mqlGithubLicense]
	CodeOfConductFile    plugin.TValue[*mqlGithubFile]
	SupportFile          plugin.TValue[*mqlGithubFile]
	SecurityFile         plugin.TValue[*mqlGithubFile]
	DependabotAlerts     plugin.TValue[[]any]
	SecretScanningAlerts plugin.TValue[[]any]
	CodeScanningAlerts   plugin.TValue[[]any]
	Findings             plugin.TValue[[]any]
	Runners              plugin.TValue[[]any]
	Environments         plugin.TValue[[]any]
	Deployments          plugin.TValue[[]any]
	Sbom                 plugin.TValue[*mqlGithubRepositorySbom]
}

// createGithubRepository creates a new instance of this resource
func createGithubRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRepository) MqlName() string {
	return "github.repository"
}

func (c *mqlGithubRepository) MqlID() string {
	return c.__id
}

func (c *mqlGithubRepository) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRepository) GetFullName() *plugin.TValue[string] {
	return &c.FullName
}

func (c *mqlGithubRepository) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubRepository) GetCloneUrl() *plugin.TValue[string] {
	return &c.CloneUrl
}

func (c *mqlGithubRepository) GetSshUrl() *plugin.TValue[string] {
	return &c.SshUrl
}

func (c *mqlGithubRepository) GetHomepage() *plugin.TValue[string] {
	return &c.Homepage
}

func (c *mqlGithubRepository) GetTopics() *plugin.TValue[[]any] {
	return &c.Topics
}

func (c *mqlGithubRepository) GetLanguage() *plugin.TValue[string] {
	return &c.Language
}

func (c *mqlGithubRepository) GetWatchersCount() *plugin.TValue[int64] {
	return &c.WatchersCount
}

func (c *mqlGithubRepository) GetForksCount() *plugin.TValue[int64] {
	return &c.ForksCount
}

func (c *mqlGithubRepository) GetStargazersCount() *plugin.TValue[int64] {
	return &c.StargazersCount
}

func (c *mqlGithubRepository) GetOpenIssuesCount() *plugin.TValue[int64] {
	return &c.OpenIssuesCount
}

func (c *mqlGithubRepository) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubRepository) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubRepository) GetPushedAt() *plugin.TValue[*time.Time] {
	return &c.PushedAt
}

func (c *mqlGithubRepository) GetArchived() *plugin.TValue[bool] {
	return &c.Archived
}

func (c *mqlGithubRepository) GetDisabled() *plugin.TValue[bool] {
	return &c.Disabled
}

func (c *mqlGithubRepository) GetPrivate() *plugin.TValue[bool] {
	return &c.Private
}

func (c *mqlGithubRepository) GetIsFork() *plugin.TValue[bool] {
	return &c.IsFork
}

func (c *mqlGithubRepository) GetVisibility() *plugin.TValue[string] {
	return &c.Visibility
}

func (c *mqlGithubRepository) GetAllowAutoMerge() *plugin.TValue[bool] {
	return &c.AllowAutoMerge
}

func (c *mqlGithubRepository) GetAllowForking() *plugin.TValue[bool] {
	return &c.AllowForking
}

func (c *mqlGithubRepository) GetAllowMergeCommit() *plugin.TValue[bool] {
	return &c.AllowMergeCommit
}

func (c *mqlGithubRepository) GetAllowRebaseMerge() *plugin.TValue[bool] {
	return &c.AllowRebaseMerge
}

func (c *mqlGithubRepository) GetAllowSquashMerge() *plugin.TValue[bool] {
	return &c.AllowSquashMerge
}

func (c *mqlGithubRepository) GetHasIssues() *plugin.TValue[bool] {
	return &c.HasIssues
}

func (c *mqlGithubRepository) GetHasProjects() *plugin.TValue[bool] {
	return &c.HasProjects
}

func (c *mqlGithubRepository) GetHasWiki() *plugin.TValue[bool] {
	return &c.HasWiki
}

func (c *mqlGithubRepository) GetHasPages() *plugin.TValue[bool] {
	return &c.HasPages
}

func (c *mqlGithubRepository) GetHasDownloads() *plugin.TValue[bool] {
	return &c.HasDownloads
}

func (c *mqlGithubRepository) GetHasDiscussions() *plugin.TValue[bool] {
	return &c.HasDiscussions
}

func (c *mqlGithubRepository) GetIsTemplate() *plugin.TValue[bool] {
	return &c.IsTemplate
}

func (c *mqlGithubRepository) GetCustomProperties() *plugin.TValue[any] {
	return &c.CustomProperties
}

func (c *mqlGithubRepository) GetOpenMergeRequests() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.OpenMergeRequests, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "openMergeRequests")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.openMergeRequests()
	})
}

func (c *mqlGithubRepository) GetClosedMergeRequests() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClosedMergeRequests, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "closedMergeRequests")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.closedMergeRequests()
	})
}

func (c *mqlGithubRepository) GetAllMergeRequests() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AllMergeRequests, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "allMergeRequests")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.allMergeRequests()
	})
}

func (c *mqlGithubRepository) GetBranches() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Branches, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "branches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.branches()
	})
}

func (c *mqlGithubRepository) GetDefaultBranchName() *plugin.TValue[string] {
	return &c.DefaultBranchName
}

func (c *mqlGithubRepository) GetDefaultBranch() *plugin.TValue[*mqlGithubBranch] {
	return plugin.GetOrCompute[*mqlGithubBranch](&c.DefaultBranch, func() (*mqlGithubBranch, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "defaultBranch")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubBranch), nil
			}
		}

		return c.defaultBranch()
	})
}

func (c *mqlGithubRepository) GetCommits() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Commits, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "commits")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.commits()
	})
}

func (c *mqlGithubRepository) GetContributors() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Contributors, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "contributors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.contributors()
	})
}

func (c *mqlGithubRepository) GetCollaborators() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Collaborators, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "collaborators")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.collaborators()
	})
}

func (c *mqlGithubRepository) GetAdminCollaborators() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AdminCollaborators, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "adminCollaborators")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.adminCollaborators()
	})
}

func (c *mqlGithubRepository) GetFiles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Files, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.files()
	})
}

func (c *mqlGithubRepository) GetReleases() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Releases, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "releases")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.releases()
	})
}

func (c *mqlGithubRepository) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubRepository) GetWebhooks() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Webhooks, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "webhooks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.webhooks()
	})
}

func (c *mqlGithubRepository) GetWorkflows() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Workflows, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "workflows")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.workflows()
	})
}

func (c *mqlGithubRepository) GetForks() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Forks, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "forks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.forks()
	})
}

func (c *mqlGithubRepository) GetStargazers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Stargazers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "stargazers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.stargazers()
	})
}

func (c *mqlGithubRepository) GetOpenIssues() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.OpenIssues, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "openIssues")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.openIssues()
	})
}

func (c *mqlGithubRepository) GetClosedIssues() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClosedIssues, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "closedIssues")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.closedIssues()
	})
}

func (c *mqlGithubRepository) GetMilestones() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Milestones, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "milestones")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.milestones()
	})
}

func (c *mqlGithubRepository) GetLicense() *plugin.TValue[*mqlGithubLicense] {
	return plugin.GetOrCompute[*mqlGithubLicense](&c.License, func() (*mqlGithubLicense, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "license")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubLicense), nil
			}
		}

		return c.license()
	})
}

func (c *mqlGithubRepository) GetCodeOfConductFile() *plugin.TValue[*mqlGithubFile] {
	return plugin.GetOrCompute[*mqlGithubFile](&c.CodeOfConductFile, func() (*mqlGithubFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "codeOfConductFile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubFile), nil
			}
		}

		return c.codeOfConductFile()
	})
}

func (c *mqlGithubRepository) GetSupportFile() *plugin.TValue[*mqlGithubFile] {
	return plugin.GetOrCompute[*mqlGithubFile](&c.SupportFile, func() (*mqlGithubFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "supportFile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubFile), nil
			}
		}

		return c.supportFile()
	})
}

func (c *mqlGithubRepository) GetSecurityFile() *plugin.TValue[*mqlGithubFile] {
	return plugin.GetOrCompute[*mqlGithubFile](&c.SecurityFile, func() (*mqlGithubFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "securityFile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubFile), nil
			}
		}

		return c.securityFile()
	})
}

func (c *mqlGithubRepository) GetDependabotAlerts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DependabotAlerts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "dependabotAlerts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.dependabotAlerts()
	})
}

func (c *mqlGithubRepository) GetSecretScanningAlerts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecretScanningAlerts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "secretScanningAlerts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.secretScanningAlerts()
	})
}

func (c *mqlGithubRepository) GetCodeScanningAlerts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CodeScanningAlerts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "codeScanningAlerts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.codeScanningAlerts()
	})
}

func (c *mqlGithubRepository) GetFindings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Findings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlGithubRepository) GetRunners() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Runners, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "runners")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.runners()
	})
}

func (c *mqlGithubRepository) GetEnvironments() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Environments, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "environments")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.environments()
	})
}

func (c *mqlGithubRepository) GetDeployments() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Deployments, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "deployments")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployments()
	})
}

func (c *mqlGithubRepository) GetSbom() *plugin.TValue[*mqlGithubRepositorySbom] {
	return plugin.GetOrCompute[*mqlGithubRepositorySbom](&c.Sbom, func() (*mqlGithubRepositorySbom, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.repository", c.__id, "sbom")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubRepositorySbom), nil
			}
		}

		return c.sbom()
	})
}

// mqlGithubRepositorySbom for the github.repository.sbom resource
type mqlGithubRepositorySbom struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubRepositorySbomInternal it will be used here
	SpdxId            plugin.TValue[string]
	SpdxVersion       plugin.TValue[string]
	Name              plugin.TValue[string]
	DataLicense       plugin.TValue[string]
	DocumentNamespace plugin.TValue[string]
	Comment           plugin.TValue[string]
	CreationInfo      plugin.TValue[any]
	Packages          plugin.TValue[[]any]
	Relationships     plugin.TValue[[]any]
}

// createGithubRepositorySbom creates a new instance of this resource
func createGithubRepositorySbom(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRepositorySbom{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.repository.sbom", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRepositorySbom) MqlName() string {
	return "github.repository.sbom"
}

func (c *mqlGithubRepositorySbom) MqlID() string {
	return c.__id
}

func (c *mqlGithubRepositorySbom) GetSpdxId() *plugin.TValue[string] {
	return &c.SpdxId
}

func (c *mqlGithubRepositorySbom) GetSpdxVersion() *plugin.TValue[string] {
	return &c.SpdxVersion
}

func (c *mqlGithubRepositorySbom) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRepositorySbom) GetDataLicense() *plugin.TValue[string] {
	return &c.DataLicense
}

func (c *mqlGithubRepositorySbom) GetDocumentNamespace() *plugin.TValue[string] {
	return &c.DocumentNamespace
}

func (c *mqlGithubRepositorySbom) GetComment() *plugin.TValue[string] {
	return &c.Comment
}

func (c *mqlGithubRepositorySbom) GetCreationInfo() *plugin.TValue[any] {
	return &c.CreationInfo
}

func (c *mqlGithubRepositorySbom) GetPackages() *plugin.TValue[[]any] {
	return &c.Packages
}

func (c *mqlGithubRepositorySbom) GetRelationships() *plugin.TValue[[]any] {
	return &c.Relationships
}

// mqlGithubRepositorySbomPackage for the github.repository.sbom.package resource
type mqlGithubRepositorySbomPackage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubRepositorySbomPackageInternal it will be used here
	SpdxId           plugin.TValue[string]
	Name             plugin.TValue[string]
	VersionInfo      plugin.TValue[string]
	DownloadLocation plugin.TValue[string]
	FilesAnalyzed    plugin.TValue[bool]
	LicenseConcluded plugin.TValue[string]
	LicenseDeclared  plugin.TValue[string]
	Supplier         plugin.TValue[string]
	CopyrightText    plugin.TValue[string]
	ExternalRefs     plugin.TValue[[]any]
}

// createGithubRepositorySbomPackage creates a new instance of this resource
func createGithubRepositorySbomPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRepositorySbomPackage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.repository.sbom.package", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRepositorySbomPackage) MqlName() string {
	return "github.repository.sbom.package"
}

func (c *mqlGithubRepositorySbomPackage) MqlID() string {
	return c.__id
}

func (c *mqlGithubRepositorySbomPackage) GetSpdxId() *plugin.TValue[string] {
	return &c.SpdxId
}

func (c *mqlGithubRepositorySbomPackage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRepositorySbomPackage) GetVersionInfo() *plugin.TValue[string] {
	return &c.VersionInfo
}

func (c *mqlGithubRepositorySbomPackage) GetDownloadLocation() *plugin.TValue[string] {
	return &c.DownloadLocation
}

func (c *mqlGithubRepositorySbomPackage) GetFilesAnalyzed() *plugin.TValue[bool] {
	return &c.FilesAnalyzed
}

func (c *mqlGithubRepositorySbomPackage) GetLicenseConcluded() *plugin.TValue[string] {
	return &c.LicenseConcluded
}

func (c *mqlGithubRepositorySbomPackage) GetLicenseDeclared() *plugin.TValue[string] {
	return &c.LicenseDeclared
}

func (c *mqlGithubRepositorySbomPackage) GetSupplier() *plugin.TValue[string] {
	return &c.Supplier
}

func (c *mqlGithubRepositorySbomPackage) GetCopyrightText() *plugin.TValue[string] {
	return &c.CopyrightText
}

func (c *mqlGithubRepositorySbomPackage) GetExternalRefs() *plugin.TValue[[]any] {
	return &c.ExternalRefs
}

// mqlGithubRepositorySbomRelationship for the github.repository.sbom.relationship resource
type mqlGithubRepositorySbomRelationship struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubRepositorySbomRelationshipInternal it will be used here
	RelationshipType   plugin.TValue[string]
	SpdxElementId      plugin.TValue[string]
	RelatedSpdxElement plugin.TValue[string]
}

// createGithubRepositorySbomRelationship creates a new instance of this resource
func createGithubRepositorySbomRelationship(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRepositorySbomRelationship{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.repository.sbom.relationship", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRepositorySbomRelationship) MqlName() string {
	return "github.repository.sbom.relationship"
}

func (c *mqlGithubRepositorySbomRelationship) MqlID() string {
	return c.__id
}

func (c *mqlGithubRepositorySbomRelationship) GetRelationshipType() *plugin.TValue[string] {
	return &c.RelationshipType
}

func (c *mqlGithubRepositorySbomRelationship) GetSpdxElementId() *plugin.TValue[string] {
	return &c.SpdxElementId
}

func (c *mqlGithubRepositorySbomRelationship) GetRelatedSpdxElement() *plugin.TValue[string] {
	return &c.RelatedSpdxElement
}

// mqlGithubLicense for the github.license resource
type mqlGithubLicense struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubLicenseInternal it will be used here
	Key    plugin.TValue[string]
	Name   plugin.TValue[string]
	Url    plugin.TValue[string]
	SpdxId plugin.TValue[string]
}

// createGithubLicense creates a new instance of this resource
func createGithubLicense(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubLicense{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.license", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubLicense) MqlName() string {
	return "github.license"
}

func (c *mqlGithubLicense) MqlID() string {
	return c.__id
}

func (c *mqlGithubLicense) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlGithubLicense) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubLicense) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubLicense) GetSpdxId() *plugin.TValue[string] {
	return &c.SpdxId
}

// mqlGithubFile for the github.file resource
type mqlGithubFile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubFileInternal it will be used here
	Path        plugin.TValue[string]
	Name        plugin.TValue[string]
	Type        plugin.TValue[string]
	Sha         plugin.TValue[string]
	IsBinary    plugin.TValue[bool]
	Files       plugin.TValue[[]any]
	OwnerName   plugin.TValue[string]
	RepoName    plugin.TValue[string]
	Content     plugin.TValue[string]
	DownloadUrl plugin.TValue[string]
	Exists      plugin.TValue[bool]
}

// createGithubFile creates a new instance of this resource
func createGithubFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubFile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.file", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubFile) MqlName() string {
	return "github.file"
}

func (c *mqlGithubFile) MqlID() string {
	return c.__id
}

func (c *mqlGithubFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlGithubFile) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubFile) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlGithubFile) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGithubFile) GetIsBinary() *plugin.TValue[bool] {
	return &c.IsBinary
}

func (c *mqlGithubFile) GetFiles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Files, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.file", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.files()
	})
}

func (c *mqlGithubFile) GetOwnerName() *plugin.TValue[string] {
	return &c.OwnerName
}

func (c *mqlGithubFile) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlGithubFile) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		return c.content()
	})
}

func (c *mqlGithubFile) GetDownloadUrl() *plugin.TValue[string] {
	return &c.DownloadUrl
}

func (c *mqlGithubFile) GetExists() *plugin.TValue[bool] {
	return &c.Exists
}

// mqlGithubRelease for the github.release resource
type mqlGithubRelease struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubReleaseInternal it will be used here
	Url         plugin.TValue[string]
	Name        plugin.TValue[string]
	TagName     plugin.TValue[string]
	PreRelease  plugin.TValue[bool]
	CreatedAt   plugin.TValue[*time.Time]
	PublishedAt plugin.TValue[*time.Time]
	Author      plugin.TValue[*mqlGithubUser]
}

// createGithubRelease creates a new instance of this resource
func createGithubRelease(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRelease{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.release", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRelease) MqlName() string {
	return "github.release"
}

func (c *mqlGithubRelease) MqlID() string {
	return c.__id
}

func (c *mqlGithubRelease) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubRelease) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRelease) GetTagName() *plugin.TValue[string] {
	return &c.TagName
}

func (c *mqlGithubRelease) GetPreRelease() *plugin.TValue[bool] {
	return &c.PreRelease
}

func (c *mqlGithubRelease) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubRelease) GetPublishedAt() *plugin.TValue[*time.Time] {
	return &c.PublishedAt
}

func (c *mqlGithubRelease) GetAuthor() *plugin.TValue[*mqlGithubUser] {
	return &c.Author
}

// mqlGithubWebhook for the github.webhook resource
type mqlGithubWebhook struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubWebhookInternal it will be used here
	Id     plugin.TValue[int64]
	Name   plugin.TValue[string]
	Url    plugin.TValue[string]
	Events plugin.TValue[[]any]
	Config plugin.TValue[any]
	Active plugin.TValue[bool]
}

// createGithubWebhook creates a new instance of this resource
func createGithubWebhook(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubWebhook{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.webhook", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubWebhook) MqlName() string {
	return "github.webhook"
}

func (c *mqlGithubWebhook) MqlID() string {
	return c.__id
}

func (c *mqlGithubWebhook) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubWebhook) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubWebhook) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubWebhook) GetEvents() *plugin.TValue[[]any] {
	return &c.Events
}

func (c *mqlGithubWebhook) GetConfig() *plugin.TValue[any] {
	return &c.Config
}

func (c *mqlGithubWebhook) GetActive() *plugin.TValue[bool] {
	return &c.Active
}

// mqlGithubWorkflow for the github.workflow resource
type mqlGithubWorkflow struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubWorkflowInternal
	Id            plugin.TValue[int64]
	Name          plugin.TValue[string]
	Path          plugin.TValue[string]
	State         plugin.TValue[string]
	CreatedAt     plugin.TValue[*time.Time]
	UpdatedAt     plugin.TValue[*time.Time]
	File          plugin.TValue[*mqlGithubFile]
	Configuration plugin.TValue[any]
}

// createGithubWorkflow creates a new instance of this resource
func createGithubWorkflow(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubWorkflow{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.workflow", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubWorkflow) MqlName() string {
	return "github.workflow"
}

func (c *mqlGithubWorkflow) MqlID() string {
	return c.__id
}

func (c *mqlGithubWorkflow) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubWorkflow) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubWorkflow) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlGithubWorkflow) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubWorkflow) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubWorkflow) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubWorkflow) GetFile() *plugin.TValue[*mqlGithubFile] {
	return plugin.GetOrCompute[*mqlGithubFile](&c.File, func() (*mqlGithubFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.workflow", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlGithubWorkflow) GetConfiguration() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Configuration, func() (any, error) {
		return c.configuration()
	})
}

// mqlGithubBranch for the github.branch resource
type mqlGithubBranch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubBranchInternal it will be used here
	Name            plugin.TValue[string]
	IsProtected     plugin.TValue[bool]
	HeadCommit      plugin.TValue[*mqlGithubCommit]
	HeadCommitSha   plugin.TValue[string]
	ProtectionRules plugin.TValue[*mqlGithubBranchprotection]
	RepoName        plugin.TValue[string]
	Owner           plugin.TValue[*mqlGithubUser]
	IsDefault       plugin.TValue[bool]
}

// createGithubBranch creates a new instance of this resource
func createGithubBranch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubBranch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.branch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubBranch) MqlName() string {
	return "github.branch"
}

func (c *mqlGithubBranch) MqlID() string {
	return c.__id
}

func (c *mqlGithubBranch) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubBranch) GetIsProtected() *plugin.TValue[bool] {
	return &c.IsProtected
}

func (c *mqlGithubBranch) GetHeadCommit() *plugin.TValue[*mqlGithubCommit] {
	return plugin.GetOrCompute[*mqlGithubCommit](&c.HeadCommit, func() (*mqlGithubCommit, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.branch", c.__id, "headCommit")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubCommit), nil
			}
		}

		return c.headCommit()
	})
}

func (c *mqlGithubBranch) GetHeadCommitSha() *plugin.TValue[string] {
	return &c.HeadCommitSha
}

func (c *mqlGithubBranch) GetProtectionRules() *plugin.TValue[*mqlGithubBranchprotection] {
	return plugin.GetOrCompute[*mqlGithubBranchprotection](&c.ProtectionRules, func() (*mqlGithubBranchprotection, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.branch", c.__id, "protectionRules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubBranchprotection), nil
			}
		}

		return c.protectionRules()
	})
}

func (c *mqlGithubBranch) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlGithubBranch) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubBranch) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

// mqlGithubBranchprotection for the github.branchprotection resource
type mqlGithubBranchprotection struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubBranchprotectionInternal it will be used here
	Id                             plugin.TValue[string]
	RequiredStatusChecks           plugin.TValue[any]
	RequiredPullRequestReviews     plugin.TValue[any]
	RequiredConversationResolution plugin.TValue[any]
	RequiredSignatures             plugin.TValue[bool]
	RequireLinearHistory           plugin.TValue[any]
	EnforceAdmins                  plugin.TValue[any]
	Restrictions                   plugin.TValue[any]
	AllowForcePushes               plugin.TValue[any]
	AllowDeletions                 plugin.TValue[any]
}

// createGithubBranchprotection creates a new instance of this resource
func createGithubBranchprotection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubBranchprotection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.branchprotection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubBranchprotection) MqlName() string {
	return "github.branchprotection"
}

func (c *mqlGithubBranchprotection) MqlID() string {
	return c.__id
}

func (c *mqlGithubBranchprotection) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlGithubBranchprotection) GetRequiredStatusChecks() *plugin.TValue[any] {
	return &c.RequiredStatusChecks
}

func (c *mqlGithubBranchprotection) GetRequiredPullRequestReviews() *plugin.TValue[any] {
	return &c.RequiredPullRequestReviews
}

func (c *mqlGithubBranchprotection) GetRequiredConversationResolution() *plugin.TValue[any] {
	return &c.RequiredConversationResolution
}

func (c *mqlGithubBranchprotection) GetRequiredSignatures() *plugin.TValue[bool] {
	return &c.RequiredSignatures
}

func (c *mqlGithubBranchprotection) GetRequireLinearHistory() *plugin.TValue[any] {
	return &c.RequireLinearHistory
}

func (c *mqlGithubBranchprotection) GetEnforceAdmins() *plugin.TValue[any] {
	return &c.EnforceAdmins
}

func (c *mqlGithubBranchprotection) GetRestrictions() *plugin.TValue[any] {
	return &c.Restrictions
}

func (c *mqlGithubBranchprotection) GetAllowForcePushes() *plugin.TValue[any] {
	return &c.AllowForcePushes
}

func (c *mqlGithubBranchprotection) GetAllowDeletions() *plugin.TValue[any] {
	return &c.AllowDeletions
}

// mqlGithubCommit for the github.commit resource
type mqlGithubCommit struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubCommitInternal it will be used here
	Owner         plugin.TValue[string]
	Repository    plugin.TValue[string]
	Sha           plugin.TValue[string]
	Url           plugin.TValue[string]
	Author        plugin.TValue[*mqlGithubUser]
	Committer     plugin.TValue[*mqlGithubUser]
	Commit        plugin.TValue[*mqlGitCommit]
	Stats         plugin.TValue[any]
	AuthoredDate  plugin.TValue[*time.Time]
	CommittedDate plugin.TValue[*time.Time]
}

// createGithubCommit creates a new instance of this resource
func createGithubCommit(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubCommit{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.commit", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubCommit) MqlName() string {
	return "github.commit"
}

func (c *mqlGithubCommit) MqlID() string {
	return c.__id
}

func (c *mqlGithubCommit) GetOwner() *plugin.TValue[string] {
	return &c.Owner
}

func (c *mqlGithubCommit) GetRepository() *plugin.TValue[string] {
	return &c.Repository
}

func (c *mqlGithubCommit) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGithubCommit) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubCommit) GetAuthor() *plugin.TValue[*mqlGithubUser] {
	return &c.Author
}

func (c *mqlGithubCommit) GetCommitter() *plugin.TValue[*mqlGithubUser] {
	return &c.Committer
}

func (c *mqlGithubCommit) GetCommit() *plugin.TValue[*mqlGitCommit] {
	return &c.Commit
}

func (c *mqlGithubCommit) GetStats() *plugin.TValue[any] {
	return &c.Stats
}

func (c *mqlGithubCommit) GetAuthoredDate() *plugin.TValue[*time.Time] {
	return &c.AuthoredDate
}

func (c *mqlGithubCommit) GetCommittedDate() *plugin.TValue[*time.Time] {
	return &c.CommittedDate
}

// mqlGithubMergeRequest for the github.mergeRequest resource
type mqlGithubMergeRequest struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubMergeRequestInternal it will be used here
	Id        plugin.TValue[int64]
	Number    plugin.TValue[int64]
	State     plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	Labels    plugin.TValue[[]any]
	Title     plugin.TValue[string]
	Owner     plugin.TValue[*mqlGithubUser]
	Assignees plugin.TValue[[]any]
	Commits   plugin.TValue[[]any]
	Reviews   plugin.TValue[[]any]
	RepoName  plugin.TValue[string]
	Milestone plugin.TValue[*mqlGithubMilestone]
	MergedAt  plugin.TValue[*time.Time]
}

// createGithubMergeRequest creates a new instance of this resource
func createGithubMergeRequest(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubMergeRequest{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.mergeRequest", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubMergeRequest) MqlName() string {
	return "github.mergeRequest"
}

func (c *mqlGithubMergeRequest) MqlID() string {
	return c.__id
}

func (c *mqlGithubMergeRequest) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubMergeRequest) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubMergeRequest) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubMergeRequest) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubMergeRequest) GetLabels() *plugin.TValue[[]any] {
	return &c.Labels
}

func (c *mqlGithubMergeRequest) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGithubMergeRequest) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubMergeRequest) GetAssignees() *plugin.TValue[[]any] {
	return &c.Assignees
}

func (c *mqlGithubMergeRequest) GetCommits() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Commits, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.mergeRequest", c.__id, "commits")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.commits()
	})
}

func (c *mqlGithubMergeRequest) GetReviews() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Reviews, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.mergeRequest", c.__id, "reviews")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.reviews()
	})
}

func (c *mqlGithubMergeRequest) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlGithubMergeRequest) GetMilestone() *plugin.TValue[*mqlGithubMilestone] {
	return &c.Milestone
}

func (c *mqlGithubMergeRequest) GetMergedAt() *plugin.TValue[*time.Time] {
	return &c.MergedAt
}

// mqlGithubReview for the github.review resource
type mqlGithubReview struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubReviewInternal it will be used here
	Url               plugin.TValue[string]
	State             plugin.TValue[string]
	AuthorAssociation plugin.TValue[string]
	User              plugin.TValue[*mqlGithubUser]
}

// createGithubReview creates a new instance of this resource
func createGithubReview(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubReview{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.review", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubReview) MqlName() string {
	return "github.review"
}

func (c *mqlGithubReview) MqlID() string {
	return c.__id
}

func (c *mqlGithubReview) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubReview) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubReview) GetAuthorAssociation() *plugin.TValue[string] {
	return &c.AuthorAssociation
}

func (c *mqlGithubReview) GetUser() *plugin.TValue[*mqlGithubUser] {
	return &c.User
}

// mqlGithubInstallation for the github.installation resource
type mqlGithubInstallation struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubInstallationInternal it will be used here
	Id        plugin.TValue[int64]
	AppId     plugin.TValue[int64]
	AppSlug   plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
}

// createGithubInstallation creates a new instance of this resource
func createGithubInstallation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubInstallation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.installation", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubInstallation) MqlName() string {
	return "github.installation"
}

func (c *mqlGithubInstallation) MqlID() string {
	return c.__id
}

func (c *mqlGithubInstallation) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubInstallation) GetAppId() *plugin.TValue[int64] {
	return &c.AppId
}

func (c *mqlGithubInstallation) GetAppSlug() *plugin.TValue[string] {
	return &c.AppSlug
}

func (c *mqlGithubInstallation) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubInstallation) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

// mqlGithubGist for the github.gist resource
type mqlGithubGist struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubGistInternal it will be used here
	Id          plugin.TValue[string]
	Description plugin.TValue[string]
	CreatedAt   plugin.TValue[*time.Time]
	UpdatedAt   plugin.TValue[*time.Time]
	Owner       plugin.TValue[*mqlGithubUser]
	Public      plugin.TValue[bool]
	Files       plugin.TValue[[]any]
}

// createGithubGist creates a new instance of this resource
func createGithubGist(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubGist{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.gist", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubGist) MqlName() string {
	return "github.gist"
}

func (c *mqlGithubGist) MqlID() string {
	return c.__id
}

func (c *mqlGithubGist) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlGithubGist) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubGist) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubGist) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubGist) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubGist) GetPublic() *plugin.TValue[bool] {
	return &c.Public
}

func (c *mqlGithubGist) GetFiles() *plugin.TValue[[]any] {
	return &c.Files
}

// mqlGithubGistfile for the github.gistfile resource
type mqlGithubGistfile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubGistfileInternal it will be used here
	GistId   plugin.TValue[string]
	Filename plugin.TValue[string]
	Type     plugin.TValue[string]
	Language plugin.TValue[string]
	RawUrl   plugin.TValue[string]
	Size     plugin.TValue[int64]
	Content  plugin.TValue[string]
}

// createGithubGistfile creates a new instance of this resource
func createGithubGistfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubGistfile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.gistfile", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubGistfile) MqlName() string {
	return "github.gistfile"
}

func (c *mqlGithubGistfile) MqlID() string {
	return c.__id
}

func (c *mqlGithubGistfile) GetGistId() *plugin.TValue[string] {
	return &c.GistId
}

func (c *mqlGithubGistfile) GetFilename() *plugin.TValue[string] {
	return &c.Filename
}

func (c *mqlGithubGistfile) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlGithubGistfile) GetLanguage() *plugin.TValue[string] {
	return &c.Language
}

func (c *mqlGithubGistfile) GetRawUrl() *plugin.TValue[string] {
	return &c.RawUrl
}

func (c *mqlGithubGistfile) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlGithubGistfile) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		return c.content()
	})
}

// mqlGithubMilestone for the github.milestone resource
type mqlGithubMilestone struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubMilestoneInternal it will be used here
	Id           plugin.TValue[int64]
	Number       plugin.TValue[int64]
	Title        plugin.TValue[string]
	Description  plugin.TValue[string]
	State        plugin.TValue[string]
	Url          plugin.TValue[string]
	HtmlUrl      plugin.TValue[string]
	Creator      plugin.TValue[*mqlGithubUser]
	OpenIssues   plugin.TValue[int64]
	ClosedIssues plugin.TValue[int64]
	CreatedAt    plugin.TValue[*time.Time]
	UpdatedAt    plugin.TValue[*time.Time]
	ClosedAt     plugin.TValue[*time.Time]
	DueOn        plugin.TValue[*time.Time]
}

// createGithubMilestone creates a new instance of this resource
func createGithubMilestone(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubMilestone{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.milestone", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubMilestone) MqlName() string {
	return "github.milestone"
}

func (c *mqlGithubMilestone) MqlID() string {
	return c.__id
}

func (c *mqlGithubMilestone) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubMilestone) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubMilestone) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGithubMilestone) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubMilestone) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubMilestone) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubMilestone) GetHtmlUrl() *plugin.TValue[string] {
	return &c.HtmlUrl
}

func (c *mqlGithubMilestone) GetCreator() *plugin.TValue[*mqlGithubUser] {
	return &c.Creator
}

func (c *mqlGithubMilestone) GetOpenIssues() *plugin.TValue[int64] {
	return &c.OpenIssues
}

func (c *mqlGithubMilestone) GetClosedIssues() *plugin.TValue[int64] {
	return &c.ClosedIssues
}

func (c *mqlGithubMilestone) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubMilestone) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubMilestone) GetClosedAt() *plugin.TValue[*time.Time] {
	return &c.ClosedAt
}

func (c *mqlGithubMilestone) GetDueOn() *plugin.TValue[*time.Time] {
	return &c.DueOn
}

// mqlGithubIssue for the github.issue resource
type mqlGithubIssue struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubIssueInternal it will be used here
	Id        plugin.TValue[int64]
	Number    plugin.TValue[int64]
	Title     plugin.TValue[string]
	State     plugin.TValue[string]
	Body      plugin.TValue[string]
	Url       plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
	ClosedAt  plugin.TValue[*time.Time]
	Assignees plugin.TValue[[]any]
	ClosedBy  plugin.TValue[*mqlGithubUser]
	Draft     plugin.TValue[bool]
	Locked    plugin.TValue[bool]
	Milestone plugin.TValue[*mqlGithubMilestone]
}

// createGithubIssue creates a new instance of this resource
func createGithubIssue(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubIssue{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.issue", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubIssue) MqlName() string {
	return "github.issue"
}

func (c *mqlGithubIssue) MqlID() string {
	return c.__id
}

func (c *mqlGithubIssue) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubIssue) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubIssue) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlGithubIssue) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubIssue) GetBody() *plugin.TValue[string] {
	return &c.Body
}

func (c *mqlGithubIssue) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubIssue) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubIssue) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubIssue) GetClosedAt() *plugin.TValue[*time.Time] {
	return &c.ClosedAt
}

func (c *mqlGithubIssue) GetAssignees() *plugin.TValue[[]any] {
	return &c.Assignees
}

func (c *mqlGithubIssue) GetClosedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.ClosedBy
}

func (c *mqlGithubIssue) GetDraft() *plugin.TValue[bool] {
	return &c.Draft
}

func (c *mqlGithubIssue) GetLocked() *plugin.TValue[bool] {
	return &c.Locked
}

func (c *mqlGithubIssue) GetMilestone() *plugin.TValue[*mqlGithubMilestone] {
	return &c.Milestone
}

// mqlGithubDependabotAlert for the github.dependabotAlert resource
type mqlGithubDependabotAlert struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubDependabotAlertInternal it will be used here
	Number                plugin.TValue[int64]
	State                 plugin.TValue[string]
	Dependency            plugin.TValue[any]
	SecurityAdvisory      plugin.TValue[any]
	SecurityVulnerability plugin.TValue[any]
	Url                   plugin.TValue[string]
	HtmlUrl               plugin.TValue[string]
	CreatedAt             plugin.TValue[*time.Time]
	UpdatedAt             plugin.TValue[*time.Time]
	DismissedAt           plugin.TValue[*time.Time]
	FixedAt               plugin.TValue[*time.Time]
	AutoDismissedAt       plugin.TValue[*time.Time]
	DismissedBy           plugin.TValue[*mqlGithubUser]
	DismissedReason       plugin.TValue[string]
	DismissedComment      plugin.TValue[string]
}

// createGithubDependabotAlert creates a new instance of this resource
func createGithubDependabotAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubDependabotAlert{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.dependabotAlert", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubDependabotAlert) MqlName() string {
	return "github.dependabotAlert"
}

func (c *mqlGithubDependabotAlert) MqlID() string {
	return c.__id
}

func (c *mqlGithubDependabotAlert) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubDependabotAlert) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubDependabotAlert) GetDependency() *plugin.TValue[any] {
	return &c.Dependency
}

func (c *mqlGithubDependabotAlert) GetSecurityAdvisory() *plugin.TValue[any] {
	return &c.SecurityAdvisory
}

func (c *mqlGithubDependabotAlert) GetSecurityVulnerability() *plugin.TValue[any] {
	return &c.SecurityVulnerability
}

func (c *mqlGithubDependabotAlert) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubDependabotAlert) GetHtmlUrl() *plugin.TValue[string] {
	return &c.HtmlUrl
}

func (c *mqlGithubDependabotAlert) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubDependabotAlert) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubDependabotAlert) GetDismissedAt() *plugin.TValue[*time.Time] {
	return &c.DismissedAt
}

func (c *mqlGithubDependabotAlert) GetFixedAt() *plugin.TValue[*time.Time] {
	return &c.FixedAt
}

func (c *mqlGithubDependabotAlert) GetAutoDismissedAt() *plugin.TValue[*time.Time] {
	return &c.AutoDismissedAt
}

func (c *mqlGithubDependabotAlert) GetDismissedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.DismissedBy
}

func (c *mqlGithubDependabotAlert) GetDismissedReason() *plugin.TValue[string] {
	return &c.DismissedReason
}

func (c *mqlGithubDependabotAlert) GetDismissedComment() *plugin.TValue[string] {
	return &c.DismissedComment
}

// mqlGithubSecretScanningAlert for the github.secretScanningAlert resource
type mqlGithubSecretScanningAlert struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubSecretScanningAlertInternal it will be used here
	Number                   plugin.TValue[int64]
	State                    plugin.TValue[string]
	Resolution               plugin.TValue[string]
	SecretType               plugin.TValue[string]
	SecretTypeDisplayName    plugin.TValue[string]
	Secret                   plugin.TValue[string]
	Validity                 plugin.TValue[string]
	PubliclyLeaked           plugin.TValue[bool]
	MultiRepo                plugin.TValue[bool]
	Url                      plugin.TValue[string]
	HtmlUrl                  plugin.TValue[string]
	CreatedAt                plugin.TValue[*time.Time]
	UpdatedAt                plugin.TValue[*time.Time]
	ResolvedAt               plugin.TValue[*time.Time]
	ResolvedBy               plugin.TValue[*mqlGithubUser]
	PushProtectionBypassed   plugin.TValue[bool]
	PushProtectionBypassedBy plugin.TValue[*mqlGithubUser]
	PushProtectionBypassedAt plugin.TValue[*time.Time]
	ResolutionComment        plugin.TValue[string]
}

// createGithubSecretScanningAlert creates a new instance of this resource
func createGithubSecretScanningAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubSecretScanningAlert{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.secretScanningAlert", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubSecretScanningAlert) MqlName() string {
	return "github.secretScanningAlert"
}

func (c *mqlGithubSecretScanningAlert) MqlID() string {
	return c.__id
}

func (c *mqlGithubSecretScanningAlert) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubSecretScanningAlert) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubSecretScanningAlert) GetResolution() *plugin.TValue[string] {
	return &c.Resolution
}

func (c *mqlGithubSecretScanningAlert) GetSecretType() *plugin.TValue[string] {
	return &c.SecretType
}

func (c *mqlGithubSecretScanningAlert) GetSecretTypeDisplayName() *plugin.TValue[string] {
	return &c.SecretTypeDisplayName
}

func (c *mqlGithubSecretScanningAlert) GetSecret() *plugin.TValue[string] {
	return &c.Secret
}

func (c *mqlGithubSecretScanningAlert) GetValidity() *plugin.TValue[string] {
	return &c.Validity
}

func (c *mqlGithubSecretScanningAlert) GetPubliclyLeaked() *plugin.TValue[bool] {
	return &c.PubliclyLeaked
}

func (c *mqlGithubSecretScanningAlert) GetMultiRepo() *plugin.TValue[bool] {
	return &c.MultiRepo
}

func (c *mqlGithubSecretScanningAlert) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubSecretScanningAlert) GetHtmlUrl() *plugin.TValue[string] {
	return &c.HtmlUrl
}

func (c *mqlGithubSecretScanningAlert) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubSecretScanningAlert) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubSecretScanningAlert) GetResolvedAt() *plugin.TValue[*time.Time] {
	return &c.ResolvedAt
}

func (c *mqlGithubSecretScanningAlert) GetResolvedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.ResolvedBy
}

func (c *mqlGithubSecretScanningAlert) GetPushProtectionBypassed() *plugin.TValue[bool] {
	return &c.PushProtectionBypassed
}

func (c *mqlGithubSecretScanningAlert) GetPushProtectionBypassedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.PushProtectionBypassedBy
}

func (c *mqlGithubSecretScanningAlert) GetPushProtectionBypassedAt() *plugin.TValue[*time.Time] {
	return &c.PushProtectionBypassedAt
}

func (c *mqlGithubSecretScanningAlert) GetResolutionComment() *plugin.TValue[string] {
	return &c.ResolutionComment
}

// mqlGithubCodeScanningAlert for the github.codeScanningAlert resource
type mqlGithubCodeScanningAlert struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubCodeScanningAlertInternal it will be used here
	Number             plugin.TValue[int64]
	State              plugin.TValue[string]
	Rule               plugin.TValue[any]
	Tool               plugin.TValue[any]
	Url                plugin.TValue[string]
	HtmlUrl            plugin.TValue[string]
	CreatedAt          plugin.TValue[*time.Time]
	UpdatedAt          plugin.TValue[*time.Time]
	FixedAt            plugin.TValue[*time.Time]
	ClosedAt           plugin.TValue[*time.Time]
	ClosedBy           plugin.TValue[*mqlGithubUser]
	DismissedAt        plugin.TValue[*time.Time]
	DismissedBy        plugin.TValue[*mqlGithubUser]
	DismissedReason    plugin.TValue[string]
	DismissedComment   plugin.TValue[string]
	MostRecentInstance plugin.TValue[any]
}

// createGithubCodeScanningAlert creates a new instance of this resource
func createGithubCodeScanningAlert(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubCodeScanningAlert{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.codeScanningAlert", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubCodeScanningAlert) MqlName() string {
	return "github.codeScanningAlert"
}

func (c *mqlGithubCodeScanningAlert) MqlID() string {
	return c.__id
}

func (c *mqlGithubCodeScanningAlert) GetNumber() *plugin.TValue[int64] {
	return &c.Number
}

func (c *mqlGithubCodeScanningAlert) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubCodeScanningAlert) GetRule() *plugin.TValue[any] {
	return &c.Rule
}

func (c *mqlGithubCodeScanningAlert) GetTool() *plugin.TValue[any] {
	return &c.Tool
}

func (c *mqlGithubCodeScanningAlert) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubCodeScanningAlert) GetHtmlUrl() *plugin.TValue[string] {
	return &c.HtmlUrl
}

func (c *mqlGithubCodeScanningAlert) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubCodeScanningAlert) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubCodeScanningAlert) GetFixedAt() *plugin.TValue[*time.Time] {
	return &c.FixedAt
}

func (c *mqlGithubCodeScanningAlert) GetClosedAt() *plugin.TValue[*time.Time] {
	return &c.ClosedAt
}

func (c *mqlGithubCodeScanningAlert) GetClosedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.ClosedBy
}

func (c *mqlGithubCodeScanningAlert) GetDismissedAt() *plugin.TValue[*time.Time] {
	return &c.DismissedAt
}

func (c *mqlGithubCodeScanningAlert) GetDismissedBy() *plugin.TValue[*mqlGithubUser] {
	return &c.DismissedBy
}

func (c *mqlGithubCodeScanningAlert) GetDismissedReason() *plugin.TValue[string] {
	return &c.DismissedReason
}

func (c *mqlGithubCodeScanningAlert) GetDismissedComment() *plugin.TValue[string] {
	return &c.DismissedComment
}

func (c *mqlGithubCodeScanningAlert) GetMostRecentInstance() *plugin.TValue[any] {
	return &c.MostRecentInstance
}

// mqlGithubAuditLogEntry for the github.auditLogEntry resource
type mqlGithubAuditLogEntry struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubAuditLogEntryInternal it will be used here
	DocumentId               plugin.TValue[string]
	Action                   plugin.TValue[string]
	Actor                    plugin.TValue[string]
	ActorId                  plugin.TValue[int64]
	ActorLocation            plugin.TValue[string]
	Business                 plugin.TValue[string]
	BusinessId               plugin.TValue[int64]
	Org                      plugin.TValue[string]
	OrgId                    plugin.TValue[int64]
	User                     plugin.TValue[string]
	UserId                   plugin.TValue[int64]
	CreatedAt                plugin.TValue[*time.Time]
	Timestamp                plugin.TValue[*time.Time]
	ExternalIdentityNameId   plugin.TValue[string]
	ExternalIdentityUsername plugin.TValue[string]
	HashedToken              plugin.TValue[string]
	TokenId                  plugin.TValue[int64]
	TokenScopes              plugin.TValue[string]
	Data                     plugin.TValue[any]
	AdditionalFields         plugin.TValue[any]
}

// createGithubAuditLogEntry creates a new instance of this resource
func createGithubAuditLogEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubAuditLogEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.auditLogEntry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubAuditLogEntry) MqlName() string {
	return "github.auditLogEntry"
}

func (c *mqlGithubAuditLogEntry) MqlID() string {
	return c.__id
}

func (c *mqlGithubAuditLogEntry) GetDocumentId() *plugin.TValue[string] {
	return &c.DocumentId
}

func (c *mqlGithubAuditLogEntry) GetAction() *plugin.TValue[string] {
	return &c.Action
}

func (c *mqlGithubAuditLogEntry) GetActor() *plugin.TValue[string] {
	return &c.Actor
}

func (c *mqlGithubAuditLogEntry) GetActorId() *plugin.TValue[int64] {
	return &c.ActorId
}

func (c *mqlGithubAuditLogEntry) GetActorLocation() *plugin.TValue[string] {
	return &c.ActorLocation
}

func (c *mqlGithubAuditLogEntry) GetBusiness() *plugin.TValue[string] {
	return &c.Business
}

func (c *mqlGithubAuditLogEntry) GetBusinessId() *plugin.TValue[int64] {
	return &c.BusinessId
}

func (c *mqlGithubAuditLogEntry) GetOrg() *plugin.TValue[string] {
	return &c.Org
}

func (c *mqlGithubAuditLogEntry) GetOrgId() *plugin.TValue[int64] {
	return &c.OrgId
}

func (c *mqlGithubAuditLogEntry) GetUser() *plugin.TValue[string] {
	return &c.User
}

func (c *mqlGithubAuditLogEntry) GetUserId() *plugin.TValue[int64] {
	return &c.UserId
}

func (c *mqlGithubAuditLogEntry) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubAuditLogEntry) GetTimestamp() *plugin.TValue[*time.Time] {
	return &c.Timestamp
}

func (c *mqlGithubAuditLogEntry) GetExternalIdentityNameId() *plugin.TValue[string] {
	return &c.ExternalIdentityNameId
}

func (c *mqlGithubAuditLogEntry) GetExternalIdentityUsername() *plugin.TValue[string] {
	return &c.ExternalIdentityUsername
}

func (c *mqlGithubAuditLogEntry) GetHashedToken() *plugin.TValue[string] {
	return &c.HashedToken
}

func (c *mqlGithubAuditLogEntry) GetTokenId() *plugin.TValue[int64] {
	return &c.TokenId
}

func (c *mqlGithubAuditLogEntry) GetTokenScopes() *plugin.TValue[string] {
	return &c.TokenScopes
}

func (c *mqlGithubAuditLogEntry) GetData() *plugin.TValue[any] {
	return &c.Data
}

func (c *mqlGithubAuditLogEntry) GetAdditionalFields() *plugin.TValue[any] {
	return &c.AdditionalFields
}

// mqlGithubRunner for the github.runner resource
type mqlGithubRunner struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubRunnerInternal it will be used here
	Id     plugin.TValue[int64]
	Name   plugin.TValue[string]
	Os     plugin.TValue[string]
	Status plugin.TValue[string]
	Busy   plugin.TValue[bool]
	Labels plugin.TValue[[]any]
}

// createGithubRunner creates a new instance of this resource
func createGithubRunner(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRunner{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.runner", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRunner) MqlName() string {
	return "github.runner"
}

func (c *mqlGithubRunner) MqlID() string {
	return c.__id
}

func (c *mqlGithubRunner) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubRunner) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRunner) GetOs() *plugin.TValue[string] {
	return &c.Os
}

func (c *mqlGithubRunner) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlGithubRunner) GetBusy() *plugin.TValue[bool] {
	return &c.Busy
}

func (c *mqlGithubRunner) GetLabels() *plugin.TValue[[]any] {
	return &c.Labels
}

// mqlGithubRunnerLabel for the github.runnerLabel resource
type mqlGithubRunnerLabel struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubRunnerLabelInternal it will be used here
	Id   plugin.TValue[int64]
	Name plugin.TValue[string]
	Type plugin.TValue[string]
}

// createGithubRunnerLabel creates a new instance of this resource
func createGithubRunnerLabel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubRunnerLabel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.runnerLabel", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubRunnerLabel) MqlName() string {
	return "github.runnerLabel"
}

func (c *mqlGithubRunnerLabel) MqlID() string {
	return c.__id
}

func (c *mqlGithubRunnerLabel) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubRunnerLabel) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubRunnerLabel) GetType() *plugin.TValue[string] {
	return &c.Type
}

// mqlGithubEnvironment for the github.environment resource
type mqlGithubEnvironment struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubEnvironmentInternal it will be used here
	Id                   plugin.TValue[int64]
	Name                 plugin.TValue[string]
	Url                  plugin.TValue[string]
	HtmlUrl              plugin.TValue[string]
	WaitTimer            plugin.TValue[int64]
	CanAdminsBypass      plugin.TValue[bool]
	CreatedAt            plugin.TValue[*time.Time]
	UpdatedAt            plugin.TValue[*time.Time]
	ProtectedBranches    plugin.TValue[bool]
	CustomBranchPolicies plugin.TValue[bool]
	ProtectionRules      plugin.TValue[[]any]
}

// createGithubEnvironment creates a new instance of this resource
func createGithubEnvironment(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubEnvironment{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.environment", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubEnvironment) MqlName() string {
	return "github.environment"
}

func (c *mqlGithubEnvironment) MqlID() string {
	return c.__id
}

func (c *mqlGithubEnvironment) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubEnvironment) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGithubEnvironment) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlGithubEnvironment) GetHtmlUrl() *plugin.TValue[string] {
	return &c.HtmlUrl
}

func (c *mqlGithubEnvironment) GetWaitTimer() *plugin.TValue[int64] {
	return &c.WaitTimer
}

func (c *mqlGithubEnvironment) GetCanAdminsBypass() *plugin.TValue[bool] {
	return &c.CanAdminsBypass
}

func (c *mqlGithubEnvironment) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubEnvironment) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubEnvironment) GetProtectedBranches() *plugin.TValue[bool] {
	return &c.ProtectedBranches
}

func (c *mqlGithubEnvironment) GetCustomBranchPolicies() *plugin.TValue[bool] {
	return &c.CustomBranchPolicies
}

func (c *mqlGithubEnvironment) GetProtectionRules() *plugin.TValue[[]any] {
	return &c.ProtectionRules
}

// mqlGithubEnvironmentProtectionRule for the github.environmentProtectionRule resource
type mqlGithubEnvironmentProtectionRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubEnvironmentProtectionRuleInternal it will be used here
	Id                plugin.TValue[int64]
	Type              plugin.TValue[string]
	WaitTimer         plugin.TValue[int64]
	PreventSelfReview plugin.TValue[bool]
	Reviewers         plugin.TValue[[]any]
}

// createGithubEnvironmentProtectionRule creates a new instance of this resource
func createGithubEnvironmentProtectionRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubEnvironmentProtectionRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.environmentProtectionRule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubEnvironmentProtectionRule) MqlName() string {
	return "github.environmentProtectionRule"
}

func (c *mqlGithubEnvironmentProtectionRule) MqlID() string {
	return c.__id
}

func (c *mqlGithubEnvironmentProtectionRule) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubEnvironmentProtectionRule) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlGithubEnvironmentProtectionRule) GetWaitTimer() *plugin.TValue[int64] {
	return &c.WaitTimer
}

func (c *mqlGithubEnvironmentProtectionRule) GetPreventSelfReview() *plugin.TValue[bool] {
	return &c.PreventSelfReview
}

func (c *mqlGithubEnvironmentProtectionRule) GetReviewers() *plugin.TValue[[]any] {
	return &c.Reviewers
}

// mqlGithubDeployment for the github.deployment resource
type mqlGithubDeployment struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlGithubDeploymentInternal
	Id           plugin.TValue[int64]
	RepoName     plugin.TValue[string]
	Owner        plugin.TValue[*mqlGithubUser]
	Sha          plugin.TValue[string]
	Ref          plugin.TValue[string]
	Task         plugin.TValue[string]
	Environment  plugin.TValue[string]
	Description  plugin.TValue[string]
	Creator      plugin.TValue[*mqlGithubUser]
	CreatedAt    plugin.TValue[*time.Time]
	UpdatedAt    plugin.TValue[*time.Time]
	Payload      plugin.TValue[any]
	StatusesUrl  plugin.TValue[string]
	LatestStatus plugin.TValue[*mqlGithubDeploymentStatus]
}

// createGithubDeployment creates a new instance of this resource
func createGithubDeployment(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubDeployment{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.deployment", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubDeployment) MqlName() string {
	return "github.deployment"
}

func (c *mqlGithubDeployment) MqlID() string {
	return c.__id
}

func (c *mqlGithubDeployment) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubDeployment) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlGithubDeployment) GetOwner() *plugin.TValue[*mqlGithubUser] {
	return &c.Owner
}

func (c *mqlGithubDeployment) GetSha() *plugin.TValue[string] {
	return &c.Sha
}

func (c *mqlGithubDeployment) GetRef() *plugin.TValue[string] {
	return &c.Ref
}

func (c *mqlGithubDeployment) GetTask() *plugin.TValue[string] {
	return &c.Task
}

func (c *mqlGithubDeployment) GetEnvironment() *plugin.TValue[string] {
	return &c.Environment
}

func (c *mqlGithubDeployment) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubDeployment) GetCreator() *plugin.TValue[*mqlGithubUser] {
	return &c.Creator
}

func (c *mqlGithubDeployment) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubDeployment) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubDeployment) GetPayload() *plugin.TValue[any] {
	return &c.Payload
}

func (c *mqlGithubDeployment) GetStatusesUrl() *plugin.TValue[string] {
	return &c.StatusesUrl
}

func (c *mqlGithubDeployment) GetLatestStatus() *plugin.TValue[*mqlGithubDeploymentStatus] {
	return plugin.GetOrCompute[*mqlGithubDeploymentStatus](&c.LatestStatus, func() (*mqlGithubDeploymentStatus, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("github.deployment", c.__id, "latestStatus")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGithubDeploymentStatus), nil
			}
		}

		return c.latestStatus()
	})
}

// mqlGithubDeploymentStatus for the github.deploymentStatus resource
type mqlGithubDeploymentStatus struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlGithubDeploymentStatusInternal it will be used here
	Id             plugin.TValue[int64]
	State          plugin.TValue[string]
	Description    plugin.TValue[string]
	Environment    plugin.TValue[string]
	Creator        plugin.TValue[*mqlGithubUser]
	CreatedAt      plugin.TValue[*time.Time]
	UpdatedAt      plugin.TValue[*time.Time]
	TargetUrl      plugin.TValue[string]
	LogUrl         plugin.TValue[string]
	EnvironmentUrl plugin.TValue[string]
}

// createGithubDeploymentStatus creates a new instance of this resource
func createGithubDeploymentStatus(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGithubDeploymentStatus{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("github.deploymentStatus", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGithubDeploymentStatus) MqlName() string {
	return "github.deploymentStatus"
}

func (c *mqlGithubDeploymentStatus) MqlID() string {
	return c.__id
}

func (c *mqlGithubDeploymentStatus) GetId() *plugin.TValue[int64] {
	return &c.Id
}

func (c *mqlGithubDeploymentStatus) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlGithubDeploymentStatus) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlGithubDeploymentStatus) GetEnvironment() *plugin.TValue[string] {
	return &c.Environment
}

func (c *mqlGithubDeploymentStatus) GetCreator() *plugin.TValue[*mqlGithubUser] {
	return &c.Creator
}

func (c *mqlGithubDeploymentStatus) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlGithubDeploymentStatus) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlGithubDeploymentStatus) GetTargetUrl() *plugin.TValue[string] {
	return &c.TargetUrl
}

func (c *mqlGithubDeploymentStatus) GetLogUrl() *plugin.TValue[string] {
	return &c.LogUrl
}

func (c *mqlGithubDeploymentStatus) GetEnvironmentUrl() *plugin.TValue[string] {
	return &c.EnvironmentUrl
}

// MqlFinding for the finding resource
type MqlFinding struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingInternal it will be used here
	Id           plugin.TValue[string]
	Ref          plugin.TValue[string]
	Mrn          plugin.TValue[string]
	GroupId      plugin.TValue[string]
	Summary      plugin.TValue[string]
	Details      plugin.TValue[*MqlFindingDetail]
	FirstSeenAt  plugin.TValue[*time.Time]
	LastSeenAt   plugin.TValue[*time.Time]
	RemediatedAt plugin.TValue[*time.Time]
	Status       plugin.TValue[string]
	Source       plugin.TValue[*MqlFindingSource]
	Affects      plugin.TValue[[]any]
	Evidences    plugin.TValue[[]any]
	Remediations plugin.TValue[[]any]
}

// createFinding creates a new instance of this resource
func createFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFinding) MqlName() string {
	return "finding"
}

func (c *MqlFinding) MqlID() string {
	return c.__id
}

func (c *MqlFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFinding) GetRef() *plugin.TValue[string] {
	return &c.Ref
}

func (c *MqlFinding) GetMrn() *plugin.TValue[string] {
	return &c.Mrn
}

func (c *MqlFinding) GetGroupId() *plugin.TValue[string] {
	return &c.GroupId
}

func (c *MqlFinding) GetSummary() *plugin.TValue[string] {
	return &c.Summary
}

func (c *MqlFinding) GetDetails() *plugin.TValue[*MqlFindingDetail] {
	return &c.Details
}

func (c *MqlFinding) GetFirstSeenAt() *plugin.TValue[*time.Time] {
	return &c.FirstSeenAt
}

func (c *MqlFinding) GetLastSeenAt() *plugin.TValue[*time.Time] {
	return &c.LastSeenAt
}

func (c *MqlFinding) GetRemediatedAt() *plugin.TValue[*time.Time] {
	return &c.RemediatedAt
}

func (c *MqlFinding) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *MqlFinding) GetSource() *plugin.TValue[*MqlFindingSource] {
	return &c.Source
}

func (c *MqlFinding) GetAffects() *plugin.TValue[[]any] {
	return &c.Affects
}

func (c *MqlFinding) GetEvidences() *plugin.TValue[[]any] {
	return &c.Evidences
}

func (c *MqlFinding) GetRemediations() *plugin.TValue[[]any] {
	return &c.Remediations
}

// MqlFindingDetail for the finding.detail resource
type MqlFindingDetail struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingDetailInternal it will be used here
	Category    plugin.TValue[string]
	Severity    plugin.TValue[*MqlFindingSeverity]
	Confidence  plugin.TValue[string]
	Description plugin.TValue[string]
	References  plugin.TValue[[]any]
	Properties  plugin.TValue[map[string]any]
}

// createFindingDetail creates a new instance of this resource
func createFindingDetail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingDetail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.detail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingDetail) MqlName() string {
	return "finding.detail"
}

func (c *MqlFindingDetail) MqlID() string {
	return c.__id
}

func (c *MqlFindingDetail) GetCategory() *plugin.TValue[string] {
	return &c.Category
}

func (c *MqlFindingDetail) GetSeverity() *plugin.TValue[*MqlFindingSeverity] {
	return &c.Severity
}

func (c *MqlFindingDetail) GetConfidence() *plugin.TValue[string] {
	return &c.Confidence
}

func (c *MqlFindingDetail) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *MqlFindingDetail) GetReferences() *plugin.TValue[[]any] {
	return &c.References
}

func (c *MqlFindingDetail) GetProperties() *plugin.TValue[map[string]any] {
	return &c.Properties
}

// MqlFindingSource for the finding.source resource
type MqlFindingSource struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingSourceInternal it will be used here
	Name plugin.TValue[string]
	Url  plugin.TValue[string]
}

// createFindingSource creates a new instance of this resource
func createFindingSource(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingSource{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.source", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingSource) MqlName() string {
	return "finding.source"
}

func (c *MqlFindingSource) MqlID() string {
	return c.__id
}

func (c *MqlFindingSource) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingSource) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

// MqlFindingSeverity for the finding.severity resource
type MqlFindingSeverity struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingSeverityInternal it will be used here
	Source   plugin.TValue[*MqlFindingSource]
	Score    plugin.TValue[float64]
	Severity plugin.TValue[string]
	Vector   plugin.TValue[string]
	Method   plugin.TValue[string]
	Rating   plugin.TValue[string]
}

// createFindingSeverity creates a new instance of this resource
func createFindingSeverity(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingSeverity{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.severity", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingSeverity) MqlName() string {
	return "finding.severity"
}

func (c *MqlFindingSeverity) MqlID() string {
	return c.__id
}

func (c *MqlFindingSeverity) GetSource() *plugin.TValue[*MqlFindingSource] {
	return &c.Source
}

func (c *MqlFindingSeverity) GetScore() *plugin.TValue[float64] {
	return &c.Score
}

func (c *MqlFindingSeverity) GetSeverity() *plugin.TValue[string] {
	return &c.Severity
}

func (c *MqlFindingSeverity) GetVector() *plugin.TValue[string] {
	return &c.Vector
}

func (c *MqlFindingSeverity) GetMethod() *plugin.TValue[string] {
	return &c.Method
}

func (c *MqlFindingSeverity) GetRating() *plugin.TValue[string] {
	return &c.Rating
}

// MqlFindingReference for the finding.reference resource
type MqlFindingReference struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingReferenceInternal it will be used here
	Id            plugin.TValue[string]
	Name          plugin.TValue[string]
	Url           plugin.TValue[string]
	ReferenceType plugin.TValue[string]
	Metadata      plugin.TValue[map[string]any]
}

// createFindingReference creates a new instance of this resource
func createFindingReference(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingReference{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.reference", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingReference) MqlName() string {
	return "finding.reference"
}

func (c *MqlFindingReference) MqlID() string {
	return c.__id
}

func (c *MqlFindingReference) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFindingReference) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingReference) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *MqlFindingReference) GetReferenceType() *plugin.TValue[string] {
	return &c.ReferenceType
}

func (c *MqlFindingReference) GetMetadata() *plugin.TValue[map[string]any] {
	return &c.Metadata
}

// MqlFindingAffects for the finding.affects resource
type MqlFindingAffects struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingAffectsInternal it will be used here
	Component     plugin.TValue[*MqlFindingComponent]
	SubComponents plugin.TValue[[]any]
}

// createFindingAffects creates a new instance of this resource
func createFindingAffects(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingAffects{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.affects", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingAffects) MqlName() string {
	return "finding.affects"
}

func (c *MqlFindingAffects) MqlID() string {
	return c.__id
}

func (c *MqlFindingAffects) GetComponent() *plugin.TValue[*MqlFindingComponent] {
	return &c.Component
}

func (c *MqlFindingAffects) GetSubComponents() *plugin.TValue[[]any] {
	return &c.SubComponents
}

// MqlFindingComponent for the finding.component resource
type MqlFindingComponent struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingComponentInternal it will be used here
	Id          plugin.TValue[string]
	Identifiers plugin.TValue[map[string]any]
	Properties  plugin.TValue[map[string]any]
	File        plugin.TValue[*MqlFindingFileComponent]
}

// createFindingComponent creates a new instance of this resource
func createFindingComponent(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingComponent{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.component", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingComponent) MqlName() string {
	return "finding.component"
}

func (c *MqlFindingComponent) MqlID() string {
	return c.__id
}

func (c *MqlFindingComponent) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFindingComponent) GetIdentifiers() *plugin.TValue[map[string]any] {
	return &c.Identifiers
}

func (c *MqlFindingComponent) GetProperties() *plugin.TValue[map[string]any] {
	return &c.Properties
}

func (c *MqlFindingComponent) GetFile() *plugin.TValue[*MqlFindingFileComponent] {
	return &c.File
}

// MqlFindingFileComponent for the finding.fileComponent resource
type MqlFindingFileComponent struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingFileComponentInternal it will be used here
	Path   plugin.TValue[string]
	Hash   plugin.TValue[string]
	Format plugin.TValue[string]
	Size   plugin.TValue[int64]
}

// createFindingFileComponent creates a new instance of this resource
func createFindingFileComponent(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingFileComponent{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.fileComponent", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingFileComponent) MqlName() string {
	return "finding.fileComponent"
}

func (c *MqlFindingFileComponent) MqlID() string {
	return c.__id
}

func (c *MqlFindingFileComponent) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *MqlFindingFileComponent) GetHash() *plugin.TValue[string] {
	return &c.Hash
}

func (c *MqlFindingFileComponent) GetFormat() *plugin.TValue[string] {
	return &c.Format
}

func (c *MqlFindingFileComponent) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

// MqlFindingEvidence for the finding.evidence resource
type MqlFindingEvidence struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingEvidenceInternal it will be used here
	Tactic      plugin.TValue[*MqlFindingAttackTactic]
	Technique   plugin.TValue[*MqlFindingAttackTechnique]
	Confidence  plugin.TValue[string]
	User        plugin.TValue[*MqlFindingUser]
	File        plugin.TValue[*MqlFindingFile]
	Process     plugin.TValue[*MqlFindingProcess]
	Container   plugin.TValue[*MqlFindingContainer]
	Kubernetes  plugin.TValue[*MqlFindingKubernetes]
	RegistryKey plugin.TValue[*MqlFindingRegistryKey]
	Connection  plugin.TValue[*MqlFindingConnection]
	Properties  plugin.TValue[map[string]any]
}

// createFindingEvidence creates a new instance of this resource
func createFindingEvidence(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingEvidence{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.evidence", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingEvidence) MqlName() string {
	return "finding.evidence"
}

func (c *MqlFindingEvidence) MqlID() string {
	return c.__id
}

func (c *MqlFindingEvidence) GetTactic() *plugin.TValue[*MqlFindingAttackTactic] {
	return &c.Tactic
}

func (c *MqlFindingEvidence) GetTechnique() *plugin.TValue[*MqlFindingAttackTechnique] {
	return &c.Technique
}

func (c *MqlFindingEvidence) GetConfidence() *plugin.TValue[string] {
	return &c.Confidence
}

func (c *MqlFindingEvidence) GetUser() *plugin.TValue[*MqlFindingUser] {
	return &c.User
}

func (c *MqlFindingEvidence) GetFile() *plugin.TValue[*MqlFindingFile] {
	return &c.File
}

func (c *MqlFindingEvidence) GetProcess() *plugin.TValue[*MqlFindingProcess] {
	return &c.Process
}

func (c *MqlFindingEvidence) GetContainer() *plugin.TValue[*MqlFindingContainer] {
	return &c.Container
}

func (c *MqlFindingEvidence) GetKubernetes() *plugin.TValue[*MqlFindingKubernetes] {
	return &c.Kubernetes
}

func (c *MqlFindingEvidence) GetRegistryKey() *plugin.TValue[*MqlFindingRegistryKey] {
	return &c.RegistryKey
}

func (c *MqlFindingEvidence) GetConnection() *plugin.TValue[*MqlFindingConnection] {
	return &c.Connection
}

func (c *MqlFindingEvidence) GetProperties() *plugin.TValue[map[string]any] {
	return &c.Properties
}

// MqlFindingFile for the finding.file resource
type MqlFindingFile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingFileInternal it will be used here
	Path     plugin.TValue[string]
	Size     plugin.TValue[int64]
	Md5      plugin.TValue[string]
	Sha256   plugin.TValue[string]
	Contents plugin.TValue[string]
}

// createFindingFile creates a new instance of this resource
func createFindingFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingFile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.file", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingFile) MqlName() string {
	return "finding.file"
}

func (c *MqlFindingFile) MqlID() string {
	return c.__id
}

func (c *MqlFindingFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *MqlFindingFile) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *MqlFindingFile) GetMd5() *plugin.TValue[string] {
	return &c.Md5
}

func (c *MqlFindingFile) GetSha256() *plugin.TValue[string] {
	return &c.Sha256
}

func (c *MqlFindingFile) GetContents() *plugin.TValue[string] {
	return &c.Contents
}

// MqlFindingUser for the finding.user resource
type MqlFindingUser struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingUserInternal it will be used here
	Id         plugin.TValue[string]
	Name       plugin.TValue[string]
	Properties plugin.TValue[map[string]any]
}

// createFindingUser creates a new instance of this resource
func createFindingUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingUser) MqlName() string {
	return "finding.user"
}

func (c *MqlFindingUser) MqlID() string {
	return c.__id
}

func (c *MqlFindingUser) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFindingUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingUser) GetProperties() *plugin.TValue[map[string]any] {
	return &c.Properties
}

// MqlFindingProcess for the finding.process resource
type MqlFindingProcess struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingProcessInternal it will be used here
	Cmdline plugin.TValue[string]
	Binary  plugin.TValue[*MqlFindingFile]
	Script  plugin.TValue[*MqlFindingFile]
	Pid     plugin.TValue[int64]
	User    plugin.TValue[*MqlFindingUser]
	Parent  plugin.TValue[*MqlFindingProcess]
}

// createFindingProcess creates a new instance of this resource
func createFindingProcess(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingProcess{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.process", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingProcess) MqlName() string {
	return "finding.process"
}

func (c *MqlFindingProcess) MqlID() string {
	return c.__id
}

func (c *MqlFindingProcess) GetCmdline() *plugin.TValue[string] {
	return &c.Cmdline
}

func (c *MqlFindingProcess) GetBinary() *plugin.TValue[*MqlFindingFile] {
	return &c.Binary
}

func (c *MqlFindingProcess) GetScript() *plugin.TValue[*MqlFindingFile] {
	return &c.Script
}

func (c *MqlFindingProcess) GetPid() *plugin.TValue[int64] {
	return &c.Pid
}

func (c *MqlFindingProcess) GetUser() *plugin.TValue[*MqlFindingUser] {
	return &c.User
}

func (c *MqlFindingProcess) GetParent() *plugin.TValue[*MqlFindingProcess] {
	return &c.Parent
}

// MqlFindingContainer for the finding.container resource
type MqlFindingContainer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingContainerInternal it will be used here
	Name     plugin.TValue[string]
	ImageUri plugin.TValue[string]
	Digest   plugin.TValue[string]
}

// createFindingContainer creates a new instance of this resource
func createFindingContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingContainer) MqlName() string {
	return "finding.container"
}

func (c *MqlFindingContainer) MqlID() string {
	return c.__id
}

func (c *MqlFindingContainer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingContainer) GetImageUri() *plugin.TValue[string] {
	return &c.ImageUri
}

func (c *MqlFindingContainer) GetDigest() *plugin.TValue[string] {
	return &c.Digest
}

// MqlFindingKubernetes for the finding.kubernetes resource
type MqlFindingKubernetes struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingKubernetesInternal it will be used here
	Pods  plugin.TValue[[]any]
	Nodes plugin.TValue[[]any]
}

// createFindingKubernetes creates a new instance of this resource
func createFindingKubernetes(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingKubernetes{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.kubernetes", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingKubernetes) MqlName() string {
	return "finding.kubernetes"
}

func (c *MqlFindingKubernetes) MqlID() string {
	return c.__id
}

func (c *MqlFindingKubernetes) GetPods() *plugin.TValue[[]any] {
	return &c.Pods
}

func (c *MqlFindingKubernetes) GetNodes() *plugin.TValue[[]any] {
	return &c.Nodes
}

// MqlFindingKubernetesPod for the finding.kubernetes.pod resource
type MqlFindingKubernetesPod struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingKubernetesPodInternal it will be used here
	Name       plugin.TValue[string]
	Namespace  plugin.TValue[string]
	Containers plugin.TValue[[]any]
}

// createFindingKubernetesPod creates a new instance of this resource
func createFindingKubernetesPod(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingKubernetesPod{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.kubernetes.pod", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingKubernetesPod) MqlName() string {
	return "finding.kubernetes.pod"
}

func (c *MqlFindingKubernetesPod) MqlID() string {
	return c.__id
}

func (c *MqlFindingKubernetesPod) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingKubernetesPod) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *MqlFindingKubernetesPod) GetContainers() *plugin.TValue[[]any] {
	return &c.Containers
}

// MqlFindingKubernetesNode for the finding.kubernetes.node resource
type MqlFindingKubernetesNode struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingKubernetesNodeInternal it will be used here
	Name plugin.TValue[string]
	Id   plugin.TValue[string]
}

// createFindingKubernetesNode creates a new instance of this resource
func createFindingKubernetesNode(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingKubernetesNode{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.kubernetes.node", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingKubernetesNode) MqlName() string {
	return "finding.kubernetes.node"
}

func (c *MqlFindingKubernetesNode) MqlID() string {
	return c.__id
}

func (c *MqlFindingKubernetesNode) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingKubernetesNode) GetId() *plugin.TValue[string] {
	return &c.Id
}

// MqlFindingRegistryKey for the finding.registryKey resource
type MqlFindingRegistryKey struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingRegistryKeyInternal it will be used here
	Path plugin.TValue[string]
	Name plugin.TValue[string]
	Data plugin.TValue[string]
}

// createFindingRegistryKey creates a new instance of this resource
func createFindingRegistryKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingRegistryKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.registryKey", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingRegistryKey) MqlName() string {
	return "finding.registryKey"
}

func (c *MqlFindingRegistryKey) MqlID() string {
	return c.__id
}

func (c *MqlFindingRegistryKey) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *MqlFindingRegistryKey) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingRegistryKey) GetData() *plugin.TValue[string] {
	return &c.Data
}

// MqlFindingConnection for the finding.connection resource
type MqlFindingConnection struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingConnectionInternal it will be used here
	DestinationAddress plugin.TValue[string]
	DestinationPort    plugin.TValue[int64]
	SourceAddress      plugin.TValue[string]
	SourcePort         plugin.TValue[int64]
	Protocol           plugin.TValue[string]
}

// createFindingConnection creates a new instance of this resource
func createFindingConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingConnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.connection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingConnection) MqlName() string {
	return "finding.connection"
}

func (c *MqlFindingConnection) MqlID() string {
	return c.__id
}

func (c *MqlFindingConnection) GetDestinationAddress() *plugin.TValue[string] {
	return &c.DestinationAddress
}

func (c *MqlFindingConnection) GetDestinationPort() *plugin.TValue[int64] {
	return &c.DestinationPort
}

func (c *MqlFindingConnection) GetSourceAddress() *plugin.TValue[string] {
	return &c.SourceAddress
}

func (c *MqlFindingConnection) GetSourcePort() *plugin.TValue[int64] {
	return &c.SourcePort
}

func (c *MqlFindingConnection) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// MqlFindingAttackTactic for the finding.attackTactic resource
type MqlFindingAttackTactic struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingAttackTacticInternal it will be used here
	Id          plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
}

// createFindingAttackTactic creates a new instance of this resource
func createFindingAttackTactic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingAttackTactic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.attackTactic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingAttackTactic) MqlName() string {
	return "finding.attackTactic"
}

func (c *MqlFindingAttackTactic) MqlID() string {
	return c.__id
}

func (c *MqlFindingAttackTactic) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFindingAttackTactic) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingAttackTactic) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

// MqlFindingAttackTechnique for the finding.attackTechnique resource
type MqlFindingAttackTechnique struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define MqlFindingAttackTechniqueInternal it will be used here
	Id          plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
}

// createFindingAttackTechnique creates a new instance of this resource
func createFindingAttackTechnique(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &MqlFindingAttackTechnique{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("finding.attackTechnique", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *MqlFindingAttackTechnique) MqlName() string {
	return "finding.attackTechnique"
}

func (c *MqlFindingAttackTechnique) MqlID() string {
	return c.__id
}

func (c *MqlFindingAttackTechnique) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *MqlFindingAttackTechnique) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *MqlFindingAttackTechnique) GetDescription() *plugin.TValue[string] {
	return &c.Description
}
