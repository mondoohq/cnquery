// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

package registry

import (
	"errors"
	"fmt"
	"runtime"
	"sync"
)

// RegistryHandler allows for loading and unloading of registry keys from files. It also allows for looking up registry keys and values.
type RegistryHandler struct {
	// a map of currently loaded registries.
	// the id is the registry's id (e.g. "SOFTWARE") and the value is the path to the loaded key (e.g. "TmpReg_SOFTWARE")
	registries map[string]string
	lock       sync.Mutex
}

const (
	subkeyPrefix = "TMPREG"
)

func NewRegistryHandler() *RegistryHandler {
	return &RegistryHandler{
		registries: make(map[string]string),
	}
}

// Loads the given registry file into the registry handler under a subkey, generated by buildSubKeyPath.
// The subkey file is indicated by the filepath parameter.
// Only known registry files (see KnownRegistryFiles) can be loaded.
func (r *RegistryHandler) LoadSubkey(registryId, filepath string) error {
	if runtime.GOOS != "windows" {
		return errors.New("loading of registry subkeys is only supported on windows")
	}

	r.lock.Lock()
	defer r.lock.Unlock()
	// sanity check, make sure we only try and load registry files we know of
	if _, ok := KnownRegistryFiles[registryId]; !ok {
		return errors.New("invalid registry id")
	}
	if _, ok := r.registries[registryId]; ok {
		return nil
	}
	// format the registry path
	key := buildSubKeyPath(registryId)
	err := LoadRegistrySubkey(key, filepath)
	if err != nil {
		return err
	}
	r.registries[registryId] = key
	return nil
}

// we use the name of the registry file as an id, e.g. "SOFTWARE"
// we combine this with the prefix to get a subkey like "TmpReg_SOFTWARE"
func buildSubKeyPath(registryId string) string {
	return fmt.Sprintf("%s_%s", subkeyPrefix, registryId)
}

// Unloads all the subkeys, that were loaded by the handler.
func (r *RegistryHandler) UnloadSubkeys() error {
	r.lock.Lock()
	defer r.lock.Unlock()
	for id, regPath := range r.registries {
		err := UnloadRegistrySubkey(regPath)
		if err != nil {
			return err
		}
		delete(r.registries, id)
	}
	return nil
}

// Gets a fully qualified registry path for a given registry id, including the root (HKLM).
func (r *RegistryHandler) getRegistryPath(id string) (string, error) {
	if path, ok := r.registries[id]; ok {
		// we always point the syscalls to HKEY_LOCAL_MACHINE so we can safely prefix it here
		return fmt.Sprintf("HKLM\\%s", path), nil
	}
	return "", fmt.Errorf("registry %s not loaded", id)
}

// Gets a fully qualified registry key path for a given registry id and key.
// E.g. if the registry id is "SOFTWARE" and the key is "Microsoft", the result will be "HKLM\TmpReg_SOFTWARE\Microsoft".
func (r *RegistryHandler) getRegistryKeyPath(id string, key string) (string, error) {
	root, err := r.getRegistryPath(id)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s\\%s", root, key), nil
}

func (r *RegistryHandler) GetRegistryItemValue(registryId string, path, key string) (RegistryKeyItem, error) {
	regPath, err := r.getRegistryKeyPath(registryId, path)
	if err != nil {
		return RegistryKeyItem{}, err
	}
	return GetNativeRegistryKeyItem(regPath, key)
}

func (r *RegistryHandler) GetNativeRegistryKeyChildren(registryId string, path string) ([]RegistryKeyChild, error) {
	regPath, err := r.getRegistryKeyPath(registryId, path)
	if err != nil {
		return nil, err
	}
	return GetNativeRegistryKeyChildren(regPath)
}
