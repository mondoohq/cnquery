// Code generated by resources. DO NOT EDIT.
package resources

import (
	"errors"

	"go.mondoo.com/cnquery/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/types"
)

var newResource = map[string]func(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error){
	"command": NewCommand,
	"file": NewFile,
	"file.permissions": NewFilePermissions,
	"user": NewUser,
	"users": NewUsers,
	"group": NewGroup,
	"groups": NewGroups,
}

// CreateResource is used by the runtime of this plugin
func CreateResource(runtime *plugin.Runtime, name string, args map[string]interface{}) (plugin.Resource, error) {
	f, ok := newResource[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in os provider")
	}

	res, err := f(runtime, args)
	if err != nil {
		return nil, err
	}

	id := res.MqlID()
	if x, ok := runtime.Resources[name+"\x00"+id]; ok {
		res = x
	} else {
		runtime.Resources[name+"\x00"+id] = res
	}

	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"command.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetCommand()).ToDataRes(types.String)
	},
	"command.stdout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStdout()).ToDataRes(types.String)
	},
	"command.stderr": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStderr()).ToDataRes(types.String)
	},
	"command.exitcode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetExitcode()).ToDataRes(types.Int)
	},
	"file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPath()).ToDataRes(types.String)
	},
	"file.basename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetBasename()).ToDataRes(types.String)
	},
	"file.dirname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetDirname()).ToDataRes(types.String)
	},
	"file.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetContent()).ToDataRes(types.String)
	},
	"file.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetExists()).ToDataRes(types.Bool)
	},
	"file.permissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPermissions()).ToDataRes(types.Resource("file.permissions"))
	},
	"file.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetSize()).ToDataRes(types.Int)
	},
	"file.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetUser()).ToDataRes(types.Resource("user"))
	},
	"file.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"file.empty": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetEmpty()).ToDataRes(types.Bool)
	},
	"file.permissions.mode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetMode()).ToDataRes(types.Int)
	},
	"file.permissions.user_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.suid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSuid()).ToDataRes(types.Bool)
	},
	"file.permissions.sgid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSgid()).ToDataRes(types.Bool)
	},
	"file.permissions.sticky": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSticky()).ToDataRes(types.Bool)
	},
	"file.permissions.isDirectory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsDirectory()).ToDataRes(types.Bool)
	},
	"file.permissions.isFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsFile()).ToDataRes(types.Bool)
	},
	"file.permissions.isSymlink": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsSymlink()).ToDataRes(types.Bool)
	},
	"file.permissions.string": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetString()).ToDataRes(types.String)
	},
	"user.uid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetUid()).ToDataRes(types.Int)
	},
	"user.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGid()).ToDataRes(types.Int)
	},
	"user.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetSid()).ToDataRes(types.String)
	},
	"user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetName()).ToDataRes(types.String)
	},
	"user.home": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetHome()).ToDataRes(types.String)
	},
	"user.shell": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetShell()).ToDataRes(types.String)
	},
	"user.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetEnabled()).ToDataRes(types.Bool)
	},
	"user.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"users.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUsers).GetList()).ToDataRes(types.Array(types.Resource("user")))
	},
	"group.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetGid()).ToDataRes(types.Int)
	},
	"group.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetSid()).ToDataRes(types.String)
	},
	"group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetName()).ToDataRes(types.String)
	},
	"group.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetMembers()).ToDataRes(types.Array(types.Resource("user")))
	},
	"groups.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroups).GetList()).ToDataRes(types.Array(types.Resource("group")))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]interface{}) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v interface{}) bool {
	"command.command": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlCommand).Command, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"command.stdout": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlCommand).Stdout, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"command.stderr": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlCommand).Stderr, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"command.exitcode": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlCommand).Exitcode, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"file.path": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Path, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"file.basename": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Basename, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"file.dirname": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Dirname, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"file.content": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Content, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"file.exists": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Exists, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Permissions, ok = plugin.RawToTValue[*mqlFilePermissions](v)
		return ok
	},
	"file.size": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Size, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"file.user": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).User, ok = plugin.RawToTValue[*mqlUser](v)
		return ok
	},
	"file.group": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Group, ok = plugin.RawToTValue[*mqlGroup](v)
		return ok
	},
	"file.empty": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFile).Empty, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.mode": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Mode, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"file.permissions.user_readable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).User_readable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.user_writeable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).User_writeable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.user_executable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).User_executable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.group_readable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Group_readable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.group_writeable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Group_writeable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.group_executable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Group_executable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.other_readable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Other_readable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.other_writeable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Other_writeable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.other_executable": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Other_executable, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.suid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Suid, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.sgid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Sgid, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.sticky": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).Sticky, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.isDirectory": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).IsDirectory, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.isFile": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).IsFile, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.isSymlink": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).IsSymlink, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"file.permissions.string": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlFilePermissions).String, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"user.uid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Uid, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"user.gid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Gid, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"user.sid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Sid, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"user.name": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Name, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"user.home": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Home, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"user.shell": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Shell, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"user.enabled": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Enabled, ok = plugin.RawToTValue[bool](v)
		return ok
	},
	"user.group": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUser).Group, ok = plugin.RawToTValue[*mqlGroup](v)
		return ok
	},
	"users.list": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlUsers).List, ok = plugin.RawToTValue[[]interface{}](v)
		return ok
	},
	"group.gid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlGroup).Gid, ok = plugin.RawToTValue[int64](v)
		return ok
	},
	"group.sid": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlGroup).Sid, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"group.name": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlGroup).Name, ok = plugin.RawToTValue[string](v)
		return ok
	},
	"group.members": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlGroup).Members, ok = plugin.RawToTValue[[]interface{}](v)
		return ok
	},
	"groups.list": func(r plugin.Resource, v interface{}) bool {
		var ok bool
		r.(*mqlGroups).List, ok = plugin.RawToTValue[[]interface{}](v)
		return ok
	},
}

func SetData(resource plugin.Resource, field string, val interface{}) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

// mqlCommand for the command resource
type mqlCommand struct {
	MqlRuntime *plugin.Runtime
	_id string
	mqlCommandInternal

	Command plugin.TValue[string]
	Stdout plugin.TValue[string]
	Stderr plugin.TValue[string]
	Exitcode plugin.TValue[int64]
}

// NewCommand creates a new instance of this resource
func NewCommand(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlCommand{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlCommand, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id, err = res.id()
	return res, err
}

func (c *mqlCommand) MqlName() string {
	return "command"
}

func (c *mqlCommand) MqlID() string {
	return c._id
}

func (c *mqlCommand) GetCommand() *plugin.TValue[string] {
	return &c.Command
}

func (c *mqlCommand) GetStdout() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stdout, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}
		return c.stdout(vargCommand.Data)
	})
}

func (c *mqlCommand) GetStderr() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stderr, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}
		return c.stderr(vargCommand.Data)
	})
}

func (c *mqlCommand) GetExitcode() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Exitcode, func() (int64, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return 0, vargCommand.Error
		}
		return c.exitcode(vargCommand.Data)
	})
}

// mqlFile for the file resource
type mqlFile struct {
	MqlRuntime *plugin.Runtime
	_id string
	// optional: if you define mqlFileInternal it will be used here

	Path plugin.TValue[string]
	Basename plugin.TValue[string]
	Dirname plugin.TValue[string]
	Content plugin.TValue[string]
	Exists plugin.TValue[bool]
	Permissions plugin.TValue[*mqlFilePermissions]
	Size plugin.TValue[int64]
	User plugin.TValue[*mqlUser]
	Group plugin.TValue[*mqlGroup]
	Empty plugin.TValue[bool]
}

// NewFile creates a new instance of this resource
func NewFile(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlFile{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlFile, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id, err = res.id()
	return res, err
}

func (c *mqlFile) MqlName() string {
	return "file"
}

func (c *mqlFile) MqlID() string {
	return c._id
}

func (c *mqlFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlFile) GetBasename() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Basename, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}
		return c.basename(vargPath.Data)
	})
}

func (c *mqlFile) GetDirname() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Dirname, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}
		return c.dirname(vargPath.Data)
	})
}

func (c *mqlFile) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		vargExists := c.GetExists()
		if vargExists.Error != nil {
			return "", vargExists.Error
		}
		return c.content(vargPath.Data, vargExists.Data)
	})
}

func (c *mqlFile) GetExists() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Exists, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}
		return c.exists(vargPath.Data)
	})
}

func (c *mqlFile) GetPermissions() *plugin.TValue[*mqlFilePermissions] {
	return plugin.GetOrCompute[*mqlFilePermissions](&c.Permissions, func() (*mqlFilePermissions, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return nil, vargPath.Error
		}
		return c.permissions(vargPath.Data)
	})
}

func (c *mqlFile) GetSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Size, func() (int64, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return 0, vargPath.Error
		}
		return c.size(vargPath.Data)
	})
}

func (c *mqlFile) GetUser() *plugin.TValue[*mqlUser] {
	return plugin.GetOrCompute[*mqlUser](&c.User, func() (*mqlUser, error) {
		return c.user()
	})
}

func (c *mqlFile) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		return c.group()
	})
}

func (c *mqlFile) GetEmpty() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Empty, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}
		return c.empty(vargPath.Data)
	})
}

// mqlFilePermissions for the file.permissions resource
type mqlFilePermissions struct {
	MqlRuntime *plugin.Runtime
	_id string
	// optional: if you define mqlFilePermissionsInternal it will be used here

	Mode plugin.TValue[int64]
	User_readable plugin.TValue[bool]
	User_writeable plugin.TValue[bool]
	User_executable plugin.TValue[bool]
	Group_readable plugin.TValue[bool]
	Group_writeable plugin.TValue[bool]
	Group_executable plugin.TValue[bool]
	Other_readable plugin.TValue[bool]
	Other_writeable plugin.TValue[bool]
	Other_executable plugin.TValue[bool]
	Suid plugin.TValue[bool]
	Sgid plugin.TValue[bool]
	Sticky plugin.TValue[bool]
	IsDirectory plugin.TValue[bool]
	IsFile plugin.TValue[bool]
	IsSymlink plugin.TValue[bool]
	String plugin.TValue[string]
}

// NewFilePermissions creates a new instance of this resource
func NewFilePermissions(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlFilePermissions{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlFilePermissions, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id, err = res.id()
	return res, err
}

func (c *mqlFilePermissions) MqlName() string {
	return "file.permissions"
}

func (c *mqlFilePermissions) MqlID() string {
	return c._id
}

func (c *mqlFilePermissions) GetMode() *plugin.TValue[int64] {
	return &c.Mode
}

func (c *mqlFilePermissions) GetUser_readable() *plugin.TValue[bool] {
	return &c.User_readable
}

func (c *mqlFilePermissions) GetUser_writeable() *plugin.TValue[bool] {
	return &c.User_writeable
}

func (c *mqlFilePermissions) GetUser_executable() *plugin.TValue[bool] {
	return &c.User_executable
}

func (c *mqlFilePermissions) GetGroup_readable() *plugin.TValue[bool] {
	return &c.Group_readable
}

func (c *mqlFilePermissions) GetGroup_writeable() *plugin.TValue[bool] {
	return &c.Group_writeable
}

func (c *mqlFilePermissions) GetGroup_executable() *plugin.TValue[bool] {
	return &c.Group_executable
}

func (c *mqlFilePermissions) GetOther_readable() *plugin.TValue[bool] {
	return &c.Other_readable
}

func (c *mqlFilePermissions) GetOther_writeable() *plugin.TValue[bool] {
	return &c.Other_writeable
}

func (c *mqlFilePermissions) GetOther_executable() *plugin.TValue[bool] {
	return &c.Other_executable
}

func (c *mqlFilePermissions) GetSuid() *plugin.TValue[bool] {
	return &c.Suid
}

func (c *mqlFilePermissions) GetSgid() *plugin.TValue[bool] {
	return &c.Sgid
}

func (c *mqlFilePermissions) GetSticky() *plugin.TValue[bool] {
	return &c.Sticky
}

func (c *mqlFilePermissions) GetIsDirectory() *plugin.TValue[bool] {
	return &c.IsDirectory
}

func (c *mqlFilePermissions) GetIsFile() *plugin.TValue[bool] {
	return &c.IsFile
}

func (c *mqlFilePermissions) GetIsSymlink() *plugin.TValue[bool] {
	return &c.IsSymlink
}

func (c *mqlFilePermissions) GetString() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.String, func() (string, error) {
		return c.string()
	})
}

// mqlUser for the user resource
type mqlUser struct {
	MqlRuntime *plugin.Runtime
	_id string
	// optional: if you define mqlUserInternal it will be used here

	Uid plugin.TValue[int64]
	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Home plugin.TValue[string]
	Shell plugin.TValue[string]
	Enabled plugin.TValue[bool]
	Group plugin.TValue[*mqlGroup]
}

// NewUser creates a new instance of this resource
func NewUser(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlUser{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlUser, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id, err = res.id()
	return res, err
}

func (c *mqlUser) MqlName() string {
	return "user"
}

func (c *mqlUser) MqlID() string {
	return c._id
}

func (c *mqlUser) GetUid() *plugin.TValue[int64] {
	return &c.Uid
}

func (c *mqlUser) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlUser) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlUser) GetHome() *plugin.TValue[string] {
	return &c.Home
}

func (c *mqlUser) GetShell() *plugin.TValue[string] {
	return &c.Shell
}

func (c *mqlUser) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlUser) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		vargGid := c.GetGid()
		if vargGid.Error != nil {
			return nil, vargGid.Error
		}
		return c.group(vargGid.Data)
	})
}

// mqlUsers for the users resource
type mqlUsers struct {
	MqlRuntime *plugin.Runtime
	_id string
	mqlUsersInternal

	List plugin.TValue[[]interface{}]
}

// NewUsers creates a new instance of this resource
func NewUsers(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlUsers{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlUsers, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id = "" // to override implement: id() (string, error)
	return res, err
}

func (c *mqlUsers) MqlName() string {
	return "users"
}

func (c *mqlUsers) MqlID() string {
	return c._id
}

func (c *mqlUsers) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		return c.list()
	})
}

// mqlGroup for the group resource
type mqlGroup struct {
	MqlRuntime *plugin.Runtime
	_id string
	mqlGroupInternal

	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Members plugin.TValue[[]interface{}]
}

// NewGroup creates a new instance of this resource
func NewGroup(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlGroup{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlGroup, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id, err = res.id()
	return res, err
}

func (c *mqlGroup) MqlName() string {
	return "group"
}

func (c *mqlGroup) MqlID() string {
	return c._id
}

func (c *mqlGroup) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlGroup) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGroup) GetMembers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Members, func() ([]interface{}, error) {
		return c.members()
	})
}

// mqlGroups for the groups resource
type mqlGroups struct {
	MqlRuntime *plugin.Runtime
	_id string
	mqlGroupsInternal

	List plugin.TValue[[]interface{}]
}

// NewGroups creates a new instance of this resource
func NewGroups(runtime *plugin.Runtime, args map[string]interface{}) (plugin.Resource, error) {
	res := &mqlGroups{
		MqlRuntime: runtime,
	}

	var err error
	// to override args, implement: init(args map[string]interface{}) (map[string]interface{}, *mqlGroups, error)

	for k, v := range args {
		if err = SetData(res, k, v); err != nil {
			return res, err
		}
	}

	res._id = "" // to override implement: id() (string, error)
	return res, err
}

func (c *mqlGroups) MqlName() string {
	return "groups"
}

func (c *mqlGroups) MqlID() string {
	return c._id
}

func (c *mqlGroups) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		return c.list()
	})
}
