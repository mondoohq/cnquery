// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/llx"
	"go.mondoo.com/cnquery/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"asset": {
			// to override args, implement: initAsset(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAsset,
		},
		"asset.eol": {
			Init: initAssetEol,
			Create: createAssetEol,
		},
		"mondoo.eol": {
			// to override args, implement: initMondooEol(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMondooEol,
		},
		"platform.eol": {
			Init: initPlatformEol,
			Create: createPlatformEol,
		},
		"platform.advisories": {
			// to override args, implement: initPlatformAdvisories(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPlatformAdvisories,
		},
		"platform.cves": {
			// to override args, implement: initPlatformCves(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPlatformCves,
		},
		"audit.cvss": {
			// to override args, implement: initAuditCvss(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuditCvss,
		},
		"audit.advisory": {
			// to override args, implement: initAuditAdvisory(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuditAdvisory,
		},
		"audit.cve": {
			// to override args, implement: initAuditCve(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuditCve,
		},
		"machine": {
			// to override args, implement: initMachine(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMachine,
		},
		"machine.bios": {
			// to override args, implement: initMachineBios(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMachineBios,
		},
		"machine.system": {
			// to override args, implement: initMachineSystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMachineSystem,
		},
		"machine.baseboard": {
			// to override args, implement: initMachineBaseboard(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMachineBaseboard,
		},
		"machine.chassis": {
			// to override args, implement: initMachineChassis(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMachineChassis,
		},
		"os": {
			// to override args, implement: initOs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOs,
		},
		"os.update": {
			// to override args, implement: initOsUpdate(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOsUpdate,
		},
		"os.base": {
			// to override args, implement: initOsBase(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOsBase,
		},
		"os.unix": {
			// to override args, implement: initOsUnix(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOsUnix,
		},
		"os.linux": {
			// to override args, implement: initOsLinux(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOsLinux,
		},
		"os.rootCertificates": {
			Init: initOsRootCertificates,
			Create: createOsRootCertificates,
		},
		"command": {
			// to override args, implement: initCommand(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createCommand,
		},
		"powershell": {
			// to override args, implement: initPowershell(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPowershell,
		},
		"file": {
			// to override args, implement: initFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFile,
		},
		"file.permissions": {
			// to override args, implement: initFilePermissions(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFilePermissions,
		},
		"files": {
			// to override args, implement: initFiles(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFiles,
		},
		"files.find": {
			Init: initFilesFind,
			Create: createFilesFind,
		},
		"parse.ini": {
			Init: initParseIni,
			Create: createParseIni,
		},
		"parse.json": {
			Init: initParseJson,
			Create: createParseJson,
		},
		"parse.plist": {
			Init: initParsePlist,
			Create: createParsePlist,
		},
		"parse.yaml": {
			Init: initParseYaml,
			Create: createParseYaml,
		},
		"parse.certificates": {
			Init: initParseCertificates,
			Create: createParseCertificates,
		},
		"parse.openpgp": {
			Init: initParseOpenpgp,
			Create: createParseOpenpgp,
		},
		"user": {
			Init: initUser,
			Create: createUser,
		},
		"privatekey": {
			Init: initPrivatekey,
			Create: createPrivatekey,
		},
		"users": {
			// to override args, implement: initUsers(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createUsers,
		},
		"authorizedkeys": {
			Init: initAuthorizedkeys,
			Create: createAuthorizedkeys,
		},
		"authorizedkeys.entry": {
			// to override args, implement: initAuthorizedkeysEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuthorizedkeysEntry,
		},
		"group": {
			// to override args, implement: initGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGroup,
		},
		"groups": {
			// to override args, implement: initGroups(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGroups,
		},
		"package": {
			Init: initPackage,
			Create: createPackage,
		},
		"packages": {
			// to override args, implement: initPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPackages,
		},
		"pam.conf": {
			Init: initPamConf,
			Create: createPamConf,
		},
		"pam.conf.serviceEntry": {
			// to override args, implement: initPamConfServiceEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPamConfServiceEntry,
		},
		"sshd": {
			// to override args, implement: initSshd(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createSshd,
		},
		"sshd.config": {
			Init: initSshdConfig,
			Create: createSshdConfig,
		},
		"service": {
			Init: initService,
			Create: createService,
		},
		"services": {
			// to override args, implement: initServices(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createServices,
		},
		"kernel": {
			Init: initKernel,
			Create: createKernel,
		},
		"kernel.module": {
			Init: initKernelModule,
			Create: createKernelModule,
		},
		"docker": {
			// to override args, implement: initDocker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDocker,
		},
		"docker.image": {
			// to override args, implement: initDockerImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDockerImage,
		},
		"docker.container": {
			// to override args, implement: initDockerContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDockerContainer,
		},
		"iptables": {
			// to override args, implement: initIptables(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createIptables,
		},
		"ip6tables": {
			// to override args, implement: initIp6tables(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createIp6tables,
		},
		"iptables.entry": {
			// to override args, implement: initIptablesEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createIptablesEntry,
		},
		"process": {
			Init: initProcess,
			Create: createProcess,
		},
		"processes": {
			// to override args, implement: initProcesses(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createProcesses,
		},
		"port": {
			// to override args, implement: initPort(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPort,
		},
		"ports": {
			// to override args, implement: initPorts(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPorts,
		},
		"auditpol": {
			// to override args, implement: initAuditpol(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuditpol,
		},
		"auditpol.entry": {
			// to override args, implement: initAuditpolEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuditpolEntry,
		},
		"secpol": {
			// to override args, implement: initSecpol(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createSecpol,
		},
		"ntp.conf": {
			Init: initNtpConf,
			Create: createNtpConf,
		},
		"rsyslog.conf": {
			// to override args, implement: initRsyslogConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createRsyslogConf,
		},
		"logindefs": {
			Init: initLogindefs,
			Create: createLogindefs,
		},
		"lsblk": {
			// to override args, implement: initLsblk(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createLsblk,
		},
		"lsblk.entry": {
			// to override args, implement: initLsblkEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createLsblkEntry,
		},
		"mount": {
			// to override args, implement: initMount(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createMount,
		},
		"mount.point": {
			Init: initMountPoint,
			Create: createMountPoint,
		},
		"shadow": {
			// to override args, implement: initShadow(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createShadow,
		},
		"shadow.entry": {
			// to override args, implement: initShadowEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createShadowEntry,
		},
		"yum": {
			// to override args, implement: initYum(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createYum,
		},
		"yum.repo": {
			Init: initYumRepo,
			Create: createYumRepo,
		},
		"registrykey": {
			// to override args, implement: initRegistrykey(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createRegistrykey,
		},
		"registrykey.property": {
			// to override args, implement: initRegistrykeyProperty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createRegistrykeyProperty,
		},
		"container.image": {
			Init: initContainerImage,
			Create: createContainerImage,
		},
		"container.repository": {
			// to override args, implement: initContainerRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createContainerRepository,
		},
		"kubelet": {
			Init: initKubelet,
			Create: createKubelet,
		},
		"python": {
			Init: initPython,
			Create: createPython,
		},
		"python.package": {
			Init: initPythonPackage,
			Create: createPythonPackage,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources[id]; ok {
				return x, nil
			}
			runtime.Resources[id] = res
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"asset.vulnerabilityReport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAsset).GetVulnerabilityReport()).ToDataRes(types.Dict)
	},
	"asset.eol.docsUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAssetEol).GetDocsUrl()).ToDataRes(types.String)
	},
	"asset.eol.productUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAssetEol).GetProductUrl()).ToDataRes(types.String)
	},
	"asset.eol.date": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAssetEol).GetDate()).ToDataRes(types.Time)
	},
	"mondoo.eol.product": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMondooEol).GetProduct()).ToDataRes(types.String)
	},
	"mondoo.eol.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMondooEol).GetVersion()).ToDataRes(types.String)
	},
	"mondoo.eol.date": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMondooEol).GetDate()).ToDataRes(types.Time)
	},
	"platform.eol.docsUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformEol).GetDocsUrl()).ToDataRes(types.String)
	},
	"platform.eol.productUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformEol).GetProductUrl()).ToDataRes(types.String)
	},
	"platform.eol.date": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformEol).GetDate()).ToDataRes(types.Time)
	},
	"platform.advisories.cvss": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformAdvisories).GetCvss()).ToDataRes(types.Resource("audit.cvss"))
	},
	"platform.advisories.stats": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformAdvisories).GetStats()).ToDataRes(types.Dict)
	},
	"platform.advisories.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformAdvisories).GetList()).ToDataRes(types.Array(types.Resource("audit.advisory")))
	},
	"platform.cves.cvss": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformCves).GetCvss()).ToDataRes(types.Resource("audit.cvss"))
	},
	"platform.cves.stats": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformCves).GetStats()).ToDataRes(types.Dict)
	},
	"platform.cves.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPlatformCves).GetList()).ToDataRes(types.Array(types.Resource("audit.cve")))
	},
	"audit.cvss.score": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCvss).GetScore()).ToDataRes(types.Float)
	},
	"audit.cvss.vector": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCvss).GetVector()).ToDataRes(types.String)
	},
	"audit.advisory.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetId()).ToDataRes(types.String)
	},
	"audit.advisory.mrn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetMrn()).ToDataRes(types.String)
	},
	"audit.advisory.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetTitle()).ToDataRes(types.String)
	},
	"audit.advisory.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetDescription()).ToDataRes(types.String)
	},
	"audit.advisory.published": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetPublished()).ToDataRes(types.Time)
	},
	"audit.advisory.modified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetModified()).ToDataRes(types.Time)
	},
	"audit.advisory.worstScore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditAdvisory).GetWorstScore()).ToDataRes(types.Resource("audit.cvss"))
	},
	"audit.cve.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetId()).ToDataRes(types.String)
	},
	"audit.cve.mrn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetMrn()).ToDataRes(types.String)
	},
	"audit.cve.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetState()).ToDataRes(types.String)
	},
	"audit.cve.summary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetSummary()).ToDataRes(types.String)
	},
	"audit.cve.unscored": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetUnscored()).ToDataRes(types.Bool)
	},
	"audit.cve.published": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetPublished()).ToDataRes(types.Time)
	},
	"audit.cve.modified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetModified()).ToDataRes(types.Time)
	},
	"audit.cve.worstScore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditCve).GetWorstScore()).ToDataRes(types.Resource("audit.cvss"))
	},
	"machine.bios.vendor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBios).GetVendor()).ToDataRes(types.String)
	},
	"machine.bios.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBios).GetVersion()).ToDataRes(types.String)
	},
	"machine.bios.releaseDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBios).GetReleaseDate()).ToDataRes(types.String)
	},
	"machine.system.manufacturer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetManufacturer()).ToDataRes(types.String)
	},
	"machine.system.product": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetProduct()).ToDataRes(types.String)
	},
	"machine.system.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetVersion()).ToDataRes(types.String)
	},
	"machine.system.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetSerial()).ToDataRes(types.String)
	},
	"machine.system.uuid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetUuid()).ToDataRes(types.String)
	},
	"machine.system.sku": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetSku()).ToDataRes(types.String)
	},
	"machine.system.family": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineSystem).GetFamily()).ToDataRes(types.String)
	},
	"machine.baseboard.manufacturer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBaseboard).GetManufacturer()).ToDataRes(types.String)
	},
	"machine.baseboard.product": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBaseboard).GetProduct()).ToDataRes(types.String)
	},
	"machine.baseboard.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBaseboard).GetVersion()).ToDataRes(types.String)
	},
	"machine.baseboard.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBaseboard).GetSerial()).ToDataRes(types.String)
	},
	"machine.baseboard.assetTag": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineBaseboard).GetAssetTag()).ToDataRes(types.String)
	},
	"machine.chassis.manufacturer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineChassis).GetManufacturer()).ToDataRes(types.String)
	},
	"machine.chassis.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineChassis).GetVersion()).ToDataRes(types.String)
	},
	"machine.chassis.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineChassis).GetSerial()).ToDataRes(types.String)
	},
	"machine.chassis.assetTag": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMachineChassis).GetAssetTag()).ToDataRes(types.String)
	},
	"os.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetName()).ToDataRes(types.String)
	},
	"os.env": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetEnv()).ToDataRes(types.Map(types.String, types.String))
	},
	"os.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetPath()).ToDataRes(types.Array(types.String))
	},
	"os.uptime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetUptime()).ToDataRes(types.Time)
	},
	"os.updates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetUpdates()).ToDataRes(types.Array(types.Resource("os.update")))
	},
	"os.rebootpending": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetRebootpending()).ToDataRes(types.Bool)
	},
	"os.hostname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetHostname()).ToDataRes(types.String)
	},
	"os.machineid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOs).GetMachineid()).ToDataRes(types.String)
	},
	"os.update.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUpdate).GetName()).ToDataRes(types.String)
	},
	"os.update.category": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUpdate).GetCategory()).ToDataRes(types.String)
	},
	"os.update.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUpdate).GetSeverity()).ToDataRes(types.String)
	},
	"os.update.restart": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUpdate).GetRestart()).ToDataRes(types.Bool)
	},
	"os.update.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUpdate).GetFormat()).ToDataRes(types.String)
	},
	"os.base.machine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetMachine()).ToDataRes(types.Resource("machine"))
	},
	"os.base.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetName()).ToDataRes(types.String)
	},
	"os.base.env": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetEnv()).ToDataRes(types.Map(types.String, types.String))
	},
	"os.base.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetPath()).ToDataRes(types.Array(types.String))
	},
	"os.base.uptime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetUptime()).ToDataRes(types.Time)
	},
	"os.base.updates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetUpdates()).ToDataRes(types.Array(types.Resource("os.update")))
	},
	"os.base.rebootpending": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetRebootpending()).ToDataRes(types.Bool)
	},
	"os.base.hostname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetHostname()).ToDataRes(types.String)
	},
	"os.base.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetGroups()).ToDataRes(types.Resource("groups"))
	},
	"os.base.users": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsBase).GetUsers()).ToDataRes(types.Resource("users"))
	},
	"os.unix.base": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsUnix).GetBase()).ToDataRes(types.Resource("os.base"))
	},
	"os.linux.unix": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsLinux).GetUnix()).ToDataRes(types.Resource("os.unix"))
	},
	"os.linux.iptables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsLinux).GetIptables()).ToDataRes(types.Resource("iptables"))
	},
	"os.linux.ip6tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsLinux).GetIp6tables()).ToDataRes(types.Resource("ip6tables"))
	},
	"os.rootCertificates.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsRootCertificates).GetFiles()).ToDataRes(types.Array(types.Resource("file")))
	},
	"os.rootCertificates.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsRootCertificates).GetContent()).ToDataRes(types.Array(types.String))
	},
	"os.rootCertificates.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOsRootCertificates).GetList()).ToDataRes(types.Array(types.Resource("certificate")))
	},
	"command.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetCommand()).ToDataRes(types.String)
	},
	"command.stdout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStdout()).ToDataRes(types.String)
	},
	"command.stderr": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStderr()).ToDataRes(types.String)
	},
	"command.exitcode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetExitcode()).ToDataRes(types.Int)
	},
	"powershell.script": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPowershell).GetScript()).ToDataRes(types.String)
	},
	"powershell.stdout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPowershell).GetStdout()).ToDataRes(types.String)
	},
	"powershell.stderr": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPowershell).GetStderr()).ToDataRes(types.String)
	},
	"powershell.exitcode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPowershell).GetExitcode()).ToDataRes(types.Int)
	},
	"file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPath()).ToDataRes(types.String)
	},
	"file.basename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetBasename()).ToDataRes(types.String)
	},
	"file.dirname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetDirname()).ToDataRes(types.String)
	},
	"file.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetContent()).ToDataRes(types.String)
	},
	"file.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetExists()).ToDataRes(types.Bool)
	},
	"file.permissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPermissions()).ToDataRes(types.Resource("file.permissions"))
	},
	"file.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetSize()).ToDataRes(types.Int)
	},
	"file.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetUser()).ToDataRes(types.Resource("user"))
	},
	"file.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"file.empty": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetEmpty()).ToDataRes(types.Bool)
	},
	"file.permissions.mode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetMode()).ToDataRes(types.Int)
	},
	"file.permissions.user_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.suid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSuid()).ToDataRes(types.Bool)
	},
	"file.permissions.sgid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSgid()).ToDataRes(types.Bool)
	},
	"file.permissions.sticky": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSticky()).ToDataRes(types.Bool)
	},
	"file.permissions.isDirectory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsDirectory()).ToDataRes(types.Bool)
	},
	"file.permissions.isFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsFile()).ToDataRes(types.Bool)
	},
	"file.permissions.isSymlink": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsSymlink()).ToDataRes(types.Bool)
	},
	"file.permissions.string": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetString()).ToDataRes(types.String)
	},
	"files.find.from": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetFrom()).ToDataRes(types.String)
	},
	"files.find.xdev": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetXdev()).ToDataRes(types.Bool)
	},
	"files.find.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetType()).ToDataRes(types.String)
	},
	"files.find.regex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetRegex()).ToDataRes(types.String)
	},
	"files.find.permissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetPermissions()).ToDataRes(types.Int)
	},
	"files.find.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetName()).ToDataRes(types.String)
	},
	"files.find.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilesFind).GetList()).ToDataRes(types.Array(types.Resource("file")))
	},
	"parse.ini.delimiter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseIni).GetDelimiter()).ToDataRes(types.String)
	},
	"parse.ini.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseIni).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.ini.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseIni).GetContent()).ToDataRes(types.String)
	},
	"parse.ini.sections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseIni).GetSections()).ToDataRes(types.Map(types.String, types.Map(types.String, types.String)))
	},
	"parse.ini.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseIni).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"parse.json.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseJson).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.json.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseJson).GetContent()).ToDataRes(types.String)
	},
	"parse.json.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseJson).GetParams()).ToDataRes(types.Dict)
	},
	"parse.plist.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParsePlist).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.plist.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParsePlist).GetContent()).ToDataRes(types.String)
	},
	"parse.plist.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParsePlist).GetParams()).ToDataRes(types.Dict)
	},
	"parse.yaml.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseYaml).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.yaml.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseYaml).GetContent()).ToDataRes(types.String)
	},
	"parse.yaml.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseYaml).GetParams()).ToDataRes(types.Dict)
	},
	"parse.certificates.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseCertificates).GetPath()).ToDataRes(types.String)
	},
	"parse.certificates.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseCertificates).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.certificates.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseCertificates).GetContent()).ToDataRes(types.String)
	},
	"parse.certificates.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseCertificates).GetList()).ToDataRes(types.Array(types.Resource("certificate")))
	},
	"parse.openpgp.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseOpenpgp).GetPath()).ToDataRes(types.String)
	},
	"parse.openpgp.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseOpenpgp).GetFile()).ToDataRes(types.Resource("file"))
	},
	"parse.openpgp.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseOpenpgp).GetContent()).ToDataRes(types.String)
	},
	"parse.openpgp.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlParseOpenpgp).GetList()).ToDataRes(types.Array(types.Resource("openpgp.entity")))
	},
	"user.uid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetUid()).ToDataRes(types.Int)
	},
	"user.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGid()).ToDataRes(types.Int)
	},
	"user.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetSid()).ToDataRes(types.String)
	},
	"user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetName()).ToDataRes(types.String)
	},
	"user.home": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetHome()).ToDataRes(types.String)
	},
	"user.shell": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetShell()).ToDataRes(types.String)
	},
	"user.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetEnabled()).ToDataRes(types.Bool)
	},
	"user.authorizedkeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetAuthorizedkeys()).ToDataRes(types.Resource("authorizedkeys"))
	},
	"user.sshkeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetSshkeys()).ToDataRes(types.Array(types.Resource("privatekey")))
	},
	"user.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"privatekey.pem": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPrivatekey).GetPem()).ToDataRes(types.String)
	},
	"privatekey.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPrivatekey).GetPath()).ToDataRes(types.String)
	},
	"privatekey.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPrivatekey).GetFile()).ToDataRes(types.Resource("file"))
	},
	"privatekey.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPrivatekey).GetEncrypted()).ToDataRes(types.Bool)
	},
	"users.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUsers).GetList()).ToDataRes(types.Array(types.Resource("user")))
	},
	"authorizedkeys.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetPath()).ToDataRes(types.String)
	},
	"authorizedkeys.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetFile()).ToDataRes(types.Resource("file"))
	},
	"authorizedkeys.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetContent()).ToDataRes(types.String)
	},
	"authorizedkeys.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetList()).ToDataRes(types.Array(types.Resource("authorizedkeys.entry")))
	},
	"authorizedkeys.entry.line": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetLine()).ToDataRes(types.Int)
	},
	"authorizedkeys.entry.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetType()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetKey()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetLabel()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetOptions()).ToDataRes(types.Array(types.String))
	},
	"authorizedkeys.entry.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetFile()).ToDataRes(types.Resource("file"))
	},
	"group.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetGid()).ToDataRes(types.Int)
	},
	"group.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetSid()).ToDataRes(types.String)
	},
	"group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetName()).ToDataRes(types.String)
	},
	"group.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetMembers()).ToDataRes(types.Array(types.Resource("user")))
	},
	"groups.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroups).GetList()).ToDataRes(types.Array(types.Resource("group")))
	},
	"package.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetName()).ToDataRes(types.String)
	},
	"package.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetVersion()).ToDataRes(types.String)
	},
	"package.arch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetArch()).ToDataRes(types.String)
	},
	"package.epoch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetEpoch()).ToDataRes(types.String)
	},
	"package.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetFormat()).ToDataRes(types.String)
	},
	"package.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetStatus()).ToDataRes(types.String)
	},
	"package.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetDescription()).ToDataRes(types.String)
	},
	"package.origin": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetOrigin()).ToDataRes(types.String)
	},
	"package.available": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetAvailable()).ToDataRes(types.String)
	},
	"package.installed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetInstalled()).ToDataRes(types.Bool)
	},
	"package.outdated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetOutdated()).ToDataRes(types.Bool)
	},
	"packages.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackages).GetList()).ToDataRes(types.Array(types.Resource("package")))
	},
	"pam.conf.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConf).GetFiles()).ToDataRes(types.Array(types.Resource("file")))
	},
	"pam.conf.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConf).GetContent()).ToDataRes(types.String)
	},
	"pam.conf.services": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConf).GetServices()).ToDataRes(types.Map(types.String, types.Array(types.String)))
	},
	"pam.conf.entries": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConf).GetEntries()).ToDataRes(types.Map(types.String, types.Array(types.Resource("pam.conf.serviceEntry"))))
	},
	"pam.conf.serviceEntry.service": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetService()).ToDataRes(types.String)
	},
	"pam.conf.serviceEntry.lineNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetLineNumber()).ToDataRes(types.Int)
	},
	"pam.conf.serviceEntry.pamType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetPamType()).ToDataRes(types.String)
	},
	"pam.conf.serviceEntry.control": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetControl()).ToDataRes(types.String)
	},
	"pam.conf.serviceEntry.module": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetModule()).ToDataRes(types.String)
	},
	"pam.conf.serviceEntry.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPamConfServiceEntry).GetOptions()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetFile()).ToDataRes(types.Resource("file"))
	},
	"sshd.config.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetFiles()).ToDataRes(types.Array(types.Resource("file")))
	},
	"sshd.config.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetContent()).ToDataRes(types.String)
	},
	"sshd.config.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"sshd.config.ciphers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetCiphers()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.macs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetMacs()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.kexs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetKexs()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.hostkeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetHostkeys()).ToDataRes(types.Array(types.String))
	},
	"service.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetName()).ToDataRes(types.String)
	},
	"service.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetDescription()).ToDataRes(types.String)
	},
	"service.installed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetInstalled()).ToDataRes(types.Bool)
	},
	"service.running": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetRunning()).ToDataRes(types.Bool)
	},
	"service.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetEnabled()).ToDataRes(types.Bool)
	},
	"service.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetType()).ToDataRes(types.String)
	},
	"service.masked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlService).GetMasked()).ToDataRes(types.Bool)
	},
	"services.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlServices).GetList()).ToDataRes(types.Array(types.Resource("service")))
	},
	"kernel.info": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernel).GetInfo()).ToDataRes(types.Dict)
	},
	"kernel.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernel).GetParameters()).ToDataRes(types.Map(types.String, types.String))
	},
	"kernel.modules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernel).GetModules()).ToDataRes(types.Array(types.Resource("kernel.module")))
	},
	"kernel.installed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernel).GetInstalled()).ToDataRes(types.Array(types.Dict))
	},
	"kernel.module.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernelModule).GetName()).ToDataRes(types.String)
	},
	"kernel.module.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernelModule).GetSize()).ToDataRes(types.String)
	},
	"kernel.module.loaded": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKernelModule).GetLoaded()).ToDataRes(types.Bool)
	},
	"docker.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDocker).GetImages()).ToDataRes(types.Array(types.Resource("docker.image")))
	},
	"docker.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDocker).GetContainers()).ToDataRes(types.Array(types.Resource("docker.container")))
	},
	"docker.image.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerImage).GetId()).ToDataRes(types.String)
	},
	"docker.image.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerImage).GetSize()).ToDataRes(types.Int)
	},
	"docker.image.virtualsize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerImage).GetVirtualsize()).ToDataRes(types.Int)
	},
	"docker.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerImage).GetTags()).ToDataRes(types.Array(types.String))
	},
	"docker.image.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerImage).GetLabels()).ToDataRes(types.Map(types.String, types.String))
	},
	"docker.container.os": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetOs()).ToDataRes(types.Resource("os.linux"))
	},
	"docker.container.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetId()).ToDataRes(types.String)
	},
	"docker.container.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetCommand()).ToDataRes(types.String)
	},
	"docker.container.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetImage()).ToDataRes(types.String)
	},
	"docker.container.imageid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetImageid()).ToDataRes(types.String)
	},
	"docker.container.names": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetNames()).ToDataRes(types.Array(types.String))
	},
	"docker.container.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetState()).ToDataRes(types.String)
	},
	"docker.container.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetStatus()).ToDataRes(types.String)
	},
	"docker.container.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDockerContainer).GetLabels()).ToDataRes(types.Map(types.String, types.String))
	},
	"iptables.input": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptables).GetInput()).ToDataRes(types.Array(types.Resource("iptables.entry")))
	},
	"iptables.output": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptables).GetOutput()).ToDataRes(types.Array(types.Resource("iptables.entry")))
	},
	"ip6tables.input": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIp6tables).GetInput()).ToDataRes(types.Array(types.Resource("iptables.entry")))
	},
	"ip6tables.output": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIp6tables).GetOutput()).ToDataRes(types.Array(types.Resource("iptables.entry")))
	},
	"iptables.entry.lineNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetLineNumber()).ToDataRes(types.Int)
	},
	"iptables.entry.packets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetPackets()).ToDataRes(types.Int)
	},
	"iptables.entry.bytes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetBytes()).ToDataRes(types.Int)
	},
	"iptables.entry.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetTarget()).ToDataRes(types.String)
	},
	"iptables.entry.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetProtocol()).ToDataRes(types.String)
	},
	"iptables.entry.opt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetOpt()).ToDataRes(types.String)
	},
	"iptables.entry.in": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetIn()).ToDataRes(types.String)
	},
	"iptables.entry.out": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetOut()).ToDataRes(types.String)
	},
	"iptables.entry.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetSource()).ToDataRes(types.String)
	},
	"iptables.entry.destination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetDestination()).ToDataRes(types.String)
	},
	"iptables.entry.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetOptions()).ToDataRes(types.String)
	},
	"iptables.entry.chain": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIptablesEntry).GetChain()).ToDataRes(types.String)
	},
	"process.pid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcess).GetPid()).ToDataRes(types.Int)
	},
	"process.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcess).GetState()).ToDataRes(types.String)
	},
	"process.executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcess).GetExecutable()).ToDataRes(types.String)
	},
	"process.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcess).GetCommand()).ToDataRes(types.String)
	},
	"process.flags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcess).GetFlags()).ToDataRes(types.Map(types.String, types.String))
	},
	"processes.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlProcesses).GetList()).ToDataRes(types.Array(types.Resource("process")))
	},
	"port.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetProtocol()).ToDataRes(types.String)
	},
	"port.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetPort()).ToDataRes(types.Int)
	},
	"port.address": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetAddress()).ToDataRes(types.String)
	},
	"port.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetUser()).ToDataRes(types.Resource("user"))
	},
	"port.process": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetProcess()).ToDataRes(types.Resource("process"))
	},
	"port.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetState()).ToDataRes(types.String)
	},
	"port.remoteAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetRemoteAddress()).ToDataRes(types.String)
	},
	"port.remotePort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetRemotePort()).ToDataRes(types.Int)
	},
	"port.tls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPort).GetTls()).ToDataRes(types.Resource("tls"))
	},
	"ports.listening": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPorts).GetListening()).ToDataRes(types.Array(types.Resource("port")))
	},
	"ports.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPorts).GetList()).ToDataRes(types.Array(types.Resource("port")))
	},
	"auditpol.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpol).GetList()).ToDataRes(types.Array(types.Resource("auditpol.entry")))
	},
	"auditpol.entry.machinename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetMachinename()).ToDataRes(types.String)
	},
	"auditpol.entry.policytarget": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetPolicytarget()).ToDataRes(types.String)
	},
	"auditpol.entry.subcategory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetSubcategory()).ToDataRes(types.String)
	},
	"auditpol.entry.subcategoryguid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetSubcategoryguid()).ToDataRes(types.String)
	},
	"auditpol.entry.inclusionsetting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetInclusionsetting()).ToDataRes(types.String)
	},
	"auditpol.entry.exclusionsetting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuditpolEntry).GetExclusionsetting()).ToDataRes(types.String)
	},
	"secpol.systemaccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSecpol).GetSystemaccess()).ToDataRes(types.Map(types.String, types.String))
	},
	"secpol.eventaudit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSecpol).GetEventaudit()).ToDataRes(types.Map(types.String, types.String))
	},
	"secpol.registryvalues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSecpol).GetRegistryvalues()).ToDataRes(types.Map(types.String, types.String))
	},
	"secpol.privilegerights": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSecpol).GetPrivilegerights()).ToDataRes(types.Map(types.String, types.Array(types.String)))
	},
	"ntp.conf.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetFile()).ToDataRes(types.Resource("file"))
	},
	"ntp.conf.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetContent()).ToDataRes(types.String)
	},
	"ntp.conf.settings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetSettings()).ToDataRes(types.Array(types.String))
	},
	"ntp.conf.servers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetServers()).ToDataRes(types.Array(types.String))
	},
	"ntp.conf.restrict": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetRestrict()).ToDataRes(types.Array(types.String))
	},
	"ntp.conf.fudge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlNtpConf).GetFudge()).ToDataRes(types.Array(types.String))
	},
	"rsyslog.conf.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRsyslogConf).GetPath()).ToDataRes(types.String)
	},
	"rsyslog.conf.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRsyslogConf).GetFiles()).ToDataRes(types.Array(types.Resource("file")))
	},
	"rsyslog.conf.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRsyslogConf).GetContent()).ToDataRes(types.String)
	},
	"rsyslog.conf.settings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRsyslogConf).GetSettings()).ToDataRes(types.Array(types.String))
	},
	"logindefs.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLogindefs).GetFile()).ToDataRes(types.Resource("file"))
	},
	"logindefs.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLogindefs).GetContent()).ToDataRes(types.String)
	},
	"logindefs.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLogindefs).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"lsblk.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblk).GetList()).ToDataRes(types.Array(types.Resource("lsblk.entry")))
	},
	"lsblk.entry.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblkEntry).GetName()).ToDataRes(types.String)
	},
	"lsblk.entry.fstype": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblkEntry).GetFstype()).ToDataRes(types.String)
	},
	"lsblk.entry.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblkEntry).GetLabel()).ToDataRes(types.String)
	},
	"lsblk.entry.uuid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblkEntry).GetUuid()).ToDataRes(types.String)
	},
	"lsblk.entry.mountpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlLsblkEntry).GetMountpoints()).ToDataRes(types.Array(types.String))
	},
	"mount.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMount).GetList()).ToDataRes(types.Array(types.Resource("mount.point")))
	},
	"mount.point.device": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMountPoint).GetDevice()).ToDataRes(types.String)
	},
	"mount.point.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMountPoint).GetPath()).ToDataRes(types.String)
	},
	"mount.point.fstype": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMountPoint).GetFstype()).ToDataRes(types.String)
	},
	"mount.point.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMountPoint).GetOptions()).ToDataRes(types.Map(types.String, types.String))
	},
	"mount.point.mounted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlMountPoint).GetMounted()).ToDataRes(types.Bool)
	},
	"shadow.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadow).GetList()).ToDataRes(types.Array(types.Resource("shadow.entry")))
	},
	"shadow.entry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetUser()).ToDataRes(types.String)
	},
	"shadow.entry.password": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetPassword()).ToDataRes(types.String)
	},
	"shadow.entry.lastchanged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetLastchanged()).ToDataRes(types.Time)
	},
	"shadow.entry.mindays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetMindays()).ToDataRes(types.Int)
	},
	"shadow.entry.maxdays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetMaxdays()).ToDataRes(types.Int)
	},
	"shadow.entry.warndays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetWarndays()).ToDataRes(types.Int)
	},
	"shadow.entry.inactivedays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetInactivedays()).ToDataRes(types.Int)
	},
	"shadow.entry.expirydates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetExpirydates()).ToDataRes(types.String)
	},
	"shadow.entry.reserved": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlShadowEntry).GetReserved()).ToDataRes(types.String)
	},
	"yum.vars": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYum).GetVars()).ToDataRes(types.Map(types.String, types.String))
	},
	"yum.repos": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYum).GetRepos()).ToDataRes(types.Array(types.Resource("yum.repo")))
	},
	"yum.repo.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetId()).ToDataRes(types.String)
	},
	"yum.repo.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetName()).ToDataRes(types.String)
	},
	"yum.repo.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetStatus()).ToDataRes(types.String)
	},
	"yum.repo.baseurl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetBaseurl()).ToDataRes(types.Array(types.String))
	},
	"yum.repo.expire": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetExpire()).ToDataRes(types.String)
	},
	"yum.repo.filename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetFilename()).ToDataRes(types.String)
	},
	"yum.repo.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetFile()).ToDataRes(types.Resource("file"))
	},
	"yum.repo.revision": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetRevision()).ToDataRes(types.String)
	},
	"yum.repo.pkgs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetPkgs()).ToDataRes(types.String)
	},
	"yum.repo.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetSize()).ToDataRes(types.String)
	},
	"yum.repo.mirrors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetMirrors()).ToDataRes(types.String)
	},
	"yum.repo.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlYumRepo).GetEnabled()).ToDataRes(types.Bool)
	},
	"registrykey.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykey).GetPath()).ToDataRes(types.String)
	},
	"registrykey.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykey).GetExists()).ToDataRes(types.Bool)
	},
	"registrykey.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykey).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"registrykey.children": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykey).GetChildren()).ToDataRes(types.Array(types.String))
	},
	"registrykey.property.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykeyProperty).GetPath()).ToDataRes(types.String)
	},
	"registrykey.property.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykeyProperty).GetName()).ToDataRes(types.String)
	},
	"registrykey.property.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykeyProperty).GetExists()).ToDataRes(types.Bool)
	},
	"registrykey.property.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlRegistrykeyProperty).GetValue()).ToDataRes(types.String)
	},
	"container.image.reference": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerImage).GetReference()).ToDataRes(types.String)
	},
	"container.image.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerImage).GetName()).ToDataRes(types.String)
	},
	"container.image.identifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerImage).GetIdentifier()).ToDataRes(types.String)
	},
	"container.image.identifierType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerImage).GetIdentifierType()).ToDataRes(types.String)
	},
	"container.image.repository": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerImage).GetRepository()).ToDataRes(types.Resource("container.repository"))
	},
	"container.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerRepository).GetName()).ToDataRes(types.String)
	},
	"container.repository.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerRepository).GetScheme()).ToDataRes(types.String)
	},
	"container.repository.fullName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerRepository).GetFullName()).ToDataRes(types.String)
	},
	"container.repository.registry": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlContainerRepository).GetRegistry()).ToDataRes(types.String)
	},
	"kubelet.configFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKubelet).GetConfigFile()).ToDataRes(types.Resource("file"))
	},
	"kubelet.process": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKubelet).GetProcess()).ToDataRes(types.Resource("process"))
	},
	"kubelet.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlKubelet).GetConfiguration()).ToDataRes(types.Dict)
	},
	"python.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPython).GetPath()).ToDataRes(types.String)
	},
	"python.packages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPython).GetPackages()).ToDataRes(types.Array(types.Resource("python.package")))
	},
	"python.toplevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPython).GetToplevel()).ToDataRes(types.Array(types.Resource("python.package")))
	},
	"python.package.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetId()).ToDataRes(types.String)
	},
	"python.package.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetName()).ToDataRes(types.String)
	},
	"python.package.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetFile()).ToDataRes(types.Resource("file"))
	},
	"python.package.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetVersion()).ToDataRes(types.String)
	},
	"python.package.license": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetLicense()).ToDataRes(types.String)
	},
	"python.package.author": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetAuthor()).ToDataRes(types.String)
	},
	"python.package.summary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetSummary()).ToDataRes(types.String)
	},
	"python.package.dependencies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPythonPackage).GetDependencies()).ToDataRes(types.Array(types.Resource("python.package")))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"asset.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAsset).__id, ok = v.Value.(string)
			return
		},
	"asset.vulnerabilityReport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAsset).VulnerabilityReport, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"asset.eol.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAssetEol).__id, ok = v.Value.(string)
			return
		},
	"asset.eol.docsUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAssetEol).DocsUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"asset.eol.productUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAssetEol).ProductUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"asset.eol.date": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAssetEol).Date, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"mondoo.eol.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMondooEol).__id, ok = v.Value.(string)
			return
		},
	"mondoo.eol.product": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMondooEol).Product, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"mondoo.eol.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMondooEol).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"mondoo.eol.date": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMondooEol).Date, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"platform.eol.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPlatformEol).__id, ok = v.Value.(string)
			return
		},
	"platform.eol.docsUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformEol).DocsUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"platform.eol.productUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformEol).ProductUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"platform.eol.date": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformEol).Date, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"platform.advisories.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPlatformAdvisories).__id, ok = v.Value.(string)
			return
		},
	"platform.advisories.cvss": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformAdvisories).Cvss, ok = plugin.RawToTValue[*mqlAuditCvss](v.Value, v.Error)
		return
	},
	"platform.advisories.stats": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformAdvisories).Stats, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"platform.advisories.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformAdvisories).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"platform.cves.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPlatformCves).__id, ok = v.Value.(string)
			return
		},
	"platform.cves.cvss": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformCves).Cvss, ok = plugin.RawToTValue[*mqlAuditCvss](v.Value, v.Error)
		return
	},
	"platform.cves.stats": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformCves).Stats, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"platform.cves.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPlatformCves).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"audit.cvss.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuditCvss).__id, ok = v.Value.(string)
			return
		},
	"audit.cvss.score": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCvss).Score, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"audit.cvss.vector": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCvss).Vector, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.advisory.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuditAdvisory).__id, ok = v.Value.(string)
			return
		},
	"audit.advisory.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.advisory.mrn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Mrn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.advisory.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.advisory.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.advisory.published": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Published, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"audit.advisory.modified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).Modified, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"audit.advisory.worstScore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditAdvisory).WorstScore, ok = plugin.RawToTValue[*mqlAuditCvss](v.Value, v.Error)
		return
	},
	"audit.cve.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuditCve).__id, ok = v.Value.(string)
			return
		},
	"audit.cve.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.cve.mrn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Mrn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.cve.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.cve.summary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Summary, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"audit.cve.unscored": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Unscored, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"audit.cve.published": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Published, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"audit.cve.modified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).Modified, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"audit.cve.worstScore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditCve).WorstScore, ok = plugin.RawToTValue[*mqlAuditCvss](v.Value, v.Error)
		return
	},
	"machine.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMachine).__id, ok = v.Value.(string)
			return
		},
	"machine.bios.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMachineBios).__id, ok = v.Value.(string)
			return
		},
	"machine.bios.vendor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBios).Vendor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.bios.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBios).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.bios.releaseDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBios).ReleaseDate, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMachineSystem).__id, ok = v.Value.(string)
			return
		},
	"machine.system.manufacturer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Manufacturer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.product": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Product, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.uuid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Uuid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.sku": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Sku, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.system.family": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineSystem).Family, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.baseboard.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMachineBaseboard).__id, ok = v.Value.(string)
			return
		},
	"machine.baseboard.manufacturer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBaseboard).Manufacturer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.baseboard.product": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBaseboard).Product, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.baseboard.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBaseboard).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.baseboard.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBaseboard).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.baseboard.assetTag": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineBaseboard).AssetTag, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.chassis.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMachineChassis).__id, ok = v.Value.(string)
			return
		},
	"machine.chassis.manufacturer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineChassis).Manufacturer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.chassis.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineChassis).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.chassis.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineChassis).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"machine.chassis.assetTag": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMachineChassis).AssetTag, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOs).__id, ok = v.Value.(string)
			return
		},
	"os.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.env": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Env, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"os.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Path, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.uptime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Uptime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"os.updates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Updates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.rebootpending": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Rebootpending, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"os.hostname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Hostname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.machineid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOs).Machineid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.update.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOsUpdate).__id, ok = v.Value.(string)
			return
		},
	"os.update.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUpdate).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.update.category": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUpdate).Category, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.update.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUpdate).Severity, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.update.restart": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUpdate).Restart, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"os.update.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUpdate).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.base.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOsBase).__id, ok = v.Value.(string)
			return
		},
	"os.base.machine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Machine, ok = plugin.RawToTValue[*mqlMachine](v.Value, v.Error)
		return
	},
	"os.base.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.base.env": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Env, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"os.base.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Path, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.base.uptime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Uptime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"os.base.updates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Updates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.base.rebootpending": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Rebootpending, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"os.base.hostname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Hostname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"os.base.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Groups, ok = plugin.RawToTValue[*mqlGroups](v.Value, v.Error)
		return
	},
	"os.base.users": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsBase).Users, ok = plugin.RawToTValue[*mqlUsers](v.Value, v.Error)
		return
	},
	"os.unix.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOsUnix).__id, ok = v.Value.(string)
			return
		},
	"os.unix.base": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsUnix).Base, ok = plugin.RawToTValue[*mqlOsBase](v.Value, v.Error)
		return
	},
	"os.linux.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOsLinux).__id, ok = v.Value.(string)
			return
		},
	"os.linux.unix": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsLinux).Unix, ok = plugin.RawToTValue[*mqlOsUnix](v.Value, v.Error)
		return
	},
	"os.linux.iptables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsLinux).Iptables, ok = plugin.RawToTValue[*mqlIptables](v.Value, v.Error)
		return
	},
	"os.linux.ip6tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsLinux).Ip6tables, ok = plugin.RawToTValue[*mqlIp6tables](v.Value, v.Error)
		return
	},
	"os.rootCertificates.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOsRootCertificates).__id, ok = v.Value.(string)
			return
		},
	"os.rootCertificates.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsRootCertificates).Files, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.rootCertificates.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsRootCertificates).Content, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"os.rootCertificates.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOsRootCertificates).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"command.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlCommand).__id, ok = v.Value.(string)
			return
		},
	"command.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Command, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.stdout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Stdout, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.stderr": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Stderr, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.exitcode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Exitcode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"powershell.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPowershell).__id, ok = v.Value.(string)
			return
		},
	"powershell.script": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPowershell).Script, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"powershell.stdout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPowershell).Stdout, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"powershell.stderr": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPowershell).Stderr, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"powershell.exitcode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPowershell).Exitcode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFile).__id, ok = v.Value.(string)
			return
		},
	"file.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.basename": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Basename, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.dirname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Dirname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Permissions, ok = plugin.RawToTValue[*mqlFilePermissions](v.Value, v.Error)
		return
	},
	"file.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).User, ok = plugin.RawToTValue[*mqlUser](v.Value, v.Error)
		return
	},
	"file.group": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Group, ok = plugin.RawToTValue[*mqlGroup](v.Value, v.Error)
		return
	},
	"file.empty": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Empty, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFilePermissions).__id, ok = v.Value.(string)
			return
		},
	"file.permissions.mode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Mode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.permissions.user_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.user_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.user_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.suid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Suid, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.sgid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Sgid, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.sticky": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Sticky, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isDirectory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsDirectory, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsFile, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isSymlink": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsSymlink, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.string": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).String, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"files.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFiles).__id, ok = v.Value.(string)
			return
		},
	"files.find.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFilesFind).__id, ok = v.Value.(string)
			return
		},
	"files.find.from": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).From, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"files.find.xdev": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).Xdev, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"files.find.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"files.find.regex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).Regex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"files.find.permissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).Permissions, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"files.find.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"files.find.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilesFind).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"parse.ini.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParseIni).__id, ok = v.Value.(string)
			return
		},
	"parse.ini.delimiter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseIni).Delimiter, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.ini.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseIni).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.ini.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseIni).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.ini.sections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseIni).Sections, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"parse.ini.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseIni).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"parse.json.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParseJson).__id, ok = v.Value.(string)
			return
		},
	"parse.json.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseJson).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.json.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseJson).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.json.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseJson).Params, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"parse.plist.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParsePlist).__id, ok = v.Value.(string)
			return
		},
	"parse.plist.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParsePlist).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.plist.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParsePlist).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.plist.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParsePlist).Params, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"parse.yaml.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParseYaml).__id, ok = v.Value.(string)
			return
		},
	"parse.yaml.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseYaml).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.yaml.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseYaml).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.yaml.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseYaml).Params, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"parse.certificates.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParseCertificates).__id, ok = v.Value.(string)
			return
		},
	"parse.certificates.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseCertificates).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.certificates.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseCertificates).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.certificates.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseCertificates).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.certificates.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseCertificates).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"parse.openpgp.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlParseOpenpgp).__id, ok = v.Value.(string)
			return
		},
	"parse.openpgp.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseOpenpgp).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.openpgp.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseOpenpgp).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"parse.openpgp.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseOpenpgp).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"parse.openpgp.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlParseOpenpgp).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlUser).__id, ok = v.Value.(string)
			return
		},
	"user.uid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Uid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"user.gid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Gid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"user.sid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Sid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.home": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Home, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.shell": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Shell, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"user.authorizedkeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Authorizedkeys, ok = plugin.RawToTValue[*mqlAuthorizedkeys](v.Value, v.Error)
		return
	},
	"user.sshkeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Sshkeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"user.group": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Group, ok = plugin.RawToTValue[*mqlGroup](v.Value, v.Error)
		return
	},
	"privatekey.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPrivatekey).__id, ok = v.Value.(string)
			return
		},
	"privatekey.pem": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPrivatekey).Pem, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"privatekey.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPrivatekey).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"privatekey.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPrivatekey).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"privatekey.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPrivatekey).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"users.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlUsers).__id, ok = v.Value.(string)
			return
		},
	"users.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUsers).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuthorizedkeys).__id, ok = v.Value.(string)
			return
		},
	"authorizedkeys.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"authorizedkeys.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuthorizedkeysEntry).__id, ok = v.Value.(string)
			return
		},
	"authorizedkeys.entry.line": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Line, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Options, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlGroup).__id, ok = v.Value.(string)
			return
		},
	"group.gid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Gid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"group.sid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Sid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"group.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Members, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"groups.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlGroups).__id, ok = v.Value.(string)
			return
		},
	"groups.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroups).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"package.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPackage).__id, ok = v.Value.(string)
			return
		},
	"package.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.arch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Arch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.epoch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Epoch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.origin": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Origin, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.available": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Available, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.installed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Installed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"package.outdated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Outdated, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"packages.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPackages).__id, ok = v.Value.(string)
			return
		},
	"packages.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackages).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pam.conf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPamConf).__id, ok = v.Value.(string)
			return
		},
	"pam.conf.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConf).Files, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pam.conf.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConf).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pam.conf.services": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConf).Services, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"pam.conf.entries": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConf).Entries, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPamConfServiceEntry).__id, ok = v.Value.(string)
			return
		},
	"pam.conf.serviceEntry.service": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).Service, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.lineNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).LineNumber, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.pamType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).PamType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.control": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).Control, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.module": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).Module, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pam.conf.serviceEntry.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPamConfServiceEntry).Options, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSshd).__id, ok = v.Value.(string)
			return
		},
	"sshd.config.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSshdConfig).__id, ok = v.Value.(string)
			return
		},
	"sshd.config.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"sshd.config.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Files, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"sshd.config.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.ciphers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Ciphers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.macs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Macs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.kexs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Kexs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.hostkeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Hostkeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"service.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlService).__id, ok = v.Value.(string)
			return
		},
	"service.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"service.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"service.installed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Installed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"service.running": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Running, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"service.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"service.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"service.masked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlService).Masked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"services.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlServices).__id, ok = v.Value.(string)
			return
		},
	"services.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlServices).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"kernel.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlKernel).__id, ok = v.Value.(string)
			return
		},
	"kernel.info": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernel).Info, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"kernel.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernel).Parameters, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"kernel.modules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernel).Modules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"kernel.installed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernel).Installed, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"kernel.module.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlKernelModule).__id, ok = v.Value.(string)
			return
		},
	"kernel.module.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernelModule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"kernel.module.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernelModule).Size, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"kernel.module.loaded": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKernelModule).Loaded, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"docker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDocker).__id, ok = v.Value.(string)
			return
		},
	"docker.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDocker).Images, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"docker.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDocker).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"docker.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDockerImage).__id, ok = v.Value.(string)
			return
		},
	"docker.image.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerImage).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.image.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerImage).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"docker.image.virtualsize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerImage).Virtualsize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"docker.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerImage).Tags, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"docker.image.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerImage).Labels, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"docker.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDockerContainer).__id, ok = v.Value.(string)
			return
		},
	"docker.container.os": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Os, ok = plugin.RawToTValue[*mqlOsLinux](v.Value, v.Error)
		return
	},
	"docker.container.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Command, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.imageid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Imageid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.names": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Names, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"docker.container.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"docker.container.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDockerContainer).Labels, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"iptables.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlIptables).__id, ok = v.Value.(string)
			return
		},
	"iptables.input": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptables).Input, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"iptables.output": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptables).Output, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ip6tables.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlIp6tables).__id, ok = v.Value.(string)
			return
		},
	"ip6tables.input": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIp6tables).Input, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ip6tables.output": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIp6tables).Output, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"iptables.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlIptablesEntry).__id, ok = v.Value.(string)
			return
		},
	"iptables.entry.lineNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).LineNumber, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"iptables.entry.packets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Packets, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"iptables.entry.bytes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Bytes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"iptables.entry.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.opt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Opt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.in": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).In, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.out": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Out, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Source, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.destination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Destination, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Options, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"iptables.entry.chain": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIptablesEntry).Chain, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"process.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlProcess).__id, ok = v.Value.(string)
			return
		},
	"process.pid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcess).Pid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"process.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcess).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"process.executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcess).Executable, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"process.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcess).Command, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"process.flags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcess).Flags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"processes.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlProcesses).__id, ok = v.Value.(string)
			return
		},
	"processes.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlProcesses).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"port.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPort).__id, ok = v.Value.(string)
			return
		},
	"port.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"port.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"port.address": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).Address, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"port.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).User, ok = plugin.RawToTValue[*mqlUser](v.Value, v.Error)
		return
	},
	"port.process": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).Process, ok = plugin.RawToTValue[*mqlProcess](v.Value, v.Error)
		return
	},
	"port.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"port.remoteAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).RemoteAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"port.remotePort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).RemotePort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"port.tls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPort).Tls, ok = plugin.RawToTValue[plugin.Resource](v.Value, v.Error)
		return
	},
	"ports.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPorts).__id, ok = v.Value.(string)
			return
		},
	"ports.listening": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPorts).Listening, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ports.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPorts).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"auditpol.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuditpol).__id, ok = v.Value.(string)
			return
		},
	"auditpol.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpol).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"auditpol.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuditpolEntry).__id, ok = v.Value.(string)
			return
		},
	"auditpol.entry.machinename": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Machinename, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"auditpol.entry.policytarget": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Policytarget, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"auditpol.entry.subcategory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Subcategory, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"auditpol.entry.subcategoryguid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Subcategoryguid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"auditpol.entry.inclusionsetting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Inclusionsetting, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"auditpol.entry.exclusionsetting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuditpolEntry).Exclusionsetting, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"secpol.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSecpol).__id, ok = v.Value.(string)
			return
		},
	"secpol.systemaccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSecpol).Systemaccess, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"secpol.eventaudit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSecpol).Eventaudit, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"secpol.registryvalues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSecpol).Registryvalues, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"secpol.privilegerights": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSecpol).Privilegerights, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"ntp.conf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlNtpConf).__id, ok = v.Value.(string)
			return
		},
	"ntp.conf.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"ntp.conf.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ntp.conf.settings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).Settings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ntp.conf.servers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).Servers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ntp.conf.restrict": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).Restrict, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ntp.conf.fudge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlNtpConf).Fudge, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"rsyslog.conf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlRsyslogConf).__id, ok = v.Value.(string)
			return
		},
	"rsyslog.conf.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRsyslogConf).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"rsyslog.conf.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRsyslogConf).Files, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"rsyslog.conf.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRsyslogConf).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"rsyslog.conf.settings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRsyslogConf).Settings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"logindefs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlLogindefs).__id, ok = v.Value.(string)
			return
		},
	"logindefs.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLogindefs).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"logindefs.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLogindefs).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"logindefs.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLogindefs).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"lsblk.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlLsblk).__id, ok = v.Value.(string)
			return
		},
	"lsblk.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblk).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"lsblk.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlLsblkEntry).__id, ok = v.Value.(string)
			return
		},
	"lsblk.entry.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblkEntry).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"lsblk.entry.fstype": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblkEntry).Fstype, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"lsblk.entry.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblkEntry).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"lsblk.entry.uuid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblkEntry).Uuid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"lsblk.entry.mountpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlLsblkEntry).Mountpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"mount.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMount).__id, ok = v.Value.(string)
			return
		},
	"mount.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMount).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"mount.point.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlMountPoint).__id, ok = v.Value.(string)
			return
		},
	"mount.point.device": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMountPoint).Device, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"mount.point.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMountPoint).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"mount.point.fstype": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMountPoint).Fstype, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"mount.point.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMountPoint).Options, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"mount.point.mounted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlMountPoint).Mounted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"shadow.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlShadow).__id, ok = v.Value.(string)
			return
		},
	"shadow.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadow).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"shadow.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlShadowEntry).__id, ok = v.Value.(string)
			return
		},
	"shadow.entry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).User, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"shadow.entry.password": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Password, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"shadow.entry.lastchanged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Lastchanged, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"shadow.entry.mindays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Mindays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"shadow.entry.maxdays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Maxdays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"shadow.entry.warndays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Warndays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"shadow.entry.inactivedays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Inactivedays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"shadow.entry.expirydates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Expirydates, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"shadow.entry.reserved": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlShadowEntry).Reserved, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlYum).__id, ok = v.Value.(string)
			return
		},
	"yum.vars": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYum).Vars, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"yum.repos": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYum).Repos, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"yum.repo.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlYumRepo).__id, ok = v.Value.(string)
			return
		},
	"yum.repo.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.baseurl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Baseurl, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"yum.repo.expire": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Expire, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.filename": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Filename, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"yum.repo.revision": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Revision, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.pkgs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Pkgs, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Size, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.mirrors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Mirrors, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"yum.repo.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlYumRepo).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"registrykey.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlRegistrykey).__id, ok = v.Value.(string)
			return
		},
	"registrykey.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykey).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"registrykey.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykey).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"registrykey.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykey).Properties, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"registrykey.children": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykey).Children, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"registrykey.property.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlRegistrykeyProperty).__id, ok = v.Value.(string)
			return
		},
	"registrykey.property.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykeyProperty).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"registrykey.property.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykeyProperty).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"registrykey.property.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykeyProperty).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"registrykey.property.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlRegistrykeyProperty).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlContainerImage).__id, ok = v.Value.(string)
			return
		},
	"container.image.reference": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerImage).Reference, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.image.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerImage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.image.identifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerImage).Identifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.image.identifierType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerImage).IdentifierType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.image.repository": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerImage).Repository, ok = plugin.RawToTValue[*mqlContainerRepository](v.Value, v.Error)
		return
	},
	"container.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlContainerRepository).__id, ok = v.Value.(string)
			return
		},
	"container.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.repository.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerRepository).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.repository.fullName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerRepository).FullName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"container.repository.registry": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlContainerRepository).Registry, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"kubelet.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlKubelet).__id, ok = v.Value.(string)
			return
		},
	"kubelet.configFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKubelet).ConfigFile, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"kubelet.process": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKubelet).Process, ok = plugin.RawToTValue[*mqlProcess](v.Value, v.Error)
		return
	},
	"kubelet.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlKubelet).Configuration, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"python.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPython).__id, ok = v.Value.(string)
			return
		},
	"python.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPython).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.packages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPython).Packages, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"python.toplevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPython).Toplevel, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"python.package.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPythonPackage).__id, ok = v.Value.(string)
			return
		},
	"python.package.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"python.package.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.license": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).License, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.author": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Author, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.summary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Summary, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"python.package.dependencies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPythonPackage).Dependencies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[os] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[os] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAsset for the asset resource
type mqlAsset struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAssetInternal it will be used here
	VulnerabilityReport plugin.TValue[interface{}]
}

// createAsset creates a new instance of this resource
func createAsset(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAsset{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("asset", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAsset) MqlName() string {
	return "asset"
}

func (c *mqlAsset) MqlID() string {
	return c.__id
}

func (c *mqlAsset) GetVulnerabilityReport() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.VulnerabilityReport, func() (interface{}, error) {
		return c.vulnerabilityReport()
	})
}

// mqlAssetEol for the asset.eol resource
type mqlAssetEol struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAssetEolInternal it will be used here
	DocsUrl plugin.TValue[string]
	ProductUrl plugin.TValue[string]
	Date plugin.TValue[*time.Time]
}

// createAssetEol creates a new instance of this resource
func createAssetEol(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAssetEol{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("asset.eol", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAssetEol) MqlName() string {
	return "asset.eol"
}

func (c *mqlAssetEol) MqlID() string {
	return c.__id
}

func (c *mqlAssetEol) GetDocsUrl() *plugin.TValue[string] {
	return &c.DocsUrl
}

func (c *mqlAssetEol) GetProductUrl() *plugin.TValue[string] {
	return &c.ProductUrl
}

func (c *mqlAssetEol) GetDate() *plugin.TValue[*time.Time] {
	return &c.Date
}

// mqlMondooEol for the mondoo.eol resource
type mqlMondooEol struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMondooEolInternal it will be used here
	Product plugin.TValue[string]
	Version plugin.TValue[string]
	Date plugin.TValue[*time.Time]
}

// createMondooEol creates a new instance of this resource
func createMondooEol(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMondooEol{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("mondoo.eol", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMondooEol) MqlName() string {
	return "mondoo.eol"
}

func (c *mqlMondooEol) MqlID() string {
	return c.__id
}

func (c *mqlMondooEol) GetProduct() *plugin.TValue[string] {
	return &c.Product
}

func (c *mqlMondooEol) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlMondooEol) GetDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Date, func() (*time.Time, error) {
		return c.date()
	})
}

// mqlPlatformEol for the platform.eol resource
type mqlPlatformEol struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPlatformEolInternal it will be used here
	DocsUrl plugin.TValue[string]
	ProductUrl plugin.TValue[string]
	Date plugin.TValue[*time.Time]
}

// createPlatformEol creates a new instance of this resource
func createPlatformEol(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPlatformEol{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("platform.eol", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPlatformEol) MqlName() string {
	return "platform.eol"
}

func (c *mqlPlatformEol) MqlID() string {
	return c.__id
}

func (c *mqlPlatformEol) GetDocsUrl() *plugin.TValue[string] {
	return &c.DocsUrl
}

func (c *mqlPlatformEol) GetProductUrl() *plugin.TValue[string] {
	return &c.ProductUrl
}

func (c *mqlPlatformEol) GetDate() *plugin.TValue[*time.Time] {
	return &c.Date
}

// mqlPlatformAdvisories for the platform.advisories resource
type mqlPlatformAdvisories struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPlatformAdvisoriesInternal it will be used here
	Cvss plugin.TValue[*mqlAuditCvss]
	Stats plugin.TValue[interface{}]
	List plugin.TValue[[]interface{}]
}

// createPlatformAdvisories creates a new instance of this resource
func createPlatformAdvisories(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPlatformAdvisories{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("platform.advisories", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPlatformAdvisories) MqlName() string {
	return "platform.advisories"
}

func (c *mqlPlatformAdvisories) MqlID() string {
	return c.__id
}

func (c *mqlPlatformAdvisories) GetCvss() *plugin.TValue[*mqlAuditCvss] {
	return plugin.GetOrCompute[*mqlAuditCvss](&c.Cvss, func() (*mqlAuditCvss, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("platform.advisories", c.__id, "cvss")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAuditCvss), nil
			}
		}

		return c.cvss()
	})
}

func (c *mqlPlatformAdvisories) GetStats() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Stats, func() (interface{}, error) {
		return c.stats()
	})
}

func (c *mqlPlatformAdvisories) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("platform.advisories", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlPlatformCves for the platform.cves resource
type mqlPlatformCves struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPlatformCvesInternal it will be used here
	Cvss plugin.TValue[*mqlAuditCvss]
	Stats plugin.TValue[interface{}]
	List plugin.TValue[[]interface{}]
}

// createPlatformCves creates a new instance of this resource
func createPlatformCves(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPlatformCves{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("platform.cves", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPlatformCves) MqlName() string {
	return "platform.cves"
}

func (c *mqlPlatformCves) MqlID() string {
	return c.__id
}

func (c *mqlPlatformCves) GetCvss() *plugin.TValue[*mqlAuditCvss] {
	return plugin.GetOrCompute[*mqlAuditCvss](&c.Cvss, func() (*mqlAuditCvss, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("platform.cves", c.__id, "cvss")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAuditCvss), nil
			}
		}

		return c.cvss()
	})
}

func (c *mqlPlatformCves) GetStats() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Stats, func() (interface{}, error) {
		return c.stats()
	})
}

func (c *mqlPlatformCves) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("platform.cves", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlAuditCvss for the audit.cvss resource
type mqlAuditCvss struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuditCvssInternal it will be used here
	Score plugin.TValue[float64]
	Vector plugin.TValue[string]
}

// createAuditCvss creates a new instance of this resource
func createAuditCvss(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuditCvss{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("audit.cvss", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuditCvss) MqlName() string {
	return "audit.cvss"
}

func (c *mqlAuditCvss) MqlID() string {
	return c.__id
}

func (c *mqlAuditCvss) GetScore() *plugin.TValue[float64] {
	return &c.Score
}

func (c *mqlAuditCvss) GetVector() *plugin.TValue[string] {
	return &c.Vector
}

// mqlAuditAdvisory for the audit.advisory resource
type mqlAuditAdvisory struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuditAdvisoryInternal it will be used here
	Id plugin.TValue[string]
	Mrn plugin.TValue[string]
	Title plugin.TValue[string]
	Description plugin.TValue[string]
	Published plugin.TValue[*time.Time]
	Modified plugin.TValue[*time.Time]
	WorstScore plugin.TValue[*mqlAuditCvss]
}

// createAuditAdvisory creates a new instance of this resource
func createAuditAdvisory(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuditAdvisory{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("audit.advisory", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuditAdvisory) MqlName() string {
	return "audit.advisory"
}

func (c *mqlAuditAdvisory) MqlID() string {
	return c.__id
}

func (c *mqlAuditAdvisory) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAuditAdvisory) GetMrn() *plugin.TValue[string] {
	return &c.Mrn
}

func (c *mqlAuditAdvisory) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlAuditAdvisory) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAuditAdvisory) GetPublished() *plugin.TValue[*time.Time] {
	return &c.Published
}

func (c *mqlAuditAdvisory) GetModified() *plugin.TValue[*time.Time] {
	return &c.Modified
}

func (c *mqlAuditAdvisory) GetWorstScore() *plugin.TValue[*mqlAuditCvss] {
	return &c.WorstScore
}

// mqlAuditCve for the audit.cve resource
type mqlAuditCve struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuditCveInternal it will be used here
	Id plugin.TValue[string]
	Mrn plugin.TValue[string]
	State plugin.TValue[string]
	Summary plugin.TValue[string]
	Unscored plugin.TValue[bool]
	Published plugin.TValue[*time.Time]
	Modified plugin.TValue[*time.Time]
	WorstScore plugin.TValue[*mqlAuditCvss]
}

// createAuditCve creates a new instance of this resource
func createAuditCve(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuditCve{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("audit.cve", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuditCve) MqlName() string {
	return "audit.cve"
}

func (c *mqlAuditCve) MqlID() string {
	return c.__id
}

func (c *mqlAuditCve) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAuditCve) GetMrn() *plugin.TValue[string] {
	return &c.Mrn
}

func (c *mqlAuditCve) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAuditCve) GetSummary() *plugin.TValue[string] {
	return &c.Summary
}

func (c *mqlAuditCve) GetUnscored() *plugin.TValue[bool] {
	return &c.Unscored
}

func (c *mqlAuditCve) GetPublished() *plugin.TValue[*time.Time] {
	return &c.Published
}

func (c *mqlAuditCve) GetModified() *plugin.TValue[*time.Time] {
	return &c.Modified
}

func (c *mqlAuditCve) GetWorstScore() *plugin.TValue[*mqlAuditCvss] {
	return &c.WorstScore
}

// mqlMachine for the machine resource
type mqlMachine struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMachineInternal it will be used here
}

// createMachine creates a new instance of this resource
func createMachine(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMachine{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("machine", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMachine) MqlName() string {
	return "machine"
}

func (c *mqlMachine) MqlID() string {
	return c.__id
}

// mqlMachineBios for the machine.bios resource
type mqlMachineBios struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMachineBiosInternal it will be used here
	Vendor plugin.TValue[string]
	Version plugin.TValue[string]
	ReleaseDate plugin.TValue[string]
}

// createMachineBios creates a new instance of this resource
func createMachineBios(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMachineBios{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("machine.bios", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMachineBios) MqlName() string {
	return "machine.bios"
}

func (c *mqlMachineBios) MqlID() string {
	return c.__id
}

func (c *mqlMachineBios) GetVendor() *plugin.TValue[string] {
	return &c.Vendor
}

func (c *mqlMachineBios) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlMachineBios) GetReleaseDate() *plugin.TValue[string] {
	return &c.ReleaseDate
}

// mqlMachineSystem for the machine.system resource
type mqlMachineSystem struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMachineSystemInternal it will be used here
	Manufacturer plugin.TValue[string]
	Product plugin.TValue[string]
	Version plugin.TValue[string]
	Serial plugin.TValue[string]
	Uuid plugin.TValue[string]
	Sku plugin.TValue[string]
	Family plugin.TValue[string]
}

// createMachineSystem creates a new instance of this resource
func createMachineSystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMachineSystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("machine.system", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMachineSystem) MqlName() string {
	return "machine.system"
}

func (c *mqlMachineSystem) MqlID() string {
	return c.__id
}

func (c *mqlMachineSystem) GetManufacturer() *plugin.TValue[string] {
	return &c.Manufacturer
}

func (c *mqlMachineSystem) GetProduct() *plugin.TValue[string] {
	return &c.Product
}

func (c *mqlMachineSystem) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlMachineSystem) GetSerial() *plugin.TValue[string] {
	return &c.Serial
}

func (c *mqlMachineSystem) GetUuid() *plugin.TValue[string] {
	return &c.Uuid
}

func (c *mqlMachineSystem) GetSku() *plugin.TValue[string] {
	return &c.Sku
}

func (c *mqlMachineSystem) GetFamily() *plugin.TValue[string] {
	return &c.Family
}

// mqlMachineBaseboard for the machine.baseboard resource
type mqlMachineBaseboard struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMachineBaseboardInternal it will be used here
	Manufacturer plugin.TValue[string]
	Product plugin.TValue[string]
	Version plugin.TValue[string]
	Serial plugin.TValue[string]
	AssetTag plugin.TValue[string]
}

// createMachineBaseboard creates a new instance of this resource
func createMachineBaseboard(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMachineBaseboard{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("machine.baseboard", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMachineBaseboard) MqlName() string {
	return "machine.baseboard"
}

func (c *mqlMachineBaseboard) MqlID() string {
	return c.__id
}

func (c *mqlMachineBaseboard) GetManufacturer() *plugin.TValue[string] {
	return &c.Manufacturer
}

func (c *mqlMachineBaseboard) GetProduct() *plugin.TValue[string] {
	return &c.Product
}

func (c *mqlMachineBaseboard) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlMachineBaseboard) GetSerial() *plugin.TValue[string] {
	return &c.Serial
}

func (c *mqlMachineBaseboard) GetAssetTag() *plugin.TValue[string] {
	return &c.AssetTag
}

// mqlMachineChassis for the machine.chassis resource
type mqlMachineChassis struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMachineChassisInternal it will be used here
	Manufacturer plugin.TValue[string]
	Version plugin.TValue[string]
	Serial plugin.TValue[string]
	AssetTag plugin.TValue[string]
}

// createMachineChassis creates a new instance of this resource
func createMachineChassis(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMachineChassis{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("machine.chassis", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMachineChassis) MqlName() string {
	return "machine.chassis"
}

func (c *mqlMachineChassis) MqlID() string {
	return c.__id
}

func (c *mqlMachineChassis) GetManufacturer() *plugin.TValue[string] {
	return &c.Manufacturer
}

func (c *mqlMachineChassis) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlMachineChassis) GetSerial() *plugin.TValue[string] {
	return &c.Serial
}

func (c *mqlMachineChassis) GetAssetTag() *plugin.TValue[string] {
	return &c.AssetTag
}

// mqlOs for the os resource
type mqlOs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsInternal it will be used here
	Name plugin.TValue[string]
	Env plugin.TValue[map[string]interface{}]
	Path plugin.TValue[[]interface{}]
	Uptime plugin.TValue[*time.Time]
	Updates plugin.TValue[[]interface{}]
	Rebootpending plugin.TValue[bool]
	Hostname plugin.TValue[string]
	Machineid plugin.TValue[string]
}

// createOs creates a new instance of this resource
func createOs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOs) MqlName() string {
	return "os"
}

func (c *mqlOs) MqlID() string {
	return c.__id
}

func (c *mqlOs) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlOs) GetEnv() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Env, func() (map[string]interface{}, error) {
		return c.env()
	})
}

func (c *mqlOs) GetPath() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Path, func() ([]interface{}, error) {
		vargEnv := c.GetEnv()
		if vargEnv.Error != nil {
			return nil, vargEnv.Error
		}

		return c.path(vargEnv.Data)
	})
}

func (c *mqlOs) GetUptime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Uptime, func() (*time.Time, error) {
		return c.uptime()
	})
}

func (c *mqlOs) GetUpdates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Updates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os", c.__id, "updates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.updates()
	})
}

func (c *mqlOs) GetRebootpending() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Rebootpending, func() (bool, error) {
		return c.rebootpending()
	})
}

func (c *mqlOs) GetHostname() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Hostname, func() (string, error) {
		return c.hostname()
	})
}

func (c *mqlOs) GetMachineid() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Machineid, func() (string, error) {
		return c.machineid()
	})
}

// mqlOsUpdate for the os.update resource
type mqlOsUpdate struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsUpdateInternal it will be used here
	Name plugin.TValue[string]
	Category plugin.TValue[string]
	Severity plugin.TValue[string]
	Restart plugin.TValue[bool]
	Format plugin.TValue[string]
}

// createOsUpdate creates a new instance of this resource
func createOsUpdate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOsUpdate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os.update", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOsUpdate) MqlName() string {
	return "os.update"
}

func (c *mqlOsUpdate) MqlID() string {
	return c.__id
}

func (c *mqlOsUpdate) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlOsUpdate) GetCategory() *plugin.TValue[string] {
	return &c.Category
}

func (c *mqlOsUpdate) GetSeverity() *plugin.TValue[string] {
	return &c.Severity
}

func (c *mqlOsUpdate) GetRestart() *plugin.TValue[bool] {
	return &c.Restart
}

func (c *mqlOsUpdate) GetFormat() *plugin.TValue[string] {
	return &c.Format
}

// mqlOsBase for the os.base resource
type mqlOsBase struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsBaseInternal it will be used here
	Machine plugin.TValue[*mqlMachine]
	Name plugin.TValue[string]
	Env plugin.TValue[map[string]interface{}]
	Path plugin.TValue[[]interface{}]
	Uptime plugin.TValue[*time.Time]
	Updates plugin.TValue[[]interface{}]
	Rebootpending plugin.TValue[bool]
	Hostname plugin.TValue[string]
	Groups plugin.TValue[*mqlGroups]
	Users plugin.TValue[*mqlUsers]
}

// createOsBase creates a new instance of this resource
func createOsBase(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOsBase{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os.base", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOsBase) MqlName() string {
	return "os.base"
}

func (c *mqlOsBase) MqlID() string {
	return c.__id
}

func (c *mqlOsBase) GetMachine() *plugin.TValue[*mqlMachine] {
	return plugin.GetOrCompute[*mqlMachine](&c.Machine, func() (*mqlMachine, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.base", c.__id, "machine")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlMachine), nil
			}
		}

		return c.machine()
	})
}

func (c *mqlOsBase) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlOsBase) GetEnv() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Env, func() (map[string]interface{}, error) {
		return c.env()
	})
}

func (c *mqlOsBase) GetPath() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Path, func() ([]interface{}, error) {
		vargEnv := c.GetEnv()
		if vargEnv.Error != nil {
			return nil, vargEnv.Error
		}

		return c.path(vargEnv.Data)
	})
}

func (c *mqlOsBase) GetUptime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Uptime, func() (*time.Time, error) {
		return c.uptime()
	})
}

func (c *mqlOsBase) GetUpdates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Updates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.base", c.__id, "updates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.updates()
	})
}

func (c *mqlOsBase) GetRebootpending() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Rebootpending, func() (bool, error) {
		return c.rebootpending()
	})
}

func (c *mqlOsBase) GetHostname() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Hostname, func() (string, error) {
		return c.hostname()
	})
}

func (c *mqlOsBase) GetGroups() *plugin.TValue[*mqlGroups] {
	return plugin.GetOrCompute[*mqlGroups](&c.Groups, func() (*mqlGroups, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.base", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGroups), nil
			}
		}

		return c.groups()
	})
}

func (c *mqlOsBase) GetUsers() *plugin.TValue[*mqlUsers] {
	return plugin.GetOrCompute[*mqlUsers](&c.Users, func() (*mqlUsers, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.base", c.__id, "users")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlUsers), nil
			}
		}

		return c.users()
	})
}

// mqlOsUnix for the os.unix resource
type mqlOsUnix struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsUnixInternal it will be used here
	Base plugin.TValue[*mqlOsBase]
}

// createOsUnix creates a new instance of this resource
func createOsUnix(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOsUnix{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os.unix", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOsUnix) MqlName() string {
	return "os.unix"
}

func (c *mqlOsUnix) MqlID() string {
	return c.__id
}

func (c *mqlOsUnix) GetBase() *plugin.TValue[*mqlOsBase] {
	return plugin.GetOrCompute[*mqlOsBase](&c.Base, func() (*mqlOsBase, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.unix", c.__id, "base")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlOsBase), nil
			}
		}

		return c.base()
	})
}

// mqlOsLinux for the os.linux resource
type mqlOsLinux struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsLinuxInternal it will be used here
	Unix plugin.TValue[*mqlOsUnix]
	Iptables plugin.TValue[*mqlIptables]
	Ip6tables plugin.TValue[*mqlIp6tables]
}

// createOsLinux creates a new instance of this resource
func createOsLinux(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOsLinux{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os.linux", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOsLinux) MqlName() string {
	return "os.linux"
}

func (c *mqlOsLinux) MqlID() string {
	return c.__id
}

func (c *mqlOsLinux) GetUnix() *plugin.TValue[*mqlOsUnix] {
	return plugin.GetOrCompute[*mqlOsUnix](&c.Unix, func() (*mqlOsUnix, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.linux", c.__id, "unix")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlOsUnix), nil
			}
		}

		return c.unix()
	})
}

func (c *mqlOsLinux) GetIptables() *plugin.TValue[*mqlIptables] {
	return plugin.GetOrCompute[*mqlIptables](&c.Iptables, func() (*mqlIptables, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.linux", c.__id, "iptables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlIptables), nil
			}
		}

		return c.iptables()
	})
}

func (c *mqlOsLinux) GetIp6tables() *plugin.TValue[*mqlIp6tables] {
	return plugin.GetOrCompute[*mqlIp6tables](&c.Ip6tables, func() (*mqlIp6tables, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.linux", c.__id, "ip6tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlIp6tables), nil
			}
		}

		return c.ip6tables()
	})
}

// mqlOsRootCertificates for the os.rootCertificates resource
type mqlOsRootCertificates struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOsRootCertificatesInternal it will be used here
	Files plugin.TValue[[]interface{}]
	Content plugin.TValue[[]interface{}]
	List plugin.TValue[[]interface{}]
}

// createOsRootCertificates creates a new instance of this resource
func createOsRootCertificates(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOsRootCertificates{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("os.rootCertificates", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOsRootCertificates) MqlName() string {
	return "os.rootCertificates"
}

func (c *mqlOsRootCertificates) MqlID() string {
	return c.__id
}

func (c *mqlOsRootCertificates) GetFiles() *plugin.TValue[[]interface{}] {
	return &c.Files
}

func (c *mqlOsRootCertificates) GetContent() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Content, func() ([]interface{}, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return nil, vargFiles.Error
		}

		return c.content(vargFiles.Data)
	})
}

func (c *mqlOsRootCertificates) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("os.rootCertificates", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.list(vargContent.Data)
	})
}

// mqlCommand for the command resource
type mqlCommand struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlCommandInternal
	Command plugin.TValue[string]
	Stdout plugin.TValue[string]
	Stderr plugin.TValue[string]
	Exitcode plugin.TValue[int64]
}

// createCommand creates a new instance of this resource
func createCommand(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlCommand{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("command", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlCommand) MqlName() string {
	return "command"
}

func (c *mqlCommand) MqlID() string {
	return c.__id
}

func (c *mqlCommand) GetCommand() *plugin.TValue[string] {
	return &c.Command
}

func (c *mqlCommand) GetStdout() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stdout, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}

		return c.stdout(vargCommand.Data)
	})
}

func (c *mqlCommand) GetStderr() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stderr, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}

		return c.stderr(vargCommand.Data)
	})
}

func (c *mqlCommand) GetExitcode() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Exitcode, func() (int64, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return 0, vargCommand.Error
		}

		return c.exitcode(vargCommand.Data)
	})
}

// mqlPowershell for the powershell resource
type mqlPowershell struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlPowershellInternal
	Script plugin.TValue[string]
	Stdout plugin.TValue[string]
	Stderr plugin.TValue[string]
	Exitcode plugin.TValue[int64]
}

// createPowershell creates a new instance of this resource
func createPowershell(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPowershell{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("powershell", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPowershell) MqlName() string {
	return "powershell"
}

func (c *mqlPowershell) MqlID() string {
	return c.__id
}

func (c *mqlPowershell) GetScript() *plugin.TValue[string] {
	return &c.Script
}

func (c *mqlPowershell) GetStdout() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stdout, func() (string, error) {
		return c.stdout()
	})
}

func (c *mqlPowershell) GetStderr() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stderr, func() (string, error) {
		return c.stderr()
	})
}

func (c *mqlPowershell) GetExitcode() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Exitcode, func() (int64, error) {
		return c.exitcode()
	})
}

// mqlFile for the file resource
type mqlFile struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFileInternal it will be used here
	Path plugin.TValue[string]
	Basename plugin.TValue[string]
	Dirname plugin.TValue[string]
	Content plugin.TValue[string]
	Exists plugin.TValue[bool]
	Permissions plugin.TValue[*mqlFilePermissions]
	Size plugin.TValue[int64]
	User plugin.TValue[*mqlUser]
	Group plugin.TValue[*mqlGroup]
	Empty plugin.TValue[bool]
}

// createFile creates a new instance of this resource
func createFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("file", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFile) MqlName() string {
	return "file"
}

func (c *mqlFile) MqlID() string {
	return c.__id
}

func (c *mqlFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlFile) GetBasename() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Basename, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		return c.basename(vargPath.Data)
	})
}

func (c *mqlFile) GetDirname() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Dirname, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		return c.dirname(vargPath.Data)
	})
}

func (c *mqlFile) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		vargExists := c.GetExists()
		if vargExists.Error != nil {
			return "", vargExists.Error
		}

		return c.content(vargPath.Data, vargExists.Data)
	})
}

func (c *mqlFile) GetExists() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Exists, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}

		return c.exists(vargPath.Data)
	})
}

func (c *mqlFile) GetPermissions() *plugin.TValue[*mqlFilePermissions] {
	return plugin.GetOrCompute[*mqlFilePermissions](&c.Permissions, func() (*mqlFilePermissions, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "permissions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFilePermissions), nil
			}
		}

		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return nil, vargPath.Error
		}

		return c.permissions(vargPath.Data)
	})
}

func (c *mqlFile) GetSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Size, func() (int64, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return 0, vargPath.Error
		}

		return c.size(vargPath.Data)
	})
}

func (c *mqlFile) GetUser() *plugin.TValue[*mqlUser] {
	return plugin.GetOrCompute[*mqlUser](&c.User, func() (*mqlUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlFile) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "group")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGroup), nil
			}
		}

		return c.group()
	})
}

func (c *mqlFile) GetEmpty() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Empty, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}

		return c.empty(vargPath.Data)
	})
}

// mqlFilePermissions for the file.permissions resource
type mqlFilePermissions struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFilePermissionsInternal it will be used here
	Mode plugin.TValue[int64]
	User_readable plugin.TValue[bool]
	User_writeable plugin.TValue[bool]
	User_executable plugin.TValue[bool]
	Group_readable plugin.TValue[bool]
	Group_writeable plugin.TValue[bool]
	Group_executable plugin.TValue[bool]
	Other_readable plugin.TValue[bool]
	Other_writeable plugin.TValue[bool]
	Other_executable plugin.TValue[bool]
	Suid plugin.TValue[bool]
	Sgid plugin.TValue[bool]
	Sticky plugin.TValue[bool]
	IsDirectory plugin.TValue[bool]
	IsFile plugin.TValue[bool]
	IsSymlink plugin.TValue[bool]
	String plugin.TValue[string]
}

// createFilePermissions creates a new instance of this resource
func createFilePermissions(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFilePermissions{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("file.permissions", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFilePermissions) MqlName() string {
	return "file.permissions"
}

func (c *mqlFilePermissions) MqlID() string {
	return c.__id
}

func (c *mqlFilePermissions) GetMode() *plugin.TValue[int64] {
	return &c.Mode
}

func (c *mqlFilePermissions) GetUser_readable() *plugin.TValue[bool] {
	return &c.User_readable
}

func (c *mqlFilePermissions) GetUser_writeable() *plugin.TValue[bool] {
	return &c.User_writeable
}

func (c *mqlFilePermissions) GetUser_executable() *plugin.TValue[bool] {
	return &c.User_executable
}

func (c *mqlFilePermissions) GetGroup_readable() *plugin.TValue[bool] {
	return &c.Group_readable
}

func (c *mqlFilePermissions) GetGroup_writeable() *plugin.TValue[bool] {
	return &c.Group_writeable
}

func (c *mqlFilePermissions) GetGroup_executable() *plugin.TValue[bool] {
	return &c.Group_executable
}

func (c *mqlFilePermissions) GetOther_readable() *plugin.TValue[bool] {
	return &c.Other_readable
}

func (c *mqlFilePermissions) GetOther_writeable() *plugin.TValue[bool] {
	return &c.Other_writeable
}

func (c *mqlFilePermissions) GetOther_executable() *plugin.TValue[bool] {
	return &c.Other_executable
}

func (c *mqlFilePermissions) GetSuid() *plugin.TValue[bool] {
	return &c.Suid
}

func (c *mqlFilePermissions) GetSgid() *plugin.TValue[bool] {
	return &c.Sgid
}

func (c *mqlFilePermissions) GetSticky() *plugin.TValue[bool] {
	return &c.Sticky
}

func (c *mqlFilePermissions) GetIsDirectory() *plugin.TValue[bool] {
	return &c.IsDirectory
}

func (c *mqlFilePermissions) GetIsFile() *plugin.TValue[bool] {
	return &c.IsFile
}

func (c *mqlFilePermissions) GetIsSymlink() *plugin.TValue[bool] {
	return &c.IsSymlink
}

func (c *mqlFilePermissions) GetString() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.String, func() (string, error) {
		return c.string()
	})
}

// mqlFiles for the files resource
type mqlFiles struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFilesInternal it will be used here
}

// createFiles creates a new instance of this resource
func createFiles(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFiles{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("files", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFiles) MqlName() string {
	return "files"
}

func (c *mqlFiles) MqlID() string {
	return c.__id
}

// mqlFilesFind for the files.find resource
type mqlFilesFind struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFilesFindInternal it will be used here
	From plugin.TValue[string]
	Xdev plugin.TValue[bool]
	Type plugin.TValue[string]
	Regex plugin.TValue[string]
	Permissions plugin.TValue[int64]
	Name plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createFilesFind creates a new instance of this resource
func createFilesFind(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFilesFind{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("files.find", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFilesFind) MqlName() string {
	return "files.find"
}

func (c *mqlFilesFind) MqlID() string {
	return c.__id
}

func (c *mqlFilesFind) GetFrom() *plugin.TValue[string] {
	return &c.From
}

func (c *mqlFilesFind) GetXdev() *plugin.TValue[bool] {
	return &c.Xdev
}

func (c *mqlFilesFind) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlFilesFind) GetRegex() *plugin.TValue[string] {
	return &c.Regex
}

func (c *mqlFilesFind) GetPermissions() *plugin.TValue[int64] {
	return &c.Permissions
}

func (c *mqlFilesFind) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlFilesFind) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("files.find", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlParseIni for the parse.ini resource
type mqlParseIni struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParseIniInternal it will be used here
	Delimiter plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Sections plugin.TValue[map[string]interface{}]
	Params plugin.TValue[map[string]interface{}]
}

// createParseIni creates a new instance of this resource
func createParseIni(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParseIni{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.ini", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParseIni) MqlName() string {
	return "parse.ini"
}

func (c *mqlParseIni) MqlID() string {
	return c.__id
}

func (c *mqlParseIni) GetDelimiter() *plugin.TValue[string] {
	return &c.Delimiter
}

func (c *mqlParseIni) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlParseIni) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParseIni) GetSections() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Sections, func() (map[string]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		vargDelimiter := c.GetDelimiter()
		if vargDelimiter.Error != nil {
			return nil, vargDelimiter.Error
		}

		return c.sections(vargContent.Data, vargDelimiter.Data)
	})
}

func (c *mqlParseIni) GetParams() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Params, func() (map[string]interface{}, error) {
		vargSections := c.GetSections()
		if vargSections.Error != nil {
			return nil, vargSections.Error
		}

		return c.params(vargSections.Data)
	})
}

// mqlParseJson for the parse.json resource
type mqlParseJson struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParseJsonInternal it will be used here
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Params plugin.TValue[interface{}]
}

// createParseJson creates a new instance of this resource
func createParseJson(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParseJson{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.json", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParseJson) MqlName() string {
	return "parse.json"
}

func (c *mqlParseJson) MqlID() string {
	return c.__id
}

func (c *mqlParseJson) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlParseJson) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParseJson) GetParams() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Params, func() (interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

// mqlParsePlist for the parse.plist resource
type mqlParsePlist struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParsePlistInternal it will be used here
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Params plugin.TValue[interface{}]
}

// createParsePlist creates a new instance of this resource
func createParsePlist(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParsePlist{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.plist", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParsePlist) MqlName() string {
	return "parse.plist"
}

func (c *mqlParsePlist) MqlID() string {
	return c.__id
}

func (c *mqlParsePlist) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlParsePlist) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParsePlist) GetParams() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Params, func() (interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

// mqlParseYaml for the parse.yaml resource
type mqlParseYaml struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParseYamlInternal it will be used here
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Params plugin.TValue[interface{}]
}

// createParseYaml creates a new instance of this resource
func createParseYaml(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParseYaml{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.yaml", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParseYaml) MqlName() string {
	return "parse.yaml"
}

func (c *mqlParseYaml) MqlID() string {
	return c.__id
}

func (c *mqlParseYaml) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlParseYaml) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParseYaml) GetParams() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Params, func() (interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

// mqlParseCertificates for the parse.certificates resource
type mqlParseCertificates struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParseCertificatesInternal it will be used here
	Path plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createParseCertificates creates a new instance of this resource
func createParseCertificates(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParseCertificates{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.certificates", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParseCertificates) MqlName() string {
	return "parse.certificates"
}

func (c *mqlParseCertificates) MqlID() string {
	return c.__id
}

func (c *mqlParseCertificates) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlParseCertificates) GetFile() *plugin.TValue[*mqlFile] {
	return plugin.GetOrCompute[*mqlFile](&c.File, func() (*mqlFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("parse.certificates", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlParseCertificates) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParseCertificates) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("parse.certificates", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return nil, vargPath.Error
		}

		return c.list(vargContent.Data, vargPath.Data)
	})
}

// mqlParseOpenpgp for the parse.openpgp resource
type mqlParseOpenpgp struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlParseOpenpgpInternal it will be used here
	Path plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createParseOpenpgp creates a new instance of this resource
func createParseOpenpgp(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlParseOpenpgp{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("parse.openpgp", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlParseOpenpgp) MqlName() string {
	return "parse.openpgp"
}

func (c *mqlParseOpenpgp) MqlID() string {
	return c.__id
}

func (c *mqlParseOpenpgp) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlParseOpenpgp) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlParseOpenpgp) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlParseOpenpgp) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("parse.openpgp", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.list(vargContent.Data)
	})
}

// mqlUser for the user resource
type mqlUser struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlUserInternal it will be used here
	Uid plugin.TValue[int64]
	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Home plugin.TValue[string]
	Shell plugin.TValue[string]
	Enabled plugin.TValue[bool]
	Authorizedkeys plugin.TValue[*mqlAuthorizedkeys]
	Sshkeys plugin.TValue[[]interface{}]
	Group plugin.TValue[*mqlGroup]
}

// createUser creates a new instance of this resource
func createUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlUser) MqlName() string {
	return "user"
}

func (c *mqlUser) MqlID() string {
	return c.__id
}

func (c *mqlUser) GetUid() *plugin.TValue[int64] {
	return &c.Uid
}

func (c *mqlUser) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlUser) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlUser) GetHome() *plugin.TValue[string] {
	return &c.Home
}

func (c *mqlUser) GetShell() *plugin.TValue[string] {
	return &c.Shell
}

func (c *mqlUser) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlUser) GetAuthorizedkeys() *plugin.TValue[*mqlAuthorizedkeys] {
	return plugin.GetOrCompute[*mqlAuthorizedkeys](&c.Authorizedkeys, func() (*mqlAuthorizedkeys, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("user", c.__id, "authorizedkeys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAuthorizedkeys), nil
			}
		}

		vargHome := c.GetHome()
		if vargHome.Error != nil {
			return nil, vargHome.Error
		}

		return c.authorizedkeys(vargHome.Data)
	})
}

func (c *mqlUser) GetSshkeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Sshkeys, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("user", c.__id, "sshkeys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.sshkeys()
	})
}

func (c *mqlUser) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("user", c.__id, "group")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGroup), nil
			}
		}

		vargGid := c.GetGid()
		if vargGid.Error != nil {
			return nil, vargGid.Error
		}

		return c.group(vargGid.Data)
	})
}

// mqlPrivatekey for the privatekey resource
type mqlPrivatekey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPrivatekeyInternal it will be used here
	Pem plugin.TValue[string]
	Path plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Encrypted plugin.TValue[bool]
}

// createPrivatekey creates a new instance of this resource
func createPrivatekey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPrivatekey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("privatekey", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPrivatekey) MqlName() string {
	return "privatekey"
}

func (c *mqlPrivatekey) MqlID() string {
	return c.__id
}

func (c *mqlPrivatekey) GetPem() *plugin.TValue[string] {
	return &c.Pem
}

func (c *mqlPrivatekey) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlPrivatekey) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlPrivatekey) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

// mqlUsers for the users resource
type mqlUsers struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlUsersInternal
	List plugin.TValue[[]interface{}]
}

// createUsers creates a new instance of this resource
func createUsers(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlUsers{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("users", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlUsers) MqlName() string {
	return "users"
}

func (c *mqlUsers) MqlID() string {
	return c.__id
}

func (c *mqlUsers) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("users", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlAuthorizedkeys for the authorizedkeys resource
type mqlAuthorizedkeys struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuthorizedkeysInternal it will be used here
	Path plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createAuthorizedkeys creates a new instance of this resource
func createAuthorizedkeys(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuthorizedkeys{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("authorizedkeys", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuthorizedkeys) MqlName() string {
	return "authorizedkeys"
}

func (c *mqlAuthorizedkeys) MqlID() string {
	return c.__id
}

func (c *mqlAuthorizedkeys) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlAuthorizedkeys) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlAuthorizedkeys) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlAuthorizedkeys) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("authorizedkeys", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return nil, vargFile.Error
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.list(vargFile.Data, vargContent.Data)
	})
}

// mqlAuthorizedkeysEntry for the authorizedkeys.entry resource
type mqlAuthorizedkeysEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuthorizedkeysEntryInternal it will be used here
	Line plugin.TValue[int64]
	Type plugin.TValue[string]
	Key plugin.TValue[string]
	Label plugin.TValue[string]
	Options plugin.TValue[[]interface{}]
	File plugin.TValue[*mqlFile]
}

// createAuthorizedkeysEntry creates a new instance of this resource
func createAuthorizedkeysEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuthorizedkeysEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("authorizedkeys.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuthorizedkeysEntry) MqlName() string {
	return "authorizedkeys.entry"
}

func (c *mqlAuthorizedkeysEntry) MqlID() string {
	return c.__id
}

func (c *mqlAuthorizedkeysEntry) GetLine() *plugin.TValue[int64] {
	return &c.Line
}

func (c *mqlAuthorizedkeysEntry) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAuthorizedkeysEntry) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlAuthorizedkeysEntry) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAuthorizedkeysEntry) GetOptions() *plugin.TValue[[]interface{}] {
	return &c.Options
}

func (c *mqlAuthorizedkeysEntry) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

// mqlGroup for the group resource
type mqlGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlGroupInternal
	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Members plugin.TValue[[]interface{}]
}

// createGroup creates a new instance of this resource
func createGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGroup) MqlName() string {
	return "group"
}

func (c *mqlGroup) MqlID() string {
	return c.__id
}

func (c *mqlGroup) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlGroup) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGroup) GetMembers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Members, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("group", c.__id, "members")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.members()
	})
}

// mqlGroups for the groups resource
type mqlGroups struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlGroupsInternal
	List plugin.TValue[[]interface{}]
}

// createGroups creates a new instance of this resource
func createGroups(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGroups{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("groups", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGroups) MqlName() string {
	return "groups"
}

func (c *mqlGroups) MqlID() string {
	return c.__id
}

func (c *mqlGroups) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("groups", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlPackage for the package resource
type mqlPackage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPackageInternal it will be used here
	Name plugin.TValue[string]
	Version plugin.TValue[string]
	Arch plugin.TValue[string]
	Epoch plugin.TValue[string]
	Format plugin.TValue[string]
	Status plugin.TValue[string]
	Description plugin.TValue[string]
	Origin plugin.TValue[string]
	Available plugin.TValue[string]
	Installed plugin.TValue[bool]
	Outdated plugin.TValue[bool]
}

// createPackage creates a new instance of this resource
func createPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPackage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("package", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPackage) MqlName() string {
	return "package"
}

func (c *mqlPackage) MqlID() string {
	return c.__id
}

func (c *mqlPackage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlPackage) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlPackage) GetArch() *plugin.TValue[string] {
	return &c.Arch
}

func (c *mqlPackage) GetEpoch() *plugin.TValue[string] {
	return &c.Epoch
}

func (c *mqlPackage) GetFormat() *plugin.TValue[string] {
	return &c.Format
}

func (c *mqlPackage) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlPackage) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlPackage) GetOrigin() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Origin, func() (string, error) {
		return c.origin()
	})
}

func (c *mqlPackage) GetAvailable() *plugin.TValue[string] {
	return &c.Available
}

func (c *mqlPackage) GetInstalled() *plugin.TValue[bool] {
	return &c.Installed
}

func (c *mqlPackage) GetOutdated() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Outdated, func() (bool, error) {
		return c.outdated()
	})
}

// mqlPackages for the packages resource
type mqlPackages struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlPackagesInternal
	List plugin.TValue[[]interface{}]
}

// createPackages creates a new instance of this resource
func createPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPackages{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("packages", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPackages) MqlName() string {
	return "packages"
}

func (c *mqlPackages) MqlID() string {
	return c.__id
}

func (c *mqlPackages) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("packages", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlPamConf for the pam.conf resource
type mqlPamConf struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPamConfInternal it will be used here
	Files plugin.TValue[[]interface{}]
	Content plugin.TValue[string]
	Services plugin.TValue[map[string]interface{}]
	Entries plugin.TValue[map[string]interface{}]
}

// createPamConf creates a new instance of this resource
func createPamConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPamConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("pam.conf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPamConf) MqlName() string {
	return "pam.conf"
}

func (c *mqlPamConf) MqlID() string {
	return c.__id
}

func (c *mqlPamConf) GetFiles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Files, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("pam.conf", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.files()
	})
}

func (c *mqlPamConf) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return "", vargFiles.Error
		}

		return c.content(vargFiles.Data)
	})
}

func (c *mqlPamConf) GetServices() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Services, func() (map[string]interface{}, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return nil, vargFiles.Error
		}

		return c.services(vargFiles.Data)
	})
}

func (c *mqlPamConf) GetEntries() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Entries, func() (map[string]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("pam.conf", c.__id, "entries")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(map[string]interface{}), nil
			}
		}

		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return nil, vargFiles.Error
		}

		return c.entries(vargFiles.Data)
	})
}

// mqlPamConfServiceEntry for the pam.conf.serviceEntry resource
type mqlPamConfServiceEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPamConfServiceEntryInternal it will be used here
	Service plugin.TValue[string]
	LineNumber plugin.TValue[int64]
	PamType plugin.TValue[string]
	Control plugin.TValue[string]
	Module plugin.TValue[string]
	Options plugin.TValue[[]interface{}]
}

// createPamConfServiceEntry creates a new instance of this resource
func createPamConfServiceEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPamConfServiceEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("pam.conf.serviceEntry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPamConfServiceEntry) MqlName() string {
	return "pam.conf.serviceEntry"
}

func (c *mqlPamConfServiceEntry) MqlID() string {
	return c.__id
}

func (c *mqlPamConfServiceEntry) GetService() *plugin.TValue[string] {
	return &c.Service
}

func (c *mqlPamConfServiceEntry) GetLineNumber() *plugin.TValue[int64] {
	return &c.LineNumber
}

func (c *mqlPamConfServiceEntry) GetPamType() *plugin.TValue[string] {
	return &c.PamType
}

func (c *mqlPamConfServiceEntry) GetControl() *plugin.TValue[string] {
	return &c.Control
}

func (c *mqlPamConfServiceEntry) GetModule() *plugin.TValue[string] {
	return &c.Module
}

func (c *mqlPamConfServiceEntry) GetOptions() *plugin.TValue[[]interface{}] {
	return &c.Options
}

// mqlSshd for the sshd resource
type mqlSshd struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlSshdInternal it will be used here
}

// createSshd creates a new instance of this resource
func createSshd(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSshd{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("sshd", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSshd) MqlName() string {
	return "sshd"
}

func (c *mqlSshd) MqlID() string {
	return c.__id
}

// mqlSshdConfig for the sshd.config resource
type mqlSshdConfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlSshdConfigInternal it will be used here
	File plugin.TValue[*mqlFile]
	Files plugin.TValue[[]interface{}]
	Content plugin.TValue[string]
	Params plugin.TValue[map[string]interface{}]
	Ciphers plugin.TValue[[]interface{}]
	Macs plugin.TValue[[]interface{}]
	Kexs plugin.TValue[[]interface{}]
	Hostkeys plugin.TValue[[]interface{}]
}

// createSshdConfig creates a new instance of this resource
func createSshdConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSshdConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("sshd.config", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSshdConfig) MqlName() string {
	return "sshd.config"
}

func (c *mqlSshdConfig) MqlID() string {
	return c.__id
}

func (c *mqlSshdConfig) GetFile() *plugin.TValue[*mqlFile] {
	return plugin.GetOrCompute[*mqlFile](&c.File, func() (*mqlFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("sshd.config", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlSshdConfig) GetFiles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Files, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("sshd.config", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return nil, vargFile.Error
		}

		return c.files(vargFile.Data)
	})
}

func (c *mqlSshdConfig) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return "", vargFiles.Error
		}

		return c.content(vargFiles.Data)
	})
}

func (c *mqlSshdConfig) GetParams() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Params, func() (map[string]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

func (c *mqlSshdConfig) GetCiphers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Ciphers, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.ciphers(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetMacs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Macs, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.macs(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetKexs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Kexs, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.kexs(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetHostkeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hostkeys, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.hostkeys(vargParams.Data)
	})
}

// mqlService for the service resource
type mqlService struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlServiceInternal it will be used here
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Installed plugin.TValue[bool]
	Running plugin.TValue[bool]
	Enabled plugin.TValue[bool]
	Type plugin.TValue[string]
	Masked plugin.TValue[bool]
}

// createService creates a new instance of this resource
func createService(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlService{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("service", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlService) MqlName() string {
	return "service"
}

func (c *mqlService) MqlID() string {
	return c.__id
}

func (c *mqlService) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlService) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlService) GetInstalled() *plugin.TValue[bool] {
	return &c.Installed
}

func (c *mqlService) GetRunning() *plugin.TValue[bool] {
	return &c.Running
}

func (c *mqlService) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlService) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlService) GetMasked() *plugin.TValue[bool] {
	return &c.Masked
}

// mqlServices for the services resource
type mqlServices struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlServicesInternal
	List plugin.TValue[[]interface{}]
}

// createServices creates a new instance of this resource
func createServices(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlServices{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("services", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlServices) MqlName() string {
	return "services"
}

func (c *mqlServices) MqlID() string {
	return c.__id
}

func (c *mqlServices) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("services", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlKernel for the kernel resource
type mqlKernel struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlKernelInternal
	Info plugin.TValue[interface{}]
	Parameters plugin.TValue[map[string]interface{}]
	Modules plugin.TValue[[]interface{}]
	Installed plugin.TValue[[]interface{}]
}

// createKernel creates a new instance of this resource
func createKernel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlKernel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("kernel", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlKernel) MqlName() string {
	return "kernel"
}

func (c *mqlKernel) MqlID() string {
	return c.__id
}

func (c *mqlKernel) GetInfo() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Info, func() (interface{}, error) {
		return c.info()
	})
}

func (c *mqlKernel) GetParameters() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Parameters, func() (map[string]interface{}, error) {
		return c.parameters()
	})
}

func (c *mqlKernel) GetModules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Modules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("kernel", c.__id, "modules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.modules()
	})
}

func (c *mqlKernel) GetInstalled() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Installed, func() ([]interface{}, error) {
		return c.installed()
	})
}

// mqlKernelModule for the kernel.module resource
type mqlKernelModule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlKernelModuleInternal it will be used here
	Name plugin.TValue[string]
	Size plugin.TValue[string]
	Loaded plugin.TValue[bool]
}

// createKernelModule creates a new instance of this resource
func createKernelModule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlKernelModule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("kernel.module", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlKernelModule) MqlName() string {
	return "kernel.module"
}

func (c *mqlKernelModule) MqlID() string {
	return c.__id
}

func (c *mqlKernelModule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlKernelModule) GetSize() *plugin.TValue[string] {
	return &c.Size
}

func (c *mqlKernelModule) GetLoaded() *plugin.TValue[bool] {
	return &c.Loaded
}

// mqlDocker for the docker resource
type mqlDocker struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDockerInternal it will be used here
	Images plugin.TValue[[]interface{}]
	Containers plugin.TValue[[]interface{}]
}

// createDocker creates a new instance of this resource
func createDocker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDocker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("docker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDocker) MqlName() string {
	return "docker"
}

func (c *mqlDocker) MqlID() string {
	return c.__id
}

func (c *mqlDocker) GetImages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Images, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("docker", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.images()
	})
}

func (c *mqlDocker) GetContainers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Containers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("docker", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containers()
	})
}

// mqlDockerImage for the docker.image resource
type mqlDockerImage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDockerImageInternal it will be used here
	Id plugin.TValue[string]
	Size plugin.TValue[int64]
	Virtualsize plugin.TValue[int64]
	Tags plugin.TValue[[]interface{}]
	Labels plugin.TValue[map[string]interface{}]
}

// createDockerImage creates a new instance of this resource
func createDockerImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDockerImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("docker.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDockerImage) MqlName() string {
	return "docker.image"
}

func (c *mqlDockerImage) MqlID() string {
	return c.__id
}

func (c *mqlDockerImage) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlDockerImage) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlDockerImage) GetVirtualsize() *plugin.TValue[int64] {
	return &c.Virtualsize
}

func (c *mqlDockerImage) GetTags() *plugin.TValue[[]interface{}] {
	return &c.Tags
}

func (c *mqlDockerImage) GetLabels() *plugin.TValue[map[string]interface{}] {
	return &c.Labels
}

// mqlDockerContainer for the docker.container resource
type mqlDockerContainer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDockerContainerInternal it will be used here
	Os plugin.TValue[*mqlOsLinux]
	Id plugin.TValue[string]
	Command plugin.TValue[string]
	Image plugin.TValue[string]
	Imageid plugin.TValue[string]
	Names plugin.TValue[[]interface{}]
	State plugin.TValue[string]
	Status plugin.TValue[string]
	Labels plugin.TValue[map[string]interface{}]
}

// createDockerContainer creates a new instance of this resource
func createDockerContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDockerContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("docker.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDockerContainer) MqlName() string {
	return "docker.container"
}

func (c *mqlDockerContainer) MqlID() string {
	return c.__id
}

func (c *mqlDockerContainer) GetOs() *plugin.TValue[*mqlOsLinux] {
	return plugin.GetOrCompute[*mqlOsLinux](&c.Os, func() (*mqlOsLinux, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("docker.container", c.__id, "os")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlOsLinux), nil
			}
		}

		return c.os()
	})
}

func (c *mqlDockerContainer) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlDockerContainer) GetCommand() *plugin.TValue[string] {
	return &c.Command
}

func (c *mqlDockerContainer) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlDockerContainer) GetImageid() *plugin.TValue[string] {
	return &c.Imageid
}

func (c *mqlDockerContainer) GetNames() *plugin.TValue[[]interface{}] {
	return &c.Names
}

func (c *mqlDockerContainer) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlDockerContainer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlDockerContainer) GetLabels() *plugin.TValue[map[string]interface{}] {
	return &c.Labels
}

// mqlIptables for the iptables resource
type mqlIptables struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlIptablesInternal it will be used here
	Input plugin.TValue[[]interface{}]
	Output plugin.TValue[[]interface{}]
}

// createIptables creates a new instance of this resource
func createIptables(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlIptables{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("iptables", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlIptables) MqlName() string {
	return "iptables"
}

func (c *mqlIptables) MqlID() string {
	return c.__id
}

func (c *mqlIptables) GetInput() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Input, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("iptables", c.__id, "input")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.input()
	})
}

func (c *mqlIptables) GetOutput() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Output, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("iptables", c.__id, "output")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.output()
	})
}

// mqlIp6tables for the ip6tables resource
type mqlIp6tables struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlIp6tablesInternal it will be used here
	Input plugin.TValue[[]interface{}]
	Output plugin.TValue[[]interface{}]
}

// createIp6tables creates a new instance of this resource
func createIp6tables(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlIp6tables{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ip6tables", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlIp6tables) MqlName() string {
	return "ip6tables"
}

func (c *mqlIp6tables) MqlID() string {
	return c.__id
}

func (c *mqlIp6tables) GetInput() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Input, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ip6tables", c.__id, "input")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.input()
	})
}

func (c *mqlIp6tables) GetOutput() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Output, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ip6tables", c.__id, "output")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.output()
	})
}

// mqlIptablesEntry for the iptables.entry resource
type mqlIptablesEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlIptablesEntryInternal it will be used here
	LineNumber plugin.TValue[int64]
	Packets plugin.TValue[int64]
	Bytes plugin.TValue[int64]
	Target plugin.TValue[string]
	Protocol plugin.TValue[string]
	Opt plugin.TValue[string]
	In plugin.TValue[string]
	Out plugin.TValue[string]
	Source plugin.TValue[string]
	Destination plugin.TValue[string]
	Options plugin.TValue[string]
	Chain plugin.TValue[string]
}

// createIptablesEntry creates a new instance of this resource
func createIptablesEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlIptablesEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("iptables.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlIptablesEntry) MqlName() string {
	return "iptables.entry"
}

func (c *mqlIptablesEntry) MqlID() string {
	return c.__id
}

func (c *mqlIptablesEntry) GetLineNumber() *plugin.TValue[int64] {
	return &c.LineNumber
}

func (c *mqlIptablesEntry) GetPackets() *plugin.TValue[int64] {
	return &c.Packets
}

func (c *mqlIptablesEntry) GetBytes() *plugin.TValue[int64] {
	return &c.Bytes
}

func (c *mqlIptablesEntry) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlIptablesEntry) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlIptablesEntry) GetOpt() *plugin.TValue[string] {
	return &c.Opt
}

func (c *mqlIptablesEntry) GetIn() *plugin.TValue[string] {
	return &c.In
}

func (c *mqlIptablesEntry) GetOut() *plugin.TValue[string] {
	return &c.Out
}

func (c *mqlIptablesEntry) GetSource() *plugin.TValue[string] {
	return &c.Source
}

func (c *mqlIptablesEntry) GetDestination() *plugin.TValue[string] {
	return &c.Destination
}

func (c *mqlIptablesEntry) GetOptions() *plugin.TValue[string] {
	return &c.Options
}

func (c *mqlIptablesEntry) GetChain() *plugin.TValue[string] {
	return &c.Chain
}

// mqlProcess for the process resource
type mqlProcess struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlProcessInternal
	Pid plugin.TValue[int64]
	State plugin.TValue[string]
	Executable plugin.TValue[string]
	Command plugin.TValue[string]
	Flags plugin.TValue[map[string]interface{}]
}

// createProcess creates a new instance of this resource
func createProcess(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlProcess{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("process", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlProcess) MqlName() string {
	return "process"
}

func (c *mqlProcess) MqlID() string {
	return c.__id
}

func (c *mqlProcess) GetPid() *plugin.TValue[int64] {
	return &c.Pid
}

func (c *mqlProcess) GetState() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.State, func() (string, error) {
		return c.state()
	})
}

func (c *mqlProcess) GetExecutable() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Executable, func() (string, error) {
		return c.executable()
	})
}

func (c *mqlProcess) GetCommand() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Command, func() (string, error) {
		return c.command()
	})
}

func (c *mqlProcess) GetFlags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Flags, func() (map[string]interface{}, error) {
		return c.flags()
	})
}

// mqlProcesses for the processes resource
type mqlProcesses struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlProcessesInternal
	List plugin.TValue[[]interface{}]
}

// createProcesses creates a new instance of this resource
func createProcesses(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlProcesses{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("processes", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlProcesses) MqlName() string {
	return "processes"
}

func (c *mqlProcesses) MqlID() string {
	return c.__id
}

func (c *mqlProcesses) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("processes", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlPort for the port resource
type mqlPort struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPortInternal it will be used here
	Protocol plugin.TValue[string]
	Port plugin.TValue[int64]
	Address plugin.TValue[string]
	User plugin.TValue[*mqlUser]
	Process plugin.TValue[*mqlProcess]
	State plugin.TValue[string]
	RemoteAddress plugin.TValue[string]
	RemotePort plugin.TValue[int64]
	Tls plugin.TValue[plugin.Resource]
}

// createPort creates a new instance of this resource
func createPort(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPort{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("port", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPort) MqlName() string {
	return "port"
}

func (c *mqlPort) MqlID() string {
	return c.__id
}

func (c *mqlPort) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlPort) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlPort) GetAddress() *plugin.TValue[string] {
	return &c.Address
}

func (c *mqlPort) GetUser() *plugin.TValue[*mqlUser] {
	return &c.User
}

func (c *mqlPort) GetProcess() *plugin.TValue[*mqlProcess] {
	return &c.Process
}

func (c *mqlPort) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlPort) GetRemoteAddress() *plugin.TValue[string] {
	return &c.RemoteAddress
}

func (c *mqlPort) GetRemotePort() *plugin.TValue[int64] {
	return &c.RemotePort
}

func (c *mqlPort) GetTls() *plugin.TValue[plugin.Resource] {
	return plugin.GetOrCompute[plugin.Resource](&c.Tls, func() (plugin.Resource, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("port", c.__id, "tls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(plugin.Resource), nil
			}
		}

		vargAddress := c.GetAddress()
		if vargAddress.Error != nil {
			return nil, vargAddress.Error
		}

		vargPort := c.GetPort()
		if vargPort.Error != nil {
			return nil, vargPort.Error
		}

		vargProtocol := c.GetProtocol()
		if vargProtocol.Error != nil {
			return nil, vargProtocol.Error
		}

		return c.tls(vargAddress.Data, vargPort.Data, vargProtocol.Data)
	})
}

// mqlPorts for the ports resource
type mqlPorts struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPortsInternal it will be used here
	Listening plugin.TValue[[]interface{}]
	List plugin.TValue[[]interface{}]
}

// createPorts creates a new instance of this resource
func createPorts(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPorts{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ports", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPorts) MqlName() string {
	return "ports"
}

func (c *mqlPorts) MqlID() string {
	return c.__id
}

func (c *mqlPorts) GetListening() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Listening, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ports", c.__id, "listening")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.listening()
	})
}

func (c *mqlPorts) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ports", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlAuditpol for the auditpol resource
type mqlAuditpol struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuditpolInternal it will be used here
	List plugin.TValue[[]interface{}]
}

// createAuditpol creates a new instance of this resource
func createAuditpol(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuditpol{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("auditpol", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuditpol) MqlName() string {
	return "auditpol"
}

func (c *mqlAuditpol) MqlID() string {
	return c.__id
}

func (c *mqlAuditpol) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("auditpol", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlAuditpolEntry for the auditpol.entry resource
type mqlAuditpolEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuditpolEntryInternal it will be used here
	Machinename plugin.TValue[string]
	Policytarget plugin.TValue[string]
	Subcategory plugin.TValue[string]
	Subcategoryguid plugin.TValue[string]
	Inclusionsetting plugin.TValue[string]
	Exclusionsetting plugin.TValue[string]
}

// createAuditpolEntry creates a new instance of this resource
func createAuditpolEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuditpolEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("auditpol.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuditpolEntry) MqlName() string {
	return "auditpol.entry"
}

func (c *mqlAuditpolEntry) MqlID() string {
	return c.__id
}

func (c *mqlAuditpolEntry) GetMachinename() *plugin.TValue[string] {
	return &c.Machinename
}

func (c *mqlAuditpolEntry) GetPolicytarget() *plugin.TValue[string] {
	return &c.Policytarget
}

func (c *mqlAuditpolEntry) GetSubcategory() *plugin.TValue[string] {
	return &c.Subcategory
}

func (c *mqlAuditpolEntry) GetSubcategoryguid() *plugin.TValue[string] {
	return &c.Subcategoryguid
}

func (c *mqlAuditpolEntry) GetInclusionsetting() *plugin.TValue[string] {
	return &c.Inclusionsetting
}

func (c *mqlAuditpolEntry) GetExclusionsetting() *plugin.TValue[string] {
	return &c.Exclusionsetting
}

// mqlSecpol for the secpol resource
type mqlSecpol struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlSecpolInternal
	Systemaccess plugin.TValue[map[string]interface{}]
	Eventaudit plugin.TValue[map[string]interface{}]
	Registryvalues plugin.TValue[map[string]interface{}]
	Privilegerights plugin.TValue[map[string]interface{}]
}

// createSecpol creates a new instance of this resource
func createSecpol(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSecpol{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("secpol", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSecpol) MqlName() string {
	return "secpol"
}

func (c *mqlSecpol) MqlID() string {
	return c.__id
}

func (c *mqlSecpol) GetSystemaccess() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Systemaccess, func() (map[string]interface{}, error) {
		return c.systemaccess()
	})
}

func (c *mqlSecpol) GetEventaudit() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Eventaudit, func() (map[string]interface{}, error) {
		return c.eventaudit()
	})
}

func (c *mqlSecpol) GetRegistryvalues() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Registryvalues, func() (map[string]interface{}, error) {
		return c.registryvalues()
	})
}

func (c *mqlSecpol) GetPrivilegerights() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Privilegerights, func() (map[string]interface{}, error) {
		return c.privilegerights()
	})
}

// mqlNtpConf for the ntp.conf resource
type mqlNtpConf struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlNtpConfInternal it will be used here
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Settings plugin.TValue[[]interface{}]
	Servers plugin.TValue[[]interface{}]
	Restrict plugin.TValue[[]interface{}]
	Fudge plugin.TValue[[]interface{}]
}

// createNtpConf creates a new instance of this resource
func createNtpConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlNtpConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ntp.conf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlNtpConf) MqlName() string {
	return "ntp.conf"
}

func (c *mqlNtpConf) MqlID() string {
	return c.__id
}

func (c *mqlNtpConf) GetFile() *plugin.TValue[*mqlFile] {
	return plugin.GetOrCompute[*mqlFile](&c.File, func() (*mqlFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ntp.conf", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlNtpConf) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlNtpConf) GetSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Settings, func() ([]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.settings(vargContent.Data)
	})
}

func (c *mqlNtpConf) GetServers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Servers, func() ([]interface{}, error) {
		vargSettings := c.GetSettings()
		if vargSettings.Error != nil {
			return nil, vargSettings.Error
		}

		return c.servers(vargSettings.Data)
	})
}

func (c *mqlNtpConf) GetRestrict() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Restrict, func() ([]interface{}, error) {
		vargSettings := c.GetSettings()
		if vargSettings.Error != nil {
			return nil, vargSettings.Error
		}

		return c.restrict(vargSettings.Data)
	})
}

func (c *mqlNtpConf) GetFudge() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Fudge, func() ([]interface{}, error) {
		vargSettings := c.GetSettings()
		if vargSettings.Error != nil {
			return nil, vargSettings.Error
		}

		return c.fudge(vargSettings.Data)
	})
}

// mqlRsyslogConf for the rsyslog.conf resource
type mqlRsyslogConf struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlRsyslogConfInternal it will be used here
	Path plugin.TValue[string]
	Files plugin.TValue[[]interface{}]
	Content plugin.TValue[string]
	Settings plugin.TValue[[]interface{}]
}

// createRsyslogConf creates a new instance of this resource
func createRsyslogConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlRsyslogConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("rsyslog.conf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlRsyslogConf) MqlName() string {
	return "rsyslog.conf"
}

func (c *mqlRsyslogConf) MqlID() string {
	return c.__id
}

func (c *mqlRsyslogConf) GetPath() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Path, func() (string, error) {
		return c.path()
	})
}

func (c *mqlRsyslogConf) GetFiles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Files, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("rsyslog.conf", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return nil, vargPath.Error
		}

		return c.files(vargPath.Data)
	})
}

func (c *mqlRsyslogConf) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return "", vargFiles.Error
		}

		return c.content(vargFiles.Data)
	})
}

func (c *mqlRsyslogConf) GetSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Settings, func() ([]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.settings(vargContent.Data)
	})
}

// mqlLogindefs for the logindefs resource
type mqlLogindefs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlLogindefsInternal it will be used here
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	Params plugin.TValue[map[string]interface{}]
}

// createLogindefs creates a new instance of this resource
func createLogindefs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlLogindefs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("logindefs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlLogindefs) MqlName() string {
	return "logindefs"
}

func (c *mqlLogindefs) MqlID() string {
	return c.__id
}

func (c *mqlLogindefs) GetFile() *plugin.TValue[*mqlFile] {
	return plugin.GetOrCompute[*mqlFile](&c.File, func() (*mqlFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("logindefs", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlLogindefs) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlLogindefs) GetParams() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Params, func() (map[string]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

// mqlLsblk for the lsblk resource
type mqlLsblk struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlLsblkInternal it will be used here
	List plugin.TValue[[]interface{}]
}

// createLsblk creates a new instance of this resource
func createLsblk(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlLsblk{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("lsblk", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlLsblk) MqlName() string {
	return "lsblk"
}

func (c *mqlLsblk) MqlID() string {
	return c.__id
}

func (c *mqlLsblk) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("lsblk", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlLsblkEntry for the lsblk.entry resource
type mqlLsblkEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlLsblkEntryInternal it will be used here
	Name plugin.TValue[string]
	Fstype plugin.TValue[string]
	Label plugin.TValue[string]
	Uuid plugin.TValue[string]
	Mountpoints plugin.TValue[[]interface{}]
}

// createLsblkEntry creates a new instance of this resource
func createLsblkEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlLsblkEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("lsblk.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlLsblkEntry) MqlName() string {
	return "lsblk.entry"
}

func (c *mqlLsblkEntry) MqlID() string {
	return c.__id
}

func (c *mqlLsblkEntry) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlLsblkEntry) GetFstype() *plugin.TValue[string] {
	return &c.Fstype
}

func (c *mqlLsblkEntry) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlLsblkEntry) GetUuid() *plugin.TValue[string] {
	return &c.Uuid
}

func (c *mqlLsblkEntry) GetMountpoints() *plugin.TValue[[]interface{}] {
	return &c.Mountpoints
}

// mqlMount for the mount resource
type mqlMount struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMountInternal it will be used here
	List plugin.TValue[[]interface{}]
}

// createMount creates a new instance of this resource
func createMount(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMount{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("mount", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMount) MqlName() string {
	return "mount"
}

func (c *mqlMount) MqlID() string {
	return c.__id
}

func (c *mqlMount) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("mount", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlMountPoint for the mount.point resource
type mqlMountPoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlMountPointInternal it will be used here
	Device plugin.TValue[string]
	Path plugin.TValue[string]
	Fstype plugin.TValue[string]
	Options plugin.TValue[map[string]interface{}]
	Mounted plugin.TValue[bool]
}

// createMountPoint creates a new instance of this resource
func createMountPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlMountPoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("mount.point", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlMountPoint) MqlName() string {
	return "mount.point"
}

func (c *mqlMountPoint) MqlID() string {
	return c.__id
}

func (c *mqlMountPoint) GetDevice() *plugin.TValue[string] {
	return &c.Device
}

func (c *mqlMountPoint) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlMountPoint) GetFstype() *plugin.TValue[string] {
	return &c.Fstype
}

func (c *mqlMountPoint) GetOptions() *plugin.TValue[map[string]interface{}] {
	return &c.Options
}

func (c *mqlMountPoint) GetMounted() *plugin.TValue[bool] {
	return &c.Mounted
}

// mqlShadow for the shadow resource
type mqlShadow struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlShadowInternal it will be used here
	List plugin.TValue[[]interface{}]
}

// createShadow creates a new instance of this resource
func createShadow(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlShadow{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("shadow", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlShadow) MqlName() string {
	return "shadow"
}

func (c *mqlShadow) MqlID() string {
	return c.__id
}

func (c *mqlShadow) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("shadow", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlShadowEntry for the shadow.entry resource
type mqlShadowEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlShadowEntryInternal it will be used here
	User plugin.TValue[string]
	Password plugin.TValue[string]
	Lastchanged plugin.TValue[*time.Time]
	Mindays plugin.TValue[int64]
	Maxdays plugin.TValue[int64]
	Warndays plugin.TValue[int64]
	Inactivedays plugin.TValue[int64]
	Expirydates plugin.TValue[string]
	Reserved plugin.TValue[string]
}

// createShadowEntry creates a new instance of this resource
func createShadowEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlShadowEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("shadow.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlShadowEntry) MqlName() string {
	return "shadow.entry"
}

func (c *mqlShadowEntry) MqlID() string {
	return c.__id
}

func (c *mqlShadowEntry) GetUser() *plugin.TValue[string] {
	return &c.User
}

func (c *mqlShadowEntry) GetPassword() *plugin.TValue[string] {
	return &c.Password
}

func (c *mqlShadowEntry) GetLastchanged() *plugin.TValue[*time.Time] {
	return &c.Lastchanged
}

func (c *mqlShadowEntry) GetMindays() *plugin.TValue[int64] {
	return &c.Mindays
}

func (c *mqlShadowEntry) GetMaxdays() *plugin.TValue[int64] {
	return &c.Maxdays
}

func (c *mqlShadowEntry) GetWarndays() *plugin.TValue[int64] {
	return &c.Warndays
}

func (c *mqlShadowEntry) GetInactivedays() *plugin.TValue[int64] {
	return &c.Inactivedays
}

func (c *mqlShadowEntry) GetExpirydates() *plugin.TValue[string] {
	return &c.Expirydates
}

func (c *mqlShadowEntry) GetReserved() *plugin.TValue[string] {
	return &c.Reserved
}

// mqlYum for the yum resource
type mqlYum struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlYumInternal it will be used here
	Vars plugin.TValue[map[string]interface{}]
	Repos plugin.TValue[[]interface{}]
}

// createYum creates a new instance of this resource
func createYum(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlYum{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("yum", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlYum) MqlName() string {
	return "yum"
}

func (c *mqlYum) MqlID() string {
	return c.__id
}

func (c *mqlYum) GetVars() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Vars, func() (map[string]interface{}, error) {
		return c.vars()
	})
}

func (c *mqlYum) GetRepos() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Repos, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("yum", c.__id, "repos")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.repos()
	})
}

// mqlYumRepo for the yum.repo resource
type mqlYumRepo struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlYumRepoInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Baseurl plugin.TValue[[]interface{}]
	Expire plugin.TValue[string]
	Filename plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Revision plugin.TValue[string]
	Pkgs plugin.TValue[string]
	Size plugin.TValue[string]
	Mirrors plugin.TValue[string]
	Enabled plugin.TValue[bool]
}

// createYumRepo creates a new instance of this resource
func createYumRepo(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlYumRepo{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("yum.repo", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlYumRepo) MqlName() string {
	return "yum.repo"
}

func (c *mqlYumRepo) MqlID() string {
	return c.__id
}

func (c *mqlYumRepo) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlYumRepo) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlYumRepo) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlYumRepo) GetBaseurl() *plugin.TValue[[]interface{}] {
	return &c.Baseurl
}

func (c *mqlYumRepo) GetExpire() *plugin.TValue[string] {
	return &c.Expire
}

func (c *mqlYumRepo) GetFilename() *plugin.TValue[string] {
	return &c.Filename
}

func (c *mqlYumRepo) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlYumRepo) GetRevision() *plugin.TValue[string] {
	return &c.Revision
}

func (c *mqlYumRepo) GetPkgs() *plugin.TValue[string] {
	return &c.Pkgs
}

func (c *mqlYumRepo) GetSize() *plugin.TValue[string] {
	return &c.Size
}

func (c *mqlYumRepo) GetMirrors() *plugin.TValue[string] {
	return &c.Mirrors
}

func (c *mqlYumRepo) GetEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Enabled, func() (bool, error) {
		return c.enabled()
	})
}

// mqlRegistrykey for the registrykey resource
type mqlRegistrykey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlRegistrykeyInternal it will be used here
	Path plugin.TValue[string]
	Exists plugin.TValue[bool]
	Properties plugin.TValue[map[string]interface{}]
	Children plugin.TValue[[]interface{}]
}

// createRegistrykey creates a new instance of this resource
func createRegistrykey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlRegistrykey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("registrykey", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlRegistrykey) MqlName() string {
	return "registrykey"
}

func (c *mqlRegistrykey) MqlID() string {
	return c.__id
}

func (c *mqlRegistrykey) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlRegistrykey) GetExists() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Exists, func() (bool, error) {
		return c.exists()
	})
}

func (c *mqlRegistrykey) GetProperties() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Properties, func() (map[string]interface{}, error) {
		return c.properties()
	})
}

func (c *mqlRegistrykey) GetChildren() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Children, func() ([]interface{}, error) {
		return c.children()
	})
}

// mqlRegistrykeyProperty for the registrykey.property resource
type mqlRegistrykeyProperty struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlRegistrykeyPropertyInternal
	Path plugin.TValue[string]
	Name plugin.TValue[string]
	Exists plugin.TValue[bool]
	Value plugin.TValue[string]
}

// createRegistrykeyProperty creates a new instance of this resource
func createRegistrykeyProperty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlRegistrykeyProperty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("registrykey.property", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlRegistrykeyProperty) MqlName() string {
	return "registrykey.property"
}

func (c *mqlRegistrykeyProperty) MqlID() string {
	return c.__id
}

func (c *mqlRegistrykeyProperty) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlRegistrykeyProperty) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlRegistrykeyProperty) GetExists() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Exists, func() (bool, error) {
		return c.exists()
	})
}

func (c *mqlRegistrykeyProperty) GetValue() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Value, func() (string, error) {
		vargExists := c.GetExists()
		if vargExists.Error != nil {
			return "", vargExists.Error
		}

		return c.value(vargExists.Data)
	})
}

// mqlContainerImage for the container.image resource
type mqlContainerImage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlContainerImageInternal it will be used here
	Reference plugin.TValue[string]
	Name plugin.TValue[string]
	Identifier plugin.TValue[string]
	IdentifierType plugin.TValue[string]
	Repository plugin.TValue[*mqlContainerRepository]
}

// createContainerImage creates a new instance of this resource
func createContainerImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlContainerImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("container.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlContainerImage) MqlName() string {
	return "container.image"
}

func (c *mqlContainerImage) MqlID() string {
	return c.__id
}

func (c *mqlContainerImage) GetReference() *plugin.TValue[string] {
	return &c.Reference
}

func (c *mqlContainerImage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlContainerImage) GetIdentifier() *plugin.TValue[string] {
	return &c.Identifier
}

func (c *mqlContainerImage) GetIdentifierType() *plugin.TValue[string] {
	return &c.IdentifierType
}

func (c *mqlContainerImage) GetRepository() *plugin.TValue[*mqlContainerRepository] {
	return plugin.GetOrCompute[*mqlContainerRepository](&c.Repository, func() (*mqlContainerRepository, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("container.image", c.__id, "repository")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlContainerRepository), nil
			}
		}

		return c.repository()
	})
}

// mqlContainerRepository for the container.repository resource
type mqlContainerRepository struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlContainerRepositoryInternal it will be used here
	Name plugin.TValue[string]
	Scheme plugin.TValue[string]
	FullName plugin.TValue[string]
	Registry plugin.TValue[string]
}

// createContainerRepository creates a new instance of this resource
func createContainerRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlContainerRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("container.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlContainerRepository) MqlName() string {
	return "container.repository"
}

func (c *mqlContainerRepository) MqlID() string {
	return c.__id
}

func (c *mqlContainerRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlContainerRepository) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlContainerRepository) GetFullName() *plugin.TValue[string] {
	return &c.FullName
}

func (c *mqlContainerRepository) GetRegistry() *plugin.TValue[string] {
	return &c.Registry
}

// mqlKubelet for the kubelet resource
type mqlKubelet struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlKubeletInternal it will be used here
	ConfigFile plugin.TValue[*mqlFile]
	Process plugin.TValue[*mqlProcess]
	Configuration plugin.TValue[interface{}]
}

// createKubelet creates a new instance of this resource
func createKubelet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlKubelet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("kubelet", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlKubelet) MqlName() string {
	return "kubelet"
}

func (c *mqlKubelet) MqlID() string {
	return c.__id
}

func (c *mqlKubelet) GetConfigFile() *plugin.TValue[*mqlFile] {
	return &c.ConfigFile
}

func (c *mqlKubelet) GetProcess() *plugin.TValue[*mqlProcess] {
	return &c.Process
}

func (c *mqlKubelet) GetConfiguration() *plugin.TValue[interface{}] {
	return &c.Configuration
}

// mqlPython for the python resource
type mqlPython struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPythonInternal it will be used here
	Path plugin.TValue[string]
	Packages plugin.TValue[[]interface{}]
	Toplevel plugin.TValue[[]interface{}]
}

// createPython creates a new instance of this resource
func createPython(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPython{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("python", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPython) MqlName() string {
	return "python"
}

func (c *mqlPython) MqlID() string {
	return c.__id
}

func (c *mqlPython) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlPython) GetPackages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Packages, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("python", c.__id, "packages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.packages()
	})
}

func (c *mqlPython) GetToplevel() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Toplevel, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("python", c.__id, "toplevel")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.toplevel()
	})
}

// mqlPythonPackage for the python.package resource
type mqlPythonPackage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPythonPackageInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Version plugin.TValue[string]
	License plugin.TValue[string]
	Author plugin.TValue[string]
	Summary plugin.TValue[string]
	Dependencies plugin.TValue[[]interface{}]
}

// createPythonPackage creates a new instance of this resource
func createPythonPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPythonPackage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("python.package", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPythonPackage) MqlName() string {
	return "python.package"
}

func (c *mqlPythonPackage) MqlID() string {
	return c.__id
}

func (c *mqlPythonPackage) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlPythonPackage) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlPythonPackage) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlPythonPackage) GetVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Version, func() (string, error) {
		return c.version()
	})
}

func (c *mqlPythonPackage) GetLicense() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.License, func() (string, error) {
		return c.license()
	})
}

func (c *mqlPythonPackage) GetAuthor() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Author, func() (string, error) {
		return c.author()
	})
}

func (c *mqlPythonPackage) GetSummary() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Summary, func() (string, error) {
		return c.summary()
	})
}

func (c *mqlPythonPackage) GetDependencies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Dependencies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("python.package", c.__id, "dependencies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dependencies()
	})
}
