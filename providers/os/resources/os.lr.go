// Code generated by resources. DO NOT EDIT.
package resources

import (
	"errors"

	"go.mondoo.com/cnquery/llx"
	"go.mondoo.com/cnquery/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"command": {
			// to override args, implement: initCommand(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createCommand,
		},
		"file": {
			// to override args, implement: initFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFile,
		},
		"file.permissions": {
			// to override args, implement: initFilePermissions(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createFilePermissions,
		},
		"user": {
			Init: initUser,
			Create: createUser,
		},
		"users": {
			// to override args, implement: initUsers(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createUsers,
		},
		"authorizedkeys": {
			Init: initAuthorizedkeys,
			Create: createAuthorizedkeys,
		},
		"authorizedkeys.entry": {
			// to override args, implement: initAuthorizedkeysEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAuthorizedkeysEntry,
		},
		"group": {
			// to override args, implement: initGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGroup,
		},
		"groups": {
			// to override args, implement: initGroups(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createGroups,
		},
		"package": {
			// to override args, implement: initPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPackage,
		},
		"packages": {
			// to override args, implement: initPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPackages,
		},
		"sshd": {
			// to override args, implement: initSshd(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createSshd,
		},
		"sshd.config": {
			Init: initSshdConfig,
			Create: createSshdConfig,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		var err error
		var res plugin.Resource
		args, res, err = f.Init(runtime, args)
		if err != nil || res != nil {
			return res, err
		}
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"command.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetCommand()).ToDataRes(types.String)
	},
	"command.stdout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStdout()).ToDataRes(types.String)
	},
	"command.stderr": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetStderr()).ToDataRes(types.String)
	},
	"command.exitcode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCommand).GetExitcode()).ToDataRes(types.Int)
	},
	"file.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPath()).ToDataRes(types.String)
	},
	"file.basename": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetBasename()).ToDataRes(types.String)
	},
	"file.dirname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetDirname()).ToDataRes(types.String)
	},
	"file.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetContent()).ToDataRes(types.String)
	},
	"file.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetExists()).ToDataRes(types.Bool)
	},
	"file.permissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetPermissions()).ToDataRes(types.Resource("file.permissions"))
	},
	"file.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetSize()).ToDataRes(types.Int)
	},
	"file.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetUser()).ToDataRes(types.Resource("user"))
	},
	"file.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"file.empty": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFile).GetEmpty()).ToDataRes(types.Bool)
	},
	"file.permissions.mode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetMode()).ToDataRes(types.Int)
	},
	"file.permissions.user_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.user_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetUser_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.group_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetGroup_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_readable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_readable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_writeable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_writeable()).ToDataRes(types.Bool)
	},
	"file.permissions.other_executable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetOther_executable()).ToDataRes(types.Bool)
	},
	"file.permissions.suid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSuid()).ToDataRes(types.Bool)
	},
	"file.permissions.sgid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSgid()).ToDataRes(types.Bool)
	},
	"file.permissions.sticky": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetSticky()).ToDataRes(types.Bool)
	},
	"file.permissions.isDirectory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsDirectory()).ToDataRes(types.Bool)
	},
	"file.permissions.isFile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsFile()).ToDataRes(types.Bool)
	},
	"file.permissions.isSymlink": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetIsSymlink()).ToDataRes(types.Bool)
	},
	"file.permissions.string": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlFilePermissions).GetString()).ToDataRes(types.String)
	},
	"user.uid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetUid()).ToDataRes(types.Int)
	},
	"user.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGid()).ToDataRes(types.Int)
	},
	"user.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetSid()).ToDataRes(types.String)
	},
	"user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetName()).ToDataRes(types.String)
	},
	"user.home": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetHome()).ToDataRes(types.String)
	},
	"user.shell": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetShell()).ToDataRes(types.String)
	},
	"user.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetEnabled()).ToDataRes(types.Bool)
	},
	"user.authorizedkeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetAuthorizedkeys()).ToDataRes(types.Resource("authorizedkeys"))
	},
	"user.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUser).GetGroup()).ToDataRes(types.Resource("group"))
	},
	"users.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUsers).GetList()).ToDataRes(types.Array(types.Resource("user")))
	},
	"authorizedkeys.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetPath()).ToDataRes(types.String)
	},
	"authorizedkeys.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetFile()).ToDataRes(types.Resource("file"))
	},
	"authorizedkeys.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetContent()).ToDataRes(types.String)
	},
	"authorizedkeys.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeys).GetList()).ToDataRes(types.Array(types.Resource("authorizedkeys.entry")))
	},
	"authorizedkeys.entry.line": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetLine()).ToDataRes(types.Int)
	},
	"authorizedkeys.entry.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetType()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetKey()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetLabel()).ToDataRes(types.String)
	},
	"authorizedkeys.entry.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetOptions()).ToDataRes(types.Array(types.String))
	},
	"authorizedkeys.entry.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAuthorizedkeysEntry).GetFile()).ToDataRes(types.Resource("file"))
	},
	"group.gid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetGid()).ToDataRes(types.Int)
	},
	"group.sid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetSid()).ToDataRes(types.String)
	},
	"group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetName()).ToDataRes(types.String)
	},
	"group.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroup).GetMembers()).ToDataRes(types.Array(types.Resource("user")))
	},
	"groups.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlGroups).GetList()).ToDataRes(types.Array(types.Resource("group")))
	},
	"package.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetName()).ToDataRes(types.String)
	},
	"package.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetVersion()).ToDataRes(types.String)
	},
	"package.arch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetArch()).ToDataRes(types.String)
	},
	"package.epoch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetEpoch()).ToDataRes(types.String)
	},
	"package.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetFormat()).ToDataRes(types.String)
	},
	"package.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetStatus()).ToDataRes(types.String)
	},
	"package.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetDescription()).ToDataRes(types.String)
	},
	"package.origin": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetOrigin()).ToDataRes(types.String)
	},
	"package.available": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetAvailable()).ToDataRes(types.String)
	},
	"package.installed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetInstalled()).ToDataRes(types.Bool)
	},
	"package.outdated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackage).GetOutdated()).ToDataRes(types.Bool)
	},
	"packages.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPackages).GetList()).ToDataRes(types.Array(types.Resource("package")))
	},
	"sshd.config.file": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetFile()).ToDataRes(types.Resource("file"))
	},
	"sshd.config.files": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetFiles()).ToDataRes(types.Array(types.Resource("file")))
	},
	"sshd.config.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetContent()).ToDataRes(types.String)
	},
	"sshd.config.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"sshd.config.ciphers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetCiphers()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.macs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetMacs()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.kexs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetKexs()).ToDataRes(types.Array(types.String))
	},
	"sshd.config.hostkeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSshdConfig).GetHostkeys()).ToDataRes(types.Array(types.String))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"command.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlCommand).__id, ok = v.Value.(string)
			return
		},
	"command.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Command, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.stdout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Stdout, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.stderr": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Stderr, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"command.exitcode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCommand).Exitcode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFile).__id, ok = v.Value.(string)
			return
		},
	"file.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.basename": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Basename, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.dirname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Dirname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"file.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Permissions, ok = plugin.RawToTValue[*mqlFilePermissions](v.Value, v.Error)
		return
	},
	"file.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).User, ok = plugin.RawToTValue[*mqlUser](v.Value, v.Error)
		return
	},
	"file.group": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Group, ok = plugin.RawToTValue[*mqlGroup](v.Value, v.Error)
		return
	},
	"file.empty": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFile).Empty, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlFilePermissions).__id, ok = v.Value.(string)
			return
		},
	"file.permissions.mode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Mode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"file.permissions.user_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.user_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.user_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).User_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.group_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Group_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_readable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_readable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_writeable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_writeable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.other_executable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Other_executable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.suid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Suid, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.sgid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Sgid, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.sticky": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).Sticky, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isDirectory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsDirectory, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isFile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsFile, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.isSymlink": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).IsSymlink, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"file.permissions.string": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlFilePermissions).String, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlUser).__id, ok = v.Value.(string)
			return
		},
	"user.uid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Uid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"user.gid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Gid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"user.sid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Sid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.home": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Home, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.shell": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Shell, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"user.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"user.authorizedkeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Authorizedkeys, ok = plugin.RawToTValue[*mqlAuthorizedkeys](v.Value, v.Error)
		return
	},
	"user.group": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUser).Group, ok = plugin.RawToTValue[*mqlGroup](v.Value, v.Error)
		return
	},
	"users.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlUsers).__id, ok = v.Value.(string)
			return
		},
	"users.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUsers).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuthorizedkeys).__id, ok = v.Value.(string)
			return
		},
	"authorizedkeys.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"authorizedkeys.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeys).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAuthorizedkeysEntry).__id, ok = v.Value.(string)
			return
		},
	"authorizedkeys.entry.line": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Line, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).Options, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"authorizedkeys.entry.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAuthorizedkeysEntry).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlGroup).__id, ok = v.Value.(string)
			return
		},
	"group.gid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Gid, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"group.sid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Sid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"group.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroup).Members, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"groups.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlGroups).__id, ok = v.Value.(string)
			return
		},
	"groups.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlGroups).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"package.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPackage).__id, ok = v.Value.(string)
			return
		},
	"package.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.arch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Arch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.epoch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Epoch, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.origin": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Origin, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.available": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Available, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"package.installed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Installed, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"package.outdated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackage).Outdated, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"packages.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPackages).__id, ok = v.Value.(string)
			return
		},
	"packages.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPackages).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSshd).__id, ok = v.Value.(string)
			return
		},
	"sshd.config.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSshdConfig).__id, ok = v.Value.(string)
			return
		},
	"sshd.config.file": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).File, ok = plugin.RawToTValue[*mqlFile](v.Value, v.Error)
		return
	},
	"sshd.config.files": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Files, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"sshd.config.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.ciphers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Ciphers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.macs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Macs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.kexs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Kexs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"sshd.config.hostkeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSshdConfig).Hostkeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[os] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[os] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlCommand for the command resource
type mqlCommand struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlCommandInternal

	Command plugin.TValue[string]
	Stdout plugin.TValue[string]
	Stderr plugin.TValue[string]
	Exitcode plugin.TValue[int64]
}

// createCommand creates a new instance of this resource
func createCommand(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlCommand{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("command", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlCommand) MqlName() string {
	return "command"
}

func (c *mqlCommand) MqlID() string {
	return c.__id
}

func (c *mqlCommand) GetCommand() *plugin.TValue[string] {
	return &c.Command
}

func (c *mqlCommand) GetStdout() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stdout, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}

		return c.stdout(vargCommand.Data)
	})
}

func (c *mqlCommand) GetStderr() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Stderr, func() (string, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return "", vargCommand.Error
		}

		return c.stderr(vargCommand.Data)
	})
}

func (c *mqlCommand) GetExitcode() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Exitcode, func() (int64, error) {
		vargCommand := c.GetCommand()
		if vargCommand.Error != nil {
			return 0, vargCommand.Error
		}

		return c.exitcode(vargCommand.Data)
	})
}

// mqlFile for the file resource
type mqlFile struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFileInternal it will be used here

	Path plugin.TValue[string]
	Basename plugin.TValue[string]
	Dirname plugin.TValue[string]
	Content plugin.TValue[string]
	Exists plugin.TValue[bool]
	Permissions plugin.TValue[*mqlFilePermissions]
	Size plugin.TValue[int64]
	User plugin.TValue[*mqlUser]
	Group plugin.TValue[*mqlGroup]
	Empty plugin.TValue[bool]
}

// createFile creates a new instance of this resource
func createFile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("file", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFile) MqlName() string {
	return "file"
}

func (c *mqlFile) MqlID() string {
	return c.__id
}

func (c *mqlFile) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlFile) GetBasename() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Basename, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		return c.basename(vargPath.Data)
	})
}

func (c *mqlFile) GetDirname() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Dirname, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		return c.dirname(vargPath.Data)
	})
}

func (c *mqlFile) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return "", vargPath.Error
		}

		vargExists := c.GetExists()
		if vargExists.Error != nil {
			return "", vargExists.Error
		}

		return c.content(vargPath.Data, vargExists.Data)
	})
}

func (c *mqlFile) GetExists() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Exists, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}

		return c.exists(vargPath.Data)
	})
}

func (c *mqlFile) GetPermissions() *plugin.TValue[*mqlFilePermissions] {
	return plugin.GetOrCompute[*mqlFilePermissions](&c.Permissions, func() (*mqlFilePermissions, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "permissions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFilePermissions), nil
			}
		}

		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return nil, vargPath.Error
		}

		return c.permissions(vargPath.Data)
	})
}

func (c *mqlFile) GetSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Size, func() (int64, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return 0, vargPath.Error
		}

		return c.size(vargPath.Data)
	})
}

func (c *mqlFile) GetUser() *plugin.TValue[*mqlUser] {
	return plugin.GetOrCompute[*mqlUser](&c.User, func() (*mqlUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlFile) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("file", c.__id, "group")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGroup), nil
			}
		}

		return c.group()
	})
}

func (c *mqlFile) GetEmpty() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Empty, func() (bool, error) {
		vargPath := c.GetPath()
		if vargPath.Error != nil {
			return false, vargPath.Error
		}

		return c.empty(vargPath.Data)
	})
}

// mqlFilePermissions for the file.permissions resource
type mqlFilePermissions struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlFilePermissionsInternal it will be used here

	Mode plugin.TValue[int64]
	User_readable plugin.TValue[bool]
	User_writeable plugin.TValue[bool]
	User_executable plugin.TValue[bool]
	Group_readable plugin.TValue[bool]
	Group_writeable plugin.TValue[bool]
	Group_executable plugin.TValue[bool]
	Other_readable plugin.TValue[bool]
	Other_writeable plugin.TValue[bool]
	Other_executable plugin.TValue[bool]
	Suid plugin.TValue[bool]
	Sgid plugin.TValue[bool]
	Sticky plugin.TValue[bool]
	IsDirectory plugin.TValue[bool]
	IsFile plugin.TValue[bool]
	IsSymlink plugin.TValue[bool]
	String plugin.TValue[string]
}

// createFilePermissions creates a new instance of this resource
func createFilePermissions(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlFilePermissions{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("file.permissions", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlFilePermissions) MqlName() string {
	return "file.permissions"
}

func (c *mqlFilePermissions) MqlID() string {
	return c.__id
}

func (c *mqlFilePermissions) GetMode() *plugin.TValue[int64] {
	return &c.Mode
}

func (c *mqlFilePermissions) GetUser_readable() *plugin.TValue[bool] {
	return &c.User_readable
}

func (c *mqlFilePermissions) GetUser_writeable() *plugin.TValue[bool] {
	return &c.User_writeable
}

func (c *mqlFilePermissions) GetUser_executable() *plugin.TValue[bool] {
	return &c.User_executable
}

func (c *mqlFilePermissions) GetGroup_readable() *plugin.TValue[bool] {
	return &c.Group_readable
}

func (c *mqlFilePermissions) GetGroup_writeable() *plugin.TValue[bool] {
	return &c.Group_writeable
}

func (c *mqlFilePermissions) GetGroup_executable() *plugin.TValue[bool] {
	return &c.Group_executable
}

func (c *mqlFilePermissions) GetOther_readable() *plugin.TValue[bool] {
	return &c.Other_readable
}

func (c *mqlFilePermissions) GetOther_writeable() *plugin.TValue[bool] {
	return &c.Other_writeable
}

func (c *mqlFilePermissions) GetOther_executable() *plugin.TValue[bool] {
	return &c.Other_executable
}

func (c *mqlFilePermissions) GetSuid() *plugin.TValue[bool] {
	return &c.Suid
}

func (c *mqlFilePermissions) GetSgid() *plugin.TValue[bool] {
	return &c.Sgid
}

func (c *mqlFilePermissions) GetSticky() *plugin.TValue[bool] {
	return &c.Sticky
}

func (c *mqlFilePermissions) GetIsDirectory() *plugin.TValue[bool] {
	return &c.IsDirectory
}

func (c *mqlFilePermissions) GetIsFile() *plugin.TValue[bool] {
	return &c.IsFile
}

func (c *mqlFilePermissions) GetIsSymlink() *plugin.TValue[bool] {
	return &c.IsSymlink
}

func (c *mqlFilePermissions) GetString() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.String, func() (string, error) {
		return c.string()
	})
}

// mqlUser for the user resource
type mqlUser struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlUserInternal it will be used here

	Uid plugin.TValue[int64]
	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Home plugin.TValue[string]
	Shell plugin.TValue[string]
	Enabled plugin.TValue[bool]
	Authorizedkeys plugin.TValue[*mqlAuthorizedkeys]
	Group plugin.TValue[*mqlGroup]
}

// createUser creates a new instance of this resource
func createUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlUser) MqlName() string {
	return "user"
}

func (c *mqlUser) MqlID() string {
	return c.__id
}

func (c *mqlUser) GetUid() *plugin.TValue[int64] {
	return &c.Uid
}

func (c *mqlUser) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlUser) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlUser) GetHome() *plugin.TValue[string] {
	return &c.Home
}

func (c *mqlUser) GetShell() *plugin.TValue[string] {
	return &c.Shell
}

func (c *mqlUser) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlUser) GetAuthorizedkeys() *plugin.TValue[*mqlAuthorizedkeys] {
	return plugin.GetOrCompute[*mqlAuthorizedkeys](&c.Authorizedkeys, func() (*mqlAuthorizedkeys, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("user", c.__id, "authorizedkeys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAuthorizedkeys), nil
			}
		}

		vargHome := c.GetHome()
		if vargHome.Error != nil {
			return nil, vargHome.Error
		}

		return c.authorizedkeys(vargHome.Data)
	})
}

func (c *mqlUser) GetGroup() *plugin.TValue[*mqlGroup] {
	return plugin.GetOrCompute[*mqlGroup](&c.Group, func() (*mqlGroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("user", c.__id, "group")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlGroup), nil
			}
		}

		vargGid := c.GetGid()
		if vargGid.Error != nil {
			return nil, vargGid.Error
		}

		return c.group(vargGid.Data)
	})
}

// mqlUsers for the users resource
type mqlUsers struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlUsersInternal

	List plugin.TValue[[]interface{}]
}

// createUsers creates a new instance of this resource
func createUsers(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlUsers{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("users", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlUsers) MqlName() string {
	return "users"
}

func (c *mqlUsers) MqlID() string {
	return c.__id
}

func (c *mqlUsers) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("users", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlAuthorizedkeys for the authorizedkeys resource
type mqlAuthorizedkeys struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuthorizedkeysInternal it will be used here

	Path plugin.TValue[string]
	File plugin.TValue[*mqlFile]
	Content plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createAuthorizedkeys creates a new instance of this resource
func createAuthorizedkeys(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuthorizedkeys{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("authorizedkeys", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuthorizedkeys) MqlName() string {
	return "authorizedkeys"
}

func (c *mqlAuthorizedkeys) MqlID() string {
	return c.__id
}

func (c *mqlAuthorizedkeys) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlAuthorizedkeys) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

func (c *mqlAuthorizedkeys) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return "", vargFile.Error
		}

		return c.content(vargFile.Data)
	})
}

func (c *mqlAuthorizedkeys) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("authorizedkeys", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return nil, vargFile.Error
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.list(vargFile.Data, vargContent.Data)
	})
}

// mqlAuthorizedkeysEntry for the authorizedkeys.entry resource
type mqlAuthorizedkeysEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAuthorizedkeysEntryInternal it will be used here

	Line plugin.TValue[int64]
	Type plugin.TValue[string]
	Key plugin.TValue[string]
	Label plugin.TValue[string]
	Options plugin.TValue[[]interface{}]
	File plugin.TValue[*mqlFile]
}

// createAuthorizedkeysEntry creates a new instance of this resource
func createAuthorizedkeysEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAuthorizedkeysEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("authorizedkeys.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAuthorizedkeysEntry) MqlName() string {
	return "authorizedkeys.entry"
}

func (c *mqlAuthorizedkeysEntry) MqlID() string {
	return c.__id
}

func (c *mqlAuthorizedkeysEntry) GetLine() *plugin.TValue[int64] {
	return &c.Line
}

func (c *mqlAuthorizedkeysEntry) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAuthorizedkeysEntry) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlAuthorizedkeysEntry) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAuthorizedkeysEntry) GetOptions() *plugin.TValue[[]interface{}] {
	return &c.Options
}

func (c *mqlAuthorizedkeysEntry) GetFile() *plugin.TValue[*mqlFile] {
	return &c.File
}

// mqlGroup for the group resource
type mqlGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlGroupInternal

	Gid plugin.TValue[int64]
	Sid plugin.TValue[string]
	Name plugin.TValue[string]
	Members plugin.TValue[[]interface{}]
}

// createGroup creates a new instance of this resource
func createGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGroup) MqlName() string {
	return "group"
}

func (c *mqlGroup) MqlID() string {
	return c.__id
}

func (c *mqlGroup) GetGid() *plugin.TValue[int64] {
	return &c.Gid
}

func (c *mqlGroup) GetSid() *plugin.TValue[string] {
	return &c.Sid
}

func (c *mqlGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlGroup) GetMembers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Members, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("group", c.__id, "members")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.members()
	})
}

// mqlGroups for the groups resource
type mqlGroups struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlGroupsInternal

	List plugin.TValue[[]interface{}]
}

// createGroups creates a new instance of this resource
func createGroups(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlGroups{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("groups", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlGroups) MqlName() string {
	return "groups"
}

func (c *mqlGroups) MqlID() string {
	return c.__id
}

func (c *mqlGroups) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("groups", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlPackage for the package resource
type mqlPackage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPackageInternal it will be used here

	Name plugin.TValue[string]
	Version plugin.TValue[string]
	Arch plugin.TValue[string]
	Epoch plugin.TValue[string]
	Format plugin.TValue[string]
	Status plugin.TValue[string]
	Description plugin.TValue[string]
	Origin plugin.TValue[string]
	Available plugin.TValue[string]
	Installed plugin.TValue[bool]
	Outdated plugin.TValue[bool]
}

// createPackage creates a new instance of this resource
func createPackage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPackage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("package", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPackage) MqlName() string {
	return "package"
}

func (c *mqlPackage) MqlID() string {
	return c.__id
}

func (c *mqlPackage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlPackage) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlPackage) GetArch() *plugin.TValue[string] {
	return &c.Arch
}

func (c *mqlPackage) GetEpoch() *plugin.TValue[string] {
	return &c.Epoch
}

func (c *mqlPackage) GetFormat() *plugin.TValue[string] {
	return &c.Format
}

func (c *mqlPackage) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlPackage) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlPackage) GetOrigin() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Origin, func() (string, error) {
		return c.origin()
	})
}

func (c *mqlPackage) GetAvailable() *plugin.TValue[string] {
	return &c.Available
}

func (c *mqlPackage) GetInstalled() *plugin.TValue[bool] {
	return &c.Installed
}

func (c *mqlPackage) GetOutdated() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Outdated, func() (bool, error) {
		return c.outdated()
	})
}

// mqlPackages for the packages resource
type mqlPackages struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlPackagesInternal

	List plugin.TValue[[]interface{}]
}

// createPackages creates a new instance of this resource
func createPackages(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPackages{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("packages", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPackages) MqlName() string {
	return "packages"
}

func (c *mqlPackages) MqlID() string {
	return c.__id
}

func (c *mqlPackages) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("packages", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlSshd for the sshd resource
type mqlSshd struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlSshdInternal it will be used here


}

// createSshd creates a new instance of this resource
func createSshd(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSshd{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("sshd", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSshd) MqlName() string {
	return "sshd"
}

func (c *mqlSshd) MqlID() string {
	return c.__id
}

// mqlSshdConfig for the sshd.config resource
type mqlSshdConfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlSshdConfigInternal it will be used here

	File plugin.TValue[*mqlFile]
	Files plugin.TValue[[]interface{}]
	Content plugin.TValue[string]
	Params plugin.TValue[map[string]interface{}]
	Ciphers plugin.TValue[[]interface{}]
	Macs plugin.TValue[[]interface{}]
	Kexs plugin.TValue[[]interface{}]
	Hostkeys plugin.TValue[[]interface{}]
}

// createSshdConfig creates a new instance of this resource
func createSshdConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSshdConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	res.__id, err = res.id()
	if err != nil {
		return nil, err
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("sshd.config", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSshdConfig) MqlName() string {
	return "sshd.config"
}

func (c *mqlSshdConfig) MqlID() string {
	return c.__id
}

func (c *mqlSshdConfig) GetFile() *plugin.TValue[*mqlFile] {
	return plugin.GetOrCompute[*mqlFile](&c.File, func() (*mqlFile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("sshd.config", c.__id, "file")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlFile), nil
			}
		}

		return c.file()
	})
}

func (c *mqlSshdConfig) GetFiles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Files, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("sshd.config", c.__id, "files")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargFile := c.GetFile()
		if vargFile.Error != nil {
			return nil, vargFile.Error
		}

		return c.files(vargFile.Data)
	})
}

func (c *mqlSshdConfig) GetContent() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Content, func() (string, error) {
		vargFiles := c.GetFiles()
		if vargFiles.Error != nil {
			return "", vargFiles.Error
		}

		return c.content(vargFiles.Data)
	})
}

func (c *mqlSshdConfig) GetParams() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Params, func() (map[string]interface{}, error) {
		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.params(vargContent.Data)
	})
}

func (c *mqlSshdConfig) GetCiphers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Ciphers, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.ciphers(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetMacs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Macs, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.macs(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetKexs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Kexs, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.kexs(vargParams.Data)
	})
}

func (c *mqlSshdConfig) GetHostkeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hostkeys, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.hostkeys(vargParams.Data)
	})
}
