// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

package networkinterface

import (
	"io"
	"net"
	"sort"
	"strings"

	"github.com/cockroachdb/errors"
	"go.mondoo.com/cnquery/v12/providers-sdk/v1/inventory"
	"go.mondoo.com/cnquery/v12/providers/os/connection/shared"
	"go.mondoo.com/cnquery/v12/providers/os/resources/powershell"
)

// netr is a helper struct to avoid passing the connection and platform
// as function arguments.
type netr struct {
	connection shared.Connection
	platform   *inventory.Platform
}

// Route represents a network route entry
type Route struct {
	Destination string
	Gateway     string
	Flags       []string
	Interface   string
	Platform    *inventory.Platform // Platform-specific flag handling
}

// Routes returns the network routes of the system.
// This function dispatches to platform-specific implementations based on runtime detection.
func Routes(conn shared.Connection, pf *inventory.Platform) ([]Route, error) {
	n := &netr{conn, pf}

	if pf.IsFamily(inventory.FAMILY_LINUX) {
		return n.detectLinuxRoutes()
	}
	if pf.IsFamily(inventory.FAMILY_DARWIN) {
		return n.detectDarwinRoutes()
	}
	if pf.IsFamily(inventory.FAMILY_WINDOWS) {
		return n.detectWindowsRoutes()
	}

	return nil, errors.New("your platform is not supported for the detection of network routes")
}

// IsDefaultRoute checks if a route is a default route (destination is 0.0.0.0/0 or ::/0)
func (r *Route) IsDefaultRoute() bool {
	return r.Destination == "0.0.0.0" || r.Destination == "0.0.0.0/0" ||
		r.Destination == "::" || r.Destination == "::/0" || r.Destination == "default"
}

// IsIPv4 checks if the route's gateway is an IPv4 address
func (r *Route) IsIPv4() bool {
	if r.Gateway == "" {
		return false
	}
	ip := net.ParseIP(r.Gateway)
	if ip == nil {
		return false
	}
	return ip.To4() != nil
}

// IsIPv6 checks if the route's gateway is an IPv6 address
func (r *Route) IsIPv6() bool {
	if r.Gateway == "" {
		return false
	}
	ip := net.ParseIP(r.Gateway)
	if ip == nil {
		return false
	}
	return ip.To4() == nil && ip.To16() != nil
}

// routeFlagsMap maps route flag bits to their human-readable names
// Based on sys/route.h constants (RTF_*) common across BSD-style systems (Linux, macOS, etc.)
var routeFlagsMap = map[int64]string{
	0x1:       "UP",        // RTF_UP - route is up
	0x2:       "GATEWAY",   // RTF_GATEWAY - route has a gateway
	0x4:       "HOST",      // RTF_HOST - host route (not a network route)
	0x8:       "REJECT",    // RTF_REJECT - reject route
	0x10:      "DYNAMIC",   // RTF_DYNAMIC - dynamically installed
	0x20:      "MODIFIED",  // RTF_MODIFIED - modified by redirect
	0x40:      "DONE",      // RTF_DONE - message confirmed
	0x80:      "MASK",      // RTF_MASK - subnet mask present
	0x100:     "CLONING",   // RTF_CLONING - generate new routes on use
	0x200:     "XRESOLVE",  // RTF_XRESOLVE - external daemon resolves name
	0x400:     "LLINFO",    // RTF_LLINFO - generated by link layer
	0x800:     "STATIC",    // RTF_STATIC - manually added
	0x1000:    "BLACKHOLE", // RTF_BLACKHOLE - just discard pkts
	0x2000:    "PROTO1",    // RTF_PROTO1 - protocol specific routing flag #1
	0x4000:    "PROTO2",    // RTF_PROTO2 - protocol specific routing flag #2
	0x40000:   "PROTO3",    // RTF_PROTO3 - protocol specific routing flag #3
	0x20000:   "WASCLONED", // RTF_WASCLONED - route generated through cloning
	0x100000:  "PRCLONING", // RTF_PRCLONING - protocol requires cloning
	0x1000000: "PINNED",    // RTF_PINNED - future use
	0x2000000: "LOCAL",     // RTF_LOCAL - route represents a local address
	0x4000000: "BROADCAST", // RTF_BROADCAST - route represents a broadcast address
	0x8000000: "MULTICAST", // RTF_MULTICAST - route represents a multicast address
}

// parseRouteFlags converts route flags integer to an array of flag strings
func parseRouteFlags(flags int64) []string {
	return parseFlags(flags, routeFlagsMap)
}

// parseFlags converts route flags integer to an array of flag strings using the provided flags map
func parseFlags(flags int64, flagsMap map[int64]string) []string {
	var flagStrings []string
	for bit, name := range flagsMap {
		if flags&bit != 0 {
			flagStrings = append(flagStrings, name)
		}
	}

	sort.Strings(flagStrings)
	return flagStrings
}

// runCommand is a wrapper around connection.RunCommand that helps execute commands
// and read the standard output for unix and windows systems.
func (n *netr) RunCommand(commandString string) (string, error) {
	if n.platform.IsFamily(inventory.FAMILY_WINDOWS) {
		commandString = powershell.Encode(commandString)
	}
	cmd, err := n.connection.RunCommand(commandString)
	if err != nil {
		return "", err
	}

	data, err := io.ReadAll(cmd.Stdout)
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(string(data)), nil
}
