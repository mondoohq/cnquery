// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/v9/llx"
	"go.mondoo.com/cnquery/v9/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v9/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"vsphere": {
			// to override args, implement: initVsphere(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphere,
		},
		"vsphere.license": {
			// to override args, implement: initVsphereLicense(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereLicense,
		},
		"esxi": {
			// to override args, implement: initEsxi(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxi,
		},
		"vsphere.datacenter": {
			// to override args, implement: initVsphereDatacenter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereDatacenter,
		},
		"vsphere.cluster": {
			// to override args, implement: initVsphereCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereCluster,
		},
		"vsphere.host": {
			Init: initVsphereHost,
			Create: createVsphereHost,
		},
		"vsphere.vm": {
			// to override args, implement: initVsphereVm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereVm,
		},
		"vsphere.vswitch.standard": {
			// to override args, implement: initVsphereVswitchStandard(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereVswitchStandard,
		},
		"vsphere.vswitch.dvs": {
			// to override args, implement: initVsphereVswitchDvs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereVswitchDvs,
		},
		"vsphere.vmnic": {
			// to override args, implement: initVsphereVmnic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereVmnic,
		},
		"vsphere.vmknic": {
			// to override args, implement: initVsphereVmknic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createVsphereVmknic,
		},
		"esxi.command": {
			Init: initEsxiCommand,
			Create: createEsxiCommand,
		},
		"esxi.vib": {
			// to override args, implement: initEsxiVib(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxiVib,
		},
		"esxi.kernelmodule": {
			// to override args, implement: initEsxiKernelmodule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxiKernelmodule,
		},
		"esxi.service": {
			// to override args, implement: initEsxiService(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxiService,
		},
		"esxi.timezone": {
			// to override args, implement: initEsxiTimezone(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxiTimezone,
		},
		"esxi.ntpconfig": {
			// to override args, implement: initEsxiNtpconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createEsxiNtpconfig,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"vsphere.about": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphere).GetAbout()).ToDataRes(types.Dict)
	},
	"vsphere.licenses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphere).GetLicenses()).ToDataRes(types.Array(types.Resource("vsphere.license")))
	},
	"vsphere.datacenters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphere).GetDatacenters()).ToDataRes(types.Array(types.Resource("vsphere.datacenter")))
	},
	"vsphere.license.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereLicense).GetName()).ToDataRes(types.String)
	},
	"vsphere.license.total": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereLicense).GetTotal()).ToDataRes(types.Int)
	},
	"vsphere.license.used": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereLicense).GetUsed()).ToDataRes(types.Int)
	},
	"esxi.host": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxi).GetHost()).ToDataRes(types.Resource("vsphere.host"))
	},
	"esxi.vm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxi).GetVm()).ToDataRes(types.Resource("vsphere.vm"))
	},
	"vsphere.datacenter.moid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetMoid()).ToDataRes(types.String)
	},
	"vsphere.datacenter.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetName()).ToDataRes(types.String)
	},
	"vsphere.datacenter.inventoryPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetInventoryPath()).ToDataRes(types.String)
	},
	"vsphere.datacenter.hosts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetHosts()).ToDataRes(types.Array(types.Resource("vsphere.host")))
	},
	"vsphere.datacenter.vms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetVms()).ToDataRes(types.Array(types.Resource("vsphere.vm")))
	},
	"vsphere.datacenter.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereDatacenter).GetClusters()).ToDataRes(types.Array(types.Resource("vsphere.cluster")))
	},
	"vsphere.cluster.moid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereCluster).GetMoid()).ToDataRes(types.String)
	},
	"vsphere.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereCluster).GetName()).ToDataRes(types.String)
	},
	"vsphere.cluster.inventoryPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereCluster).GetInventoryPath()).ToDataRes(types.String)
	},
	"vsphere.cluster.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereCluster).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.cluster.hosts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereCluster).GetHosts()).ToDataRes(types.Array(types.Resource("vsphere.host")))
	},
	"vsphere.host.moid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetMoid()).ToDataRes(types.String)
	},
	"vsphere.host.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetName()).ToDataRes(types.String)
	},
	"vsphere.host.inventoryPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetInventoryPath()).ToDataRes(types.String)
	},
	"vsphere.host.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.host.standardSwitch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetStandardSwitch()).ToDataRes(types.Array(types.Resource("vsphere.vswitch.standard")))
	},
	"vsphere.host.distributedSwitch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetDistributedSwitch()).ToDataRes(types.Array(types.Resource("vsphere.vswitch.dvs")))
	},
	"vsphere.host.adapters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetAdapters()).ToDataRes(types.Array(types.Resource("vsphere.vmnic")))
	},
	"vsphere.host.vmknics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetVmknics()).ToDataRes(types.Array(types.Resource("vsphere.vmknic")))
	},
	"vsphere.host.packages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetPackages()).ToDataRes(types.Array(types.Resource("esxi.vib")))
	},
	"vsphere.host.acceptanceLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetAcceptanceLevel()).ToDataRes(types.String)
	},
	"vsphere.host.kernelModules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetKernelModules()).ToDataRes(types.Array(types.Resource("esxi.kernelmodule")))
	},
	"vsphere.host.advancedSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetAdvancedSettings()).ToDataRes(types.Map(types.String, types.String))
	},
	"vsphere.host.services": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetServices()).ToDataRes(types.Array(types.Resource("esxi.service")))
	},
	"vsphere.host.timezone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetTimezone()).ToDataRes(types.Resource("esxi.timezone"))
	},
	"vsphere.host.ntp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetNtp()).ToDataRes(types.Resource("esxi.ntpconfig"))
	},
	"vsphere.host.snmp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereHost).GetSnmp()).ToDataRes(types.Map(types.String, types.String))
	},
	"vsphere.vm.moid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVm).GetMoid()).ToDataRes(types.String)
	},
	"vsphere.vm.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVm).GetName()).ToDataRes(types.String)
	},
	"vsphere.vm.inventoryPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVm).GetInventoryPath()).ToDataRes(types.String)
	},
	"vsphere.vm.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVm).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.vm.advancedSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVm).GetAdvancedSettings()).ToDataRes(types.Map(types.String, types.String))
	},
	"vsphere.vswitch.standard.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetName()).ToDataRes(types.String)
	},
	"vsphere.vswitch.standard.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.vswitch.standard.failoverPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetFailoverPolicy()).ToDataRes(types.Dict)
	},
	"vsphere.vswitch.standard.securityPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetSecurityPolicy()).ToDataRes(types.Dict)
	},
	"vsphere.vswitch.standard.shapingPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetShapingPolicy()).ToDataRes(types.Dict)
	},
	"vsphere.vswitch.standard.uplinks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchStandard).GetUplinks()).ToDataRes(types.Array(types.Resource("vsphere.vmnic")))
	},
	"vsphere.vswitch.dvs.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchDvs).GetName()).ToDataRes(types.String)
	},
	"vsphere.vswitch.dvs.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchDvs).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.vswitch.dvs.uplinks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVswitchDvs).GetUplinks()).ToDataRes(types.Array(types.Resource("vsphere.vmnic")))
	},
	"vsphere.vmnic.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmnic).GetName()).ToDataRes(types.String)
	},
	"vsphere.vmnic.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmnic).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.vmnic.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmnic).GetDetails()).ToDataRes(types.Dict)
	},
	"vsphere.vmnic.pauseParams": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmnic).GetPauseParams()).ToDataRes(types.Dict)
	},
	"vsphere.vmknic.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmknic).GetName()).ToDataRes(types.String)
	},
	"vsphere.vmknic.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmknic).GetProperties()).ToDataRes(types.Dict)
	},
	"vsphere.vmknic.ipv4": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmknic).GetIpv4()).ToDataRes(types.Array(types.Dict))
	},
	"vsphere.vmknic.ipv6": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmknic).GetIpv6()).ToDataRes(types.Array(types.Dict))
	},
	"vsphere.vmknic.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlVsphereVmknic).GetTags()).ToDataRes(types.Array(types.String))
	},
	"esxi.command.inventoryPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiCommand).GetInventoryPath()).ToDataRes(types.String)
	},
	"esxi.command.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiCommand).GetCommand()).ToDataRes(types.String)
	},
	"esxi.command.result": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiCommand).GetResult()).ToDataRes(types.Array(types.Dict))
	},
	"esxi.vib.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetId()).ToDataRes(types.String)
	},
	"esxi.vib.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetName()).ToDataRes(types.String)
	},
	"esxi.vib.acceptanceLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetAcceptanceLevel()).ToDataRes(types.String)
	},
	"esxi.vib.creationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetCreationDate()).ToDataRes(types.Time)
	},
	"esxi.vib.installDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetInstallDate()).ToDataRes(types.Time)
	},
	"esxi.vib.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetStatus()).ToDataRes(types.String)
	},
	"esxi.vib.vendor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetVendor()).ToDataRes(types.String)
	},
	"esxi.vib.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiVib).GetVersion()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetName()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.modulefile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetModulefile()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetVersion()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.loaded": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetLoaded()).ToDataRes(types.Bool)
	},
	"esxi.kernelmodule.license": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetLicense()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetEnabled()).ToDataRes(types.Bool)
	},
	"esxi.kernelmodule.signedStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetSignedStatus()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.signatureDigest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetSignatureDigest()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.signatureFingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetSignatureFingerprint()).ToDataRes(types.String)
	},
	"esxi.kernelmodule.vibAcceptanceLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiKernelmodule).GetVibAcceptanceLevel()).ToDataRes(types.String)
	},
	"esxi.service.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetKey()).ToDataRes(types.String)
	},
	"esxi.service.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetLabel()).ToDataRes(types.String)
	},
	"esxi.service.required": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetRequired()).ToDataRes(types.Bool)
	},
	"esxi.service.uninstallable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetUninstallable()).ToDataRes(types.Bool)
	},
	"esxi.service.running": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetRunning()).ToDataRes(types.Bool)
	},
	"esxi.service.ruleset": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetRuleset()).ToDataRes(types.Array(types.String))
	},
	"esxi.service.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiService).GetPolicy()).ToDataRes(types.String)
	},
	"esxi.timezone.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiTimezone).GetKey()).ToDataRes(types.String)
	},
	"esxi.timezone.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiTimezone).GetName()).ToDataRes(types.String)
	},
	"esxi.timezone.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiTimezone).GetDescription()).ToDataRes(types.String)
	},
	"esxi.timezone.offset": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiTimezone).GetOffset()).ToDataRes(types.Int)
	},
	"esxi.ntpconfig.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiNtpconfig).GetId()).ToDataRes(types.String)
	},
	"esxi.ntpconfig.server": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiNtpconfig).GetServer()).ToDataRes(types.Array(types.String))
	},
	"esxi.ntpconfig.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlEsxiNtpconfig).GetConfig()).ToDataRes(types.Array(types.String))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"vsphere.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphere).__id, ok = v.Value.(string)
			return
		},
	"vsphere.about": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphere).About, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.licenses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphere).Licenses, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.datacenters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphere).Datacenters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.license.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereLicense).__id, ok = v.Value.(string)
			return
		},
	"vsphere.license.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereLicense).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.license.total": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereLicense).Total, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"vsphere.license.used": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereLicense).Used, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"esxi.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxi).__id, ok = v.Value.(string)
			return
		},
	"esxi.host": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxi).Host, ok = plugin.RawToTValue[*mqlVsphereHost](v.Value, v.Error)
		return
	},
	"esxi.vm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxi).Vm, ok = plugin.RawToTValue[*mqlVsphereVm](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereDatacenter).__id, ok = v.Value.(string)
			return
		},
	"vsphere.datacenter.moid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).Moid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.inventoryPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).InventoryPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.hosts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).Hosts, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.vms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).Vms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.datacenter.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereDatacenter).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereCluster).__id, ok = v.Value.(string)
			return
		},
	"vsphere.cluster.moid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereCluster).Moid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.cluster.inventoryPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereCluster).InventoryPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.cluster.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereCluster).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.cluster.hosts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereCluster).Hosts, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereHost).__id, ok = v.Value.(string)
			return
		},
	"vsphere.host.moid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Moid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.host.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.host.inventoryPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).InventoryPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.host.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.standardSwitch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).StandardSwitch, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.distributedSwitch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).DistributedSwitch, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.adapters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Adapters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.vmknics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Vmknics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.packages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Packages, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.acceptanceLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).AcceptanceLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.host.kernelModules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).KernelModules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.advancedSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).AdvancedSettings, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.services": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Services, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.host.timezone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Timezone, ok = plugin.RawToTValue[*mqlEsxiTimezone](v.Value, v.Error)
		return
	},
	"vsphere.host.ntp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Ntp, ok = plugin.RawToTValue[*mqlEsxiNtpconfig](v.Value, v.Error)
		return
	},
	"vsphere.host.snmp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereHost).Snmp, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereVm).__id, ok = v.Value.(string)
			return
		},
	"vsphere.vm.moid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVm).Moid, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vm.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVm).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vm.inventoryPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVm).InventoryPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vm.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVm).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vm.advancedSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVm).AdvancedSettings, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereVswitchStandard).__id, ok = v.Value.(string)
			return
		},
	"vsphere.vswitch.standard.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.failoverPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).FailoverPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.securityPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).SecurityPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.shapingPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).ShapingPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.standard.uplinks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchStandard).Uplinks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.dvs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereVswitchDvs).__id, ok = v.Value.(string)
			return
		},
	"vsphere.vswitch.dvs.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchDvs).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.dvs.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchDvs).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vswitch.dvs.uplinks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVswitchDvs).Uplinks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmnic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereVmnic).__id, ok = v.Value.(string)
			return
		},
	"vsphere.vmnic.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmnic).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vmnic.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmnic).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmnic.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmnic).Details, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmnic.pauseParams": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmnic).PauseParams, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmknic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlVsphereVmknic).__id, ok = v.Value.(string)
			return
		},
	"vsphere.vmknic.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmknic).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"vsphere.vmknic.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmknic).Properties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmknic.ipv4": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmknic).Ipv4, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmknic.ipv6": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmknic).Ipv6, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"vsphere.vmknic.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlVsphereVmknic).Tags, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"esxi.command.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiCommand).__id, ok = v.Value.(string)
			return
		},
	"esxi.command.inventoryPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiCommand).InventoryPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.command.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiCommand).Command, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.command.result": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiCommand).Result, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"esxi.vib.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiVib).__id, ok = v.Value.(string)
			return
		},
	"esxi.vib.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.vib.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.vib.acceptanceLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).AcceptanceLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.vib.creationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).CreationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"esxi.vib.installDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).InstallDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"esxi.vib.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.vib.vendor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).Vendor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.vib.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiVib).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiKernelmodule).__id, ok = v.Value.(string)
			return
		},
	"esxi.kernelmodule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.modulefile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).Modulefile, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.loaded": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).Loaded, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.license": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).License, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.signedStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).SignedStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.signatureDigest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).SignatureDigest, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.signatureFingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).SignatureFingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.kernelmodule.vibAcceptanceLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiKernelmodule).VibAcceptanceLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.service.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiService).__id, ok = v.Value.(string)
			return
		},
	"esxi.service.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.service.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.service.required": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Required, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"esxi.service.uninstallable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Uninstallable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"esxi.service.running": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Running, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"esxi.service.ruleset": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Ruleset, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"esxi.service.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiService).Policy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.timezone.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiTimezone).__id, ok = v.Value.(string)
			return
		},
	"esxi.timezone.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiTimezone).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.timezone.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiTimezone).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.timezone.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiTimezone).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.timezone.offset": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiTimezone).Offset, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"esxi.ntpconfig.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlEsxiNtpconfig).__id, ok = v.Value.(string)
			return
		},
	"esxi.ntpconfig.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiNtpconfig).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"esxi.ntpconfig.server": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiNtpconfig).Server, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"esxi.ntpconfig.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlEsxiNtpconfig).Config, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[vsphere] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[vsphere] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlVsphere for the vsphere resource
type mqlVsphere struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlVsphereInternal it will be used here
	About plugin.TValue[interface{}]
	Licenses plugin.TValue[[]interface{}]
	Datacenters plugin.TValue[[]interface{}]
}

// createVsphere creates a new instance of this resource
func createVsphere(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphere{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphere) MqlName() string {
	return "vsphere"
}

func (c *mqlVsphere) MqlID() string {
	return c.__id
}

func (c *mqlVsphere) GetAbout() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.About, func() (interface{}, error) {
		return c.about()
	})
}

func (c *mqlVsphere) GetLicenses() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Licenses, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere", c.__id, "licenses")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.licenses()
	})
}

func (c *mqlVsphere) GetDatacenters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Datacenters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere", c.__id, "datacenters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.datacenters()
	})
}

// mqlVsphereLicense for the vsphere.license resource
type mqlVsphereLicense struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlVsphereLicenseInternal it will be used here
	Name plugin.TValue[string]
	Total plugin.TValue[int64]
	Used plugin.TValue[int64]
}

// createVsphereLicense creates a new instance of this resource
func createVsphereLicense(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereLicense{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.license", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereLicense) MqlName() string {
	return "vsphere.license"
}

func (c *mqlVsphereLicense) MqlID() string {
	return c.__id
}

func (c *mqlVsphereLicense) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereLicense) GetTotal() *plugin.TValue[int64] {
	return &c.Total
}

func (c *mqlVsphereLicense) GetUsed() *plugin.TValue[int64] {
	return &c.Used
}

// mqlEsxi for the esxi resource
type mqlEsxi struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiInternal it will be used here
	Host plugin.TValue[*mqlVsphereHost]
	Vm plugin.TValue[*mqlVsphereVm]
}

// createEsxi creates a new instance of this resource
func createEsxi(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxi{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxi) MqlName() string {
	return "esxi"
}

func (c *mqlEsxi) MqlID() string {
	return c.__id
}

func (c *mqlEsxi) GetHost() *plugin.TValue[*mqlVsphereHost] {
	return plugin.GetOrCompute[*mqlVsphereHost](&c.Host, func() (*mqlVsphereHost, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("esxi", c.__id, "host")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlVsphereHost), nil
			}
		}

		return c.host()
	})
}

func (c *mqlEsxi) GetVm() *plugin.TValue[*mqlVsphereVm] {
	return plugin.GetOrCompute[*mqlVsphereVm](&c.Vm, func() (*mqlVsphereVm, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("esxi", c.__id, "vm")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlVsphereVm), nil
			}
		}

		return c.vm()
	})
}

// mqlVsphereDatacenter for the vsphere.datacenter resource
type mqlVsphereDatacenter struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlVsphereDatacenterInternal it will be used here
	Moid plugin.TValue[string]
	Name plugin.TValue[string]
	InventoryPath plugin.TValue[string]
	Hosts plugin.TValue[[]interface{}]
	Vms plugin.TValue[[]interface{}]
	Clusters plugin.TValue[[]interface{}]
}

// createVsphereDatacenter creates a new instance of this resource
func createVsphereDatacenter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereDatacenter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.datacenter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereDatacenter) MqlName() string {
	return "vsphere.datacenter"
}

func (c *mqlVsphereDatacenter) MqlID() string {
	return c.__id
}

func (c *mqlVsphereDatacenter) GetMoid() *plugin.TValue[string] {
	return &c.Moid
}

func (c *mqlVsphereDatacenter) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereDatacenter) GetInventoryPath() *plugin.TValue[string] {
	return &c.InventoryPath
}

func (c *mqlVsphereDatacenter) GetHosts() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hosts, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.datacenter", c.__id, "hosts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.hosts()
	})
}

func (c *mqlVsphereDatacenter) GetVms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.datacenter", c.__id, "vms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vms()
	})
}

func (c *mqlVsphereDatacenter) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.datacenter", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlVsphereCluster for the vsphere.cluster resource
type mqlVsphereCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlVsphereClusterInternal it will be used here
	Moid plugin.TValue[string]
	Name plugin.TValue[string]
	InventoryPath plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	Hosts plugin.TValue[[]interface{}]
}

// createVsphereCluster creates a new instance of this resource
func createVsphereCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereCluster) MqlName() string {
	return "vsphere.cluster"
}

func (c *mqlVsphereCluster) MqlID() string {
	return c.__id
}

func (c *mqlVsphereCluster) GetMoid() *plugin.TValue[string] {
	return &c.Moid
}

func (c *mqlVsphereCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereCluster) GetInventoryPath() *plugin.TValue[string] {
	return &c.InventoryPath
}

func (c *mqlVsphereCluster) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereCluster) GetHosts() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hosts, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.cluster", c.__id, "hosts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.hosts()
	})
}

// mqlVsphereHost for the vsphere.host resource
type mqlVsphereHost struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlVsphereHostInternal
	Moid plugin.TValue[string]
	Name plugin.TValue[string]
	InventoryPath plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	StandardSwitch plugin.TValue[[]interface{}]
	DistributedSwitch plugin.TValue[[]interface{}]
	Adapters plugin.TValue[[]interface{}]
	Vmknics plugin.TValue[[]interface{}]
	Packages plugin.TValue[[]interface{}]
	AcceptanceLevel plugin.TValue[string]
	KernelModules plugin.TValue[[]interface{}]
	AdvancedSettings plugin.TValue[map[string]interface{}]
	Services plugin.TValue[[]interface{}]
	Timezone plugin.TValue[*mqlEsxiTimezone]
	Ntp plugin.TValue[*mqlEsxiNtpconfig]
	Snmp plugin.TValue[map[string]interface{}]
}

// createVsphereHost creates a new instance of this resource
func createVsphereHost(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereHost{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.host", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereHost) MqlName() string {
	return "vsphere.host"
}

func (c *mqlVsphereHost) MqlID() string {
	return c.__id
}

func (c *mqlVsphereHost) GetMoid() *plugin.TValue[string] {
	return &c.Moid
}

func (c *mqlVsphereHost) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereHost) GetInventoryPath() *plugin.TValue[string] {
	return &c.InventoryPath
}

func (c *mqlVsphereHost) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereHost) GetStandardSwitch() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.StandardSwitch, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "standardSwitch")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.standardSwitch()
	})
}

func (c *mqlVsphereHost) GetDistributedSwitch() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DistributedSwitch, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "distributedSwitch")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.distributedSwitch()
	})
}

func (c *mqlVsphereHost) GetAdapters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Adapters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "adapters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.adapters()
	})
}

func (c *mqlVsphereHost) GetVmknics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vmknics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "vmknics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vmknics()
	})
}

func (c *mqlVsphereHost) GetPackages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Packages, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "packages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.packages()
	})
}

func (c *mqlVsphereHost) GetAcceptanceLevel() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AcceptanceLevel, func() (string, error) {
		return c.acceptanceLevel()
	})
}

func (c *mqlVsphereHost) GetKernelModules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.KernelModules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "kernelModules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.kernelModules()
	})
}

func (c *mqlVsphereHost) GetAdvancedSettings() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.AdvancedSettings, func() (map[string]interface{}, error) {
		return c.advancedSettings()
	})
}

func (c *mqlVsphereHost) GetServices() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Services, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "services")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.services()
	})
}

func (c *mqlVsphereHost) GetTimezone() *plugin.TValue[*mqlEsxiTimezone] {
	return plugin.GetOrCompute[*mqlEsxiTimezone](&c.Timezone, func() (*mqlEsxiTimezone, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "timezone")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlEsxiTimezone), nil
			}
		}

		return c.timezone()
	})
}

func (c *mqlVsphereHost) GetNtp() *plugin.TValue[*mqlEsxiNtpconfig] {
	return plugin.GetOrCompute[*mqlEsxiNtpconfig](&c.Ntp, func() (*mqlEsxiNtpconfig, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.host", c.__id, "ntp")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlEsxiNtpconfig), nil
			}
		}

		return c.ntp()
	})
}

func (c *mqlVsphereHost) GetSnmp() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Snmp, func() (map[string]interface{}, error) {
		return c.snmp()
	})
}

// mqlVsphereVm for the vsphere.vm resource
type mqlVsphereVm struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlVsphereVmInternal
	Moid plugin.TValue[string]
	Name plugin.TValue[string]
	InventoryPath plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	AdvancedSettings plugin.TValue[map[string]interface{}]
}

// createVsphereVm creates a new instance of this resource
func createVsphereVm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereVm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.vm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereVm) MqlName() string {
	return "vsphere.vm"
}

func (c *mqlVsphereVm) MqlID() string {
	return c.__id
}

func (c *mqlVsphereVm) GetMoid() *plugin.TValue[string] {
	return &c.Moid
}

func (c *mqlVsphereVm) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereVm) GetInventoryPath() *plugin.TValue[string] {
	return &c.InventoryPath
}

func (c *mqlVsphereVm) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereVm) GetAdvancedSettings() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.AdvancedSettings, func() (map[string]interface{}, error) {
		return c.advancedSettings()
	})
}

// mqlVsphereVswitchStandard for the vsphere.vswitch.standard resource
type mqlVsphereVswitchStandard struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlVsphereVswitchStandardInternal
	Name plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	FailoverPolicy plugin.TValue[interface{}]
	SecurityPolicy plugin.TValue[interface{}]
	ShapingPolicy plugin.TValue[interface{}]
	Uplinks plugin.TValue[[]interface{}]
}

// createVsphereVswitchStandard creates a new instance of this resource
func createVsphereVswitchStandard(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereVswitchStandard{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.vswitch.standard", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereVswitchStandard) MqlName() string {
	return "vsphere.vswitch.standard"
}

func (c *mqlVsphereVswitchStandard) MqlID() string {
	return c.__id
}

func (c *mqlVsphereVswitchStandard) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereVswitchStandard) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereVswitchStandard) GetFailoverPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.FailoverPolicy, func() (interface{}, error) {
		return c.failoverPolicy()
	})
}

func (c *mqlVsphereVswitchStandard) GetSecurityPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.SecurityPolicy, func() (interface{}, error) {
		return c.securityPolicy()
	})
}

func (c *mqlVsphereVswitchStandard) GetShapingPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.ShapingPolicy, func() (interface{}, error) {
		return c.shapingPolicy()
	})
}

func (c *mqlVsphereVswitchStandard) GetUplinks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Uplinks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.vswitch.standard", c.__id, "uplinks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.uplinks()
	})
}

// mqlVsphereVswitchDvs for the vsphere.vswitch.dvs resource
type mqlVsphereVswitchDvs struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlVsphereVswitchDvsInternal
	Name plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	Uplinks plugin.TValue[[]interface{}]
}

// createVsphereVswitchDvs creates a new instance of this resource
func createVsphereVswitchDvs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereVswitchDvs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.vswitch.dvs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereVswitchDvs) MqlName() string {
	return "vsphere.vswitch.dvs"
}

func (c *mqlVsphereVswitchDvs) MqlID() string {
	return c.__id
}

func (c *mqlVsphereVswitchDvs) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereVswitchDvs) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereVswitchDvs) GetUplinks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Uplinks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("vsphere.vswitch.dvs", c.__id, "uplinks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.uplinks()
	})
}

// mqlVsphereVmnic for the vsphere.vmnic resource
type mqlVsphereVmnic struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlVsphereVmnicInternal
	Name plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	Details plugin.TValue[interface{}]
	PauseParams plugin.TValue[interface{}]
}

// createVsphereVmnic creates a new instance of this resource
func createVsphereVmnic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereVmnic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.vmnic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereVmnic) MqlName() string {
	return "vsphere.vmnic"
}

func (c *mqlVsphereVmnic) MqlID() string {
	return c.__id
}

func (c *mqlVsphereVmnic) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereVmnic) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereVmnic) GetDetails() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Details, func() (interface{}, error) {
		return c.details()
	})
}

func (c *mqlVsphereVmnic) GetPauseParams() *plugin.TValue[interface{}] {
	return &c.PauseParams
}

// mqlVsphereVmknic for the vsphere.vmknic resource
type mqlVsphereVmknic struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlVsphereVmknicInternal it will be used here
	Name plugin.TValue[string]
	Properties plugin.TValue[interface{}]
	Ipv4 plugin.TValue[[]interface{}]
	Ipv6 plugin.TValue[[]interface{}]
	Tags plugin.TValue[[]interface{}]
}

// createVsphereVmknic creates a new instance of this resource
func createVsphereVmknic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlVsphereVmknic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("vsphere.vmknic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlVsphereVmknic) MqlName() string {
	return "vsphere.vmknic"
}

func (c *mqlVsphereVmknic) MqlID() string {
	return c.__id
}

func (c *mqlVsphereVmknic) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlVsphereVmknic) GetProperties() *plugin.TValue[interface{}] {
	return &c.Properties
}

func (c *mqlVsphereVmknic) GetIpv4() *plugin.TValue[[]interface{}] {
	return &c.Ipv4
}

func (c *mqlVsphereVmknic) GetIpv6() *plugin.TValue[[]interface{}] {
	return &c.Ipv6
}

func (c *mqlVsphereVmknic) GetTags() *plugin.TValue[[]interface{}] {
	return &c.Tags
}

// mqlEsxiCommand for the esxi.command resource
type mqlEsxiCommand struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiCommandInternal it will be used here
	InventoryPath plugin.TValue[string]
	Command plugin.TValue[string]
	Result plugin.TValue[[]interface{}]
}

// createEsxiCommand creates a new instance of this resource
func createEsxiCommand(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiCommand{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.command", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiCommand) MqlName() string {
	return "esxi.command"
}

func (c *mqlEsxiCommand) MqlID() string {
	return c.__id
}

func (c *mqlEsxiCommand) GetInventoryPath() *plugin.TValue[string] {
	return &c.InventoryPath
}

func (c *mqlEsxiCommand) GetCommand() *plugin.TValue[string] {
	return &c.Command
}

func (c *mqlEsxiCommand) GetResult() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Result, func() ([]interface{}, error) {
		return c.result()
	})
}

// mqlEsxiVib for the esxi.vib resource
type mqlEsxiVib struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiVibInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	AcceptanceLevel plugin.TValue[string]
	CreationDate plugin.TValue[*time.Time]
	InstallDate plugin.TValue[*time.Time]
	Status plugin.TValue[string]
	Vendor plugin.TValue[string]
	Version plugin.TValue[string]
}

// createEsxiVib creates a new instance of this resource
func createEsxiVib(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiVib{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.vib", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiVib) MqlName() string {
	return "esxi.vib"
}

func (c *mqlEsxiVib) MqlID() string {
	return c.__id
}

func (c *mqlEsxiVib) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlEsxiVib) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlEsxiVib) GetAcceptanceLevel() *plugin.TValue[string] {
	return &c.AcceptanceLevel
}

func (c *mqlEsxiVib) GetCreationDate() *plugin.TValue[*time.Time] {
	return &c.CreationDate
}

func (c *mqlEsxiVib) GetInstallDate() *plugin.TValue[*time.Time] {
	return &c.InstallDate
}

func (c *mqlEsxiVib) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlEsxiVib) GetVendor() *plugin.TValue[string] {
	return &c.Vendor
}

func (c *mqlEsxiVib) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

// mqlEsxiKernelmodule for the esxi.kernelmodule resource
type mqlEsxiKernelmodule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiKernelmoduleInternal it will be used here
	Name plugin.TValue[string]
	Modulefile plugin.TValue[string]
	Version plugin.TValue[string]
	Loaded plugin.TValue[bool]
	License plugin.TValue[string]
	Enabled plugin.TValue[bool]
	SignedStatus plugin.TValue[string]
	SignatureDigest plugin.TValue[string]
	SignatureFingerprint plugin.TValue[string]
	VibAcceptanceLevel plugin.TValue[string]
}

// createEsxiKernelmodule creates a new instance of this resource
func createEsxiKernelmodule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiKernelmodule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.kernelmodule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiKernelmodule) MqlName() string {
	return "esxi.kernelmodule"
}

func (c *mqlEsxiKernelmodule) MqlID() string {
	return c.__id
}

func (c *mqlEsxiKernelmodule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlEsxiKernelmodule) GetModulefile() *plugin.TValue[string] {
	return &c.Modulefile
}

func (c *mqlEsxiKernelmodule) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlEsxiKernelmodule) GetLoaded() *plugin.TValue[bool] {
	return &c.Loaded
}

func (c *mqlEsxiKernelmodule) GetLicense() *plugin.TValue[string] {
	return &c.License
}

func (c *mqlEsxiKernelmodule) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlEsxiKernelmodule) GetSignedStatus() *plugin.TValue[string] {
	return &c.SignedStatus
}

func (c *mqlEsxiKernelmodule) GetSignatureDigest() *plugin.TValue[string] {
	return &c.SignatureDigest
}

func (c *mqlEsxiKernelmodule) GetSignatureFingerprint() *plugin.TValue[string] {
	return &c.SignatureFingerprint
}

func (c *mqlEsxiKernelmodule) GetVibAcceptanceLevel() *plugin.TValue[string] {
	return &c.VibAcceptanceLevel
}

// mqlEsxiService for the esxi.service resource
type mqlEsxiService struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiServiceInternal it will be used here
	Key plugin.TValue[string]
	Label plugin.TValue[string]
	Required plugin.TValue[bool]
	Uninstallable plugin.TValue[bool]
	Running plugin.TValue[bool]
	Ruleset plugin.TValue[[]interface{}]
	Policy plugin.TValue[string]
}

// createEsxiService creates a new instance of this resource
func createEsxiService(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiService{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.service", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiService) MqlName() string {
	return "esxi.service"
}

func (c *mqlEsxiService) MqlID() string {
	return c.__id
}

func (c *mqlEsxiService) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlEsxiService) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlEsxiService) GetRequired() *plugin.TValue[bool] {
	return &c.Required
}

func (c *mqlEsxiService) GetUninstallable() *plugin.TValue[bool] {
	return &c.Uninstallable
}

func (c *mqlEsxiService) GetRunning() *plugin.TValue[bool] {
	return &c.Running
}

func (c *mqlEsxiService) GetRuleset() *plugin.TValue[[]interface{}] {
	return &c.Ruleset
}

func (c *mqlEsxiService) GetPolicy() *plugin.TValue[string] {
	return &c.Policy
}

// mqlEsxiTimezone for the esxi.timezone resource
type mqlEsxiTimezone struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiTimezoneInternal it will be used here
	Key plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Offset plugin.TValue[int64]
}

// createEsxiTimezone creates a new instance of this resource
func createEsxiTimezone(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiTimezone{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.timezone", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiTimezone) MqlName() string {
	return "esxi.timezone"
}

func (c *mqlEsxiTimezone) MqlID() string {
	return c.__id
}

func (c *mqlEsxiTimezone) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlEsxiTimezone) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlEsxiTimezone) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlEsxiTimezone) GetOffset() *plugin.TValue[int64] {
	return &c.Offset
}

// mqlEsxiNtpconfig for the esxi.ntpconfig resource
type mqlEsxiNtpconfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlEsxiNtpconfigInternal it will be used here
	Id plugin.TValue[string]
	Server plugin.TValue[[]interface{}]
	Config plugin.TValue[[]interface{}]
}

// createEsxiNtpconfig creates a new instance of this resource
func createEsxiNtpconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlEsxiNtpconfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("esxi.ntpconfig", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlEsxiNtpconfig) MqlName() string {
	return "esxi.ntpconfig"
}

func (c *mqlEsxiNtpconfig) MqlID() string {
	return c.__id
}

func (c *mqlEsxiNtpconfig) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlEsxiNtpconfig) GetServer() *plugin.TValue[[]interface{}] {
	return &c.Server
}

func (c *mqlEsxiNtpconfig) GetConfig() *plugin.TValue[[]interface{}] {
	return &c.Config
}
