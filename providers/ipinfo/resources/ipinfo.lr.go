// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"

	"github.com/rs/zerolog/log"
	"go.mondoo.com/cnquery/v12/llx"
	"go.mondoo.com/cnquery/v12/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v12/types"
)

// The MQL type names exposed as public consts for ease of reference.
const (
	ResourceIpinfo string = "ipinfo"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory{
		"ipinfo": {
			Init:   initIpinfo,
			Create: createIpinfo,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			mqlId := res.MqlID()
			if mqlId == "" {
				log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
			}
			id := name + "\x00" + mqlId
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/cnquery/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"ipinfo.requested_ip": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetRequested_ip()).ToDataRes(types.IP)
	},
	"ipinfo.returned_ip": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetReturned_ip()).ToDataRes(types.IP)
	},
	"ipinfo.hostname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetHostname()).ToDataRes(types.String)
	},
	"ipinfo.bogon": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetBogon()).ToDataRes(types.Bool)
	},
	"ipinfo.city": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetCity()).ToDataRes(types.String)
	},
	"ipinfo.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetRegion()).ToDataRes(types.String)
	},
	"ipinfo.country": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetCountry()).ToDataRes(types.String)
	},
	"ipinfo.country_name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetCountry_name()).ToDataRes(types.String)
	},
	"ipinfo.is_eu": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetIs_eu()).ToDataRes(types.Bool)
	},
	"ipinfo.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetLocation()).ToDataRes(types.String)
	},
	"ipinfo.org": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetOrg()).ToDataRes(types.String)
	},
	"ipinfo.postal": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetPostal()).ToDataRes(types.String)
	},
	"ipinfo.timezone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlIpinfo).GetTimezone()).ToDataRes(types.String)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool{
	"ipinfo.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).__id, ok = v.Value.(string)
		return
	},
	"ipinfo.requested_ip": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Requested_ip, ok = plugin.RawToTValue[llx.RawIP](v.Value, v.Error)
		return
	},
	"ipinfo.returned_ip": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Returned_ip, ok = plugin.RawToTValue[llx.RawIP](v.Value, v.Error)
		return
	},
	"ipinfo.hostname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Hostname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.bogon": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Bogon, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"ipinfo.city": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).City, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.country": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Country, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.country_name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Country_name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.is_eu": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Is_eu, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"ipinfo.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.org": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Org, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.postal": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Postal, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ipinfo.timezone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlIpinfo).Timezone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName()+"."+field]
	if !ok {
		return errors.New("[ipinfo] cannot set '" + field + "' in resource '" + resource.MqlName() + "', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[ipinfo] cannot set '" + field + "' in resource '" + resource.MqlName() + "', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlIpinfo for the ipinfo resource
type mqlIpinfo struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlIpinfoInternal it will be used here
	Requested_ip plugin.TValue[llx.RawIP]
	Returned_ip  plugin.TValue[llx.RawIP]
	Hostname     plugin.TValue[string]
	Bogon        plugin.TValue[bool]
	City         plugin.TValue[string]
	Region       plugin.TValue[string]
	Country      plugin.TValue[string]
	Country_name plugin.TValue[string]
	Is_eu        plugin.TValue[bool]
	Location     plugin.TValue[string]
	Org          plugin.TValue[string]
	Postal       plugin.TValue[string]
	Timezone     plugin.TValue[string]
}

// createIpinfo creates a new instance of this resource
func createIpinfo(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlIpinfo{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ipinfo", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlIpinfo) MqlName() string {
	return "ipinfo"
}

func (c *mqlIpinfo) MqlID() string {
	return c.__id
}

func (c *mqlIpinfo) GetRequested_ip() *plugin.TValue[llx.RawIP] {
	return &c.Requested_ip
}

func (c *mqlIpinfo) GetReturned_ip() *plugin.TValue[llx.RawIP] {
	return &c.Returned_ip
}

func (c *mqlIpinfo) GetHostname() *plugin.TValue[string] {
	return &c.Hostname
}

func (c *mqlIpinfo) GetBogon() *plugin.TValue[bool] {
	return &c.Bogon
}

func (c *mqlIpinfo) GetCity() *plugin.TValue[string] {
	return &c.City
}

func (c *mqlIpinfo) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlIpinfo) GetCountry() *plugin.TValue[string] {
	return &c.Country
}

func (c *mqlIpinfo) GetCountry_name() *plugin.TValue[string] {
	return &c.Country_name
}

func (c *mqlIpinfo) GetIs_eu() *plugin.TValue[bool] {
	return &c.Is_eu
}

func (c *mqlIpinfo) GetLocation() *plugin.TValue[string] {
	return &c.Location
}

func (c *mqlIpinfo) GetOrg() *plugin.TValue[string] {
	return &c.Org
}

func (c *mqlIpinfo) GetPostal() *plugin.TValue[string] {
	return &c.Postal
}

func (c *mqlIpinfo) GetTimezone() *plugin.TValue[string] {
	return &c.Timezone
}
