// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/v11/llx"
	"go.mondoo.com/cnquery/v11/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v11/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"socket": {
			// to override args, implement: initSocket(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createSocket,
		},
		"http": {
			// to override args, implement: initHttp(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttp,
		},
		"http.get": {
			Init: initHttpGet,
			Create: createHttpGet,
		},
		"http.header": {
			// to override args, implement: initHttpHeader(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttpHeader,
		},
		"http.header.sts": {
			// to override args, implement: initHttpHeaderSts(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttpHeaderSts,
		},
		"http.header.xssProtection": {
			// to override args, implement: initHttpHeaderXssProtection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttpHeaderXssProtection,
		},
		"http.header.contentType": {
			// to override args, implement: initHttpHeaderContentType(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttpHeaderContentType,
		},
		"http.header.setCookie": {
			// to override args, implement: initHttpHeaderSetCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createHttpHeaderSetCookie,
		},
		"url": {
			Init: initUrl,
			Create: createUrl,
		},
		"tls": {
			Init: initTls,
			Create: createTls,
		},
		"certificates": {
			// to override args, implement: initCertificates(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createCertificates,
		},
		"certificate": {
			// to override args, implement: initCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createCertificate,
		},
		"pkix.name": {
			// to override args, implement: initPkixName(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPkixName,
		},
		"pkix.extension": {
			// to override args, implement: initPkixExtension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPkixExtension,
		},
		"pkix.sanExtension": {
			// to override args, implement: initPkixSanExtension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createPkixSanExtension,
		},
		"openpgp.entities": {
			// to override args, implement: initOpenpgpEntities(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpenpgpEntities,
		},
		"openpgp.entity": {
			// to override args, implement: initOpenpgpEntity(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpenpgpEntity,
		},
		"openpgp.publicKey": {
			// to override args, implement: initOpenpgpPublicKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpenpgpPublicKey,
		},
		"openpgp.identity": {
			// to override args, implement: initOpenpgpIdentity(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpenpgpIdentity,
		},
		"openpgp.signature": {
			// to override args, implement: initOpenpgpSignature(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createOpenpgpSignature,
		},
		"domainName": {
			Init: initDomainName,
			Create: createDomainName,
		},
		"dns": {
			Init: initDns,
			Create: createDns,
		},
		"dns.record": {
			// to override args, implement: initDnsRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDnsRecord,
		},
		"dns.mxRecord": {
			// to override args, implement: initDnsMxRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDnsMxRecord,
		},
		"dns.dkimRecord": {
			// to override args, implement: initDnsDkimRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createDnsDkimRecord,
		},
		"whois": {
			Init: initWhois,
			Create: createWhois,
		},
		"whois.domainInfo": {
			// to override args, implement: initWhoisDomainInfo(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createWhoisDomainInfo,
		},
		"whois.contact": {
			// to override args, implement: initWhoisContact(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createWhoisContact,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"socket.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSocket).GetProtocol()).ToDataRes(types.String)
	},
	"socket.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSocket).GetPort()).ToDataRes(types.Int)
	},
	"socket.address": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlSocket).GetAddress()).ToDataRes(types.String)
	},
	"http.get.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpGet).GetUrl()).ToDataRes(types.Resource("url"))
	},
	"http.get.header": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpGet).GetHeader()).ToDataRes(types.Resource("http.header"))
	},
	"http.get.statusCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpGet).GetStatusCode()).ToDataRes(types.Int)
	},
	"http.get.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpGet).GetVersion()).ToDataRes(types.String)
	},
	"http.get.body": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpGet).GetBody()).ToDataRes(types.String)
	},
	"http.header.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetParams()).ToDataRes(types.Map(types.String, types.Array(types.String)))
	},
	"http.header.sts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetSts()).ToDataRes(types.Resource("http.header.sts"))
	},
	"http.header.xFrameOptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetXFrameOptions()).ToDataRes(types.String)
	},
	"http.header.xXssProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetXXssProtection()).ToDataRes(types.Resource("http.header.xssProtection"))
	},
	"http.header.xContentTypeOptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetXContentTypeOptions()).ToDataRes(types.String)
	},
	"http.header.referrerPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetReferrerPolicy()).ToDataRes(types.String)
	},
	"http.header.contentType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetContentType()).ToDataRes(types.Resource("http.header.contentType"))
	},
	"http.header.setCookie": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetSetCookie()).ToDataRes(types.Resource("http.header.setCookie"))
	},
	"http.header.csp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeader).GetCsp()).ToDataRes(types.Map(types.String, types.String))
	},
	"http.header.sts.maxAge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSts).GetMaxAge()).ToDataRes(types.Time)
	},
	"http.header.sts.includeSubDomains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSts).GetIncludeSubDomains()).ToDataRes(types.Bool)
	},
	"http.header.sts.preload": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSts).GetPreload()).ToDataRes(types.Bool)
	},
	"http.header.xssProtection.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderXssProtection).GetEnabled()).ToDataRes(types.Bool)
	},
	"http.header.xssProtection.mode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderXssProtection).GetMode()).ToDataRes(types.String)
	},
	"http.header.xssProtection.report": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderXssProtection).GetReport()).ToDataRes(types.String)
	},
	"http.header.contentType.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderContentType).GetType()).ToDataRes(types.String)
	},
	"http.header.contentType.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderContentType).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"http.header.setCookie.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSetCookie).GetName()).ToDataRes(types.String)
	},
	"http.header.setCookie.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSetCookie).GetValue()).ToDataRes(types.String)
	},
	"http.header.setCookie.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlHttpHeaderSetCookie).GetParams()).ToDataRes(types.Map(types.String, types.String))
	},
	"url.string": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetString()).ToDataRes(types.String)
	},
	"url.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetScheme()).ToDataRes(types.String)
	},
	"url.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetUser()).ToDataRes(types.String)
	},
	"url.password": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetPassword()).ToDataRes(types.String)
	},
	"url.host": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetHost()).ToDataRes(types.String)
	},
	"url.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetPort()).ToDataRes(types.Int)
	},
	"url.path": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetPath()).ToDataRes(types.String)
	},
	"url.query": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetQuery()).ToDataRes(types.Map(types.String, types.String))
	},
	"url.rawQuery": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetRawQuery()).ToDataRes(types.String)
	},
	"url.rawFragment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlUrl).GetRawFragment()).ToDataRes(types.String)
	},
	"tls.socket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetSocket()).ToDataRes(types.Resource("socket"))
	},
	"tls.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetDomainName()).ToDataRes(types.String)
	},
	"tls.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetParams()).ToDataRes(types.Dict)
	},
	"tls.versions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetVersions()).ToDataRes(types.Array(types.String))
	},
	"tls.ciphers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetCiphers()).ToDataRes(types.Array(types.String))
	},
	"tls.extensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetExtensions()).ToDataRes(types.Array(types.String))
	},
	"tls.certificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetCertificates()).ToDataRes(types.Array(types.Resource("certificate")))
	},
	"tls.nonSniCertificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlTls).GetNonSniCertificates()).ToDataRes(types.Array(types.Resource("certificate")))
	},
	"certificates.pem": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificates).GetPem()).ToDataRes(types.String)
	},
	"certificates.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificates).GetList()).ToDataRes(types.Array(types.Resource("certificate")))
	},
	"certificate.pem": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetPem()).ToDataRes(types.String)
	},
	"certificate.fingerprints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetFingerprints()).ToDataRes(types.Map(types.String, types.String))
	},
	"certificate.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSerial()).ToDataRes(types.String)
	},
	"certificate.subjectKeyID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSubjectKeyID()).ToDataRes(types.String)
	},
	"certificate.authorityKeyID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetAuthorityKeyID()).ToDataRes(types.String)
	},
	"certificate.subject": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSubject()).ToDataRes(types.Resource("pkix.name"))
	},
	"certificate.issuer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetIssuer()).ToDataRes(types.Resource("pkix.name"))
	},
	"certificate.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetVersion()).ToDataRes(types.Int)
	},
	"certificate.notBefore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetNotBefore()).ToDataRes(types.Time)
	},
	"certificate.notAfter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetNotAfter()).ToDataRes(types.Time)
	},
	"certificate.expiresIn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetExpiresIn()).ToDataRes(types.Time)
	},
	"certificate.signature": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSignature()).ToDataRes(types.String)
	},
	"certificate.signingAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSigningAlgorithm()).ToDataRes(types.String)
	},
	"certificate.isCA": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetIsCA()).ToDataRes(types.Bool)
	},
	"certificate.keyUsage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetKeyUsage()).ToDataRes(types.Array(types.String))
	},
	"certificate.extendedKeyUsage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetExtendedKeyUsage()).ToDataRes(types.Array(types.String))
	},
	"certificate.extensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetExtensions()).ToDataRes(types.Array(types.Resource("pkix.extension")))
	},
	"certificate.policyIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetPolicyIdentifier()).ToDataRes(types.Array(types.String))
	},
	"certificate.crlDistributionPoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetCrlDistributionPoints()).ToDataRes(types.Array(types.String))
	},
	"certificate.ocspServer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetOcspServer()).ToDataRes(types.Array(types.String))
	},
	"certificate.issuingCertificateUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetIssuingCertificateUrl()).ToDataRes(types.Array(types.String))
	},
	"certificate.isRevoked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetIsRevoked()).ToDataRes(types.Bool)
	},
	"certificate.revokedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetRevokedAt()).ToDataRes(types.Time)
	},
	"certificate.isVerified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetIsVerified()).ToDataRes(types.Bool)
	},
	"certificate.sanExtension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlCertificate).GetSanExtension()).ToDataRes(types.Resource("pkix.sanExtension"))
	},
	"pkix.name.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetId()).ToDataRes(types.String)
	},
	"pkix.name.dn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetDn()).ToDataRes(types.String)
	},
	"pkix.name.serialNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetSerialNumber()).ToDataRes(types.String)
	},
	"pkix.name.commonName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetCommonName()).ToDataRes(types.String)
	},
	"pkix.name.country": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetCountry()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetOrganization()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.organizationalUnit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetOrganizationalUnit()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.locality": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetLocality()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.province": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetProvince()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.streetAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetStreetAddress()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.postalCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetPostalCode()).ToDataRes(types.Array(types.String))
	},
	"pkix.name.names": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetNames()).ToDataRes(types.Map(types.String, types.String))
	},
	"pkix.name.extraNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixName).GetExtraNames()).ToDataRes(types.Map(types.String, types.String))
	},
	"pkix.extension.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixExtension).GetId()).ToDataRes(types.String)
	},
	"pkix.extension.identifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixExtension).GetIdentifier()).ToDataRes(types.String)
	},
	"pkix.extension.critical": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixExtension).GetCritical()).ToDataRes(types.Bool)
	},
	"pkix.extension.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixExtension).GetValue()).ToDataRes(types.String)
	},
	"pkix.sanExtension.extension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixSanExtension).GetExtension()).ToDataRes(types.Resource("pkix.extension"))
	},
	"pkix.sanExtension.dnsNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixSanExtension).GetDnsNames()).ToDataRes(types.Array(types.String))
	},
	"pkix.sanExtension.ipAddresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixSanExtension).GetIpAddresses()).ToDataRes(types.Array(types.String))
	},
	"pkix.sanExtension.emailAddresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixSanExtension).GetEmailAddresses()).ToDataRes(types.Array(types.String))
	},
	"pkix.sanExtension.uris": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlPkixSanExtension).GetUris()).ToDataRes(types.Array(types.String))
	},
	"openpgp.entities.content": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpEntities).GetContent()).ToDataRes(types.String)
	},
	"openpgp.entities.list": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpEntities).GetList()).ToDataRes(types.Array(types.Resource("openpgp.entity")))
	},
	"openpgp.entity.primaryPublicKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpEntity).GetPrimaryPublicKey()).ToDataRes(types.Resource("openpgp.publicKey"))
	},
	"openpgp.entity.identities": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpEntity).GetIdentities()).ToDataRes(types.Array(types.Resource("openpgp.identity")))
	},
	"openpgp.publicKey.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetId()).ToDataRes(types.String)
	},
	"openpgp.publicKey.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetVersion()).ToDataRes(types.Int)
	},
	"openpgp.publicKey.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetFingerprint()).ToDataRes(types.String)
	},
	"openpgp.publicKey.keyAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetKeyAlgorithm()).ToDataRes(types.String)
	},
	"openpgp.publicKey.bitLength": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetBitLength()).ToDataRes(types.Int)
	},
	"openpgp.publicKey.creationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpPublicKey).GetCreationTime()).ToDataRes(types.Time)
	},
	"openpgp.identity.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetFingerprint()).ToDataRes(types.String)
	},
	"openpgp.identity.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetId()).ToDataRes(types.String)
	},
	"openpgp.identity.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetName()).ToDataRes(types.String)
	},
	"openpgp.identity.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetEmail()).ToDataRes(types.String)
	},
	"openpgp.identity.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetComment()).ToDataRes(types.String)
	},
	"openpgp.identity.signatures": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpIdentity).GetSignatures()).ToDataRes(types.Array(types.Resource("openpgp.signature")))
	},
	"openpgp.signature.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetFingerprint()).ToDataRes(types.String)
	},
	"openpgp.signature.identityName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetIdentityName()).ToDataRes(types.String)
	},
	"openpgp.signature.hash": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetHash()).ToDataRes(types.String)
	},
	"openpgp.signature.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetVersion()).ToDataRes(types.Int)
	},
	"openpgp.signature.signatureType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetSignatureType()).ToDataRes(types.String)
	},
	"openpgp.signature.keyAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetKeyAlgorithm()).ToDataRes(types.String)
	},
	"openpgp.signature.creationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetCreationTime()).ToDataRes(types.Time)
	},
	"openpgp.signature.lifetimeSecs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetLifetimeSecs()).ToDataRes(types.Int)
	},
	"openpgp.signature.expiresIn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetExpiresIn()).ToDataRes(types.Time)
	},
	"openpgp.signature.keyLifetimeSecs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetKeyLifetimeSecs()).ToDataRes(types.Int)
	},
	"openpgp.signature.keyExpiresIn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlOpenpgpSignature).GetKeyExpiresIn()).ToDataRes(types.Time)
	},
	"domainName.fqdn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDomainName).GetFqdn()).ToDataRes(types.String)
	},
	"domainName.effectiveTLDPlusOne": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDomainName).GetEffectiveTLDPlusOne()).ToDataRes(types.String)
	},
	"domainName.tld": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDomainName).GetTld()).ToDataRes(types.String)
	},
	"domainName.tldIcannManaged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDomainName).GetTldIcannManaged()).ToDataRes(types.Bool)
	},
	"domainName.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDomainName).GetLabels()).ToDataRes(types.Array(types.String))
	},
	"dns.fqdn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDns).GetFqdn()).ToDataRes(types.String)
	},
	"dns.params": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDns).GetParams()).ToDataRes(types.Dict)
	},
	"dns.records": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDns).GetRecords()).ToDataRes(types.Array(types.Resource("dns.record")))
	},
	"dns.mx": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDns).GetMx()).ToDataRes(types.Array(types.Resource("dns.mxRecord")))
	},
	"dns.dkim": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDns).GetDkim()).ToDataRes(types.Array(types.Resource("dns.dkimRecord")))
	},
	"dns.record.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsRecord).GetName()).ToDataRes(types.String)
	},
	"dns.record.ttl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsRecord).GetTtl()).ToDataRes(types.Int)
	},
	"dns.record.class": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsRecord).GetClass()).ToDataRes(types.String)
	},
	"dns.record.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsRecord).GetType()).ToDataRes(types.String)
	},
	"dns.record.rdata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsRecord).GetRdata()).ToDataRes(types.Array(types.String))
	},
	"dns.mxRecord.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsMxRecord).GetName()).ToDataRes(types.String)
	},
	"dns.mxRecord.preference": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsMxRecord).GetPreference()).ToDataRes(types.Int)
	},
	"dns.mxRecord.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsMxRecord).GetDomainName()).ToDataRes(types.String)
	},
	"dns.dkimRecord.dnsTxt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetDnsTxt()).ToDataRes(types.String)
	},
	"dns.dkimRecord.domain": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetDomain()).ToDataRes(types.String)
	},
	"dns.dkimRecord.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetVersion()).ToDataRes(types.String)
	},
	"dns.dkimRecord.hashAlgorithms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetHashAlgorithms()).ToDataRes(types.Array(types.String))
	},
	"dns.dkimRecord.keyType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetKeyType()).ToDataRes(types.String)
	},
	"dns.dkimRecord.notes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetNotes()).ToDataRes(types.String)
	},
	"dns.dkimRecord.publicKeyData": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetPublicKeyData()).ToDataRes(types.String)
	},
	"dns.dkimRecord.serviceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetServiceTypes()).ToDataRes(types.Array(types.String))
	},
	"dns.dkimRecord.flags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetFlags()).ToDataRes(types.Array(types.String))
	},
	"dns.dkimRecord.valid": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlDnsDkimRecord).GetValid()).ToDataRes(types.Bool)
	},
	"whois.host": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetHost()).ToDataRes(types.String)
	},
	"whois.domain": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetDomain()).ToDataRes(types.Resource("whois.domainInfo"))
	},
	"whois.registrar": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetRegistrar()).ToDataRes(types.Resource("whois.contact"))
	},
	"whois.registrant": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetRegistrant()).ToDataRes(types.Resource("whois.contact"))
	},
	"whois.administrative": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetAdministrative()).ToDataRes(types.Resource("whois.contact"))
	},
	"whois.technical": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetTechnical()).ToDataRes(types.Resource("whois.contact"))
	},
	"whois.billing": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhois).GetBilling()).ToDataRes(types.Resource("whois.contact"))
	},
	"whois.domainInfo.domain": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetDomain()).ToDataRes(types.String)
	},
	"whois.domainInfo.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetName()).ToDataRes(types.String)
	},
	"whois.domainInfo.punyCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetPunyCode()).ToDataRes(types.String)
	},
	"whois.domainInfo.extension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetExtension()).ToDataRes(types.String)
	},
	"whois.domainInfo.whoisServer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetWhoisServer()).ToDataRes(types.String)
	},
	"whois.domainInfo.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetStatus()).ToDataRes(types.Array(types.String))
	},
	"whois.domainInfo.nameServers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetNameServers()).ToDataRes(types.Array(types.String))
	},
	"whois.domainInfo.dnssec": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetDnssec()).ToDataRes(types.Bool)
	},
	"whois.domainInfo.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetCreatedAt()).ToDataRes(types.Time)
	},
	"whois.domainInfo.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"whois.domainInfo.expiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisDomainInfo).GetExpiresAt()).ToDataRes(types.Time)
	},
	"whois.contact.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetName()).ToDataRes(types.String)
	},
	"whois.contact.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetOrganization()).ToDataRes(types.String)
	},
	"whois.contact.street": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetStreet()).ToDataRes(types.String)
	},
	"whois.contact.city": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetCity()).ToDataRes(types.String)
	},
	"whois.contact.province": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetProvince()).ToDataRes(types.String)
	},
	"whois.contact.postalCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetPostalCode()).ToDataRes(types.String)
	},
	"whois.contact.country": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetCountry()).ToDataRes(types.String)
	},
	"whois.contact.phone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetPhone()).ToDataRes(types.String)
	},
	"whois.contact.email": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetEmail()).ToDataRes(types.String)
	},
	"whois.contact.registrarUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlWhoisContact).GetRegistrarUrl()).ToDataRes(types.String)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"socket.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlSocket).__id, ok = v.Value.(string)
			return
		},
	"socket.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSocket).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"socket.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSocket).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"socket.address": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlSocket).Address, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttp).__id, ok = v.Value.(string)
			return
		},
	"http.get.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpGet).__id, ok = v.Value.(string)
			return
		},
	"http.get.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpGet).Url, ok = plugin.RawToTValue[*mqlUrl](v.Value, v.Error)
		return
	},
	"http.get.header": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpGet).Header, ok = plugin.RawToTValue[*mqlHttpHeader](v.Value, v.Error)
		return
	},
	"http.get.statusCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpGet).StatusCode, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"http.get.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpGet).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.get.body": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpGet).Body, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpHeader).__id, ok = v.Value.(string)
			return
		},
	"http.header.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"http.header.sts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).Sts, ok = plugin.RawToTValue[*mqlHttpHeaderSts](v.Value, v.Error)
		return
	},
	"http.header.xFrameOptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).XFrameOptions, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.xXssProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).XXssProtection, ok = plugin.RawToTValue[*mqlHttpHeaderXssProtection](v.Value, v.Error)
		return
	},
	"http.header.xContentTypeOptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).XContentTypeOptions, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.referrerPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).ReferrerPolicy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.contentType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).ContentType, ok = plugin.RawToTValue[*mqlHttpHeaderContentType](v.Value, v.Error)
		return
	},
	"http.header.setCookie": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).SetCookie, ok = plugin.RawToTValue[*mqlHttpHeaderSetCookie](v.Value, v.Error)
		return
	},
	"http.header.csp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeader).Csp, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"http.header.sts.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpHeaderSts).__id, ok = v.Value.(string)
			return
		},
	"http.header.sts.maxAge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSts).MaxAge, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"http.header.sts.includeSubDomains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSts).IncludeSubDomains, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"http.header.sts.preload": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSts).Preload, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"http.header.xssProtection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpHeaderXssProtection).__id, ok = v.Value.(string)
			return
		},
	"http.header.xssProtection.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderXssProtection).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"http.header.xssProtection.mode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderXssProtection).Mode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.xssProtection.report": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderXssProtection).Report, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.contentType.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpHeaderContentType).__id, ok = v.Value.(string)
			return
		},
	"http.header.contentType.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderContentType).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.contentType.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderContentType).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"http.header.setCookie.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlHttpHeaderSetCookie).__id, ok = v.Value.(string)
			return
		},
	"http.header.setCookie.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSetCookie).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.setCookie.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSetCookie).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"http.header.setCookie.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlHttpHeaderSetCookie).Params, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"url.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlUrl).__id, ok = v.Value.(string)
			return
		},
	"url.string": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).String, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).User, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.password": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Password, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.host": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Host, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"url.path": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Path, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.query": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).Query, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"url.rawQuery": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).RawQuery, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"url.rawFragment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlUrl).RawFragment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"tls.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlTls).__id, ok = v.Value.(string)
			return
		},
	"tls.socket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Socket, ok = plugin.RawToTValue[*mqlSocket](v.Value, v.Error)
		return
	},
	"tls.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"tls.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Params, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"tls.versions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Versions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"tls.ciphers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Ciphers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"tls.extensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Extensions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"tls.certificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).Certificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"tls.nonSniCertificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlTls).NonSniCertificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificates.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlCertificates).__id, ok = v.Value.(string)
			return
		},
	"certificates.pem": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificates).Pem, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificates.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificates).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlCertificate).__id, ok = v.Value.(string)
			return
		},
	"certificate.pem": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Pem, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.fingerprints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Fingerprints, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"certificate.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.subjectKeyID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).SubjectKeyID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.authorityKeyID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).AuthorityKeyID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.subject": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Subject, ok = plugin.RawToTValue[*mqlPkixName](v.Value, v.Error)
		return
	},
	"certificate.issuer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Issuer, ok = plugin.RawToTValue[*mqlPkixName](v.Value, v.Error)
		return
	},
	"certificate.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Version, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"certificate.notBefore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).NotBefore, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"certificate.notAfter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).NotAfter, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"certificate.expiresIn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).ExpiresIn, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"certificate.signature": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Signature, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.signingAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).SigningAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"certificate.isCA": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).IsCA, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"certificate.keyUsage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).KeyUsage, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.extendedKeyUsage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).ExtendedKeyUsage, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.extensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).Extensions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.policyIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).PolicyIdentifier, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.crlDistributionPoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).CrlDistributionPoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.ocspServer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).OcspServer, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.issuingCertificateUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).IssuingCertificateUrl, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"certificate.isRevoked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).IsRevoked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"certificate.revokedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).RevokedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"certificate.isVerified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).IsVerified, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"certificate.sanExtension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlCertificate).SanExtension, ok = plugin.RawToTValue[*mqlPkixSanExtension](v.Value, v.Error)
		return
	},
	"pkix.name.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPkixName).__id, ok = v.Value.(string)
			return
		},
	"pkix.name.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.name.dn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Dn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.name.serialNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).SerialNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.name.commonName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).CommonName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.name.country": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Country, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Organization, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.organizationalUnit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).OrganizationalUnit, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.locality": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Locality, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.province": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Province, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.streetAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).StreetAddress, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.postalCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).PostalCode, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.names": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).Names, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"pkix.name.extraNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixName).ExtraNames, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"pkix.extension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPkixExtension).__id, ok = v.Value.(string)
			return
		},
	"pkix.extension.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixExtension).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.extension.identifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixExtension).Identifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.extension.critical": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixExtension).Critical, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"pkix.extension.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixExtension).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"pkix.sanExtension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlPkixSanExtension).__id, ok = v.Value.(string)
			return
		},
	"pkix.sanExtension.extension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixSanExtension).Extension, ok = plugin.RawToTValue[*mqlPkixExtension](v.Value, v.Error)
		return
	},
	"pkix.sanExtension.dnsNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixSanExtension).DnsNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.sanExtension.ipAddresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixSanExtension).IpAddresses, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.sanExtension.emailAddresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixSanExtension).EmailAddresses, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"pkix.sanExtension.uris": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlPkixSanExtension).Uris, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"openpgp.entities.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpenpgpEntities).__id, ok = v.Value.(string)
			return
		},
	"openpgp.entities.content": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpEntities).Content, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.entities.list": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpEntities).List, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"openpgp.entity.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpenpgpEntity).__id, ok = v.Value.(string)
			return
		},
	"openpgp.entity.primaryPublicKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpEntity).PrimaryPublicKey, ok = plugin.RawToTValue[*mqlOpenpgpPublicKey](v.Value, v.Error)
		return
	},
	"openpgp.entity.identities": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpEntity).Identities, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpenpgpPublicKey).__id, ok = v.Value.(string)
			return
		},
	"openpgp.publicKey.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).Version, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.keyAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).KeyAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.bitLength": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).BitLength, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"openpgp.publicKey.creationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpPublicKey).CreationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"openpgp.identity.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpenpgpIdentity).__id, ok = v.Value.(string)
			return
		},
	"openpgp.identity.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.identity.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.identity.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.identity.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.identity.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.identity.signatures": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpIdentity).Signatures, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"openpgp.signature.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlOpenpgpSignature).__id, ok = v.Value.(string)
			return
		},
	"openpgp.signature.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.signature.identityName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).IdentityName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.signature.hash": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).Hash, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.signature.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).Version, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"openpgp.signature.signatureType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).SignatureType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.signature.keyAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).KeyAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"openpgp.signature.creationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).CreationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"openpgp.signature.lifetimeSecs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).LifetimeSecs, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"openpgp.signature.expiresIn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).ExpiresIn, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"openpgp.signature.keyLifetimeSecs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).KeyLifetimeSecs, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"openpgp.signature.keyExpiresIn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlOpenpgpSignature).KeyExpiresIn, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"domainName.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDomainName).__id, ok = v.Value.(string)
			return
		},
	"domainName.fqdn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDomainName).Fqdn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"domainName.effectiveTLDPlusOne": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDomainName).EffectiveTLDPlusOne, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"domainName.tld": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDomainName).Tld, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"domainName.tldIcannManaged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDomainName).TldIcannManaged, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"domainName.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDomainName).Labels, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDns).__id, ok = v.Value.(string)
			return
		},
	"dns.fqdn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDns).Fqdn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.params": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDns).Params, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"dns.records": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDns).Records, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.mx": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDns).Mx, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.dkim": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDns).Dkim, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.record.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDnsRecord).__id, ok = v.Value.(string)
			return
		},
	"dns.record.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsRecord).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.record.ttl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsRecord).Ttl, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"dns.record.class": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsRecord).Class, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.record.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsRecord).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.record.rdata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsRecord).Rdata, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.mxRecord.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDnsMxRecord).__id, ok = v.Value.(string)
			return
		},
	"dns.mxRecord.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsMxRecord).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.mxRecord.preference": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsMxRecord).Preference, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"dns.mxRecord.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsMxRecord).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlDnsDkimRecord).__id, ok = v.Value.(string)
			return
		},
	"dns.dkimRecord.dnsTxt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).DnsTxt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.domain": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).Domain, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.hashAlgorithms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).HashAlgorithms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.keyType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).KeyType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.notes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).Notes, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.publicKeyData": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).PublicKeyData, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.serviceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).ServiceTypes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.flags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).Flags, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"dns.dkimRecord.valid": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlDnsDkimRecord).Valid, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"whois.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlWhois).__id, ok = v.Value.(string)
			return
		},
	"whois.host": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Host, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domain": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Domain, ok = plugin.RawToTValue[*mqlWhoisDomainInfo](v.Value, v.Error)
		return
	},
	"whois.registrar": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Registrar, ok = plugin.RawToTValue[*mqlWhoisContact](v.Value, v.Error)
		return
	},
	"whois.registrant": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Registrant, ok = plugin.RawToTValue[*mqlWhoisContact](v.Value, v.Error)
		return
	},
	"whois.administrative": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Administrative, ok = plugin.RawToTValue[*mqlWhoisContact](v.Value, v.Error)
		return
	},
	"whois.technical": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Technical, ok = plugin.RawToTValue[*mqlWhoisContact](v.Value, v.Error)
		return
	},
	"whois.billing": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhois).Billing, ok = plugin.RawToTValue[*mqlWhoisContact](v.Value, v.Error)
		return
	},
	"whois.domainInfo.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlWhoisDomainInfo).__id, ok = v.Value.(string)
			return
		},
	"whois.domainInfo.domain": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).Domain, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domainInfo.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domainInfo.punyCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).PunyCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domainInfo.extension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).Extension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domainInfo.whoisServer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).WhoisServer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.domainInfo.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).Status, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"whois.domainInfo.nameServers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).NameServers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"whois.domainInfo.dnssec": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).Dnssec, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"whois.domainInfo.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"whois.domainInfo.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"whois.domainInfo.expiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisDomainInfo).ExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"whois.contact.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlWhoisContact).__id, ok = v.Value.(string)
			return
		},
	"whois.contact.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Organization, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.street": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Street, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.city": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).City, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.province": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Province, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.postalCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).PostalCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.country": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Country, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.phone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Phone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.email": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).Email, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"whois.contact.registrarUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlWhoisContact).RegistrarUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[network] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[network] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlSocket for the socket resource
type mqlSocket struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlSocketInternal it will be used here
	Protocol plugin.TValue[string]
	Port plugin.TValue[int64]
	Address plugin.TValue[string]
}

// createSocket creates a new instance of this resource
func createSocket(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlSocket{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("socket", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlSocket) MqlName() string {
	return "socket"
}

func (c *mqlSocket) MqlID() string {
	return c.__id
}

func (c *mqlSocket) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlSocket) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlSocket) GetAddress() *plugin.TValue[string] {
	return &c.Address
}

// mqlHttp for the http resource
type mqlHttp struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpInternal it will be used here
}

// createHttp creates a new instance of this resource
func createHttp(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttp{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttp) MqlName() string {
	return "http"
}

func (c *mqlHttp) MqlID() string {
	return c.__id
}

// mqlHttpGet for the http.get resource
type mqlHttpGet struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlHttpGetInternal
	Url plugin.TValue[*mqlUrl]
	Header plugin.TValue[*mqlHttpHeader]
	StatusCode plugin.TValue[int64]
	Version plugin.TValue[string]
	Body plugin.TValue[string]
}

// createHttpGet creates a new instance of this resource
func createHttpGet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpGet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.get", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpGet) MqlName() string {
	return "http.get"
}

func (c *mqlHttpGet) MqlID() string {
	return c.__id
}

func (c *mqlHttpGet) GetUrl() *plugin.TValue[*mqlUrl] {
	return &c.Url
}

func (c *mqlHttpGet) GetHeader() *plugin.TValue[*mqlHttpHeader] {
	return plugin.GetOrCompute[*mqlHttpHeader](&c.Header, func() (*mqlHttpHeader, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("http.get", c.__id, "header")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlHttpHeader), nil
			}
		}

		return c.header()
	})
}

func (c *mqlHttpGet) GetStatusCode() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.StatusCode, func() (int64, error) {
		return c.statusCode()
	})
}

func (c *mqlHttpGet) GetVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Version, func() (string, error) {
		return c.version()
	})
}

func (c *mqlHttpGet) GetBody() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Body, func() (string, error) {
		return c.body()
	})
}

// mqlHttpHeader for the http.header resource
type mqlHttpHeader struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpHeaderInternal it will be used here
	Params plugin.TValue[map[string]interface{}]
	Sts plugin.TValue[*mqlHttpHeaderSts]
	XFrameOptions plugin.TValue[string]
	XXssProtection plugin.TValue[*mqlHttpHeaderXssProtection]
	XContentTypeOptions plugin.TValue[string]
	ReferrerPolicy plugin.TValue[string]
	ContentType plugin.TValue[*mqlHttpHeaderContentType]
	SetCookie plugin.TValue[*mqlHttpHeaderSetCookie]
	Csp plugin.TValue[map[string]interface{}]
}

// createHttpHeader creates a new instance of this resource
func createHttpHeader(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpHeader{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.header", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpHeader) MqlName() string {
	return "http.header"
}

func (c *mqlHttpHeader) MqlID() string {
	return c.__id
}

func (c *mqlHttpHeader) GetParams() *plugin.TValue[map[string]interface{}] {
	return &c.Params
}

func (c *mqlHttpHeader) GetSts() *plugin.TValue[*mqlHttpHeaderSts] {
	return plugin.GetOrCompute[*mqlHttpHeaderSts](&c.Sts, func() (*mqlHttpHeaderSts, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("http.header", c.__id, "sts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlHttpHeaderSts), nil
			}
		}

		return c.sts()
	})
}

func (c *mqlHttpHeader) GetXFrameOptions() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.XFrameOptions, func() (string, error) {
		return c.xFrameOptions()
	})
}

func (c *mqlHttpHeader) GetXXssProtection() *plugin.TValue[*mqlHttpHeaderXssProtection] {
	return plugin.GetOrCompute[*mqlHttpHeaderXssProtection](&c.XXssProtection, func() (*mqlHttpHeaderXssProtection, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("http.header", c.__id, "xXssProtection")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlHttpHeaderXssProtection), nil
			}
		}

		return c.xXssProtection()
	})
}

func (c *mqlHttpHeader) GetXContentTypeOptions() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.XContentTypeOptions, func() (string, error) {
		return c.xContentTypeOptions()
	})
}

func (c *mqlHttpHeader) GetReferrerPolicy() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.ReferrerPolicy, func() (string, error) {
		return c.referrerPolicy()
	})
}

func (c *mqlHttpHeader) GetContentType() *plugin.TValue[*mqlHttpHeaderContentType] {
	return plugin.GetOrCompute[*mqlHttpHeaderContentType](&c.ContentType, func() (*mqlHttpHeaderContentType, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("http.header", c.__id, "contentType")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlHttpHeaderContentType), nil
			}
		}

		return c.contentType()
	})
}

func (c *mqlHttpHeader) GetSetCookie() *plugin.TValue[*mqlHttpHeaderSetCookie] {
	return plugin.GetOrCompute[*mqlHttpHeaderSetCookie](&c.SetCookie, func() (*mqlHttpHeaderSetCookie, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("http.header", c.__id, "setCookie")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlHttpHeaderSetCookie), nil
			}
		}

		return c.setCookie()
	})
}

func (c *mqlHttpHeader) GetCsp() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Csp, func() (map[string]interface{}, error) {
		return c.csp()
	})
}

// mqlHttpHeaderSts for the http.header.sts resource
type mqlHttpHeaderSts struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpHeaderStsInternal it will be used here
	MaxAge plugin.TValue[*time.Time]
	IncludeSubDomains plugin.TValue[bool]
	Preload plugin.TValue[bool]
}

// createHttpHeaderSts creates a new instance of this resource
func createHttpHeaderSts(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpHeaderSts{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.header.sts", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpHeaderSts) MqlName() string {
	return "http.header.sts"
}

func (c *mqlHttpHeaderSts) MqlID() string {
	return c.__id
}

func (c *mqlHttpHeaderSts) GetMaxAge() *plugin.TValue[*time.Time] {
	return &c.MaxAge
}

func (c *mqlHttpHeaderSts) GetIncludeSubDomains() *plugin.TValue[bool] {
	return &c.IncludeSubDomains
}

func (c *mqlHttpHeaderSts) GetPreload() *plugin.TValue[bool] {
	return &c.Preload
}

// mqlHttpHeaderXssProtection for the http.header.xssProtection resource
type mqlHttpHeaderXssProtection struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpHeaderXssProtectionInternal it will be used here
	Enabled plugin.TValue[bool]
	Mode plugin.TValue[string]
	Report plugin.TValue[string]
}

// createHttpHeaderXssProtection creates a new instance of this resource
func createHttpHeaderXssProtection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpHeaderXssProtection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.header.xssProtection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpHeaderXssProtection) MqlName() string {
	return "http.header.xssProtection"
}

func (c *mqlHttpHeaderXssProtection) MqlID() string {
	return c.__id
}

func (c *mqlHttpHeaderXssProtection) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlHttpHeaderXssProtection) GetMode() *plugin.TValue[string] {
	return &c.Mode
}

func (c *mqlHttpHeaderXssProtection) GetReport() *plugin.TValue[string] {
	return &c.Report
}

// mqlHttpHeaderContentType for the http.header.contentType resource
type mqlHttpHeaderContentType struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpHeaderContentTypeInternal it will be used here
	Type plugin.TValue[string]
	Params plugin.TValue[map[string]interface{}]
}

// createHttpHeaderContentType creates a new instance of this resource
func createHttpHeaderContentType(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpHeaderContentType{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.header.contentType", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpHeaderContentType) MqlName() string {
	return "http.header.contentType"
}

func (c *mqlHttpHeaderContentType) MqlID() string {
	return c.__id
}

func (c *mqlHttpHeaderContentType) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlHttpHeaderContentType) GetParams() *plugin.TValue[map[string]interface{}] {
	return &c.Params
}

// mqlHttpHeaderSetCookie for the http.header.setCookie resource
type mqlHttpHeaderSetCookie struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlHttpHeaderSetCookieInternal it will be used here
	Name plugin.TValue[string]
	Value plugin.TValue[string]
	Params plugin.TValue[map[string]interface{}]
}

// createHttpHeaderSetCookie creates a new instance of this resource
func createHttpHeaderSetCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlHttpHeaderSetCookie{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("http.header.setCookie", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlHttpHeaderSetCookie) MqlName() string {
	return "http.header.setCookie"
}

func (c *mqlHttpHeaderSetCookie) MqlID() string {
	return c.__id
}

func (c *mqlHttpHeaderSetCookie) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlHttpHeaderSetCookie) GetValue() *plugin.TValue[string] {
	return &c.Value
}

func (c *mqlHttpHeaderSetCookie) GetParams() *plugin.TValue[map[string]interface{}] {
	return &c.Params
}

// mqlUrl for the url resource
type mqlUrl struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlUrlInternal it will be used here
	String plugin.TValue[string]
	Scheme plugin.TValue[string]
	User plugin.TValue[string]
	Password plugin.TValue[string]
	Host plugin.TValue[string]
	Port plugin.TValue[int64]
	Path plugin.TValue[string]
	Query plugin.TValue[map[string]interface{}]
	RawQuery plugin.TValue[string]
	RawFragment plugin.TValue[string]
}

// createUrl creates a new instance of this resource
func createUrl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlUrl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("url", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlUrl) MqlName() string {
	return "url"
}

func (c *mqlUrl) MqlID() string {
	return c.__id
}

func (c *mqlUrl) GetString() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.String, func() (string, error) {
		return c.string()
	})
}

func (c *mqlUrl) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlUrl) GetUser() *plugin.TValue[string] {
	return &c.User
}

func (c *mqlUrl) GetPassword() *plugin.TValue[string] {
	return &c.Password
}

func (c *mqlUrl) GetHost() *plugin.TValue[string] {
	return &c.Host
}

func (c *mqlUrl) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlUrl) GetPath() *plugin.TValue[string] {
	return &c.Path
}

func (c *mqlUrl) GetQuery() *plugin.TValue[map[string]interface{}] {
	return &c.Query
}

func (c *mqlUrl) GetRawQuery() *plugin.TValue[string] {
	return &c.RawQuery
}

func (c *mqlUrl) GetRawFragment() *plugin.TValue[string] {
	return &c.RawFragment
}

// mqlTls for the tls resource
type mqlTls struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlTlsInternal
	Socket plugin.TValue[*mqlSocket]
	DomainName plugin.TValue[string]
	Params plugin.TValue[interface{}]
	Versions plugin.TValue[[]interface{}]
	Ciphers plugin.TValue[[]interface{}]
	Extensions plugin.TValue[[]interface{}]
	Certificates plugin.TValue[[]interface{}]
	NonSniCertificates plugin.TValue[[]interface{}]
}

// createTls creates a new instance of this resource
func createTls(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlTls{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("tls", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlTls) MqlName() string {
	return "tls"
}

func (c *mqlTls) MqlID() string {
	return c.__id
}

func (c *mqlTls) GetSocket() *plugin.TValue[*mqlSocket] {
	return &c.Socket
}

func (c *mqlTls) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlTls) GetParams() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Params, func() (interface{}, error) {
		vargSocket := c.GetSocket()
		if vargSocket.Error != nil {
			return nil, vargSocket.Error
		}

		vargDomainName := c.GetDomainName()
		if vargDomainName.Error != nil {
			return nil, vargDomainName.Error
		}

		return c.params(vargSocket.Data, vargDomainName.Data)
	})
}

func (c *mqlTls) GetVersions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Versions, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.versions(vargParams.Data)
	})
}

func (c *mqlTls) GetCiphers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Ciphers, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.ciphers(vargParams.Data)
	})
}

func (c *mqlTls) GetExtensions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Extensions, func() ([]interface{}, error) {
		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.extensions(vargParams.Data)
	})
}

func (c *mqlTls) GetCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Certificates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("tls", c.__id, "certificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargSocket := c.GetSocket()
		if vargSocket.Error != nil {
			return nil, vargSocket.Error
		}

		vargDomainName := c.GetDomainName()
		if vargDomainName.Error != nil {
			return nil, vargDomainName.Error
		}

		return c.certificates(vargSocket.Data, vargDomainName.Data)
	})
}

func (c *mqlTls) GetNonSniCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NonSniCertificates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("tls", c.__id, "nonSniCertificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargSocket := c.GetSocket()
		if vargSocket.Error != nil {
			return nil, vargSocket.Error
		}

		vargDomainName := c.GetDomainName()
		if vargDomainName.Error != nil {
			return nil, vargDomainName.Error
		}

		return c.nonSniCertificates(vargSocket.Data, vargDomainName.Data)
	})
}

// mqlCertificates for the certificates resource
type mqlCertificates struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlCertificatesInternal it will be used here
	Pem plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createCertificates creates a new instance of this resource
func createCertificates(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlCertificates{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("certificates", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlCertificates) MqlName() string {
	return "certificates"
}

func (c *mqlCertificates) MqlID() string {
	return c.__id
}

func (c *mqlCertificates) GetPem() *plugin.TValue[string] {
	return &c.Pem
}

func (c *mqlCertificates) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("certificates", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.list()
	})
}

// mqlCertificate for the certificate resource
type mqlCertificate struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlCertificateInternal
	Pem plugin.TValue[string]
	Fingerprints plugin.TValue[map[string]interface{}]
	Serial plugin.TValue[string]
	SubjectKeyID plugin.TValue[string]
	AuthorityKeyID plugin.TValue[string]
	Subject plugin.TValue[*mqlPkixName]
	Issuer plugin.TValue[*mqlPkixName]
	Version plugin.TValue[int64]
	NotBefore plugin.TValue[*time.Time]
	NotAfter plugin.TValue[*time.Time]
	ExpiresIn plugin.TValue[*time.Time]
	Signature plugin.TValue[string]
	SigningAlgorithm plugin.TValue[string]
	IsCA plugin.TValue[bool]
	KeyUsage plugin.TValue[[]interface{}]
	ExtendedKeyUsage plugin.TValue[[]interface{}]
	Extensions plugin.TValue[[]interface{}]
	PolicyIdentifier plugin.TValue[[]interface{}]
	CrlDistributionPoints plugin.TValue[[]interface{}]
	OcspServer plugin.TValue[[]interface{}]
	IssuingCertificateUrl plugin.TValue[[]interface{}]
	IsRevoked plugin.TValue[bool]
	RevokedAt plugin.TValue[*time.Time]
	IsVerified plugin.TValue[bool]
	SanExtension plugin.TValue[*mqlPkixSanExtension]
}

// createCertificate creates a new instance of this resource
func createCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlCertificate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("certificate", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlCertificate) MqlName() string {
	return "certificate"
}

func (c *mqlCertificate) MqlID() string {
	return c.__id
}

func (c *mqlCertificate) GetPem() *plugin.TValue[string] {
	return &c.Pem
}

func (c *mqlCertificate) GetFingerprints() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Fingerprints, func() (map[string]interface{}, error) {
		return c.fingerprints()
	})
}

func (c *mqlCertificate) GetSerial() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Serial, func() (string, error) {
		return c.serial()
	})
}

func (c *mqlCertificate) GetSubjectKeyID() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.SubjectKeyID, func() (string, error) {
		return c.subjectKeyID()
	})
}

func (c *mqlCertificate) GetAuthorityKeyID() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AuthorityKeyID, func() (string, error) {
		return c.authorityKeyID()
	})
}

func (c *mqlCertificate) GetSubject() *plugin.TValue[*mqlPkixName] {
	return plugin.GetOrCompute[*mqlPkixName](&c.Subject, func() (*mqlPkixName, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("certificate", c.__id, "subject")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlPkixName), nil
			}
		}

		return c.subject()
	})
}

func (c *mqlCertificate) GetIssuer() *plugin.TValue[*mqlPkixName] {
	return plugin.GetOrCompute[*mqlPkixName](&c.Issuer, func() (*mqlPkixName, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("certificate", c.__id, "issuer")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlPkixName), nil
			}
		}

		return c.issuer()
	})
}

func (c *mqlCertificate) GetVersion() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Version, func() (int64, error) {
		return c.version()
	})
}

func (c *mqlCertificate) GetNotBefore() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.NotBefore, func() (*time.Time, error) {
		return c.notBefore()
	})
}

func (c *mqlCertificate) GetNotAfter() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.NotAfter, func() (*time.Time, error) {
		return c.notAfter()
	})
}

func (c *mqlCertificate) GetExpiresIn() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ExpiresIn, func() (*time.Time, error) {
		return c.expiresIn()
	})
}

func (c *mqlCertificate) GetSignature() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Signature, func() (string, error) {
		return c.signature()
	})
}

func (c *mqlCertificate) GetSigningAlgorithm() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.SigningAlgorithm, func() (string, error) {
		return c.signingAlgorithm()
	})
}

func (c *mqlCertificate) GetIsCA() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsCA, func() (bool, error) {
		return c.isCA()
	})
}

func (c *mqlCertificate) GetKeyUsage() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.KeyUsage, func() ([]interface{}, error) {
		return c.keyUsage()
	})
}

func (c *mqlCertificate) GetExtendedKeyUsage() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ExtendedKeyUsage, func() ([]interface{}, error) {
		return c.extendedKeyUsage()
	})
}

func (c *mqlCertificate) GetExtensions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Extensions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("certificate", c.__id, "extensions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.extensions()
	})
}

func (c *mqlCertificate) GetPolicyIdentifier() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PolicyIdentifier, func() ([]interface{}, error) {
		return c.policyIdentifier()
	})
}

func (c *mqlCertificate) GetCrlDistributionPoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CrlDistributionPoints, func() ([]interface{}, error) {
		return c.crlDistributionPoints()
	})
}

func (c *mqlCertificate) GetOcspServer() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.OcspServer, func() ([]interface{}, error) {
		return c.ocspServer()
	})
}

func (c *mqlCertificate) GetIssuingCertificateUrl() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.IssuingCertificateUrl, func() ([]interface{}, error) {
		return c.issuingCertificateUrl()
	})
}

func (c *mqlCertificate) GetIsRevoked() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsRevoked, func() (bool, error) {
		return c.isRevoked()
	})
}

func (c *mqlCertificate) GetRevokedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.RevokedAt, func() (*time.Time, error) {
		return c.revokedAt()
	})
}

func (c *mqlCertificate) GetIsVerified() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsVerified, func() (bool, error) {
		return c.isVerified()
	})
}

func (c *mqlCertificate) GetSanExtension() *plugin.TValue[*mqlPkixSanExtension] {
	return plugin.GetOrCompute[*mqlPkixSanExtension](&c.SanExtension, func() (*mqlPkixSanExtension, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("certificate", c.__id, "sanExtension")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlPkixSanExtension), nil
			}
		}

		return c.sanExtension()
	})
}

// mqlPkixName for the pkix.name resource
type mqlPkixName struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPkixNameInternal it will be used here
	Id plugin.TValue[string]
	Dn plugin.TValue[string]
	SerialNumber plugin.TValue[string]
	CommonName plugin.TValue[string]
	Country plugin.TValue[[]interface{}]
	Organization plugin.TValue[[]interface{}]
	OrganizationalUnit plugin.TValue[[]interface{}]
	Locality plugin.TValue[[]interface{}]
	Province plugin.TValue[[]interface{}]
	StreetAddress plugin.TValue[[]interface{}]
	PostalCode plugin.TValue[[]interface{}]
	Names plugin.TValue[map[string]interface{}]
	ExtraNames plugin.TValue[map[string]interface{}]
}

// createPkixName creates a new instance of this resource
func createPkixName(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPkixName{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("pkix.name", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPkixName) MqlName() string {
	return "pkix.name"
}

func (c *mqlPkixName) MqlID() string {
	return c.__id
}

func (c *mqlPkixName) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlPkixName) GetDn() *plugin.TValue[string] {
	return &c.Dn
}

func (c *mqlPkixName) GetSerialNumber() *plugin.TValue[string] {
	return &c.SerialNumber
}

func (c *mqlPkixName) GetCommonName() *plugin.TValue[string] {
	return &c.CommonName
}

func (c *mqlPkixName) GetCountry() *plugin.TValue[[]interface{}] {
	return &c.Country
}

func (c *mqlPkixName) GetOrganization() *plugin.TValue[[]interface{}] {
	return &c.Organization
}

func (c *mqlPkixName) GetOrganizationalUnit() *plugin.TValue[[]interface{}] {
	return &c.OrganizationalUnit
}

func (c *mqlPkixName) GetLocality() *plugin.TValue[[]interface{}] {
	return &c.Locality
}

func (c *mqlPkixName) GetProvince() *plugin.TValue[[]interface{}] {
	return &c.Province
}

func (c *mqlPkixName) GetStreetAddress() *plugin.TValue[[]interface{}] {
	return &c.StreetAddress
}

func (c *mqlPkixName) GetPostalCode() *plugin.TValue[[]interface{}] {
	return &c.PostalCode
}

func (c *mqlPkixName) GetNames() *plugin.TValue[map[string]interface{}] {
	return &c.Names
}

func (c *mqlPkixName) GetExtraNames() *plugin.TValue[map[string]interface{}] {
	return &c.ExtraNames
}

// mqlPkixExtension for the pkix.extension resource
type mqlPkixExtension struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPkixExtensionInternal it will be used here
	Id plugin.TValue[string]
	Identifier plugin.TValue[string]
	Critical plugin.TValue[bool]
	Value plugin.TValue[string]
}

// createPkixExtension creates a new instance of this resource
func createPkixExtension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPkixExtension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("pkix.extension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPkixExtension) MqlName() string {
	return "pkix.extension"
}

func (c *mqlPkixExtension) MqlID() string {
	return c.__id
}

func (c *mqlPkixExtension) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlPkixExtension) GetIdentifier() *plugin.TValue[string] {
	return &c.Identifier
}

func (c *mqlPkixExtension) GetCritical() *plugin.TValue[bool] {
	return &c.Critical
}

func (c *mqlPkixExtension) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlPkixSanExtension for the pkix.sanExtension resource
type mqlPkixSanExtension struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlPkixSanExtensionInternal it will be used here
	Extension plugin.TValue[*mqlPkixExtension]
	DnsNames plugin.TValue[[]interface{}]
	IpAddresses plugin.TValue[[]interface{}]
	EmailAddresses plugin.TValue[[]interface{}]
	Uris plugin.TValue[[]interface{}]
}

// createPkixSanExtension creates a new instance of this resource
func createPkixSanExtension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlPkixSanExtension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("pkix.sanExtension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlPkixSanExtension) MqlName() string {
	return "pkix.sanExtension"
}

func (c *mqlPkixSanExtension) MqlID() string {
	return c.__id
}

func (c *mqlPkixSanExtension) GetExtension() *plugin.TValue[*mqlPkixExtension] {
	return &c.Extension
}

func (c *mqlPkixSanExtension) GetDnsNames() *plugin.TValue[[]interface{}] {
	return &c.DnsNames
}

func (c *mqlPkixSanExtension) GetIpAddresses() *plugin.TValue[[]interface{}] {
	return &c.IpAddresses
}

func (c *mqlPkixSanExtension) GetEmailAddresses() *plugin.TValue[[]interface{}] {
	return &c.EmailAddresses
}

func (c *mqlPkixSanExtension) GetUris() *plugin.TValue[[]interface{}] {
	return &c.Uris
}

// mqlOpenpgpEntities for the openpgp.entities resource
type mqlOpenpgpEntities struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpenpgpEntitiesInternal it will be used here
	Content plugin.TValue[string]
	List plugin.TValue[[]interface{}]
}

// createOpenpgpEntities creates a new instance of this resource
func createOpenpgpEntities(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpenpgpEntities{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("openpgp.entities", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpenpgpEntities) MqlName() string {
	return "openpgp.entities"
}

func (c *mqlOpenpgpEntities) MqlID() string {
	return c.__id
}

func (c *mqlOpenpgpEntities) GetContent() *plugin.TValue[string] {
	return &c.Content
}

func (c *mqlOpenpgpEntities) GetList() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.List, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("openpgp.entities", c.__id, "list")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargContent := c.GetContent()
		if vargContent.Error != nil {
			return nil, vargContent.Error
		}

		return c.list(vargContent.Data)
	})
}

// mqlOpenpgpEntity for the openpgp.entity resource
type mqlOpenpgpEntity struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlOpenpgpEntityInternal
	PrimaryPublicKey plugin.TValue[*mqlOpenpgpPublicKey]
	Identities plugin.TValue[[]interface{}]
}

// createOpenpgpEntity creates a new instance of this resource
func createOpenpgpEntity(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpenpgpEntity{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("openpgp.entity", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpenpgpEntity) MqlName() string {
	return "openpgp.entity"
}

func (c *mqlOpenpgpEntity) MqlID() string {
	return c.__id
}

func (c *mqlOpenpgpEntity) GetPrimaryPublicKey() *plugin.TValue[*mqlOpenpgpPublicKey] {
	return &c.PrimaryPublicKey
}

func (c *mqlOpenpgpEntity) GetIdentities() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Identities, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("openpgp.entity", c.__id, "identities")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.identities()
	})
}

// mqlOpenpgpPublicKey for the openpgp.publicKey resource
type mqlOpenpgpPublicKey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpenpgpPublicKeyInternal it will be used here
	Id plugin.TValue[string]
	Version plugin.TValue[int64]
	Fingerprint plugin.TValue[string]
	KeyAlgorithm plugin.TValue[string]
	BitLength plugin.TValue[int64]
	CreationTime plugin.TValue[*time.Time]
}

// createOpenpgpPublicKey creates a new instance of this resource
func createOpenpgpPublicKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpenpgpPublicKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("openpgp.publicKey", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpenpgpPublicKey) MqlName() string {
	return "openpgp.publicKey"
}

func (c *mqlOpenpgpPublicKey) MqlID() string {
	return c.__id
}

func (c *mqlOpenpgpPublicKey) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlOpenpgpPublicKey) GetVersion() *plugin.TValue[int64] {
	return &c.Version
}

func (c *mqlOpenpgpPublicKey) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlOpenpgpPublicKey) GetKeyAlgorithm() *plugin.TValue[string] {
	return &c.KeyAlgorithm
}

func (c *mqlOpenpgpPublicKey) GetBitLength() *plugin.TValue[int64] {
	return &c.BitLength
}

func (c *mqlOpenpgpPublicKey) GetCreationTime() *plugin.TValue[*time.Time] {
	return &c.CreationTime
}

// mqlOpenpgpIdentity for the openpgp.identity resource
type mqlOpenpgpIdentity struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlOpenpgpIdentityInternal
	Fingerprint plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Email plugin.TValue[string]
	Comment plugin.TValue[string]
	Signatures plugin.TValue[[]interface{}]
}

// createOpenpgpIdentity creates a new instance of this resource
func createOpenpgpIdentity(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpenpgpIdentity{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("openpgp.identity", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpenpgpIdentity) MqlName() string {
	return "openpgp.identity"
}

func (c *mqlOpenpgpIdentity) MqlID() string {
	return c.__id
}

func (c *mqlOpenpgpIdentity) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlOpenpgpIdentity) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlOpenpgpIdentity) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlOpenpgpIdentity) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlOpenpgpIdentity) GetComment() *plugin.TValue[string] {
	return &c.Comment
}

func (c *mqlOpenpgpIdentity) GetSignatures() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Signatures, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("openpgp.identity", c.__id, "signatures")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.signatures()
	})
}

// mqlOpenpgpSignature for the openpgp.signature resource
type mqlOpenpgpSignature struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlOpenpgpSignatureInternal it will be used here
	Fingerprint plugin.TValue[string]
	IdentityName plugin.TValue[string]
	Hash plugin.TValue[string]
	Version plugin.TValue[int64]
	SignatureType plugin.TValue[string]
	KeyAlgorithm plugin.TValue[string]
	CreationTime plugin.TValue[*time.Time]
	LifetimeSecs plugin.TValue[int64]
	ExpiresIn plugin.TValue[*time.Time]
	KeyLifetimeSecs plugin.TValue[int64]
	KeyExpiresIn plugin.TValue[*time.Time]
}

// createOpenpgpSignature creates a new instance of this resource
func createOpenpgpSignature(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlOpenpgpSignature{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("openpgp.signature", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlOpenpgpSignature) MqlName() string {
	return "openpgp.signature"
}

func (c *mqlOpenpgpSignature) MqlID() string {
	return c.__id
}

func (c *mqlOpenpgpSignature) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlOpenpgpSignature) GetIdentityName() *plugin.TValue[string] {
	return &c.IdentityName
}

func (c *mqlOpenpgpSignature) GetHash() *plugin.TValue[string] {
	return &c.Hash
}

func (c *mqlOpenpgpSignature) GetVersion() *plugin.TValue[int64] {
	return &c.Version
}

func (c *mqlOpenpgpSignature) GetSignatureType() *plugin.TValue[string] {
	return &c.SignatureType
}

func (c *mqlOpenpgpSignature) GetKeyAlgorithm() *plugin.TValue[string] {
	return &c.KeyAlgorithm
}

func (c *mqlOpenpgpSignature) GetCreationTime() *plugin.TValue[*time.Time] {
	return &c.CreationTime
}

func (c *mqlOpenpgpSignature) GetLifetimeSecs() *plugin.TValue[int64] {
	return &c.LifetimeSecs
}

func (c *mqlOpenpgpSignature) GetExpiresIn() *plugin.TValue[*time.Time] {
	return &c.ExpiresIn
}

func (c *mqlOpenpgpSignature) GetKeyLifetimeSecs() *plugin.TValue[int64] {
	return &c.KeyLifetimeSecs
}

func (c *mqlOpenpgpSignature) GetKeyExpiresIn() *plugin.TValue[*time.Time] {
	return &c.KeyExpiresIn
}

// mqlDomainName for the domainName resource
type mqlDomainName struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDomainNameInternal it will be used here
	Fqdn plugin.TValue[string]
	EffectiveTLDPlusOne plugin.TValue[string]
	Tld plugin.TValue[string]
	TldIcannManaged plugin.TValue[bool]
	Labels plugin.TValue[[]interface{}]
}

// createDomainName creates a new instance of this resource
func createDomainName(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDomainName{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("domainName", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDomainName) MqlName() string {
	return "domainName"
}

func (c *mqlDomainName) MqlID() string {
	return c.__id
}

func (c *mqlDomainName) GetFqdn() *plugin.TValue[string] {
	return &c.Fqdn
}

func (c *mqlDomainName) GetEffectiveTLDPlusOne() *plugin.TValue[string] {
	return &c.EffectiveTLDPlusOne
}

func (c *mqlDomainName) GetTld() *plugin.TValue[string] {
	return &c.Tld
}

func (c *mqlDomainName) GetTldIcannManaged() *plugin.TValue[bool] {
	return &c.TldIcannManaged
}

func (c *mqlDomainName) GetLabels() *plugin.TValue[[]interface{}] {
	return &c.Labels
}

// mqlDns for the dns resource
type mqlDns struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDnsInternal it will be used here
	Fqdn plugin.TValue[string]
	Params plugin.TValue[interface{}]
	Records plugin.TValue[[]interface{}]
	Mx plugin.TValue[[]interface{}]
	Dkim plugin.TValue[[]interface{}]
}

// createDns creates a new instance of this resource
func createDns(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDns{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("dns", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDns) MqlName() string {
	return "dns"
}

func (c *mqlDns) MqlID() string {
	return c.__id
}

func (c *mqlDns) GetFqdn() *plugin.TValue[string] {
	return &c.Fqdn
}

func (c *mqlDns) GetParams() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Params, func() (interface{}, error) {
		vargFqdn := c.GetFqdn()
		if vargFqdn.Error != nil {
			return nil, vargFqdn.Error
		}

		return c.params(vargFqdn.Data)
	})
}

func (c *mqlDns) GetRecords() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Records, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("dns", c.__id, "records")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.records(vargParams.Data)
	})
}

func (c *mqlDns) GetMx() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Mx, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("dns", c.__id, "mx")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.mx(vargParams.Data)
	})
}

func (c *mqlDns) GetDkim() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Dkim, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("dns", c.__id, "dkim")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		vargParams := c.GetParams()
		if vargParams.Error != nil {
			return nil, vargParams.Error
		}

		return c.dkim(vargParams.Data)
	})
}

// mqlDnsRecord for the dns.record resource
type mqlDnsRecord struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDnsRecordInternal it will be used here
	Name plugin.TValue[string]
	Ttl plugin.TValue[int64]
	Class plugin.TValue[string]
	Type plugin.TValue[string]
	Rdata plugin.TValue[[]interface{}]
}

// createDnsRecord creates a new instance of this resource
func createDnsRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDnsRecord{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("dns.record", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDnsRecord) MqlName() string {
	return "dns.record"
}

func (c *mqlDnsRecord) MqlID() string {
	return c.__id
}

func (c *mqlDnsRecord) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlDnsRecord) GetTtl() *plugin.TValue[int64] {
	return &c.Ttl
}

func (c *mqlDnsRecord) GetClass() *plugin.TValue[string] {
	return &c.Class
}

func (c *mqlDnsRecord) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlDnsRecord) GetRdata() *plugin.TValue[[]interface{}] {
	return &c.Rdata
}

// mqlDnsMxRecord for the dns.mxRecord resource
type mqlDnsMxRecord struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlDnsMxRecordInternal it will be used here
	Name plugin.TValue[string]
	Preference plugin.TValue[int64]
	DomainName plugin.TValue[string]
}

// createDnsMxRecord creates a new instance of this resource
func createDnsMxRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDnsMxRecord{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("dns.mxRecord", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDnsMxRecord) MqlName() string {
	return "dns.mxRecord"
}

func (c *mqlDnsMxRecord) MqlID() string {
	return c.__id
}

func (c *mqlDnsMxRecord) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlDnsMxRecord) GetPreference() *plugin.TValue[int64] {
	return &c.Preference
}

func (c *mqlDnsMxRecord) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

// mqlDnsDkimRecord for the dns.dkimRecord resource
type mqlDnsDkimRecord struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlDnsDkimRecordInternal
	DnsTxt plugin.TValue[string]
	Domain plugin.TValue[string]
	Version plugin.TValue[string]
	HashAlgorithms plugin.TValue[[]interface{}]
	KeyType plugin.TValue[string]
	Notes plugin.TValue[string]
	PublicKeyData plugin.TValue[string]
	ServiceTypes plugin.TValue[[]interface{}]
	Flags plugin.TValue[[]interface{}]
	Valid plugin.TValue[bool]
}

// createDnsDkimRecord creates a new instance of this resource
func createDnsDkimRecord(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlDnsDkimRecord{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("dns.dkimRecord", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlDnsDkimRecord) MqlName() string {
	return "dns.dkimRecord"
}

func (c *mqlDnsDkimRecord) MqlID() string {
	return c.__id
}

func (c *mqlDnsDkimRecord) GetDnsTxt() *plugin.TValue[string] {
	return &c.DnsTxt
}

func (c *mqlDnsDkimRecord) GetDomain() *plugin.TValue[string] {
	return &c.Domain
}

func (c *mqlDnsDkimRecord) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlDnsDkimRecord) GetHashAlgorithms() *plugin.TValue[[]interface{}] {
	return &c.HashAlgorithms
}

func (c *mqlDnsDkimRecord) GetKeyType() *plugin.TValue[string] {
	return &c.KeyType
}

func (c *mqlDnsDkimRecord) GetNotes() *plugin.TValue[string] {
	return &c.Notes
}

func (c *mqlDnsDkimRecord) GetPublicKeyData() *plugin.TValue[string] {
	return &c.PublicKeyData
}

func (c *mqlDnsDkimRecord) GetServiceTypes() *plugin.TValue[[]interface{}] {
	return &c.ServiceTypes
}

func (c *mqlDnsDkimRecord) GetFlags() *plugin.TValue[[]interface{}] {
	return &c.Flags
}

func (c *mqlDnsDkimRecord) GetValid() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Valid, func() (bool, error) {
		return c.valid()
	})
}

// mqlWhois for the whois resource
type mqlWhois struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlWhoisInternal it will be used here
	Host plugin.TValue[string]
	Domain plugin.TValue[*mqlWhoisDomainInfo]
	Registrar plugin.TValue[*mqlWhoisContact]
	Registrant plugin.TValue[*mqlWhoisContact]
	Administrative plugin.TValue[*mqlWhoisContact]
	Technical plugin.TValue[*mqlWhoisContact]
	Billing plugin.TValue[*mqlWhoisContact]
}

// createWhois creates a new instance of this resource
func createWhois(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlWhois{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("whois", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlWhois) MqlName() string {
	return "whois"
}

func (c *mqlWhois) MqlID() string {
	return c.__id
}

func (c *mqlWhois) GetHost() *plugin.TValue[string] {
	return &c.Host
}

func (c *mqlWhois) GetDomain() *plugin.TValue[*mqlWhoisDomainInfo] {
	return plugin.GetOrCompute[*mqlWhoisDomainInfo](&c.Domain, func() (*mqlWhoisDomainInfo, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "domain")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisDomainInfo), nil
			}
		}

		return c.domain()
	})
}

func (c *mqlWhois) GetRegistrar() *plugin.TValue[*mqlWhoisContact] {
	return plugin.GetOrCompute[*mqlWhoisContact](&c.Registrar, func() (*mqlWhoisContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "registrar")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisContact), nil
			}
		}

		return c.registrar()
	})
}

func (c *mqlWhois) GetRegistrant() *plugin.TValue[*mqlWhoisContact] {
	return plugin.GetOrCompute[*mqlWhoisContact](&c.Registrant, func() (*mqlWhoisContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "registrant")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisContact), nil
			}
		}

		return c.registrant()
	})
}

func (c *mqlWhois) GetAdministrative() *plugin.TValue[*mqlWhoisContact] {
	return plugin.GetOrCompute[*mqlWhoisContact](&c.Administrative, func() (*mqlWhoisContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "administrative")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisContact), nil
			}
		}

		return c.administrative()
	})
}

func (c *mqlWhois) GetTechnical() *plugin.TValue[*mqlWhoisContact] {
	return plugin.GetOrCompute[*mqlWhoisContact](&c.Technical, func() (*mqlWhoisContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "technical")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisContact), nil
			}
		}

		return c.technical()
	})
}

func (c *mqlWhois) GetBilling() *plugin.TValue[*mqlWhoisContact] {
	return plugin.GetOrCompute[*mqlWhoisContact](&c.Billing, func() (*mqlWhoisContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("whois", c.__id, "billing")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlWhoisContact), nil
			}
		}

		return c.billing()
	})
}

// mqlWhoisDomainInfo for the whois.domainInfo resource
type mqlWhoisDomainInfo struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlWhoisDomainInfoInternal it will be used here
	Domain plugin.TValue[string]
	Name plugin.TValue[string]
	PunyCode plugin.TValue[string]
	Extension plugin.TValue[string]
	WhoisServer plugin.TValue[string]
	Status plugin.TValue[[]interface{}]
	NameServers plugin.TValue[[]interface{}]
	Dnssec plugin.TValue[bool]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
	ExpiresAt plugin.TValue[*time.Time]
}

// createWhoisDomainInfo creates a new instance of this resource
func createWhoisDomainInfo(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlWhoisDomainInfo{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("whois.domainInfo", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlWhoisDomainInfo) MqlName() string {
	return "whois.domainInfo"
}

func (c *mqlWhoisDomainInfo) MqlID() string {
	return c.__id
}

func (c *mqlWhoisDomainInfo) GetDomain() *plugin.TValue[string] {
	return &c.Domain
}

func (c *mqlWhoisDomainInfo) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlWhoisDomainInfo) GetPunyCode() *plugin.TValue[string] {
	return &c.PunyCode
}

func (c *mqlWhoisDomainInfo) GetExtension() *plugin.TValue[string] {
	return &c.Extension
}

func (c *mqlWhoisDomainInfo) GetWhoisServer() *plugin.TValue[string] {
	return &c.WhoisServer
}

func (c *mqlWhoisDomainInfo) GetStatus() *plugin.TValue[[]interface{}] {
	return &c.Status
}

func (c *mqlWhoisDomainInfo) GetNameServers() *plugin.TValue[[]interface{}] {
	return &c.NameServers
}

func (c *mqlWhoisDomainInfo) GetDnssec() *plugin.TValue[bool] {
	return &c.Dnssec
}

func (c *mqlWhoisDomainInfo) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlWhoisDomainInfo) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlWhoisDomainInfo) GetExpiresAt() *plugin.TValue[*time.Time] {
	return &c.ExpiresAt
}

// mqlWhoisContact for the whois.contact resource
type mqlWhoisContact struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlWhoisContactInternal it will be used here
	Name plugin.TValue[string]
	Organization plugin.TValue[string]
	Street plugin.TValue[string]
	City plugin.TValue[string]
	Province plugin.TValue[string]
	PostalCode plugin.TValue[string]
	Country plugin.TValue[string]
	Phone plugin.TValue[string]
	Email plugin.TValue[string]
	RegistrarUrl plugin.TValue[string]
}

// createWhoisContact creates a new instance of this resource
func createWhoisContact(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlWhoisContact{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("whois.contact", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlWhoisContact) MqlName() string {
	return "whois.contact"
}

func (c *mqlWhoisContact) MqlID() string {
	return c.__id
}

func (c *mqlWhoisContact) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlWhoisContact) GetOrganization() *plugin.TValue[string] {
	return &c.Organization
}

func (c *mqlWhoisContact) GetStreet() *plugin.TValue[string] {
	return &c.Street
}

func (c *mqlWhoisContact) GetCity() *plugin.TValue[string] {
	return &c.City
}

func (c *mqlWhoisContact) GetProvince() *plugin.TValue[string] {
	return &c.Province
}

func (c *mqlWhoisContact) GetPostalCode() *plugin.TValue[string] {
	return &c.PostalCode
}

func (c *mqlWhoisContact) GetCountry() *plugin.TValue[string] {
	return &c.Country
}

func (c *mqlWhoisContact) GetPhone() *plugin.TValue[string] {
	return &c.Phone
}

func (c *mqlWhoisContact) GetEmail() *plugin.TValue[string] {
	return &c.Email
}

func (c *mqlWhoisContact) GetRegistrarUrl() *plugin.TValue[string] {
	return &c.RegistrarUrl
}
