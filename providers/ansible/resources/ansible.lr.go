// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"

	"go.mondoo.com/cnquery/v11/llx"
	"go.mondoo.com/cnquery/v11/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v11/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"ansible": {
			// to override args, implement: initAnsible(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAnsible,
		},
		"ansible.play": {
			// to override args, implement: initAnsiblePlay(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAnsiblePlay,
		},
		"ansible.task": {
			// to override args, implement: initAnsibleTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAnsibleTask,
		},
		"ansible.handler": {
			// to override args, implement: initAnsibleHandler(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAnsibleHandler,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"ansible.plays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsible).GetPlays()).ToDataRes(types.Array(types.Resource("ansible.play")))
	},
	"ansible.play.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetName()).ToDataRes(types.String)
	},
	"ansible.play.hosts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetHosts()).ToDataRes(types.Dict)
	},
	"ansible.play.remoteUser": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetRemoteUser()).ToDataRes(types.String)
	},
	"ansible.play.become": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetBecome()).ToDataRes(types.Bool)
	},
	"ansible.play.becomeUser": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetBecomeUser()).ToDataRes(types.String)
	},
	"ansible.play.becomeMethod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetBecomeMethod()).ToDataRes(types.String)
	},
	"ansible.play.becomeFlags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetBecomeFlags()).ToDataRes(types.String)
	},
	"ansible.play.strategy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetStrategy()).ToDataRes(types.String)
	},
	"ansible.play.maxFailPercentage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetMaxFailPercentage()).ToDataRes(types.Int)
	},
	"ansible.play.ignoreUnreachable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetIgnoreUnreachable()).ToDataRes(types.Bool)
	},
	"ansible.play.anyErrorsFatal": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetAnyErrorsFatal()).ToDataRes(types.Bool)
	},
	"ansible.play.vars": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetVars()).ToDataRes(types.Map(types.String, types.Dict))
	},
	"ansible.play.roles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetRoles()).ToDataRes(types.Array(types.String))
	},
	"ansible.play.tasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetTasks()).ToDataRes(types.Array(types.Resource("ansible.task")))
	},
	"ansible.play.handlers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsiblePlay).GetHandlers()).ToDataRes(types.Array(types.Resource("ansible.handler")))
	},
	"ansible.task.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetName()).ToDataRes(types.String)
	},
	"ansible.task.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetAction()).ToDataRes(types.Dict)
	},
	"ansible.task.vars": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetVars()).ToDataRes(types.Map(types.String, types.Dict))
	},
	"ansible.task.register": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetRegister()).ToDataRes(types.String)
	},
	"ansible.task.when": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetWhen()).ToDataRes(types.String)
	},
	"ansible.task.failedWhen": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetFailedWhen()).ToDataRes(types.String)
	},
	"ansible.task.changedWhen": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetChangedWhen()).ToDataRes(types.String)
	},
	"ansible.task.notify": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetNotify()).ToDataRes(types.Array(types.String))
	},
	"ansible.task.importPlaybook": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetImportPlaybook()).ToDataRes(types.String)
	},
	"ansible.task.includePlaybook": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetIncludePlaybook()).ToDataRes(types.String)
	},
	"ansible.task.importTasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetImportTasks()).ToDataRes(types.String)
	},
	"ansible.task.includeTasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetIncludeTasks()).ToDataRes(types.String)
	},
	"ansible.task.block": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetBlock()).ToDataRes(types.Array(types.Resource("ansible.task")))
	},
	"ansible.task.rescue": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleTask).GetRescue()).ToDataRes(types.Array(types.Resource("ansible.task")))
	},
	"ansible.handler.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleHandler).GetName()).ToDataRes(types.String)
	},
	"ansible.handler.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAnsibleHandler).GetAction()).ToDataRes(types.Dict)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"ansible.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAnsible).__id, ok = v.Value.(string)
			return
		},
	"ansible.plays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsible).Plays, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.play.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAnsiblePlay).__id, ok = v.Value.(string)
			return
		},
	"ansible.play.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.hosts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Hosts, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"ansible.play.remoteUser": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).RemoteUser, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.become": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Become, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"ansible.play.becomeUser": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).BecomeUser, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.becomeMethod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).BecomeMethod, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.becomeFlags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).BecomeFlags, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.strategy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Strategy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.play.maxFailPercentage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).MaxFailPercentage, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"ansible.play.ignoreUnreachable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).IgnoreUnreachable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"ansible.play.anyErrorsFatal": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).AnyErrorsFatal, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"ansible.play.vars": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Vars, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"ansible.play.roles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Roles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.play.tasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Tasks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.play.handlers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsiblePlay).Handlers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.task.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAnsibleTask).__id, ok = v.Value.(string)
			return
		},
	"ansible.task.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Action, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"ansible.task.vars": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Vars, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"ansible.task.register": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Register, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.when": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).When, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.failedWhen": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).FailedWhen, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.changedWhen": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).ChangedWhen, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.notify": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Notify, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.task.importPlaybook": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).ImportPlaybook, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.includePlaybook": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).IncludePlaybook, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.importTasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).ImportTasks, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.includeTasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).IncludeTasks, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.task.block": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Block, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.task.rescue": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleTask).Rescue, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"ansible.handler.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAnsibleHandler).__id, ok = v.Value.(string)
			return
		},
	"ansible.handler.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleHandler).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"ansible.handler.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAnsibleHandler).Action, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[ansible] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[ansible] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAnsible for the ansible resource
type mqlAnsible struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAnsibleInternal it will be used here
	Plays plugin.TValue[[]interface{}]
}

// createAnsible creates a new instance of this resource
func createAnsible(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAnsible{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ansible", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAnsible) MqlName() string {
	return "ansible"
}

func (c *mqlAnsible) MqlID() string {
	return c.__id
}

func (c *mqlAnsible) GetPlays() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Plays, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ansible", c.__id, "plays")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.plays()
	})
}

// mqlAnsiblePlay for the ansible.play resource
type mqlAnsiblePlay struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAnsiblePlayInternal
	Name plugin.TValue[string]
	Hosts plugin.TValue[interface{}]
	RemoteUser plugin.TValue[string]
	Become plugin.TValue[bool]
	BecomeUser plugin.TValue[string]
	BecomeMethod plugin.TValue[string]
	BecomeFlags plugin.TValue[string]
	Strategy plugin.TValue[string]
	MaxFailPercentage plugin.TValue[int64]
	IgnoreUnreachable plugin.TValue[bool]
	AnyErrorsFatal plugin.TValue[bool]
	Vars plugin.TValue[map[string]interface{}]
	Roles plugin.TValue[[]interface{}]
	Tasks plugin.TValue[[]interface{}]
	Handlers plugin.TValue[[]interface{}]
}

// createAnsiblePlay creates a new instance of this resource
func createAnsiblePlay(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAnsiblePlay{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ansible.play", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAnsiblePlay) MqlName() string {
	return "ansible.play"
}

func (c *mqlAnsiblePlay) MqlID() string {
	return c.__id
}

func (c *mqlAnsiblePlay) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAnsiblePlay) GetHosts() *plugin.TValue[interface{}] {
	return &c.Hosts
}

func (c *mqlAnsiblePlay) GetRemoteUser() *plugin.TValue[string] {
	return &c.RemoteUser
}

func (c *mqlAnsiblePlay) GetBecome() *plugin.TValue[bool] {
	return &c.Become
}

func (c *mqlAnsiblePlay) GetBecomeUser() *plugin.TValue[string] {
	return &c.BecomeUser
}

func (c *mqlAnsiblePlay) GetBecomeMethod() *plugin.TValue[string] {
	return &c.BecomeMethod
}

func (c *mqlAnsiblePlay) GetBecomeFlags() *plugin.TValue[string] {
	return &c.BecomeFlags
}

func (c *mqlAnsiblePlay) GetStrategy() *plugin.TValue[string] {
	return &c.Strategy
}

func (c *mqlAnsiblePlay) GetMaxFailPercentage() *plugin.TValue[int64] {
	return &c.MaxFailPercentage
}

func (c *mqlAnsiblePlay) GetIgnoreUnreachable() *plugin.TValue[bool] {
	return &c.IgnoreUnreachable
}

func (c *mqlAnsiblePlay) GetAnyErrorsFatal() *plugin.TValue[bool] {
	return &c.AnyErrorsFatal
}

func (c *mqlAnsiblePlay) GetVars() *plugin.TValue[map[string]interface{}] {
	return &c.Vars
}

func (c *mqlAnsiblePlay) GetRoles() *plugin.TValue[[]interface{}] {
	return &c.Roles
}

func (c *mqlAnsiblePlay) GetTasks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tasks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ansible.play", c.__id, "tasks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tasks()
	})
}

func (c *mqlAnsiblePlay) GetHandlers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Handlers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ansible.play", c.__id, "handlers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.handlers()
	})
}

// mqlAnsibleTask for the ansible.task resource
type mqlAnsibleTask struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAnsibleTaskInternal
	Name plugin.TValue[string]
	Action plugin.TValue[interface{}]
	Vars plugin.TValue[map[string]interface{}]
	Register plugin.TValue[string]
	When plugin.TValue[string]
	FailedWhen plugin.TValue[string]
	ChangedWhen plugin.TValue[string]
	Notify plugin.TValue[[]interface{}]
	ImportPlaybook plugin.TValue[string]
	IncludePlaybook plugin.TValue[string]
	ImportTasks plugin.TValue[string]
	IncludeTasks plugin.TValue[string]
	Block plugin.TValue[[]interface{}]
	Rescue plugin.TValue[[]interface{}]
}

// createAnsibleTask creates a new instance of this resource
func createAnsibleTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAnsibleTask{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ansible.task", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAnsibleTask) MqlName() string {
	return "ansible.task"
}

func (c *mqlAnsibleTask) MqlID() string {
	return c.__id
}

func (c *mqlAnsibleTask) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAnsibleTask) GetAction() *plugin.TValue[interface{}] {
	return &c.Action
}

func (c *mqlAnsibleTask) GetVars() *plugin.TValue[map[string]interface{}] {
	return &c.Vars
}

func (c *mqlAnsibleTask) GetRegister() *plugin.TValue[string] {
	return &c.Register
}

func (c *mqlAnsibleTask) GetWhen() *plugin.TValue[string] {
	return &c.When
}

func (c *mqlAnsibleTask) GetFailedWhen() *plugin.TValue[string] {
	return &c.FailedWhen
}

func (c *mqlAnsibleTask) GetChangedWhen() *plugin.TValue[string] {
	return &c.ChangedWhen
}

func (c *mqlAnsibleTask) GetNotify() *plugin.TValue[[]interface{}] {
	return &c.Notify
}

func (c *mqlAnsibleTask) GetImportPlaybook() *plugin.TValue[string] {
	return &c.ImportPlaybook
}

func (c *mqlAnsibleTask) GetIncludePlaybook() *plugin.TValue[string] {
	return &c.IncludePlaybook
}

func (c *mqlAnsibleTask) GetImportTasks() *plugin.TValue[string] {
	return &c.ImportTasks
}

func (c *mqlAnsibleTask) GetIncludeTasks() *plugin.TValue[string] {
	return &c.IncludeTasks
}

func (c *mqlAnsibleTask) GetBlock() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Block, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ansible.task", c.__id, "block")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.block()
	})
}

func (c *mqlAnsibleTask) GetRescue() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Rescue, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("ansible.task", c.__id, "rescue")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.rescue()
	})
}

// mqlAnsibleHandler for the ansible.handler resource
type mqlAnsibleHandler struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAnsibleHandlerInternal it will be used here
	Name plugin.TValue[string]
	Action plugin.TValue[interface{}]
}

// createAnsibleHandler creates a new instance of this resource
func createAnsibleHandler(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAnsibleHandler{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("ansible.handler", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAnsibleHandler) MqlName() string {
	return "ansible.handler"
}

func (c *mqlAnsibleHandler) MqlID() string {
	return c.__id
}

func (c *mqlAnsibleHandler) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAnsibleHandler) GetAction() *plugin.TValue[interface{}] {
	return &c.Action
}
