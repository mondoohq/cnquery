// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/v11/llx"
	"go.mondoo.com/cnquery/v11/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v11/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"aws": {
			// to override args, implement: initAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAws,
		},
		"aws.account": {
			Init: initAwsAccount,
			Create: createAwsAccount,
		},
		"aws.organization": {
			// to override args, implement: initAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsOrganization,
		},
		"aws.vpc": {
			Init: initAwsVpc,
			Create: createAwsVpc,
		},
		"aws.vpc.routetable": {
			// to override args, implement: initAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetable,
		},
		"aws.vpc.routetable.association": {
			// to override args, implement: initAwsVpcRoutetableAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetableAssociation,
		},
		"aws.vpc.subnet": {
			Init: initAwsVpcSubnet,
			Create: createAwsVpcSubnet,
		},
		"aws.vpc.endpoint": {
			// to override args, implement: initAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcEndpoint,
		},
		"aws.vpc.flowlog": {
			// to override args, implement: initAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcFlowlog,
		},
		"aws.waf": {
			Init: initAwsWaf,
			Create: createAwsWaf,
		},
		"aws.waf.acl": {
			// to override args, implement: initAwsWafAcl(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafAcl,
		},
		"aws.waf.rulegroup": {
			// to override args, implement: initAwsWafRulegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRulegroup,
		},
		"aws.waf.rule": {
			// to override args, implement: initAwsWafRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRule,
		},
		"aws.waf.rule.action": {
			// to override args, implement: initAwsWafRuleAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleAction,
		},
		"aws.waf.rule.statement": {
			// to override args, implement: initAwsWafRuleStatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatement,
		},
		"aws.waf.rule.statement.geomatchstatement": {
			// to override args, implement: initAwsWafRuleStatementGeomatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementGeomatchstatement,
		},
		"aws.waf.rule.statement.ipsetreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementIpsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementIpsetreferencestatement,
		},
		"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig": {
			// to override args, implement: initAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig,
		},
		"aws.waf.rule.statement.labelmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementLabelmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementLabelmatchstatement,
		},
		"aws.waf.rule.statement.managedrulegroupstatement": {
			// to override args, implement: initAwsWafRuleStatementManagedrulegroupstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementManagedrulegroupstatement,
		},
		"aws.waf.rule.statement.andstatement": {
			// to override args, implement: initAwsWafRuleStatementAndstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementAndstatement,
		},
		"aws.waf.rule.statement.notstatement": {
			// to override args, implement: initAwsWafRuleStatementNotstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementNotstatement,
		},
		"aws.waf.rule.statement.orstatement": {
			// to override args, implement: initAwsWafRuleStatementOrstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementOrstatement,
		},
		"aws.waf.rule.statement.ratebasedstatement": {
			// to override args, implement: initAwsWafRuleStatementRatebasedstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRatebasedstatement,
		},
		"aws.waf.rule.statement.regexpatternsetreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementRegexpatternsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRegexpatternsetreferencestatement,
		},
		"aws.waf.rule.statement.rulegroupreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementRulegroupreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRulegroupreferencestatement,
		},
		"aws.waf.rule.statement.sizeconstraintstatement": {
			// to override args, implement: initAwsWafRuleStatementSizeconstraintstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementSizeconstraintstatement,
		},
		"aws.waf.rule.statement.regexmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementRegexmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRegexmatchstatement,
		},
		"aws.waf.rule.statement.bytematchstatement": {
			// to override args, implement: initAwsWafRuleStatementBytematchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementBytematchstatement,
		},
		"aws.waf.rule.fieldtomatch": {
			// to override args, implement: initAwsWafRuleFieldtomatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatch,
		},
		"aws.waf.rule.fieldtomatch.body": {
			// to override args, implement: initAwsWafRuleFieldtomatchBody(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchBody,
		},
		"aws.waf.rule.fieldtomatch.cookie": {
			// to override args, implement: initAwsWafRuleFieldtomatchCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchCookie,
		},
		"aws.waf.rule.fieldtomatch.headerorder": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeaderorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeaderorder,
		},
		"aws.waf.rule.fieldtomatch.singleheader": {
			// to override args, implement: initAwsWafRuleFieldtomatchSingleheader(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchSingleheader,
		},
		"aws.waf.rule.fieldtomatch.singlequeryargument": {
			// to override args, implement: initAwsWafRuleFieldtomatchSinglequeryargument(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchSinglequeryargument,
		},
		"aws.waf.rule.fieldtomatch.ja3fingerprint": {
			// to override args, implement: initAwsWafRuleFieldtomatchJa3fingerprint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJa3fingerprint,
		},
		"aws.waf.rule.fieldtomatch.jsonbody": {
			// to override args, implement: initAwsWafRuleFieldtomatchJsonbody(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJsonbody,
		},
		"aws.waf.rule.fieldtomatch.jsonbody.matchpattern": {
			// to override args, implement: initAwsWafRuleFieldtomatchJsonbodyMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJsonbodyMatchpattern,
		},
		"aws.waf.rule.fieldtomatch.headers": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeaders(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeaders,
		},
		"aws.waf.rule.fieldtomatch.headers.matchpattern": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeadersMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeadersMatchpattern,
		},
		"aws.waf.rule.statement.xssmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementXssmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementXssmatchstatement,
		},
		"aws.waf.rule.statement.sqlimatchstatement": {
			// to override args, implement: initAwsWafRuleStatementSqlimatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementSqlimatchstatement,
		},
		"aws.waf.ipset": {
			// to override args, implement: initAwsWafIpset(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafIpset,
		},
		"aws.efs": {
			// to override args, implement: initAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfs,
		},
		"aws.efs.filesystem": {
			Init: initAwsEfsFilesystem,
			Create: createAwsEfsFilesystem,
		},
		"aws.kms": {
			// to override args, implement: initAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsKms,
		},
		"aws.kms.key": {
			Init: initAwsKmsKey,
			Create: createAwsKmsKey,
		},
		"aws.iam": {
			// to override args, implement: initAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIam,
		},
		"aws.iam.usercredentialreportentry": {
			// to override args, implement: initAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamUsercredentialreportentry,
		},
		"aws.iam.user": {
			Init: initAwsIamUser,
			Create: createAwsIamUser,
		},
		"aws.iam.loginProfile": {
			// to override args, implement: initAwsIamLoginProfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamLoginProfile,
		},
		"aws.iam.policy": {
			// to override args, implement: initAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicy,
		},
		"aws.iam.policyversion": {
			// to override args, implement: initAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicyversion,
		},
		"aws.iam.role": {
			Init: initAwsIamRole,
			Create: createAwsIamRole,
		},
		"aws.iam.group": {
			Init: initAwsIamGroup,
			Create: createAwsIamGroup,
		},
		"aws.iam.virtualmfadevice": {
			// to override args, implement: initAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamVirtualmfadevice,
		},
		"aws.iam.accessAnalyzer": {
			// to override args, implement: initAwsIamAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessAnalyzer,
		},
		"aws.iam.accessanalyzer.analyzer": {
			// to override args, implement: initAwsIamAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessanalyzerAnalyzer,
		},
		"aws.iam.accessanalyzer.finding": {
			// to override args, implement: initAwsIamAccessanalyzerFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessanalyzerFinding,
		},
		"aws.sagemaker": {
			// to override args, implement: initAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemaker,
		},
		"aws.sagemaker.notebookinstance": {
			Init: initAwsSagemakerNotebookinstance,
			Create: createAwsSagemakerNotebookinstance,
		},
		"aws.sagemaker.notebookinstance.details": {
			// to override args, implement: initAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerNotebookinstanceDetails,
		},
		"aws.sagemaker.endpoint": {
			// to override args, implement: initAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerEndpoint,
		},
		"aws.sns": {
			// to override args, implement: initAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSns,
		},
		"aws.sns.topic": {
			// to override args, implement: initAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsTopic,
		},
		"aws.sns.subscription": {
			// to override args, implement: initAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsSubscription,
		},
		"aws.es": {
			// to override args, implement: initAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEs,
		},
		"aws.es.domain": {
			Init: initAwsEsDomain,
			Create: createAwsEsDomain,
		},
		"aws.acm": {
			// to override args, implement: initAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAcm,
		},
		"aws.acm.certificate": {
			Init: initAwsAcmCertificate,
			Create: createAwsAcmCertificate,
		},
		"aws.autoscaling": {
			// to override args, implement: initAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscaling,
		},
		"aws.autoscaling.group": {
			Init: initAwsAutoscalingGroup,
			Create: createAwsAutoscalingGroup,
		},
		"aws.elb": {
			// to override args, implement: initAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElb,
		},
		"aws.elb.targetgroup": {
			// to override args, implement: initAwsElbTargetgroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElbTargetgroup,
		},
		"aws.elb.loadbalancer": {
			Init: initAwsElbLoadbalancer,
			Create: createAwsElbLoadbalancer,
		},
		"aws.codebuild": {
			// to override args, implement: initAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodebuild,
		},
		"aws.codebuild.project": {
			Init: initAwsCodebuildProject,
			Create: createAwsCodebuildProject,
		},
		"aws.guardduty": {
			// to override args, implement: initAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuardduty,
		},
		"aws.guardduty.detector": {
			// to override args, implement: initAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuarddutyDetector,
		},
		"aws.guardduty.finding": {
			// to override args, implement: initAwsGuarddutyFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuarddutyFinding,
		},
		"aws.securityhub": {
			// to override args, implement: initAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhub,
		},
		"aws.securityhub.hub": {
			// to override args, implement: initAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhubHub,
		},
		"aws.secretsmanager": {
			// to override args, implement: initAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanager,
		},
		"aws.secretsmanager.secret": {
			// to override args, implement: initAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanagerSecret,
		},
		"aws.ecs": {
			// to override args, implement: initAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcs,
		},
		"aws.ecs.cluster": {
			Init: initAwsEcsCluster,
			Create: createAwsEcsCluster,
		},
		"aws.ecs.instance": {
			// to override args, implement: initAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsInstance,
		},
		"aws.ecs.task": {
			Init: initAwsEcsTask,
			Create: createAwsEcsTask,
		},
		"aws.ecs.container": {
			// to override args, implement: initAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsContainer,
		},
		"aws.emr": {
			// to override args, implement: initAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmr,
		},
		"aws.emr.cluster": {
			// to override args, implement: initAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmrCluster,
		},
		"aws.cloudwatch": {
			// to override args, implement: initAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatch,
		},
		"aws.cloudwatch.metricsalarm": {
			Init: initAwsCloudwatchMetricsalarm,
			Create: createAwsCloudwatchMetricsalarm,
		},
		"aws.cloudwatch.metric": {
			Init: initAwsCloudwatchMetric,
			Create: createAwsCloudwatchMetric,
		},
		"aws.cloudwatch.metricdimension": {
			// to override args, implement: initAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricdimension,
		},
		"aws.cloudwatch.metricstatistics": {
			Init: initAwsCloudwatchMetricstatistics,
			Create: createAwsCloudwatchMetricstatistics,
		},
		"aws.cloudwatch.metric.datapoint": {
			// to override args, implement: initAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricDatapoint,
		},
		"aws.cloudwatch.loggroup": {
			Init: initAwsCloudwatchLoggroup,
			Create: createAwsCloudwatchLoggroup,
		},
		"aws.cloudwatch.loggroup.metricsfilter": {
			// to override args, implement: initAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchLoggroupMetricsfilter,
		},
		"aws.cloudfront": {
			// to override args, implement: initAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfront,
		},
		"aws.cloudfront.distribution": {
			// to override args, implement: initAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistribution,
		},
		"aws.cloudfront.distribution.origin": {
			// to override args, implement: initAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistributionOrigin,
		},
		"aws.cloudfront.function": {
			// to override args, implement: initAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontFunction,
		},
		"aws.cloudtrail": {
			// to override args, implement: initAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudtrail,
		},
		"aws.cloudtrail.trail": {
			Init: initAwsCloudtrailTrail,
			Create: createAwsCloudtrailTrail,
		},
		"aws.s3control": {
			// to override args, implement: initAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3control,
		},
		"aws.s3": {
			// to override args, implement: initAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3,
		},
		"aws.s3.bucket": {
			Init: initAwsS3Bucket,
			Create: createAwsS3Bucket,
		},
		"aws.s3.bucket.grant": {
			// to override args, implement: initAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketGrant,
		},
		"aws.s3.bucket.corsrule": {
			// to override args, implement: initAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketCorsrule,
		},
		"aws.s3.bucket.policy": {
			// to override args, implement: initAwsS3BucketPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketPolicy,
		},
		"aws.applicationAutoscaling": {
			// to override args, implement: initAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscaling,
		},
		"aws.applicationautoscaling.target": {
			// to override args, implement: initAwsApplicationautoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationautoscalingTarget,
		},
		"aws.backup": {
			// to override args, implement: initAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackup,
		},
		"aws.backup.vault": {
			// to override args, implement: initAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVault,
		},
		"aws.backup.vaultRecoveryPoint": {
			// to override args, implement: initAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVaultRecoveryPoint,
		},
		"aws.dynamodb": {
			// to override args, implement: initAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodb,
		},
		"aws.dynamodb.export": {
			// to override args, implement: initAwsDynamodbExport(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodbExport,
		},
		"aws.dynamodb.limit": {
			// to override args, implement: initAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodbLimit,
		},
		"aws.dynamodb.globaltable": {
			Init: initAwsDynamodbGlobaltable,
			Create: createAwsDynamodbGlobaltable,
		},
		"aws.dynamodb.table": {
			Init: initAwsDynamodbTable,
			Create: createAwsDynamodbTable,
		},
		"aws.sqs": {
			// to override args, implement: initAwsSqs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSqs,
		},
		"aws.sqs.queue": {
			// to override args, implement: initAwsSqsQueue(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSqsQueue,
		},
		"aws.rds": {
			// to override args, implement: initAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRds,
		},
		"aws.rds.backupsetting": {
			// to override args, implement: initAwsRdsBackupsetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsBackupsetting,
		},
		"aws.rds.dbcluster": {
			// to override args, implement: initAwsRdsDbcluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsDbcluster,
		},
		"aws.rds.snapshot": {
			// to override args, implement: initAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsSnapshot,
		},
		"aws.rds.dbinstance": {
			Init: initAwsRdsDbinstance,
			Create: createAwsRdsDbinstance,
		},
		"aws.rds.pendingMaintenanceAction": {
			// to override args, implement: initAwsRdsPendingMaintenanceAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsPendingMaintenanceAction,
		},
		"aws.elasticache": {
			// to override args, implement: initAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticache,
		},
		"aws.elasticache.cluster": {
			// to override args, implement: initAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticacheCluster,
		},
		"aws.elasticache.serverlessCache": {
			// to override args, implement: initAwsElasticacheServerlessCache(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticacheServerlessCache,
		},
		"aws.redshift": {
			// to override args, implement: initAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRedshift,
		},
		"aws.redshift.cluster": {
			Init: initAwsRedshiftCluster,
			Create: createAwsRedshiftCluster,
		},
		"aws.ecr": {
			// to override args, implement: initAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcr,
		},
		"aws.ecr.repository": {
			// to override args, implement: initAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcrRepository,
		},
		"aws.ecr.image": {
			Init: initAwsEcrImage,
			Create: createAwsEcrImage,
		},
		"aws.dms": {
			// to override args, implement: initAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDms,
		},
		"aws.apigateway": {
			// to override args, implement: initAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigateway,
		},
		"aws.apigateway.restapi": {
			Init: initAwsApigatewayRestapi,
			Create: createAwsApigatewayRestapi,
		},
		"aws.apigateway.stage": {
			// to override args, implement: initAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigatewayStage,
		},
		"aws.lambda": {
			// to override args, implement: initAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsLambda,
		},
		"aws.lambda.function": {
			Init: initAwsLambdaFunction,
			Create: createAwsLambdaFunction,
		},
		"aws.ssm": {
			// to override args, implement: initAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSsm,
		},
		"aws.ssm.parameter": {
			// to override args, implement: initAwsSsmParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSsmParameter,
		},
		"aws.ssm.instance": {
			Init: initAwsSsmInstance,
			Create: createAwsSsmInstance,
		},
		"aws.ec2": {
			// to override args, implement: initAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2,
		},
		"aws.ec2.eip": {
			Init: initAwsEc2Eip,
			Create: createAwsEc2Eip,
		},
		"aws.vpc.natgateway": {
			// to override args, implement: initAwsVpcNatgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcNatgateway,
		},
		"aws.vpc.natgateway.address": {
			// to override args, implement: initAwsVpcNatgatewayAddress(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcNatgatewayAddress,
		},
		"aws.vpc.serviceEndpoint": {
			// to override args, implement: initAwsVpcServiceEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcServiceEndpoint,
		},
		"aws.vpc.peeringConnection": {
			// to override args, implement: initAwsVpcPeeringConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcPeeringConnection,
		},
		"aws.vpc.peeringConnection.peeringVpc": {
			// to override args, implement: initAwsVpcPeeringConnectionPeeringVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcPeeringConnectionPeeringVpc,
		},
		"aws.ec2.networkacl": {
			// to override args, implement: initAwsEc2Networkacl(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Networkacl,
		},
		"aws.ec2.networkacl.association": {
			// to override args, implement: initAwsEc2NetworkaclAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclAssociation,
		},
		"aws.ec2.networkacl.entry": {
			// to override args, implement: initAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntry,
		},
		"aws.ec2.networkacl.entry.portrange": {
			// to override args, implement: initAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntryPortrange,
		},
		"aws.ec2.vpnconnection": {
			// to override args, implement: initAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vpnconnection,
		},
		"aws.ec2.vgwtelemetry": {
			// to override args, implement: initAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vgwtelemetry,
		},
		"aws.ec2.internetgateway": {
			// to override args, implement: initAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Internetgateway,
		},
		"aws.ec2.snapshot": {
			Init: initAwsEc2Snapshot,
			Create: createAwsEc2Snapshot,
		},
		"aws.ec2.volume": {
			Init: initAwsEc2Volume,
			Create: createAwsEc2Volume,
		},
		"aws.inspector": {
			// to override args, implement: initAwsInspector(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspector,
		},
		"aws.inspector.coverage": {
			// to override args, implement: initAwsInspectorCoverage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverage,
		},
		"aws.inspector.coverage.instance": {
			// to override args, implement: initAwsInspectorCoverageInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageInstance,
		},
		"aws.inspector.coverage.image": {
			// to override args, implement: initAwsInspectorCoverageImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageImage,
		},
		"aws.inspector.coverage.repository": {
			// to override args, implement: initAwsInspectorCoverageRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageRepository,
		},
		"aws.ec2.instance": {
			Init: initAwsEc2Instance,
			Create: createAwsEc2Instance,
		},
		"aws.ec2.networkinterface": {
			// to override args, implement: initAwsEc2Networkinterface(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Networkinterface,
		},
		"aws.ec2.keypair": {
			Init: initAwsEc2Keypair,
			Create: createAwsEc2Keypair,
		},
		"aws.ec2.image": {
			Init: initAwsEc2Image,
			Create: createAwsEc2Image,
		},
		"aws.ec2.instance.device": {
			// to override args, implement: initAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2InstanceDevice,
		},
		"aws.ec2.securitygroup": {
			Init: initAwsEc2Securitygroup,
			Create: createAwsEc2Securitygroup,
		},
		"aws.ec2.securitygroup.ippermission": {
			// to override args, implement: initAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2SecuritygroupIppermission,
		},
		"aws.config": {
			// to override args, implement: initAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfig,
		},
		"aws.config.rule": {
			// to override args, implement: initAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRule,
		},
		"aws.config.recorder": {
			// to override args, implement: initAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRecorder,
		},
		"aws.config.deliverychannel": {
			// to override args, implement: initAwsConfigDeliverychannel(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigDeliverychannel,
		},
		"aws.eks": {
			// to override args, implement: initAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEks,
		},
		"aws.eks.nodegroup": {
			// to override args, implement: initAwsEksNodegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksNodegroup,
		},
		"aws.eks.addon": {
			// to override args, implement: initAwsEksAddon(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksAddon,
		},
		"aws.eks.cluster": {
			// to override args, implement: initAwsEksCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksCluster,
		},
		"aws.neptune": {
			// to override args, implement: initAwsNeptune(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptune,
		},
		"aws.neptune.cluster": {
			// to override args, implement: initAwsNeptuneCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptuneCluster,
		},
		"aws.neptune.instance": {
			// to override args, implement: initAwsNeptuneInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptuneInstance,
		},
		"aws.timestream.liveanalytics": {
			// to override args, implement: initAwsTimestreamLiveanalytics(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalytics,
		},
		"aws.timestream.liveanalytics.database": {
			// to override args, implement: initAwsTimestreamLiveanalyticsDatabase(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalyticsDatabase,
		},
		"aws.timestream.liveanalytics.table": {
			// to override args, implement: initAwsTimestreamLiveanalyticsTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalyticsTable,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"aws.vpcs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetVpcs()).ToDataRes(types.Array(types.Resource("aws.vpc")))
	},
	"aws.regions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetRegions()).ToDataRes(types.Array(types.String))
	},
	"aws.account.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetId()).ToDataRes(types.String)
	},
	"aws.account.aliases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetAliases()).ToDataRes(types.Array(types.String))
	},
	"aws.account.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetOrganization()).ToDataRes(types.Resource("aws.organization"))
	},
	"aws.account.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.organization.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetArn()).ToDataRes(types.String)
	},
	"aws.organization.featureSet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetFeatureSet()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountId()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountEmail()).ToDataRes(types.String)
	},
	"aws.organization.accounts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetAccounts()).ToDataRes(types.Array(types.Resource("aws.account")))
	},
	"aws.vpc.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetName()).ToDataRes(types.String)
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetCidrBlock()).ToDataRes(types.String)
	},
	"aws.vpc.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetInstanceTenancy()).ToDataRes(types.String)
	},
	"aws.vpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.vpc.endpoint")))
	},
	"aws.vpc.flowLogs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetFlowLogs()).ToDataRes(types.Array(types.Resource("aws.vpc.flowlog")))
	},
	"aws.vpc.routeTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRouteTables()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable")))
	},
	"aws.vpc.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.vpc.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.natGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetNatGateways()).ToDataRes(types.Array(types.Resource("aws.vpc.natgateway")))
	},
	"aws.vpc.serviceEndpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetServiceEndpoints()).ToDataRes(types.Array(types.Resource("aws.vpc.serviceEndpoint")))
	},
	"aws.vpc.peeringConnections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetPeeringConnections()).ToDataRes(types.Array(types.Resource("aws.vpc.peeringConnection")))
	},
	"aws.vpc.routetable.associations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetAssociations()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable.association")))
	},
	"aws.vpc.routetable.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetRoutes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.vpc.routetable.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.routetable.association.routeTableAssociationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetRouteTableAssociationId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.associationsState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetAssociationsState()).ToDataRes(types.Dict)
	},
	"aws.vpc.routetable.association.gatewayId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetGatewayId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.main": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetMain()).ToDataRes(types.Bool)
	},
	"aws.vpc.routetable.association.routeTableId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetRouteTableId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.vpc.subnet.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetCidrs()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetMapPublicIpOnLaunch()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetDefaultForAvailabilityZone()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.assignIpv6AddressOnCreation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAssignIpv6AddressOnCreation()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetServiceName()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetPolicyDocument()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetSubnets()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.endpoint.privateDnsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetPrivateDnsEnabled()).ToDataRes(types.Bool)
	},
	"aws.vpc.endpoint.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.flowlog.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.flowlog.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.flowlog.destination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDestination()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.destinationType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDestinationType()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.deliverLogsStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDeliverLogsStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.maxAggregationInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetMaxAggregationInterval()).ToDataRes(types.Int)
	},
	"aws.vpc.flowlog.trafficType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTrafficType()).ToDataRes(types.String)
	},
	"aws.waf.acls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetAcls()).ToDataRes(types.Array(types.Resource("aws.waf.acl")))
	},
	"aws.waf.ruleGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetRuleGroups()).ToDataRes(types.Array(types.Resource("aws.waf.rulegroup")))
	},
	"aws.waf.ipSets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetIpSets()).ToDataRes(types.Array(types.Resource("aws.waf.ipset")))
	},
	"aws.waf.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.acl.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.acl.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetId()).ToDataRes(types.String)
	},
	"aws.waf.acl.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetName()).ToDataRes(types.String)
	},
	"aws.waf.acl.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.acl.managedByFirewallManager": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetManagedByFirewallManager()).ToDataRes(types.Bool)
	},
	"aws.waf.acl.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetRules()).ToDataRes(types.Array(types.Resource("aws.waf.rule")))
	},
	"aws.waf.acl.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetRules()).ToDataRes(types.Array(types.Resource("aws.waf.rule")))
	},
	"aws.waf.rulegroup.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.priority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetPriority()).ToDataRes(types.Int)
	},
	"aws.waf.rule.statement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetStatement()).ToDataRes(types.Resource("aws.waf.rule.statement"))
	},
	"aws.waf.rule.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetAction()).ToDataRes(types.Resource("aws.waf.rule.action"))
	},
	"aws.waf.rule.belongsTo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetBelongsTo()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetAction()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.responseCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetResponseCode()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.kind": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetKind()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.json": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetJson()).ToDataRes(types.Dict)
	},
	"aws.waf.rule.statement.sqliMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetSqliMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.sqlimatchstatement"))
	},
	"aws.waf.rule.statement.xssMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetXssMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.xssmatchstatement"))
	},
	"aws.waf.rule.statement.byteMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetByteMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.bytematchstatement"))
	},
	"aws.waf.rule.statement.regexMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRegexMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.regexmatchstatement"))
	},
	"aws.waf.rule.statement.geoMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetGeoMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.geomatchstatement"))
	},
	"aws.waf.rule.statement.ipSetReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetIpSetReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.ipsetreferencestatement"))
	},
	"aws.waf.rule.statement.labelMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetLabelMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.labelmatchstatement"))
	},
	"aws.waf.rule.statement.managedRuleGroupStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetManagedRuleGroupStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.managedrulegroupstatement"))
	},
	"aws.waf.rule.statement.notStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetNotStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.notstatement"))
	},
	"aws.waf.rule.statement.orStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetOrStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.orstatement"))
	},
	"aws.waf.rule.statement.andStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetAndStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.andstatement"))
	},
	"aws.waf.rule.statement.rateBasedStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRateBasedStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.ratebasedstatement"))
	},
	"aws.waf.rule.statement.regexPatternSetReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRegexPatternSetReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.regexpatternsetreferencestatement"))
	},
	"aws.waf.rule.statement.ruleGroupReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRuleGroupReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.rulegroupreferencestatement"))
	},
	"aws.waf.rule.statement.sizeConstraintStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetSizeConstraintStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.sizeconstraintstatement"))
	},
	"aws.waf.rule.statement.geomatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.geomatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.geomatchstatement.countryCodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetCountryCodes()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipSetForwardedIPConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetIpSetForwardedIPConfig()).ToDataRes(types.Resource("aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig"))
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.headerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetHeaderName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.position": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetPosition()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.fallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetKey()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.vendorName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetVendorName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetStatements()).ToDataRes(types.Array(types.Resource("aws.waf.rule.statement")))
	},
	"aws.waf.rule.statement.notstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.notstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.notstatement.statement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetStatement()).ToDataRes(types.Resource("aws.waf.rule.statement"))
	},
	"aws.waf.rule.statement.orstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.orstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.orstatement.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetStatements()).ToDataRes(types.Array(types.Resource("aws.waf.rule.statement")))
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.excludeRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetExcludeRules()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.sizeconstraintstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetSize()).ToDataRes(types.Int)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.comparisonOperator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetComparisonOperator()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.regexmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexmatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.regexmatchstatement.regexString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetRegexString()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.bytematchstatement.searchString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetSearchString()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetTarget()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.method": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetMethod()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.uriPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetUriPath()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.queryString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetQueryString()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.allQueryArguments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetAllQueryArguments()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.body": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetBody()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.body"))
	},
	"aws.waf.rule.fieldtomatch.cookie": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetCookie()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.cookie"))
	},
	"aws.waf.rule.fieldtomatch.singleHeader": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetSingleHeader()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.singleheader"))
	},
	"aws.waf.rule.fieldtomatch.headerOrder": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetHeaderOrder()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headerorder"))
	},
	"aws.waf.rule.fieldtomatch.headers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetHeaders()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headers"))
	},
	"aws.waf.rule.fieldtomatch.ja3Fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetJa3Fingerprint()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.ja3fingerprint"))
	},
	"aws.waf.rule.fieldtomatch.jsonBody": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetJsonBody()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.jsonbody"))
	},
	"aws.waf.rule.fieldtomatch.singleQueryArgument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetSingleQueryArgument()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.singlequeryargument"))
	},
	"aws.waf.rule.fieldtomatch.body.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.body.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.body.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.fallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchScope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetMatchScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.invalidFallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetInvalidFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetMatchPattern()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.jsonbody.matchpattern"))
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.all": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetAll()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.includePaths": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetIncludePaths()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.fieldtomatch.headers.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchScope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetMatchScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetMatchPattern()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headers.matchpattern"))
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.all": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetAll()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.includeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetIncludeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.excludeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetExcludeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.xssmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.xssmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.xssmatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.sqlimatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sqlimatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sqlimatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.sqlimatchstatement.sensitivityLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetSensitivityLevel()).ToDataRes(types.String)
	},
	"aws.waf.ipset.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.ipset.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetId()).ToDataRes(types.String)
	},
	"aws.waf.ipset.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.ipset.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetName()).ToDataRes(types.String)
	},
	"aws.waf.ipset.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.ipset.addressType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetAddressType()).ToDataRes(types.String)
	},
	"aws.waf.ipset.addresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetAddresses()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystems": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfs).GetFilesystems()).ToDataRes(types.Array(types.Resource("aws.efs.filesystem")))
	},
	"aws.efs.filesystem.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetName()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetId()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetArn()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetBackupPolicy()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystem.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetRegion()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.kms.keys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKms).GetKeys()).ToDataRes(types.Array(types.Resource("aws.kms.key")))
	},
	"aws.kms.key.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetId()).ToDataRes(types.String)
	},
	"aws.kms.key.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetArn()).ToDataRes(types.String)
	},
	"aws.kms.key.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetRegion()).ToDataRes(types.String)
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetKeyRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.kms.key.metadata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetMetadata()).ToDataRes(types.Dict)
	},
	"aws.iam.users": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.roles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.credentialReport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetCredentialReport()).ToDataRes(types.Array(types.Resource("aws.iam.usercredentialreportentry")))
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountPasswordPolicy()).ToDataRes(types.Dict)
	},
	"aws.iam.accountSummary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountSummary()).ToDataRes(types.Map(types.String, types.Int))
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetVirtualMfaDevices()).ToDataRes(types.Array(types.Resource("aws.iam.virtualmfadevice")))
	},
	"aws.iam.serverCertificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetServerCertificates()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetMfaActive()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordEnabled()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastChanged()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordNextRotation()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUserCreationTime()).ToDataRes(types.Time)
	},
	"aws.iam.user.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetId()).ToDataRes(types.String)
	},
	"aws.iam.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetName()).ToDataRes(types.String)
	},
	"aws.iam.user.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.user.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.user.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPolicies()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.user.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAccessKeys()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.user.loginProfile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetLoginProfile()).ToDataRes(types.Resource("aws.iam.loginProfile"))
	},
	"aws.iam.loginProfile.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamLoginProfile).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.policy.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.iam.policy.policyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetPolicyId()).ToDataRes(types.String)
	},
	"aws.iam.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.iam.policy.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetIsAttachable()).ToDataRes(types.Bool)
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachmentCount()).ToDataRes(types.Int)
	},
	"aws.iam.policy.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetUpdateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetScope()).ToDataRes(types.String)
	},
	"aws.iam.policy.versions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetVersions()).ToDataRes(types.Array(types.Resource("aws.iam.policyversion")))
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDefaultVersion()).ToDataRes(types.Resource("aws.iam.policyversion"))
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policyversion.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetVersionId()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetIsDefaultVersion()).ToDataRes(types.Bool)
	},
	"aws.iam.policyversion.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.role.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.role.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetId()).ToDataRes(types.String)
	},
	"aws.iam.role.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetName()).ToDataRes(types.String)
	},
	"aws.iam.role.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.role.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.role.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.role.assumeRolePolicyDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetAssumeRolePolicyDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.group.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetId()).ToDataRes(types.String)
	},
	"aws.iam.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetName()).ToDataRes(types.String)
	},
	"aws.iam.group.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.group.usernames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetUsernames()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetSerialNumber()).ToDataRes(types.String)
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetEnableDate()).ToDataRes(types.Time)
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.accessAnalyzer.analyzers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessAnalyzer).GetAnalyzers()).ToDataRes(types.Array(types.Resource("aws.iam.accessanalyzer.analyzer")))
	},
	"aws.iam.accessAnalyzer.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessAnalyzer).GetFindings()).ToDataRes(types.Array(types.Resource("aws.iam.accessanalyzer.finding")))
	},
	"aws.iam.accessanalyzer.analyzer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetName()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetStatus()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetRegion()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetLastResourceAnalyzed()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetLastResourceAnalyzedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.analyzer.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetId()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.error": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetError()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceArn()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceOwnerAccount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceOwnerAccount()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetStatus()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.analyzedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetAnalyzedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetRegion()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.analyzerArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetAnalyzerArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.sagemaker.endpoint")))
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetNotebookInstances()).ToDataRes(types.Array(types.Resource("aws.sagemaker.notebookinstance")))
	},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetDetails()).ToDataRes(types.Resource("aws.sagemaker.notebookinstance.details"))
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetDirectInternetAccess()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetConfig()).ToDataRes(types.Dict)
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.topics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSns).GetTopics()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.sns.topic.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.topic.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetRegion()).ToDataRes(types.String)
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetSubscriptions()).ToDataRes(types.Array(types.Resource("aws.sns.subscription")))
	},
	"aws.sns.topic.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetAttributes()).ToDataRes(types.Dict)
	},
	"aws.sns.topic.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.subscription.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetProtocol()).ToDataRes(types.String)
	},
	"aws.es.domains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEs).GetDomains()).ToDataRes(types.Array(types.Resource("aws.es.domain")))
	},
	"aws.es.domain.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetArn()).ToDataRes(types.String)
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEncryptionAtRestEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetNodeToNodeEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetName()).ToDataRes(types.String)
	},
	"aws.es.domain.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.es.domain.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetRegion()).ToDataRes(types.String)
	},
	"aws.es.domain.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetElasticsearchVersion()).ToDataRes(types.String)
	},
	"aws.es.domain.domainId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainId()).ToDataRes(types.String)
	},
	"aws.es.domain.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcm).GetCertificates()).ToDataRes(types.Array(types.Resource("aws.acm.certificate")))
	},
	"aws.acm.certificate.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetArn()).ToDataRes(types.String)
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotBefore()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotAfter()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificate.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetStatus()).ToDataRes(types.String)
	},
	"aws.acm.certificate.subject": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSubject()).ToDataRes(types.String)
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCertificate()).ToDataRes(types.Resource("certificate"))
	},
	"aws.acm.certificate.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.acm.certificate.keyAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetKeyAlgorithm()).ToDataRes(types.String)
	},
	"aws.acm.certificate.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSerial()).ToDataRes(types.String)
	},
	"aws.acm.certificate.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSource()).ToDataRes(types.String)
	},
	"aws.acm.certificate.issuer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetIssuer()).ToDataRes(types.String)
	},
	"aws.acm.certificate.issuedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetIssuedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.importedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetImportedAt()).ToDataRes(types.Time)
	},
	"aws.autoscaling.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscaling).GetGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.autoscaling.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLoadBalancerNames()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckType()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.autoscaling.group.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.minSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMinSize()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.maxSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMaxSize()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.defaultCooldown": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDefaultCooldown()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.launchConfigurationName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLaunchConfigurationName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.healthCheckGracePeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckGracePeriod()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.autoscaling.group.maxInstanceLifetime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMaxInstanceLifetime()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.desiredCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDesiredCapacity()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.capacityRebalance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetCapacityRebalance()).ToDataRes(types.Bool)
	},
	"aws.autoscaling.group.defaultInstanceWarmup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDefaultInstanceWarmup()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetClassicLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.targetgroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetName()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetPort()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetProtocol()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.protocolVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetProtocolVersion()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.ipAddressType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetIpAddressType()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckEnabled()).ToDataRes(types.Bool)
	},
	"aws.elb.targetgroup.healthCheckIntervalSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckIntervalSeconds()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.healthCheckPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckPath()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckPort()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckProtocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckProtocol()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckTimeoutSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckTimeoutSeconds()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.targetType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetTargetType()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.unhealthyThresholdCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetUnhealthyThresholdCount()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.elb.targetgroup.ec2Targets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetEc2Targets()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.elb.targetgroup.lambdaTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetLambdaTargets()).ToDataRes(types.Array(types.Resource("aws.lambda.function")))
	},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetDnsName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetListenerDescriptions()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetScheme()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetVpcId()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.elb.loadbalancer.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.elb.loadbalancer.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elb.loadbalancer.hostedZoneId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetHostedZoneId()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetRegion()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.elbType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetElbType()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.elb.loadbalancer.targetGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetTargetGroups()).ToDataRes(types.Array(types.Resource("aws.elb.targetgroup")))
	},
	"aws.codebuild.projects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuild).GetProjects()).ToDataRes(types.Array(types.Resource("aws.codebuild.project")))
	},
	"aws.codebuild.project.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetArn()).ToDataRes(types.String)
	},
	"aws.codebuild.project.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetDescription()).ToDataRes(types.String)
	},
	"aws.codebuild.project.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetName()).ToDataRes(types.String)
	},
	"aws.codebuild.project.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetEnvironment()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetRegion()).ToDataRes(types.String)
	},
	"aws.codebuild.project.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetSource()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetFindings()).ToDataRes(types.Array(types.Resource("aws.guardduty.finding")))
	},
	"aws.guardduty.detectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetDetectors()).ToDataRes(types.Array(types.Resource("aws.guardduty.detector")))
	},
	"aws.guardduty.detector.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetStatus()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.features": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFeatures()).ToDataRes(types.Array(types.Dict))
	},
	"aws.guardduty.detector.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindingPublishingFrequency()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindings()).ToDataRes(types.Array(types.Resource("aws.guardduty.finding")))
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetUnarchivedFindings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.guardduty.finding.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetArn()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetTitle()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetDescription()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetSeverity()).ToDataRes(types.Float)
	},
	"aws.guardduty.finding.confidence": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetConfidence()).ToDataRes(types.Float)
	},
	"aws.guardduty.finding.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetType()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.guardduty.finding.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.securityhub.hubs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhub).GetHubs()).ToDataRes(types.Array(types.Resource("aws.securityhub.hub")))
	},
	"aws.securityhub.hub.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetArn()).ToDataRes(types.String)
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetSubscribedAt()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanager).GetSecrets()).ToDataRes(types.Array(types.Resource("aws.secretsmanager.secret")))
	},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetArn()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetDescription()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastChangedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastRotatedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetName()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetNextRotationDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetPrimaryRegion()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetClusters()).ToDataRes(types.Array(types.Resource("aws.ecs.cluster")))
	},
	"aws.ecs.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRunningTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetPendingTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegisteredContainerInstancesCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTasks()).ToDataRes(types.Array(types.Resource("aws.ecs.task")))
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetAgentConnected()).ToDataRes(types.Bool)
	},
	"aws.ecs.instance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetId()).ToDataRes(types.String)
	},
	"aws.ecs.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetCapacityProvider()).ToDataRes(types.String)
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetEc2Instance()).ToDataRes(types.Resource("aws.ec2.instance"))
	},
	"aws.ecs.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.task.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetConnectivity()).ToDataRes(types.Dict)
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.task.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.task.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.container.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.container.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.container.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetImage()).ToDataRes(types.String)
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskDefinitionArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetLogDriver()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.container.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.container.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.container.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetCommand()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRuntimeId()).ToDataRes(types.String)
	},
	"aws.ecs.container.containerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetContainerName()).ToDataRes(types.String)
	},
	"aws.emr.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmr).GetClusters()).ToDataRes(types.Array(types.Resource("aws.emr.cluster")))
	},
	"aws.emr.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetName()).ToDataRes(types.String)
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetNormalizedInstanceHours()).ToDataRes(types.Int)
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetOutpostArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetMasterInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.emr.cluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetId()).ToDataRes(types.String)
	},
	"aws.emr.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.cloudwatch.logGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetLogGroups()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup")))
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetState()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetStateReason()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetInsufficientDataActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetOkActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetDimensions()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricdimension")))
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetStatistics()).ToDataRes(types.Resource("aws.cloudwatch.metricstatistics"))
	},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetValue()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetLabel()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetDatapoints()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric.datapoint")))
	},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetTimestamp()).ToDataRes(types.Time)
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMaximum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMinimum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetAverage()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetSum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetUnit()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetMetricsFilters()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup.metricsfilter")))
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.retentionInDays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRetentionInDays()).ToDataRes(types.Int)
	},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterPattern()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudfront.distributions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetDistributions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution")))
	},
	"aws.cloudfront.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.function")))
	},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetOrigins()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution.origin")))
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDefaultCacheBehavior()).ToDataRes(types.Dict)
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetCacheBehaviors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetHttpVersion()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetIsIPV6Enabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetPriceClass()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.cnames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetCnames()).ToDataRes(types.Array(types.String))
	},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetId()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionAttempts()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionTimeout()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetOriginPath()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetAccount()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetName()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetLastModifiedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStage()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetComment()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrail).GetTrails()).ToDataRes(types.Array(types.Resource("aws.cloudtrail.trail")))
	},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetName()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsMultiRegionTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsOrganizationTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogFileValidationEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIncludeGlobalServiceEvents()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetS3bucket()).ToDataRes(types.Resource("aws.s3.bucket"))
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetSnsTopicARN()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogGroup()).ToDataRes(types.Resource("aws.cloudwatch.loggroup"))
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetCloudWatchLogsRoleArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.cloudWatchLogsLogGroupArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetCloudWatchLogsLogGroupArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetEventSelectors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetRegion()).ToDataRes(types.String)
	},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3control).GetAccountPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.buckets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3).GetBuckets()).ToDataRes(types.Array(types.Resource("aws.s3.bucket")))
	},
	"aws.s3.bucket.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetArn()).ToDataRes(types.String)
	},
	"aws.s3.bucket.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPolicy()).ToDataRes(types.Resource("aws.s3.bucket.policy"))
	},
	"aws.s3.bucket.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.acl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetAcl()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.grant")))
	},
	"aws.s3.bucket.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetOwner()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.cors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCors()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.corsrule")))
	},
	"aws.s3.bucket.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLocation()).ToDataRes(types.String)
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetVersioning()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLogging()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetStaticWebsiteHosting()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetDefaultLock()).ToDataRes(types.String)
	},
	"aws.s3.bucket.replication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetReplication()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetEncryption()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetExists()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.s3.bucket.grant.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetPermission()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetGrantee()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedMethods()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedOrigins()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetExposeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetMaxAgeSeconds()).ToDataRes(types.Int)
	},
	"aws.s3.bucket.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetDocument()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetVersion()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetStatements()).ToDataRes(types.Array(types.Dict))
	},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetScalableTargets()).ToDataRes(types.Array(types.Resource("aws.applicationautoscaling.target")))
	},
	"aws.applicationautoscaling.target.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetArn()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.scalableDimension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetScalableDimension()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.minCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetMinCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationautoscaling.target.maxCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetMaxCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationautoscaling.target.suspendedState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetSuspendedState()).ToDataRes(types.Dict)
	},
	"aws.applicationautoscaling.target.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vaults": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackup).GetVaults()).ToDataRes(types.Array(types.Resource("aws.backup.vault")))
	},
	"aws.backup.vault.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vault.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetName()).ToDataRes(types.String)
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRecoveryPoints()).ToDataRes(types.Array(types.Resource("aws.backup.vaultRecoveryPoint")))
	},
	"aws.backup.vault.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRegion()).ToDataRes(types.String)
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vault.locked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetLocked()).ToDataRes(types.Bool)
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetResourceType()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreatedBy()).ToDataRes(types.Dict)
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIamRoleArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetStatus()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreationDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCompletionDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIsEncrypted()).ToDataRes(types.Bool)
	},
	"aws.dynamodb.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetGlobalTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.globaltable")))
	},
	"aws.dynamodb.tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.table")))
	},
	"aws.dynamodb.limits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetLimits()).ToDataRes(types.Array(types.Resource("aws.dynamodb.limit")))
	},
	"aws.dynamodb.exports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetExports()).ToDataRes(types.Array(types.Resource("aws.dynamodb.export")))
	},
	"aws.dynamodb.export.table": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetTable()).ToDataRes(types.Resource("aws.dynamodb.table"))
	},
	"aws.dynamodb.export.s3Bucket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3Bucket()).ToDataRes(types.Resource("aws.s3.bucket"))
	},
	"aws.dynamodb.export.s3Prefix": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3Prefix()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.itemCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetItemCount()).ToDataRes(types.Int)
	},
	"aws.dynamodb.export.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetType()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetStatus()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetFormat()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetStartTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.export.endTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetEndTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.export.s3SseAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3SseAlgorithm()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.dynamodb.export.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetReplicaSettings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetId()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetSseDescription()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetProvisionedThroughput()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetContinuousBackups()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.dynamodb.table.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.table.deletionProtectionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetDeletionProtectionEnabled()).ToDataRes(types.Bool)
	},
	"aws.dynamodb.table.globalTableVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetGlobalTableVersion()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.items": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetItems()).ToDataRes(types.Int)
	},
	"aws.dynamodb.table.sizeBytes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetSizeBytes()).ToDataRes(types.Int)
	},
	"aws.dynamodb.table.latestStreamArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetLatestStreamArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetStatus()).ToDataRes(types.String)
	},
	"aws.sqs.queues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqs).GetQueues()).ToDataRes(types.Array(types.Resource("aws.sqs.queue")))
	},
	"aws.sqs.queue.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetArn()).ToDataRes(types.String)
	},
	"aws.sqs.queue.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.sqs.queue.deadLetterQueue": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetDeadLetterQueue()).ToDataRes(types.Resource("aws.sqs.queue"))
	},
	"aws.sqs.queue.deliveryDelaySeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetDeliveryDelaySeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sqs.queue.lastModified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetLastModified()).ToDataRes(types.Time)
	},
	"aws.sqs.queue.maxReceiveCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMaxReceiveCount()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.maximumMessageSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMaximumMessageSize()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.messageRetentionPeriodSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMessageRetentionPeriodSeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.receiveMessageWaitTimeSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetReceiveMessageWaitTimeSeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetRegion()).ToDataRes(types.String)
	},
	"aws.sqs.queue.sqsManagedSseEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetSqsManagedSseEnabled()).ToDataRes(types.Bool)
	},
	"aws.sqs.queue.queueType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetQueueType()).ToDataRes(types.String)
	},
	"aws.sqs.queue.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetUrl()).ToDataRes(types.String)
	},
	"aws.sqs.queue.visibilityTimeoutSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetVisibilityTimeoutSeconds()).ToDataRes(types.Int)
	},
	"aws.rds.dbInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetDbInstances()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetInstances()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.dbClusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetDbClusters()).ToDataRes(types.Array(types.Resource("aws.rds.dbcluster")))
	},
	"aws.rds.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetClusters()).ToDataRes(types.Array(types.Resource("aws.rds.dbcluster")))
	},
	"aws.rds.allPendingMaintenanceActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetAllPendingMaintenanceActions()).ToDataRes(types.Array(types.Resource("aws.rds.pendingMaintenanceAction")))
	},
	"aws.rds.backupsetting.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetTarget()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.retentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.backupsetting.dedicatedLogVolume": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetDedicatedLogVolume()).ToDataRes(types.Bool)
	},
	"aws.rds.backupsetting.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.backupsetting.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.backupsetting.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.timezone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetTimezone()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.earliestRestoreAvailable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetEarliestRestoreAvailable()).ToDataRes(types.Time)
	},
	"aws.rds.backupsetting.latestRestoreAvailable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetLatestRestoreAvailable()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMembers()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbcluster.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.storageAllocated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageAllocated()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.storageIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageIops()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageType()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.clusterDbInstanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetClusterDbInstanceClass()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.rds.dbcluster.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.rds.dbcluster.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.hostedZoneId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetHostedZoneId()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.backupSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetBackupSettings()).ToDataRes(types.Array(types.Resource("aws.rds.backupsetting")))
	},
	"aws.rds.dbcluster.engineLifecycleSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngineLifecycleSupport()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.certificateExpiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCertificateExpiresAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.certificateAuthority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCertificateAuthority()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.iamDatabaseAuthentication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetIamDatabaseAuthentication()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.activityStreamMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetActivityStreamMode()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.activityStreamStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetActivityStreamStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetId()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.rds.snapshot.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetType()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetIsClusterSnapshot()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.snapshot.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.snapshot.allocatedStorage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetAllocatedStorage()).ToDataRes(types.Int)
	},
	"aws.rds.snapshot.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetName()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageAllocated()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageIops()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageType()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnhancedMonitoringResourceArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceClass()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceIdentifier()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.backupSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetBackupSettings()).ToDataRes(types.Array(types.Resource("aws.rds.backupsetting")))
	},
	"aws.rds.dbinstance.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.rds.dbinstance.engineLifecycleSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngineLifecycleSupport()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.certificateExpiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCertificateExpiresAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.certificateAuthority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCertificateAuthority()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.iamDatabaseAuthentication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetIamDatabaseAuthentication()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.customIamInstanceProfile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCustomIamInstanceProfile()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.activityStreamMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetActivityStreamMode()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.activityStreamStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetActivityStreamStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.pendingMaintenanceActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPendingMaintenanceActions()).ToDataRes(types.Array(types.Resource("aws.rds.pendingMaintenanceAction")))
	},
	"aws.rds.dbinstance.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.resourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetResourceArn()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetAction()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetDescription()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.autoAppliedAfterDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetAutoAppliedAfterDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.currentApplyDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetCurrentApplyDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.forcedApplyDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetForcedApplyDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.optInStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetOptInStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetClusters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetCacheClusters()).ToDataRes(types.Array(types.Resource("aws.elasticache.cluster")))
	},
	"aws.elasticache.serverlessCaches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetServerlessCaches()).ToDataRes(types.Array(types.Resource("aws.elasticache.serverlessCache")))
	},
	"aws.elasticache.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAtRestEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenLastModifiedDate()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterCreateTime()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterId()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodes()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSecurityGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetClientDownloadLandingPage()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetIpDiscovery()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetLogDeliveryConfigurations()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNotificationConfiguration()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNumCacheNodes()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetPreferredAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSnapshotRetentionLimit()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionMode()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetArn()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetName()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetDescription()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetEngine()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.majorEngineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetMajorEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elasticache.serverlessCache.snapshotRetentionLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetSnapshotRetentionLimit()).ToDataRes(types.Int)
	},
	"aws.elasticache.serverlessCache.dailySnapshotTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetDailySnapshotTime()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetRegion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.redshift.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshift).GetClusters()).ToDataRes(types.Array(types.Resource("aws.redshift.cluster")))
	},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAllowVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAutomatedSnapshotRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterParameterGroupNames()).ToDataRes(types.Array(types.String))
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterRevisionNumber()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterStatus()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterVersion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetDbName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEnhancedVpcRouting()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNextMaintenanceWindowStartTime()).ToDataRes(types.Time)
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNumberOfNodes()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetParameters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetVpcId()).ToDataRes(types.String)
	},
	"aws.ecr.privateRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPrivateRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPublicRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetName()).ToDataRes(types.String)
	},
	"aws.ecr.repository.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetUri()).ToDataRes(types.String)
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.repository.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.ecr.repository.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImageScanOnPush()).ToDataRes(types.Bool)
	},
	"aws.ecr.image.digest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetDigest()).ToDataRes(types.String)
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetMediaType()).ToDataRes(types.String)
	},
	"aws.ecr.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetTags()).ToDataRes(types.Array(types.String))
	},
	"aws.ecr.image.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.image.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRepoName()).ToDataRes(types.String)
	},
	"aws.ecr.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.image.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetUri()).ToDataRes(types.String)
	},
	"aws.dms.replicationInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDms).GetReplicationInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.apigateway.restApis": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigateway).GetRestApis()).ToDataRes(types.Array(types.Resource("aws.apigateway.restapi")))
	},
	"aws.apigateway.restapi.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetId()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetCreatedDate()).ToDataRes(types.Time)
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetStages()).ToDataRes(types.Array(types.Resource("aws.apigateway.stage")))
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetRegion()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.apigateway.stage.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetTracingEnabled()).ToDataRes(types.Bool)
	},
	"aws.apigateway.stage.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDeploymentId()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetMethodSettings()).ToDataRes(types.Dict)
	},
	"aws.lambda.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambda).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.lambda.function")))
	},
	"aws.lambda.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetName()).ToDataRes(types.String)
	},
	"aws.lambda.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetConcurrency()).ToDataRes(types.Int)
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetDlqTargetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetPolicy()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRegion()).ToDataRes(types.String)
	},
	"aws.lambda.function.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ssm.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsm).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ssm.instance")))
	},
	"aws.ssm.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsm).GetParameters()).ToDataRes(types.Array(types.Resource("aws.ssm.parameter")))
	},
	"aws.ssm.parameter.allowedPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetAllowedPattern()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetArn()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetRegion()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.dataType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetDataType()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetDescription()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.ssm.parameter.lastModifiedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetLastModifiedDate()).ToDataRes(types.Time)
	},
	"aws.ssm.parameter.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetName()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.tier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetTier()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetType()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetVersion()).ToDataRes(types.Int)
	},
	"aws.ssm.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPingStatus()).ToDataRes(types.String)
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetIpAddress()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformName()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformType()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ssm.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ssm.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ssm.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetEbsEncryptionByDefault()).ToDataRes(types.Map(types.String, types.Bool))
	},
	"aws.ec2.volumes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVolumes()).ToDataRes(types.Array(types.Resource("aws.ec2.volume")))
	},
	"aws.ec2.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.ec2.snapshot")))
	},
	"aws.ec2.internetGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInternetGateways()).ToDataRes(types.Array(types.Resource("aws.ec2.internetgateway")))
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVpnConnections()).ToDataRes(types.Array(types.Resource("aws.ec2.vpnconnection")))
	},
	"aws.ec2.networkAcls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetNetworkAcls()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl")))
	},
	"aws.ec2.keypairs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetKeypairs()).ToDataRes(types.Array(types.Resource("aws.ec2.keypair")))
	},
	"aws.ec2.eips": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetEips()).ToDataRes(types.Array(types.Resource("aws.ec2.eip")))
	},
	"aws.ec2.eip.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ec2.eip.attached": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetAttached()).ToDataRes(types.Bool)
	},
	"aws.ec2.eip.instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetInstance()).ToDataRes(types.Resource("aws.ec2.instance"))
	},
	"aws.ec2.eip.networkInterfaceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetNetworkInterfaceId()).ToDataRes(types.String)
	},
	"aws.ec2.eip.networkInterfaceOwnerId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetNetworkInterfaceOwnerId()).ToDataRes(types.String)
	},
	"aws.ec2.eip.privateIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPrivateIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.eip.publicIpv4Pool": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPublicIpv4Pool()).ToDataRes(types.String)
	},
	"aws.ec2.eip.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.eip.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.natgateway.natGatewayId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetNatGatewayId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.natgateway.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.vpc.natgateway.addresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetAddresses()).ToDataRes(types.Array(types.Resource("aws.vpc.natgateway.address")))
	},
	"aws.vpc.natgateway.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.vpc.natgateway.address.allocationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetAllocationId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.networkInterfaceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetNetworkInterfaceId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.privateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetPrivateIp()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetPublicIp()).ToDataRes(types.Resource("aws.ec2.eip"))
	},
	"aws.vpc.natgateway.address.isPrimary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetIsPrimary()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.acceptanceRequired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetAcceptanceRequired()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.dnsNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetDnsNames()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.managesVpcEndpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetManagesVpcEndpoints()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetOwner()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.payerResponsibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPayerResponsibility()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.privateDnsNameVerificationState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPrivateDnsNameVerificationState()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.privateDnsNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPrivateDnsNames()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.serviceEndpoint.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.vpcEndpointPolicySupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetVpcEndpointPolicySupported()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.acceptorVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetAcceptorVpc()).ToDataRes(types.Resource("aws.vpc.peeringConnection.peeringVpc"))
	},
	"aws.vpc.peeringConnection.expirationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetExpirationTime()).ToDataRes(types.Time)
	},
	"aws.vpc.peeringConnection.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.requestorVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetRequestorVpc()).ToDataRes(types.Resource("aws.vpc.peeringConnection.peeringVpc"))
	},
	"aws.vpc.peeringConnection.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.allowDnsResolutionFromRemoteVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetAllowDnsResolutionFromRemoteVpc()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.peeringVpc.allowEgressFromLocalClassicLinkToRemoteVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetAllowEgressFromLocalClassicLinkToRemoteVpc()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.peeringVpc.allowEgressFromLocalVpcToRemoteClassicLink": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetAllowEgressFromLocalVpcToRemoteClassicLink()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv4CiderBlocks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetIpv4CiderBlocks()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv6CiderBlocks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetIpv6CiderBlocks()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.ownerID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetOwnerID()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.peeringVpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.peeringVpc.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.vpc.peeringConnection.peeringVpc.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetVpcId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetEntries()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl.entry")))
	},
	"aws.ec2.networkacl.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkacl.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.networkacl.associations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetAssociations()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl.association")))
	},
	"aws.ec2.networkacl.association.associationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetAssociationId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.association.networkAclId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetNetworkAclId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.association.subnetId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetSubnetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetEgress()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetRuleAction()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.ruleNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetRuleNumber()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetPortRange()).ToDataRes(types.Resource("aws.ec2.networkacl.entry.portrange"))
	},
	"aws.ec2.networkacl.entry.cidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetCidrBlock()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.ipv6CidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetIpv6CidrBlock()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetFrom()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetTo()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetVgwTelemetry()).ToDataRes(types.Array(types.Resource("aws.ec2.vgwtelemetry")))
	},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetOutsideIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatusMessage()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetCreateVolumePermission()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetStartTime()).ToDataRes(types.Time)
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.volumeSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetVolumeSize()).ToDataRes(types.Int)
	},
	"aws.ec2.snapshot.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.volume.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.volume.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetVolumeType()).ToDataRes(types.String)
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetCreateTime()).ToDataRes(types.Time)
	},
	"aws.ec2.volume.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.volume.multiAttachEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetMultiAttachEnabled()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.throughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetThroughput()).ToDataRes(types.Int)
	},
	"aws.ec2.volume.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetSize()).ToDataRes(types.Int)
	},
	"aws.ec2.volume.iops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetIops()).ToDataRes(types.Int)
	},
	"aws.inspector.coverages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspector).GetCoverages()).ToDataRes(types.Array(types.Resource("aws.inspector.coverage")))
	},
	"aws.inspector.coverage.accountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetAccountId()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetResourceId()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetResourceType()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.lastScannedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetLastScannedAt()).ToDataRes(types.Time)
	},
	"aws.inspector.coverage.statusReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetStatusReason()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.statusCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetStatusCode()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.scanType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetScanType()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.ec2Instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEc2Instance()).ToDataRes(types.Resource("aws.inspector.coverage.instance"))
	},
	"aws.inspector.coverage.ecrImage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEcrImage()).ToDataRes(types.Resource("aws.inspector.coverage.image"))
	},
	"aws.inspector.coverage.ecrRepo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEcrRepo()).ToDataRes(types.Resource("aws.inspector.coverage.repository"))
	},
	"aws.inspector.coverage.lambda": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetLambda()).ToDataRes(types.Resource("aws.lambda.function"))
	},
	"aws.inspector.coverage.instance.platform": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetPlatform()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.inspector.coverage.instance.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetImage()).ToDataRes(types.Resource("aws.ec2.image"))
	},
	"aws.inspector.coverage.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.image.imagePulledAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetImagePulledAt()).ToDataRes(types.Time)
	},
	"aws.inspector.coverage.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.inspector.coverage.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetName()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.scanFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetScanFrequency()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDetailedMonitoring()).ToDataRes(types.String)
	},
	"aws.ec2.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSsm()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpTokens()).ToDataRes(types.String)
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpEndpoint()).ToDataRes(types.String)
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPatchState()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDeviceMappings()).ToDataRes(types.Array(types.Resource("aws.ec2.instance.device")))
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPlatformDetails()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceStatus()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateReason()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionReason()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEbsOptimized()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.enaSupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEnaSupported()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceType()).ToDataRes(types.String)
	},
	"aws.ec2.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.instance.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetImage()).ToDataRes(types.Resource("aws.ec2.image"))
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetLaunchTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetKeypair()).ToDataRes(types.Resource("aws.ec2.keypair"))
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpcArn()).ToDataRes(types.String)
	},
	"aws.ec2.instance.hypervisor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHypervisor()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceLifecycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceLifecycle()).ToDataRes(types.String)
	},
	"aws.ec2.instance.rootDeviceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRootDeviceType()).ToDataRes(types.String)
	},
	"aws.ec2.instance.rootDeviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRootDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.architecture": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetArchitecture()).ToDataRes(types.String)
	},
	"aws.ec2.instance.tpmSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetTpmSupport()).ToDataRes(types.String)
	},
	"aws.ec2.instance.networkInterfaces": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetNetworkInterfaces()).ToDataRes(types.Array(types.Resource("aws.ec2.networkinterface")))
	},
	"aws.ec2.networkinterface.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.ec2.networkinterface.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.networkinterface.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.sourceDestCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSourceDestCheck()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.requesterManaged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetRequesterManaged()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.networkinterface.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.networkinterface.ipv6Native": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetIpv6Native()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.macAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetMacAddress()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.privateDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetPrivateDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.privateIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetPrivateIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetFingerprint()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetType()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.keypair.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.image.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.image.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.image.architecture": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArchitecture()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerId()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerAlias()).ToDataRes(types.String)
	},
	"aws.ec2.image.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.image.deprecatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetDeprecatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeleteOnTermination()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissions()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissionsEgress()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIsAttachedToNetworkInterface()).ToDataRes(types.Bool)
	},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetFromPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetToPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpProtocol()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpRanges()).ToDataRes(types.Array(types.String))
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpv6Ranges()).ToDataRes(types.Array(types.String))
	},
	"aws.ec2.securitygroup.ippermission.prefixListIds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetPrefixListIds()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.securitygroup.ippermission.userIdGroupPairs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetUserIdGroupPairs()).ToDataRes(types.Array(types.Dict))
	},
	"aws.config.recorders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRecorders()).ToDataRes(types.Array(types.Resource("aws.config.recorder")))
	},
	"aws.config.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRules()).ToDataRes(types.Array(types.Resource("aws.config.rule")))
	},
	"aws.config.deliveryChannels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetDeliveryChannels()).ToDataRes(types.Array(types.Resource("aws.config.deliverychannel")))
	},
	"aws.config.rule.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetArn()).ToDataRes(types.String)
	},
	"aws.config.rule.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetState()).ToDataRes(types.String)
	},
	"aws.config.rule.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetSource()).ToDataRes(types.Dict)
	},
	"aws.config.rule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetId()).ToDataRes(types.String)
	},
	"aws.config.rule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetName()).ToDataRes(types.String)
	},
	"aws.config.rule.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetDescription()).ToDataRes(types.String)
	},
	"aws.config.rule.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetRegion()).ToDataRes(types.String)
	},
	"aws.config.recorder.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetName()).ToDataRes(types.String)
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRoleArn()).ToDataRes(types.String)
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetAllSupported()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetIncludeGlobalResourceTypes()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.recording": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRecording()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.config.recorder.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRegion()).ToDataRes(types.String)
	},
	"aws.config.recorder.resourceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetResourceTypes()).ToDataRes(types.Array(types.String))
	},
	"aws.config.deliverychannel.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetName()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.s3BucketName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetS3BucketName()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.s3KeyPrefix": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetS3KeyPrefix()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.snsTopicARN": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetSnsTopicARN()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEks).GetClusters()).ToDataRes(types.Array(types.Resource("aws.eks.cluster")))
	},
	"aws.eks.nodegroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetName()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.nodegroup.modifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetModifiedAt()).ToDataRes(types.Time)
	},
	"aws.eks.nodegroup.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.capacityType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetCapacityType()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.scalingConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetScalingConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.nodegroup.instanceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetInstanceTypes()).ToDataRes(types.Array(types.String))
	},
	"aws.eks.nodegroup.amiType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetAmiType()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.nodeRole": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetNodeRole()).ToDataRes(types.Resource("aws.iam.role"))
	},
	"aws.eks.nodegroup.diskSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetDiskSize()).ToDataRes(types.Int)
	},
	"aws.eks.nodegroup.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetLabels()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.nodegroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.nodegroup.autoscalingGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetAutoscalingGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.eks.addon.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetName()).ToDataRes(types.String)
	},
	"aws.eks.addon.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.addon.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.addon.addonVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetAddonVersion()).ToDataRes(types.String)
	},
	"aws.eks.addon.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.addon.modifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetModifiedAt()).ToDataRes(types.Time)
	},
	"aws.eks.addon.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.addon.publisher": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetPublisher()).ToDataRes(types.String)
	},
	"aws.eks.addon.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetOwner()).ToDataRes(types.String)
	},
	"aws.eks.addon.configurationValues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetConfigurationValues()).ToDataRes(types.String)
	},
	"aws.eks.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetName()).ToDataRes(types.String)
	},
	"aws.eks.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.eks.cluster.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEncryptionConfig()).ToDataRes(types.Array(types.Dict))
	},
	"aws.eks.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetNetworkConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetResourcesVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.cluster.nodeGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetNodeGroups()).ToDataRes(types.Array(types.Resource("aws.eks.nodegroup")))
	},
	"aws.eks.cluster.addons": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetAddons()).ToDataRes(types.Array(types.Resource("aws.eks.addon")))
	},
	"aws.eks.cluster.iamRole": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetIamRole()).ToDataRes(types.Resource("aws.iam.role"))
	},
	"aws.eks.cluster.supportType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetSupportType()).ToDataRes(types.String)
	},
	"aws.eks.cluster.authenticationMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetAuthenticationMode()).ToDataRes(types.String)
	},
	"aws.neptune.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptune).GetClusters()).ToDataRes(types.Array(types.Resource("aws.neptune.cluster")))
	},
	"aws.neptune.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptune).GetInstances()).ToDataRes(types.Array(types.Resource("aws.neptune.instance")))
	},
	"aws.neptune.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetName()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.clusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.globalClusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetGlobalClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.automaticRestartTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetAutomaticRestartTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.cluster.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.neptune.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.crossAccountClone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetCrossAccountClone()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.clusterParameterGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterParameterGroup()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.subnetGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetSubnetGroup()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.clusterResourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterResourceId()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.earliestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEarliestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.cluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.iamDatabaseAuthenticationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetIamDatabaseAuthenticationEnabled()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPort()).ToDataRes(types.Int)
	},
	"aws.neptune.cluster.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStorageType()).ToDataRes(types.String)
	},
	"aws.neptune.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetName()).ToDataRes(types.String)
	},
	"aws.neptune.instance.clusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.instance.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.neptune.instance.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.instanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetInstanceClass()).ToDataRes(types.String)
	},
	"aws.neptune.instance.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStatus()).ToDataRes(types.String)
	},
	"aws.neptune.instance.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPort()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.instance.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEndpoint()).ToDataRes(types.Dict)
	},
	"aws.neptune.instance.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEngine()).ToDataRes(types.String)
	},
	"aws.neptune.instance.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.neptune.instance.enhancedMonitoringResourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEnhancedMonitoringResourceArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.iamDatabaseAuthenticationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetIamDatabaseAuthenticationEnabled()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.neptune.instance.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.neptune.instance.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.instance.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.neptune.instance.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.monitoringRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMonitoringRoleArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.neptune.instance.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.neptune.instance.promotionTier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPromotionTier()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.neptune.instance.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStorageType()).ToDataRes(types.String)
	},
	"aws.neptune.instance.tdeCredentialArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetTdeCredentialArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.databases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalytics).GetDatabases()).ToDataRes(types.Array(types.Resource("aws.timestream.liveanalytics.database")))
	},
	"aws.timestream.liveanalytics.tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalytics).GetTables()).ToDataRes(types.Array(types.Resource("aws.timestream.liveanalytics.table")))
	},
	"aws.timestream.liveanalytics.database.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetRegion()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.database.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.database.tableCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetTableCount()).ToDataRes(types.Int)
	},
	"aws.timestream.liveanalytics.table.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.databaseName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetDatabaseName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetRegion()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.table.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.table.magneticStoreWriteProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetMagneticStoreWriteProperties()).ToDataRes(types.Dict)
	},
	"aws.timestream.liveanalytics.table.retentionProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetRetentionProperties()).ToDataRes(types.Dict)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"aws.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAws).__id, ok = v.Value.(string)
			return
		},
	"aws.vpcs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Vpcs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.regions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Regions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccount).__id, ok = v.Value.(string)
			return
		},
	"aws.account.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.aliases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Aliases, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Organization, ok = plugin.RawToTValue[*mqlAwsOrganization](v.Value, v.Error)
		return
	},
	"aws.account.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.organization.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsOrganization).__id, ok = v.Value.(string)
			return
		},
	"aws.organization.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.featureSet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).FeatureSet, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountEmail, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.accounts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Accounts, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpc).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).InstanceTenancy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Endpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.flowLogs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).FlowLogs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routeTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).RouteTables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Subnets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.natGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).NatGateways, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).ServiceEndpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).PeeringConnections, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcRoutetable).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.routetable.associations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Associations, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Routes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcRoutetableAssociation).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.routetable.association.routeTableAssociationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).RouteTableAssociationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.associationsState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).AssociationsState, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.gatewayId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).GatewayId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.main": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).Main, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.routeTableId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).RouteTableId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcSubnet).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.subnet.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Cidrs, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).MapPublicIpOnLaunch, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).DefaultForAvailabilityZone, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.assignIpv6AddressOnCreation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AssignIpv6AddressOnCreation, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.endpoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).ServiceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).PolicyDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Subnets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.privateDnsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).PrivateDnsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcFlowlog).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.flowlog.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.destination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Destination, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.destinationType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).DestinationType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.deliverLogsStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).DeliverLogsStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.maxAggregationInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).MaxAggregationInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.trafficType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).TrafficType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWaf).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.acls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).Acls, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.ruleGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).RuleGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.ipSets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).IpSets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafAcl).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.acl.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.managedByFirewallManager": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).ManagedByFirewallManager, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.acl.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Rules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.acl.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRulegroup).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rulegroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Rules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRule).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.priority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Priority, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Statement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Action, ok = plugin.RawToTValue[*mqlAwsWafRuleAction](v.Value, v.Error)
		return
	},
	"aws.waf.rule.belongsTo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).BelongsTo, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleAction).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.action.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).Action, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.responseCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).ResponseCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.kind": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Kind, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.json": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Json, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqliMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).SqliMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementSqlimatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).XssMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementXssmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.byteMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).ByteMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementBytematchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RegexMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRegexmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geoMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).GeoMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementGeomatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipSetReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).IpSetReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementIpsetreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).LabelMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementLabelmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedRuleGroupStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).ManagedRuleGroupStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementManagedrulegroupstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).NotStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementNotstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).OrStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementOrstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).AndStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementAndstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rateBasedStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RateBasedStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRatebasedstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexPatternSetReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RegexPatternSetReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ruleGroupReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RuleGroupReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRulegroupreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeConstraintStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).SizeConstraintStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementSizeconstraintstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementGeomatchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.geomatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.countryCodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).CountryCodes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementIpsetreferencestatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.ipsetreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipSetForwardedIPConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).IpSetForwardedIPConfig, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.headerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).HeaderName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.position": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).Position, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.fallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).FallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementLabelmatchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.labelmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.managedrulegroupstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.vendorName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).VendorName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementAndstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.andstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).Statements, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementNotstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.notstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.statement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).Statement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementOrstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.orstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).Statements, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ratebasedstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementRatebasedstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.rulegroupreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.excludeRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).ExcludeRules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementSizeconstraintstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.sizeconstraintstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.comparisonOperator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).ComparisonOperator, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementRegexmatchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.regexmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.regexString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).RegexString, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementBytematchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.bytematchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.searchString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).SearchString, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatch).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.method": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Method, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.uriPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).UriPath, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.queryString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).QueryString, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.allQueryArguments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).AllQueryArguments, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Body, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchBody](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Cookie, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchCookie](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleHeader": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).SingleHeader, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchSingleheader](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerOrder": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).HeaderOrder, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeaderorder](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Headers, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeaders](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3Fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Ja3Fingerprint, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonBody": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).JsonBody, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJsonbody](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleQueryArgument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).SingleQueryArgument, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchBody).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.body.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchCookie).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.cookie.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchHeaderorder).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.headerorder.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchSingleheader).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.singleheader.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.singlequeryargument.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.fallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).FallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchJsonbody).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.jsonbody.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchScope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).MatchScope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.invalidFallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).InvalidFallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).MatchPattern, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.all": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).All, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.includePaths": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).IncludePaths, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchHeaders).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.headers.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchScope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).MatchScope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).MatchPattern, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.all": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).All, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.includeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).IncludeHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.excludeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).ExcludeHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementXssmatchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.xssmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafRuleStatementSqlimatchstatement).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.rule.statement.sqlimatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.sensitivityLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).SensitivityLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsWafIpset).__id, ok = v.Value.(string)
			return
		},
	"aws.waf.ipset.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.addressType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).AddressType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.addresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Addresses, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfs).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystems": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfs).Filesystems, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfsFilesystem).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystem.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).BackupPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.kms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKms).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.keys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKms).Keys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.kms.key.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKmsKey).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.key.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).KeyRotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.kms.key.metadata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Metadata, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIam).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.users": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Users, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.roles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Roles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.credentialReport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).CredentialReport, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountPasswordPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountSummary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountSummary, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).VirtualMfaDevices, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.serverCertificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).ServerCertificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUsercredentialreportentry).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Properties, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).MfaActive, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastChanged, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordNextRotation, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).UserCreationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUser).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.user.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AccessKeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.loginProfile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).LoginProfile, ok = plugin.RawToTValue[*mqlAwsIamLoginProfile](v.Value, v.Error)
		return
	},
	"aws.iam.loginProfile.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamLoginProfile).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.loginProfile.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamLoginProfile).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicy).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policy.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.policyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).PolicyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).IsAttachable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachmentCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.iam.policy.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).UpdateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.versions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Versions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).DefaultVersion, ok = plugin.RawToTValue[*mqlAwsIamPolicyversion](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedUsers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedRoles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicyversion).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policyversion.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).VersionId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).IsDefaultVersion, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Document, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamRole).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.role.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.role.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.assumeRolePolicyDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).AssumeRolePolicyDocument, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.usernames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Usernames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamVirtualmfadevice).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).SerialNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).EnableDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.accessAnalyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamAccessAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.accessAnalyzer.analyzers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessAnalyzer).Analyzers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accessAnalyzer.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessAnalyzer).Findings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamAccessanalyzerAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.accessanalyzer.analyzer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).LastResourceAnalyzed, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).LastResourceAnalyzedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamAccessanalyzerFinding).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.accessanalyzer.finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.error": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Error, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceOwnerAccount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceOwnerAccount, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.analyzedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).AnalyzedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.analyzerArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).AnalyzerArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemaker).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).Endpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).NotebookInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstance).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Details, ok = plugin.RawToTValue[*mqlAwsSagemakerNotebookinstanceDetails](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstanceDetails).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).DirectInternetAccess, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Config, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSns).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSns).Topics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsTopic).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topic.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Subscriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Attributes, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsSubscription).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.subscription.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEs).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEs).Domains, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.es.domain.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEsDomain).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domain.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).EncryptionAtRestEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).NodeToNodeEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).ElasticsearchVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcm).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcm).Certificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcmCertificate).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificate.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotBefore, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotAfter, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.subject": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Subject, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Certificate, ok = plugin.RawToTValue[plugin.Resource](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.keyAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).KeyAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Source, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.issuer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Issuer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.issuedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).IssuedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.importedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).ImportedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.autoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscaling).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscaling).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscalingGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LoadBalancerNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.minSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MinSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.maxSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MaxSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.defaultCooldown": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DefaultCooldown, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.launchConfigurationName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LaunchConfigurationName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckGracePeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckGracePeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.maxInstanceLifetime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MaxInstanceLifetime, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.desiredCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DesiredCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).AvailabilityZones, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.capacityRebalance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).CapacityRebalance, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.defaultInstanceWarmup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DefaultInstanceWarmup, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElb).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).ClassicLoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).LoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElbTargetgroup).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.targetgroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.protocolVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).ProtocolVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.ipAddressType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).IpAddressType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckIntervalSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckIntervalSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckPort, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckProtocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckProtocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckTimeoutSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckTimeoutSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.targetType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).TargetType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.unhealthyThresholdCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).UnhealthyThresholdCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.ec2Targets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Ec2Targets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.lambdaTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).LambdaTargets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElbLoadbalancer).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).DnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ListenerDescriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Attributes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).AvailabilityZones, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.hostedZoneId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).HostedZoneId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.elbType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ElbType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.targetGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).TargetGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuild).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.projects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuild).Projects, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuildProject).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.project.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Environment, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Source, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuardduty).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Findings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Detectors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuarddutyDetector).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.detector.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.features": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Features, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).FindingPublishingFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Findings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).UnarchivedFindings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuarddutyFinding).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.finding.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Severity, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.confidence": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Confidence, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.securityhub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hubs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhub).Hubs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhubHub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hub.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).SubscribedAt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanager).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanager).Secrets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanagerSecret).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastChangedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastRotatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).NextRotationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).PrimaryRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcs).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RunningTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).PendingTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RegisteredContainerInstancesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Configuration, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tasks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).AgentConnected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).CapacityProvider, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Ec2Instance, ok = plugin.RawToTValue[*mqlAwsEc2Instance](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsTask).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.task.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Connectivity, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsContainer).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.container.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskDefinitionArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).LogDriver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Command, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).RuntimeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.containerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ContainerName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmr).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmr).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmrCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).NormalizedInstanceHours, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).OutpostArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Status, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).MasterInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatch).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.logGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).LogGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricsalarm).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricNamespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Actions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).StateReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).InsufficientDataActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).OkActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetric).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Dimensions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Statistics, ok = plugin.RawToTValue[*mqlAwsCloudwatchMetricstatistics](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricdimension).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricstatistics).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Datapoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricDatapoint).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Timestamp, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Maximum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Minimum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Average, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Sum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Unit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroup).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).MetricsFilters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.retentionInDays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).RetentionInDays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroupMetricsfilter).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfront).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distributions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Distributions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Functions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontDistribution).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Origins, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DefaultCacheBehavior, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).CacheBehaviors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).HttpVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).IsIPV6Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).PriceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.cnames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Cnames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontDistributionOrigin).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionAttempts, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionTimeout, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).OriginPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Account, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontFunction).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).LastModifiedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Stage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudtrail).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudtrail.trails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrail).Trails, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudtrailTrail).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsMultiRegionTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsOrganizationTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogFileValidationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IncludeGlobalServiceEvents, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).S3bucket, ok = plugin.RawToTValue[*mqlAwsS3Bucket](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).SnsTopicARN, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Status, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogGroup, ok = plugin.RawToTValue[*mqlAwsCloudwatchLoggroup](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).CloudWatchLogsRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.cloudWatchLogsLogGroupArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).CloudWatchLogsLogGroupArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).EventSelectors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3control.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3control).__id, ok = v.Value.(string)
			return
		},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3control).AccountPublicAccessBlock, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.buckets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3).Buckets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3Bucket).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Policy, ok = plugin.RawToTValue[*mqlAwsS3BucketPolicy](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.acl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Acl, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Owner, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.cors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Cors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Versioning, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Logging, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).StaticWebsiteHosting, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).DefaultLock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.replication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Replication, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Encryption, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).PublicAccessBlock, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketGrant).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.grant.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Permission, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Grantee, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketCorsrule).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedMethods, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedOrigins, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).ExposeHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).MaxAgeSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketPolicy).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Document, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Statements, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApplicationAutoscaling).__id, ok = v.Value.(string)
			return
		},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).ScalableTargets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApplicationautoscalingTarget).__id, ok = v.Value.(string)
			return
		},
	"aws.applicationautoscaling.target.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.scalableDimension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).ScalableDimension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.minCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).MinCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.maxCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).MaxCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.suspendedState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).SuspendedState, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackup).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vaults": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackup).Vaults, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vault.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackupVault).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vault.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).RecoveryPoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vault.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vault.locked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Locked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackupVaultRecoveryPoint).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreatedBy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IamRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CompletionDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IsEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.dynamodb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodb).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Backups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).GlobalTables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Tables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Limits, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.exports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Exports, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbExport).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.export.table": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Table, ok = plugin.RawToTValue[*mqlAwsDynamodbTable](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3Bucket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3Bucket, ok = plugin.RawToTValue[*mqlAwsS3Bucket](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3Prefix": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3Prefix, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.itemCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).ItemCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.endTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).EndTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3SseAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3SseAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbLimit).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.limit.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbGlobaltable).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).ReplicaSettings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbTable).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.table.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Backups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).SseDescription, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ProvisionedThroughput, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ContinuousBackups, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.deletionProtectionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).DeletionProtectionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.globalTableVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).GlobalTableVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.items": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Items, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.sizeBytes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).SizeBytes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.latestStreamArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).LatestStreamArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSqs).__id, ok = v.Value.(string)
			return
		},
	"aws.sqs.queues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqs).Queues, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSqsQueue).__id, ok = v.Value.(string)
			return
		},
	"aws.sqs.queue.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.deadLetterQueue": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).DeadLetterQueue, ok = plugin.RawToTValue[*mqlAwsSqsQueue](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.deliveryDelaySeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).DeliveryDelaySeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.lastModified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).LastModified, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.maxReceiveCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MaxReceiveCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.maximumMessageSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MaximumMessageSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.messageRetentionPeriodSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MessageRetentionPeriodSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.receiveMessageWaitTimeSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).ReceiveMessageWaitTimeSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.sqsManagedSseEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).SqsManagedSseEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.queueType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).QueueType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.visibilityTimeoutSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).VisibilityTimeoutSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRds).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).DbInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbClusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).DbClusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.allPendingMaintenanceActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).AllPendingMaintenanceActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsBackupsetting).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.backupsetting.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.retentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).RetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.dedicatedLogVolume": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).DedicatedLogVolume, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.timezone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Timezone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.earliestRestoreAvailable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).EarliestRestoreAvailable, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.latestRestoreAvailable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).LatestRestoreAvailable, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsDbcluster).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbcluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Members, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageAllocated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageAllocated, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.clusterDbInstanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ClusterDbInstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).AvailabilityZones, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.hostedZoneId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).HostedZoneId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.backupSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).BackupSettings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engineLifecycleSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).EngineLifecycleSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.certificateExpiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CertificateExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.certificateAuthority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CertificateAuthority, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.iamDatabaseAuthentication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).IamDatabaseAuthentication, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.activityStreamMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ActivityStreamMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.activityStreamStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ActivityStreamStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsSnapshot).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Attributes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).IsClusterSnapshot, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.allocatedStorage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).AllocatedStorage, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsDbinstance).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageAllocated, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnhancedMonitoringResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.backupSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).BackupSettings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Subnets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engineLifecycleSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EngineLifecycleSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.certificateExpiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CertificateExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.certificateAuthority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CertificateAuthority, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.iamDatabaseAuthentication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).IamDatabaseAuthentication, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.customIamInstanceProfile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CustomIamInstanceProfile, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.activityStreamMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).ActivityStreamMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.activityStreamStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).ActivityStreamStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.pendingMaintenanceActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PendingMaintenanceActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsPendingMaintenanceAction).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.pendingMaintenanceAction.resourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).ResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).Action, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.autoAppliedAfterDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).AutoAppliedAfterDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.currentApplyDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).CurrentApplyDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.forcedApplyDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).ForcedApplyDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.optInStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).OptInStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElasticache).__id, ok = v.Value.(string)
			return
		},
	"aws.elasticache.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).CacheClusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCaches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).ServerlessCaches, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElasticacheCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.elasticache.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AtRestEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenLastModifiedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterCreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).ClientDownloadLandingPage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).IpDiscovery, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).LogDeliveryConfigurations, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NotificationConfiguration, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NumCacheNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).PreferredAvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SnapshotRetentionLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElasticacheServerlessCache).__id, ok = v.Value.(string)
			return
		},
	"aws.elasticache.serverlessCache.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.majorEngineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).MajorEngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.snapshotRetentionLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).SnapshotRetentionLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.dailySnapshotTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).DailySnapshotTime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRedshift).__id, ok = v.Value.(string)
			return
		},
	"aws.redshift.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshift).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRedshiftCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AllowVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AutomatedSnapshotRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterParameterGroupNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterRevisionNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).DbName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).EnhancedVpcRouting, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Logging, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NextMaintenanceWindowStartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NumberOfNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Parameters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcr).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.privateRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PrivateRepositories, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PublicRepositories, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).Images, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcrRepository).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.repository.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Images, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).ImageScanOnPush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcrImage).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.image.digest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Digest, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).MediaType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Tags, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.image.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDms).__id, ok = v.Value.(string)
			return
		},
	"aws.dms.replicationInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDms).ReplicationInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigateway).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.restApis": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigateway).RestApis, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigatewayRestapi).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.restapi.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).CreatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Stages, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigatewayStage).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.stage.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).TracingEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).DeploymentId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).MethodSettings, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsLambda).__id, ok = v.Value.(string)
			return
		},
	"aws.lambda.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambda).Functions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsLambdaFunction).__id, ok = v.Value.(string)
			return
		},
	"aws.lambda.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Concurrency, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).DlqTargetArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Policy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).VpcConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ssm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSsm).__id, ok = v.Value.(string)
			return
		},
	"aws.ssm.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ssm.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).Parameters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSsmParameter).__id, ok = v.Value.(string)
			return
		},
	"aws.ssm.parameter.allowedPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).AllowedPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.dataType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).DataType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.lastModifiedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).LastModifiedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.tier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Tier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Version, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSsmInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.ssm.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PingStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).IpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).EbsEncryptionByDefault, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volumes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Volumes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.internetGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).InternetGateways, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).VpnConnections, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkAcls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).NetworkAcls, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.keypairs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Keypairs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.eips": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Eips, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Eip).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.eip.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.attached": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Attached, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Instance, ok = plugin.RawToTValue[*mqlAwsEc2Instance](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.networkInterfaceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).NetworkInterfaceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.networkInterfaceOwnerId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).NetworkInterfaceOwnerId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.privateIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PrivateIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.publicIpv4Pool": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PublicIpv4Pool, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcNatgateway).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.natgateway.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.natGatewayId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).NatGatewayId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.addresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Addresses, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcNatgatewayAddress).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.natgateway.address.allocationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).AllocationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.networkInterfaceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).NetworkInterfaceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.privateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).PrivateIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).PublicIp, ok = plugin.RawToTValue[*mqlAwsEc2Eip](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.isPrimary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).IsPrimary, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcServiceEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.serviceEndpoint.acceptanceRequired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).AcceptanceRequired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).AvailabilityZones, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.dnsNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).DnsNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.managesVpcEndpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).ManagesVpcEndpoints, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Owner, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.payerResponsibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PayerResponsibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.privateDnsNameVerificationState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PrivateDnsNameVerificationState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.privateDnsNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PrivateDnsNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.vpcEndpointPolicySupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).VpcEndpointPolicySupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcPeeringConnection).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.peeringConnection.acceptorVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).AcceptorVpc, ok = plugin.RawToTValue[*mqlAwsVpcPeeringConnectionPeeringVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.expirationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).ExpirationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.requestorVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).RequestorVpc, ok = plugin.RawToTValue[*mqlAwsVpcPeeringConnectionPeeringVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcPeeringConnectionPeeringVpc).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.peeringConnection.peeringVpc.allowDnsResolutionFromRemoteVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).AllowDnsResolutionFromRemoteVpc, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.allowEgressFromLocalClassicLinkToRemoteVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).AllowEgressFromLocalClassicLinkToRemoteVpc, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.allowEgressFromLocalVpcToRemoteClassicLink": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).AllowEgressFromLocalVpcToRemoteClassicLink, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv4CiderBlocks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Ipv4CiderBlocks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv6CiderBlocks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Ipv6CiderBlocks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ownerID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).OwnerID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Networkacl).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Entries, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.associations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Associations, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2NetworkaclAssociation).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.association.associationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).AssociationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.networkAclId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).NetworkAclId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.subnetId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).SubnetId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2NetworkaclEntry).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Egress, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).RuleAction, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ruleNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).RuleNumber, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).PortRange, ok = plugin.RawToTValue[*mqlAwsEc2NetworkaclEntryPortrange](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.cidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ipv6CidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Ipv6CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2NetworkaclEntryPortrange).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).From, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).To, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Vpnconnection).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).VgwTelemetry, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Vgwtelemetry).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).OutsideIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).StatusMessage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Internetgateway).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Attachments, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Snapshot).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).CreateVolumePermission, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.volumeSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).VolumeSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Volume).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.volume.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Attachments, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).VolumeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).CreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.multiAttachEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).MultiAttachEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.throughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Throughput, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.iops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Iops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.inspector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsInspector).__id, ok = v.Value.(string)
			return
		},
	"aws.inspector.coverages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspector).Coverages, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsInspectorCoverage).__id, ok = v.Value.(string)
			return
		},
	"aws.inspector.coverage.accountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).AccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.lastScannedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).LastScannedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.statusReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).StatusReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.statusCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).StatusCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.scanType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ScanType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ec2Instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Ec2Instance, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageInstance](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ecrImage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).EcrImage, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageImage](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ecrRepo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).EcrRepo, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageRepository](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.lambda": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Lambda, ok = plugin.RawToTValue[*mqlAwsLambdaFunction](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsInspectorCoverageInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.inspector.coverage.instance.platform": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Platform, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Image, ok = plugin.RawToTValue[*mqlAwsEc2Image](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsInspectorCoverageImage).__id, ok = v.Value.(string)
			return
		},
	"aws.inspector.coverage.image.imagePulledAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).ImagePulledAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsInspectorCoverageRepository).__id, ok = v.Value.(string)
			return
		},
	"aws.inspector.coverage.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.scanFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).ScanFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Instance).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DetailedMonitoring, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Ssm, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpTokens, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpEndpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PatchState, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DeviceMappings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PlatformDetails, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceStatus, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateReason, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EbsOptimized, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.enaSupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EnaSupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Image, ok = plugin.RawToTValue[*mqlAwsEc2Image](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).LaunchTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Keypair, ok = plugin.RawToTValue[*mqlAwsEc2Keypair](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).VpcArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.hypervisor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Hypervisor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceLifecycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceLifecycle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.rootDeviceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).RootDeviceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.rootDeviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).RootDeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.architecture": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Architecture, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.tpmSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).TpmSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.networkInterfaces": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).NetworkInterfaces, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Networkinterface).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkinterface.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.sourceDestCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).SourceDestCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.requesterManaged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).RequesterManaged, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.ipv6Native": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Ipv6Native, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.macAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).MacAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.privateDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).PrivateDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.privateIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).PrivateIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Keypair).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.keypair.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Image).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.architecture": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Architecture, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerAlias, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.image.deprecatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).DeprecatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2InstanceDevice).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeleteOnTermination, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Securitygroup).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissionsEgress, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IsAttachedToNetworkInterface, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2SecuritygroupIppermission).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).FromPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).ToPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpProtocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpRanges, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Ipv6Ranges, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.prefixListIds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).PrefixListIds, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.userIdGroupPairs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).UserIdGroupPairs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfig).__id, ok = v.Value.(string)
			return
		},
	"aws.config.recorders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Recorders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Rules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.deliveryChannels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).DeliveryChannels, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.rule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfigRule).__id, ok = v.Value.(string)
			return
		},
	"aws.config.rule.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Source, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.config.rule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfigRecorder).__id, ok = v.Value.(string)
			return
		},
	"aws.config.recorder.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).RoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).AllSupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).IncludeGlobalResourceTypes, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.recording": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Recording, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.resourceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).ResourceTypes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfigDeliverychannel).__id, ok = v.Value.(string)
			return
		},
	"aws.config.deliverychannel.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.s3BucketName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).S3BucketName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.s3KeyPrefix": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).S3KeyPrefix, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.snsTopicARN": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).SnsTopicARN, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEks).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEks).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEksNodegroup).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.nodegroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.modifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).ModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.capacityType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).CapacityType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.scalingConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).ScalingConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.instanceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).InstanceTypes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.amiType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).AmiType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.nodeRole": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).NodeRole, ok = plugin.RawToTValue[*mqlAwsIamRole](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.diskSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).DiskSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Labels, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.autoscalingGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).AutoscalingGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.addon.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEksAddon).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.addon.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.addonVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).AddonVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.addon.modifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).ModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.addon.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.addon.publisher": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Publisher, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Owner, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.configurationValues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).ConfigurationValues, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEksCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).EncryptionConfig, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Logging, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).NetworkConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).ResourcesVpcConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.nodeGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).NodeGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.addons": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Addons, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.iamRole": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).IamRole, ok = plugin.RawToTValue[*mqlAwsIamRole](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.supportType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).SupportType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.authenticationMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).AuthenticationMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsNeptune).__id, ok = v.Value.(string)
			return
		},
	"aws.neptune.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptune).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptune).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsNeptuneCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.neptune.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.globalClusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).GlobalClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.automaticRestartTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).AutomaticRestartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).AvailabilityZones, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.crossAccountClone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).CrossAccountClone, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterParameterGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterParameterGroup, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.subnetGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).SubnetGroup, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterResourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.earliestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EarliestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.iamDatabaseAuthenticationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).IamDatabaseAuthenticationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsNeptuneInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.neptune.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.clusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).ClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.instanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).InstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Endpoint, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.enhancedMonitoringResourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EnhancedMonitoringResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.iamDatabaseAuthenticationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).IamDatabaseAuthenticationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.monitoringRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MonitoringRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.promotionTier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PromotionTier, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.tdeCredentialArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).TdeCredentialArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsTimestreamLiveanalytics).__id, ok = v.Value.(string)
			return
		},
	"aws.timestream.liveanalytics.databases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalytics).Databases, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalytics).Tables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsTimestreamLiveanalyticsDatabase).__id, ok = v.Value.(string)
			return
		},
	"aws.timestream.liveanalytics.database.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.tableCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).TableCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsTimestreamLiveanalyticsTable).__id, ok = v.Value.(string)
			return
		},
	"aws.timestream.liveanalytics.table.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.databaseName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).DatabaseName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.magneticStoreWriteProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).MagneticStoreWriteProperties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.retentionProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).RetentionProperties, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAws for the aws resource
type mqlAws struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInternal it will be used here
	Vpcs plugin.TValue[[]interface{}]
	Regions plugin.TValue[[]interface{}]
}

// createAws creates a new instance of this resource
func createAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAws{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAws) MqlName() string {
	return "aws"
}

func (c *mqlAws) MqlID() string {
	return c.__id
}

func (c *mqlAws) GetVpcs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vpcs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws", c.__id, "vpcs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vpcs()
	})
}

func (c *mqlAws) GetRegions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Regions, func() ([]interface{}, error) {
		return c.regions()
	})
}

// mqlAwsAccount for the aws.account resource
type mqlAwsAccount struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccountInternal it will be used here
	Id plugin.TValue[string]
	Aliases plugin.TValue[[]interface{}]
	Organization plugin.TValue[*mqlAwsOrganization]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsAccount creates a new instance of this resource
func createAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccount{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.account", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccount) MqlName() string {
	return "aws.account"
}

func (c *mqlAwsAccount) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccount) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsAccount) GetAliases() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Aliases, func() ([]interface{}, error) {
		return c.aliases()
	})
}

func (c *mqlAwsAccount) GetOrganization() *plugin.TValue[*mqlAwsOrganization] {
	return plugin.GetOrCompute[*mqlAwsOrganization](&c.Organization, func() (*mqlAwsOrganization, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "organization")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsOrganization), nil
			}
		}

		return c.organization()
	})
}

func (c *mqlAwsAccount) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsOrganization for the aws.organization resource
type mqlAwsOrganization struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsOrganizationInternal it will be used here
	Arn plugin.TValue[string]
	FeatureSet plugin.TValue[string]
	MasterAccountId plugin.TValue[string]
	MasterAccountEmail plugin.TValue[string]
	Accounts plugin.TValue[[]interface{}]
}

// createAwsOrganization creates a new instance of this resource
func createAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOrganization{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.organization", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOrganization) MqlName() string {
	return "aws.organization"
}

func (c *mqlAwsOrganization) MqlID() string {
	return c.__id
}

func (c *mqlAwsOrganization) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsOrganization) GetFeatureSet() *plugin.TValue[string] {
	return &c.FeatureSet
}

func (c *mqlAwsOrganization) GetMasterAccountId() *plugin.TValue[string] {
	return &c.MasterAccountId
}

func (c *mqlAwsOrganization) GetMasterAccountEmail() *plugin.TValue[string] {
	return &c.MasterAccountEmail
}

func (c *mqlAwsOrganization) GetAccounts() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Accounts, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.organization", c.__id, "accounts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.accounts()
	})
}

// mqlAwsVpc for the aws.vpc resource
type mqlAwsVpc struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CidrBlock plugin.TValue[string]
	State plugin.TValue[string]
	IsDefault plugin.TValue[bool]
	InstanceTenancy plugin.TValue[string]
	Region plugin.TValue[string]
	Endpoints plugin.TValue[[]interface{}]
	FlowLogs plugin.TValue[[]interface{}]
	RouteTables plugin.TValue[[]interface{}]
	Subnets plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
	NatGateways plugin.TValue[[]interface{}]
	ServiceEndpoints plugin.TValue[[]interface{}]
	PeeringConnections plugin.TValue[[]interface{}]
}

// createAwsVpc creates a new instance of this resource
func createAwsVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpc) MqlName() string {
	return "aws.vpc"
}

func (c *mqlAwsVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpc) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpc) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpc) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsVpc) GetCidrBlock() *plugin.TValue[string] {
	return &c.CidrBlock
}

func (c *mqlAwsVpc) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpc) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsVpc) GetInstanceTenancy() *plugin.TValue[string] {
	return &c.InstanceTenancy
}

func (c *mqlAwsVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpc) GetEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Endpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsVpc) GetFlowLogs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.FlowLogs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "flowLogs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.flowLogs()
	})
}

func (c *mqlAwsVpc) GetRouteTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RouteTables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "routeTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.routeTables()
	})
}

func (c *mqlAwsVpc) GetSubnets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subnets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subnets()
	})
}

func (c *mqlAwsVpc) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsVpc) GetNatGateways() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NatGateways, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "natGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.natGateways()
	})
}

func (c *mqlAwsVpc) GetServiceEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ServiceEndpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "serviceEndpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.serviceEndpoints()
	})
}

func (c *mqlAwsVpc) GetPeeringConnections() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PeeringConnections, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "peeringConnections")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.peeringConnections()
	})
}

// mqlAwsVpcRoutetable for the aws.vpc.routetable resource
type mqlAwsVpcRoutetable struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsVpcRoutetableInternal
	Associations plugin.TValue[[]interface{}]
	Id plugin.TValue[string]
	Routes plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpcRoutetable creates a new instance of this resource
func createAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetable) MqlName() string {
	return "aws.vpc.routetable"
}

func (c *mqlAwsVpcRoutetable) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetable) GetAssociations() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Associations, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.routetable", c.__id, "associations")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.associations()
	})
}

func (c *mqlAwsVpcRoutetable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcRoutetable) GetRoutes() *plugin.TValue[[]interface{}] {
	return &c.Routes
}

func (c *mqlAwsVpcRoutetable) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsVpcRoutetableAssociation for the aws.vpc.routetable.association resource
type mqlAwsVpcRoutetableAssociation struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsVpcRoutetableAssociationInternal
	RouteTableAssociationId plugin.TValue[string]
	AssociationsState plugin.TValue[interface{}]
	GatewayId plugin.TValue[string]
	Main plugin.TValue[bool]
	RouteTableId plugin.TValue[string]
	Subnet plugin.TValue[*mqlAwsVpcSubnet]
}

// createAwsVpcRoutetableAssociation creates a new instance of this resource
func createAwsVpcRoutetableAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetableAssociation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable.association", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetableAssociation) MqlName() string {
	return "aws.vpc.routetable.association"
}

func (c *mqlAwsVpcRoutetableAssociation) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetableAssociation) GetRouteTableAssociationId() *plugin.TValue[string] {
	return &c.RouteTableAssociationId
}

func (c *mqlAwsVpcRoutetableAssociation) GetAssociationsState() *plugin.TValue[interface{}] {
	return &c.AssociationsState
}

func (c *mqlAwsVpcRoutetableAssociation) GetGatewayId() *plugin.TValue[string] {
	return &c.GatewayId
}

func (c *mqlAwsVpcRoutetableAssociation) GetMain() *plugin.TValue[bool] {
	return &c.Main
}

func (c *mqlAwsVpcRoutetableAssociation) GetRouteTableId() *plugin.TValue[string] {
	return &c.RouteTableId
}

func (c *mqlAwsVpcRoutetableAssociation) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.routetable.association", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

// mqlAwsVpcSubnet for the aws.vpc.subnet resource
type mqlAwsVpcSubnet struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcSubnetInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Cidrs plugin.TValue[string]
	MapPublicIpOnLaunch plugin.TValue[bool]
	AvailabilityZone plugin.TValue[string]
	DefaultForAvailabilityZone plugin.TValue[bool]
	AssignIpv6AddressOnCreation plugin.TValue[bool]
	State plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsVpcSubnet creates a new instance of this resource
func createAwsVpcSubnet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcSubnet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.subnet", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcSubnet) MqlName() string {
	return "aws.vpc.subnet"
}

func (c *mqlAwsVpcSubnet) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcSubnet) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpcSubnet) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcSubnet) GetCidrs() *plugin.TValue[string] {
	return &c.Cidrs
}

func (c *mqlAwsVpcSubnet) GetMapPublicIpOnLaunch() *plugin.TValue[bool] {
	return &c.MapPublicIpOnLaunch
}

func (c *mqlAwsVpcSubnet) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsVpcSubnet) GetDefaultForAvailabilityZone() *plugin.TValue[bool] {
	return &c.DefaultForAvailabilityZone
}

func (c *mqlAwsVpcSubnet) GetAssignIpv6AddressOnCreation() *plugin.TValue[bool] {
	return &c.AssignIpv6AddressOnCreation
}

func (c *mqlAwsVpcSubnet) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcSubnet) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsVpcEndpoint for the aws.vpc.endpoint resource
type mqlAwsVpcEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcEndpointInternal it will be used here
	Id plugin.TValue[string]
	Type plugin.TValue[string]
	Vpc plugin.TValue[string]
	Region plugin.TValue[string]
	ServiceName plugin.TValue[string]
	PolicyDocument plugin.TValue[string]
	Subnets plugin.TValue[[]interface{}]
	PrivateDnsEnabled plugin.TValue[bool]
	State plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsVpcEndpoint creates a new instance of this resource
func createAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcEndpoint) MqlName() string {
	return "aws.vpc.endpoint"
}

func (c *mqlAwsVpcEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcEndpoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcEndpoint) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcEndpoint) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcEndpoint) GetServiceName() *plugin.TValue[string] {
	return &c.ServiceName
}

func (c *mqlAwsVpcEndpoint) GetPolicyDocument() *plugin.TValue[string] {
	return &c.PolicyDocument
}

func (c *mqlAwsVpcEndpoint) GetSubnets() *plugin.TValue[[]interface{}] {
	return &c.Subnets
}

func (c *mqlAwsVpcEndpoint) GetPrivateDnsEnabled() *plugin.TValue[bool] {
	return &c.PrivateDnsEnabled
}

func (c *mqlAwsVpcEndpoint) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcEndpoint) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsVpcFlowlog for the aws.vpc.flowlog resource
type mqlAwsVpcFlowlog struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcFlowlogInternal it will be used here
	Id plugin.TValue[string]
	Vpc plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreatedAt plugin.TValue[*time.Time]
	Destination plugin.TValue[string]
	DestinationType plugin.TValue[string]
	DeliverLogsStatus plugin.TValue[string]
	MaxAggregationInterval plugin.TValue[int64]
	TrafficType plugin.TValue[string]
}

// createAwsVpcFlowlog creates a new instance of this resource
func createAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcFlowlog{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.flowlog", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcFlowlog) MqlName() string {
	return "aws.vpc.flowlog"
}

func (c *mqlAwsVpcFlowlog) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcFlowlog) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcFlowlog) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcFlowlog) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcFlowlog) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcFlowlog) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsVpcFlowlog) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsVpcFlowlog) GetDestination() *plugin.TValue[string] {
	return &c.Destination
}

func (c *mqlAwsVpcFlowlog) GetDestinationType() *plugin.TValue[string] {
	return &c.DestinationType
}

func (c *mqlAwsVpcFlowlog) GetDeliverLogsStatus() *plugin.TValue[string] {
	return &c.DeliverLogsStatus
}

func (c *mqlAwsVpcFlowlog) GetMaxAggregationInterval() *plugin.TValue[int64] {
	return &c.MaxAggregationInterval
}

func (c *mqlAwsVpcFlowlog) GetTrafficType() *plugin.TValue[string] {
	return &c.TrafficType
}

// mqlAwsWaf for the aws.waf resource
type mqlAwsWaf struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafInternal it will be used here
	Acls plugin.TValue[[]interface{}]
	RuleGroups plugin.TValue[[]interface{}]
	IpSets plugin.TValue[[]interface{}]
	Scope plugin.TValue[string]
}

// createAwsWaf creates a new instance of this resource
func createAwsWaf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWaf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWaf) MqlName() string {
	return "aws.waf"
}

func (c *mqlAwsWaf) MqlID() string {
	return c.__id
}

func (c *mqlAwsWaf) GetAcls() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Acls, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "acls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.acls()
	})
}

func (c *mqlAwsWaf) GetRuleGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RuleGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "ruleGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.ruleGroups()
	})
}

func (c *mqlAwsWaf) GetIpSets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.IpSets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "ipSets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.ipSets()
	})
}

func (c *mqlAwsWaf) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafAcl for the aws.waf.acl resource
type mqlAwsWafAcl struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafAclInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	ManagedByFirewallManager plugin.TValue[bool]
	Rules plugin.TValue[[]interface{}]
	Scope plugin.TValue[string]
}

// createAwsWafAcl creates a new instance of this resource
func createAwsWafAcl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafAcl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.acl", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafAcl) MqlName() string {
	return "aws.waf.acl"
}

func (c *mqlAwsWafAcl) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafAcl) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafAcl) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafAcl) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafAcl) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafAcl) GetManagedByFirewallManager() *plugin.TValue[bool] {
	return &c.ManagedByFirewallManager
}

func (c *mqlAwsWafAcl) GetRules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Rules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf.acl", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsWafAcl) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRulegroup for the aws.waf.rulegroup resource
type mqlAwsWafRulegroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRulegroupInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Rules plugin.TValue[[]interface{}]
	Scope plugin.TValue[string]
}

// createAwsWafRulegroup creates a new instance of this resource
func createAwsWafRulegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRulegroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rulegroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRulegroup) MqlName() string {
	return "aws.waf.rulegroup"
}

func (c *mqlAwsWafRulegroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRulegroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRulegroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRulegroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRulegroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafRulegroup) GetRules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Rules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf.rulegroup", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsWafRulegroup) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRule for the aws.waf.rule resource
type mqlAwsWafRule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Priority plugin.TValue[int64]
	Statement plugin.TValue[*mqlAwsWafRuleStatement]
	Action plugin.TValue[*mqlAwsWafRuleAction]
	BelongsTo plugin.TValue[string]
}

// createAwsWafRule creates a new instance of this resource
func createAwsWafRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRule) MqlName() string {
	return "aws.waf.rule"
}

func (c *mqlAwsWafRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRule) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRule) GetPriority() *plugin.TValue[int64] {
	return &c.Priority
}

func (c *mqlAwsWafRule) GetStatement() *plugin.TValue[*mqlAwsWafRuleStatement] {
	return &c.Statement
}

func (c *mqlAwsWafRule) GetAction() *plugin.TValue[*mqlAwsWafRuleAction] {
	return &c.Action
}

func (c *mqlAwsWafRule) GetBelongsTo() *plugin.TValue[string] {
	return &c.BelongsTo
}

// mqlAwsWafRuleAction for the aws.waf.rule.action resource
type mqlAwsWafRuleAction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleActionInternal it will be used here
	RuleName plugin.TValue[string]
	Action plugin.TValue[string]
	ResponseCode plugin.TValue[string]
}

// createAwsWafRuleAction creates a new instance of this resource
func createAwsWafRuleAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleAction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.action", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleAction) MqlName() string {
	return "aws.waf.rule.action"
}

func (c *mqlAwsWafRuleAction) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleAction) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleAction) GetAction() *plugin.TValue[string] {
	return &c.Action
}

func (c *mqlAwsWafRuleAction) GetResponseCode() *plugin.TValue[string] {
	return &c.ResponseCode
}

// mqlAwsWafRuleStatement for the aws.waf.rule.statement resource
type mqlAwsWafRuleStatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementInternal it will be used here
	Id plugin.TValue[string]
	Kind plugin.TValue[string]
	Json plugin.TValue[interface{}]
	SqliMatchStatement plugin.TValue[*mqlAwsWafRuleStatementSqlimatchstatement]
	XssMatchStatement plugin.TValue[*mqlAwsWafRuleStatementXssmatchstatement]
	ByteMatchStatement plugin.TValue[*mqlAwsWafRuleStatementBytematchstatement]
	RegexMatchStatement plugin.TValue[*mqlAwsWafRuleStatementRegexmatchstatement]
	GeoMatchStatement plugin.TValue[*mqlAwsWafRuleStatementGeomatchstatement]
	IpSetReferenceStatement plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatement]
	LabelMatchStatement plugin.TValue[*mqlAwsWafRuleStatementLabelmatchstatement]
	ManagedRuleGroupStatement plugin.TValue[*mqlAwsWafRuleStatementManagedrulegroupstatement]
	NotStatement plugin.TValue[*mqlAwsWafRuleStatementNotstatement]
	OrStatement plugin.TValue[*mqlAwsWafRuleStatementOrstatement]
	AndStatement plugin.TValue[*mqlAwsWafRuleStatementAndstatement]
	RateBasedStatement plugin.TValue[*mqlAwsWafRuleStatementRatebasedstatement]
	RegexPatternSetReferenceStatement plugin.TValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement]
	RuleGroupReferenceStatement plugin.TValue[*mqlAwsWafRuleStatementRulegroupreferencestatement]
	SizeConstraintStatement plugin.TValue[*mqlAwsWafRuleStatementSizeconstraintstatement]
}

// createAwsWafRuleStatement creates a new instance of this resource
func createAwsWafRuleStatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatement) MqlName() string {
	return "aws.waf.rule.statement"
}

func (c *mqlAwsWafRuleStatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatement) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRuleStatement) GetKind() *plugin.TValue[string] {
	return &c.Kind
}

func (c *mqlAwsWafRuleStatement) GetJson() *plugin.TValue[interface{}] {
	return &c.Json
}

func (c *mqlAwsWafRuleStatement) GetSqliMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementSqlimatchstatement] {
	return &c.SqliMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetXssMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementXssmatchstatement] {
	return &c.XssMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetByteMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementBytematchstatement] {
	return &c.ByteMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetRegexMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementRegexmatchstatement] {
	return &c.RegexMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetGeoMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementGeomatchstatement] {
	return &c.GeoMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetIpSetReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatement] {
	return &c.IpSetReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetLabelMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementLabelmatchstatement] {
	return &c.LabelMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetManagedRuleGroupStatement() *plugin.TValue[*mqlAwsWafRuleStatementManagedrulegroupstatement] {
	return &c.ManagedRuleGroupStatement
}

func (c *mqlAwsWafRuleStatement) GetNotStatement() *plugin.TValue[*mqlAwsWafRuleStatementNotstatement] {
	return &c.NotStatement
}

func (c *mqlAwsWafRuleStatement) GetOrStatement() *plugin.TValue[*mqlAwsWafRuleStatementOrstatement] {
	return &c.OrStatement
}

func (c *mqlAwsWafRuleStatement) GetAndStatement() *plugin.TValue[*mqlAwsWafRuleStatementAndstatement] {
	return &c.AndStatement
}

func (c *mqlAwsWafRuleStatement) GetRateBasedStatement() *plugin.TValue[*mqlAwsWafRuleStatementRatebasedstatement] {
	return &c.RateBasedStatement
}

func (c *mqlAwsWafRuleStatement) GetRegexPatternSetReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement] {
	return &c.RegexPatternSetReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetRuleGroupReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementRulegroupreferencestatement] {
	return &c.RuleGroupReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetSizeConstraintStatement() *plugin.TValue[*mqlAwsWafRuleStatementSizeconstraintstatement] {
	return &c.SizeConstraintStatement
}

// mqlAwsWafRuleStatementGeomatchstatement for the aws.waf.rule.statement.geomatchstatement resource
type mqlAwsWafRuleStatementGeomatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementGeomatchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	CountryCodes plugin.TValue[[]interface{}]
}

// createAwsWafRuleStatementGeomatchstatement creates a new instance of this resource
func createAwsWafRuleStatementGeomatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementGeomatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.geomatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) MqlName() string {
	return "aws.waf.rule.statement.geomatchstatement"
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetCountryCodes() *plugin.TValue[[]interface{}] {
	return &c.CountryCodes
}

// mqlAwsWafRuleStatementIpsetreferencestatement for the aws.waf.rule.statement.ipsetreferencestatement resource
type mqlAwsWafRuleStatementIpsetreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementIpsetreferencestatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Arn plugin.TValue[string]
	IpSetForwardedIPConfig plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig]
}

// createAwsWafRuleStatementIpsetreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementIpsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementIpsetreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ipsetreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.ipsetreferencestatement"
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetIpSetForwardedIPConfig() *plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig] {
	return &c.IpSetForwardedIPConfig
}

// mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig for the aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig resource
type mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfigInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	HeaderName plugin.TValue[string]
	Position plugin.TValue[string]
	FallbackBehavior plugin.TValue[string]
}

// createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig creates a new instance of this resource
func createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) MqlName() string {
	return "aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig"
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetHeaderName() *plugin.TValue[string] {
	return &c.HeaderName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetPosition() *plugin.TValue[string] {
	return &c.Position
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetFallbackBehavior() *plugin.TValue[string] {
	return &c.FallbackBehavior
}

// mqlAwsWafRuleStatementLabelmatchstatement for the aws.waf.rule.statement.labelmatchstatement resource
type mqlAwsWafRuleStatementLabelmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementLabelmatchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Key plugin.TValue[string]
	Scope plugin.TValue[string]
}

// createAwsWafRuleStatementLabelmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementLabelmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementLabelmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.labelmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.labelmatchstatement"
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRuleStatementManagedrulegroupstatement for the aws.waf.rule.statement.managedrulegroupstatement resource
type mqlAwsWafRuleStatementManagedrulegroupstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementManagedrulegroupstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name plugin.TValue[string]
	VendorName plugin.TValue[string]
}

// createAwsWafRuleStatementManagedrulegroupstatement creates a new instance of this resource
func createAwsWafRuleStatementManagedrulegroupstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementManagedrulegroupstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.managedrulegroupstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) MqlName() string {
	return "aws.waf.rule.statement.managedrulegroupstatement"
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetVendorName() *plugin.TValue[string] {
	return &c.VendorName
}

// mqlAwsWafRuleStatementAndstatement for the aws.waf.rule.statement.andstatement resource
type mqlAwsWafRuleStatementAndstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementAndstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statements plugin.TValue[[]interface{}]
}

// createAwsWafRuleStatementAndstatement creates a new instance of this resource
func createAwsWafRuleStatementAndstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementAndstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.andstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementAndstatement) MqlName() string {
	return "aws.waf.rule.statement.andstatement"
}

func (c *mqlAwsWafRuleStatementAndstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementAndstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementAndstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementAndstatement) GetStatements() *plugin.TValue[[]interface{}] {
	return &c.Statements
}

// mqlAwsWafRuleStatementNotstatement for the aws.waf.rule.statement.notstatement resource
type mqlAwsWafRuleStatementNotstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementNotstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statement plugin.TValue[*mqlAwsWafRuleStatement]
}

// createAwsWafRuleStatementNotstatement creates a new instance of this resource
func createAwsWafRuleStatementNotstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementNotstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.notstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementNotstatement) MqlName() string {
	return "aws.waf.rule.statement.notstatement"
}

func (c *mqlAwsWafRuleStatementNotstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementNotstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementNotstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementNotstatement) GetStatement() *plugin.TValue[*mqlAwsWafRuleStatement] {
	return &c.Statement
}

// mqlAwsWafRuleStatementOrstatement for the aws.waf.rule.statement.orstatement resource
type mqlAwsWafRuleStatementOrstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementOrstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statements plugin.TValue[[]interface{}]
}

// createAwsWafRuleStatementOrstatement creates a new instance of this resource
func createAwsWafRuleStatementOrstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementOrstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.orstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementOrstatement) MqlName() string {
	return "aws.waf.rule.statement.orstatement"
}

func (c *mqlAwsWafRuleStatementOrstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementOrstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementOrstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementOrstatement) GetStatements() *plugin.TValue[[]interface{}] {
	return &c.Statements
}

// mqlAwsWafRuleStatementRatebasedstatement for the aws.waf.rule.statement.ratebasedstatement resource
type mqlAwsWafRuleStatementRatebasedstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementRatebasedstatementInternal it will be used here
}

// createAwsWafRuleStatementRatebasedstatement creates a new instance of this resource
func createAwsWafRuleStatementRatebasedstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRatebasedstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ratebasedstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRatebasedstatement) MqlName() string {
	return "aws.waf.rule.statement.ratebasedstatement"
}

func (c *mqlAwsWafRuleStatementRatebasedstatement) MqlID() string {
	return c.__id
}

// mqlAwsWafRuleStatementRegexpatternsetreferencestatement for the aws.waf.rule.statement.regexpatternsetreferencestatement resource
type mqlAwsWafRuleStatementRegexpatternsetreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementRegexpatternsetreferencestatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Arn plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementRegexpatternsetreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementRegexpatternsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRegexpatternsetreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.regexpatternsetreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.regexpatternsetreferencestatement"
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementRulegroupreferencestatement for the aws.waf.rule.statement.rulegroupreferencestatement resource
type mqlAwsWafRuleStatementRulegroupreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementRulegroupreferencestatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Arn plugin.TValue[string]
	ExcludeRules plugin.TValue[[]interface{}]
}

// createAwsWafRuleStatementRulegroupreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementRulegroupreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRulegroupreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.rulegroupreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.rulegroupreferencestatement"
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetExcludeRules() *plugin.TValue[[]interface{}] {
	return &c.ExcludeRules
}

// mqlAwsWafRuleStatementSizeconstraintstatement for the aws.waf.rule.statement.sizeconstraintstatement resource
type mqlAwsWafRuleStatementSizeconstraintstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementSizeconstraintstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Size plugin.TValue[int64]
	ComparisonOperator plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementSizeconstraintstatement creates a new instance of this resource
func createAwsWafRuleStatementSizeconstraintstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementSizeconstraintstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.sizeconstraintstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) MqlName() string {
	return "aws.waf.rule.statement.sizeconstraintstatement"
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetComparisonOperator() *plugin.TValue[string] {
	return &c.ComparisonOperator
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementRegexmatchstatement for the aws.waf.rule.statement.regexmatchstatement resource
type mqlAwsWafRuleStatementRegexmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementRegexmatchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	RegexString plugin.TValue[string]
}

// createAwsWafRuleStatementRegexmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementRegexmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRegexmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.regexmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.regexmatchstatement"
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetRegexString() *plugin.TValue[string] {
	return &c.RegexString
}

// mqlAwsWafRuleStatementBytematchstatement for the aws.waf.rule.statement.bytematchstatement resource
type mqlAwsWafRuleStatementBytematchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementBytematchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	SearchString plugin.TValue[string]
}

// createAwsWafRuleStatementBytematchstatement creates a new instance of this resource
func createAwsWafRuleStatementBytematchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementBytematchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.bytematchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementBytematchstatement) MqlName() string {
	return "aws.waf.rule.statement.bytematchstatement"
}

func (c *mqlAwsWafRuleStatementBytematchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetSearchString() *plugin.TValue[string] {
	return &c.SearchString
}

// mqlAwsWafRuleFieldtomatch for the aws.waf.rule.fieldtomatch resource
type mqlAwsWafRuleFieldtomatch struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchInternal it will be used here
	Target plugin.TValue[string]
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Method plugin.TValue[bool]
	UriPath plugin.TValue[bool]
	QueryString plugin.TValue[bool]
	AllQueryArguments plugin.TValue[bool]
	Body plugin.TValue[*mqlAwsWafRuleFieldtomatchBody]
	Cookie plugin.TValue[*mqlAwsWafRuleFieldtomatchCookie]
	SingleHeader plugin.TValue[*mqlAwsWafRuleFieldtomatchSingleheader]
	HeaderOrder plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaderorder]
	Headers plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaders]
	Ja3Fingerprint plugin.TValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint]
	JsonBody plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbody]
	SingleQueryArgument plugin.TValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument]
}

// createAwsWafRuleFieldtomatch creates a new instance of this resource
func createAwsWafRuleFieldtomatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatch) MqlName() string {
	return "aws.waf.rule.fieldtomatch"
}

func (c *mqlAwsWafRuleFieldtomatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatch) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlAwsWafRuleFieldtomatch) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatch) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatch) GetMethod() *plugin.TValue[bool] {
	return &c.Method
}

func (c *mqlAwsWafRuleFieldtomatch) GetUriPath() *plugin.TValue[bool] {
	return &c.UriPath
}

func (c *mqlAwsWafRuleFieldtomatch) GetQueryString() *plugin.TValue[bool] {
	return &c.QueryString
}

func (c *mqlAwsWafRuleFieldtomatch) GetAllQueryArguments() *plugin.TValue[bool] {
	return &c.AllQueryArguments
}

func (c *mqlAwsWafRuleFieldtomatch) GetBody() *plugin.TValue[*mqlAwsWafRuleFieldtomatchBody] {
	return &c.Body
}

func (c *mqlAwsWafRuleFieldtomatch) GetCookie() *plugin.TValue[*mqlAwsWafRuleFieldtomatchCookie] {
	return &c.Cookie
}

func (c *mqlAwsWafRuleFieldtomatch) GetSingleHeader() *plugin.TValue[*mqlAwsWafRuleFieldtomatchSingleheader] {
	return &c.SingleHeader
}

func (c *mqlAwsWafRuleFieldtomatch) GetHeaderOrder() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaderorder] {
	return &c.HeaderOrder
}

func (c *mqlAwsWafRuleFieldtomatch) GetHeaders() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaders] {
	return &c.Headers
}

func (c *mqlAwsWafRuleFieldtomatch) GetJa3Fingerprint() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint] {
	return &c.Ja3Fingerprint
}

func (c *mqlAwsWafRuleFieldtomatch) GetJsonBody() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbody] {
	return &c.JsonBody
}

func (c *mqlAwsWafRuleFieldtomatch) GetSingleQueryArgument() *plugin.TValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument] {
	return &c.SingleQueryArgument
}

// mqlAwsWafRuleFieldtomatchBody for the aws.waf.rule.fieldtomatch.body resource
type mqlAwsWafRuleFieldtomatchBody struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchBodyInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchBody creates a new instance of this resource
func createAwsWafRuleFieldtomatchBody(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchBody{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.body", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchBody) MqlName() string {
	return "aws.waf.rule.fieldtomatch.body"
}

func (c *mqlAwsWafRuleFieldtomatchBody) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchCookie for the aws.waf.rule.fieldtomatch.cookie resource
type mqlAwsWafRuleFieldtomatchCookie struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchCookieInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchCookie creates a new instance of this resource
func createAwsWafRuleFieldtomatchCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchCookie{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.cookie", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchCookie) MqlName() string {
	return "aws.waf.rule.fieldtomatch.cookie"
}

func (c *mqlAwsWafRuleFieldtomatchCookie) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchHeaderorder for the aws.waf.rule.fieldtomatch.headerorder resource
type mqlAwsWafRuleFieldtomatchHeaderorder struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeaderorderInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchHeaderorder creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeaderorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeaderorder{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headerorder", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headerorder"
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchSingleheader for the aws.waf.rule.fieldtomatch.singleheader resource
type mqlAwsWafRuleFieldtomatchSingleheader struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchSingleheaderInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchSingleheader creates a new instance of this resource
func createAwsWafRuleFieldtomatchSingleheader(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchSingleheader{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.singleheader", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) MqlName() string {
	return "aws.waf.rule.fieldtomatch.singleheader"
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsWafRuleFieldtomatchSinglequeryargument for the aws.waf.rule.fieldtomatch.singlequeryargument resource
type mqlAwsWafRuleFieldtomatchSinglequeryargument struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchSinglequeryargumentInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchSinglequeryargument creates a new instance of this resource
func createAwsWafRuleFieldtomatchSinglequeryargument(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchSinglequeryargument{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.singlequeryargument", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) MqlName() string {
	return "aws.waf.rule.fieldtomatch.singlequeryargument"
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsWafRuleFieldtomatchJa3fingerprint for the aws.waf.rule.fieldtomatch.ja3fingerprint resource
type mqlAwsWafRuleFieldtomatchJa3fingerprint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchJa3fingerprintInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	FallbackBehavior plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchJa3fingerprint creates a new instance of this resource
func createAwsWafRuleFieldtomatchJa3fingerprint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJa3fingerprint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.ja3fingerprint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) MqlName() string {
	return "aws.waf.rule.fieldtomatch.ja3fingerprint"
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetFallbackBehavior() *plugin.TValue[string] {
	return &c.FallbackBehavior
}

// mqlAwsWafRuleFieldtomatchJsonbody for the aws.waf.rule.fieldtomatch.jsonbody resource
type mqlAwsWafRuleFieldtomatchJsonbody struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchJsonbodyInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
	MatchScope plugin.TValue[string]
	InvalidFallbackBehavior plugin.TValue[string]
	MatchPattern plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern]
}

// createAwsWafRuleFieldtomatchJsonbody creates a new instance of this resource
func createAwsWafRuleFieldtomatchJsonbody(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJsonbody{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.jsonbody", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) MqlName() string {
	return "aws.waf.rule.fieldtomatch.jsonbody"
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetMatchScope() *plugin.TValue[string] {
	return &c.MatchScope
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetInvalidFallbackBehavior() *plugin.TValue[string] {
	return &c.InvalidFallbackBehavior
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetMatchPattern() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern] {
	return &c.MatchPattern
}

// mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern for the aws.waf.rule.fieldtomatch.jsonbody.matchpattern resource
type mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchJsonbodyMatchpatternInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	All plugin.TValue[bool]
	IncludePaths plugin.TValue[[]interface{}]
}

// createAwsWafRuleFieldtomatchJsonbodyMatchpattern creates a new instance of this resource
func createAwsWafRuleFieldtomatchJsonbodyMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.jsonbody.matchpattern", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) MqlName() string {
	return "aws.waf.rule.fieldtomatch.jsonbody.matchpattern"
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetAll() *plugin.TValue[bool] {
	return &c.All
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetIncludePaths() *plugin.TValue[[]interface{}] {
	return &c.IncludePaths
}

// mqlAwsWafRuleFieldtomatchHeaders for the aws.waf.rule.fieldtomatch.headers resource
type mqlAwsWafRuleFieldtomatchHeaders struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeadersInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	MatchScope plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
	MatchPattern plugin.TValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern]
}

// createAwsWafRuleFieldtomatchHeaders creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeaders(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeaders{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headers", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headers"
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetMatchScope() *plugin.TValue[string] {
	return &c.MatchScope
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetMatchPattern() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern] {
	return &c.MatchPattern
}

// mqlAwsWafRuleFieldtomatchHeadersMatchpattern for the aws.waf.rule.fieldtomatch.headers.matchpattern resource
type mqlAwsWafRuleFieldtomatchHeadersMatchpattern struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeadersMatchpatternInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	All plugin.TValue[bool]
	IncludeHeaders plugin.TValue[[]interface{}]
	ExcludeHeaders plugin.TValue[[]interface{}]
}

// createAwsWafRuleFieldtomatchHeadersMatchpattern creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeadersMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeadersMatchpattern{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headers.matchpattern", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headers.matchpattern"
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetAll() *plugin.TValue[bool] {
	return &c.All
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetIncludeHeaders() *plugin.TValue[[]interface{}] {
	return &c.IncludeHeaders
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetExcludeHeaders() *plugin.TValue[[]interface{}] {
	return &c.ExcludeHeaders
}

// mqlAwsWafRuleStatementXssmatchstatement for the aws.waf.rule.statement.xssmatchstatement resource
type mqlAwsWafRuleStatementXssmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementXssmatchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementXssmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementXssmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementXssmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.xssmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.xssmatchstatement"
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementSqlimatchstatement for the aws.waf.rule.statement.sqlimatchstatement resource
type mqlAwsWafRuleStatementSqlimatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafRuleStatementSqlimatchstatementInternal it will be used here
	RuleName plugin.TValue[string]
	StatementID plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	SensitivityLevel plugin.TValue[string]
}

// createAwsWafRuleStatementSqlimatchstatement creates a new instance of this resource
func createAwsWafRuleStatementSqlimatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementSqlimatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.sqlimatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) MqlName() string {
	return "aws.waf.rule.statement.sqlimatchstatement"
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetSensitivityLevel() *plugin.TValue[string] {
	return &c.SensitivityLevel
}

// mqlAwsWafIpset for the aws.waf.ipset resource
type mqlAwsWafIpset struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsWafIpsetInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Scope plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	AddressType plugin.TValue[string]
	Addresses plugin.TValue[interface{}]
}

// createAwsWafIpset creates a new instance of this resource
func createAwsWafIpset(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafIpset{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.ipset", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafIpset) MqlName() string {
	return "aws.waf.ipset"
}

func (c *mqlAwsWafIpset) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafIpset) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafIpset) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafIpset) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

func (c *mqlAwsWafIpset) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafIpset) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafIpset) GetAddressType() *plugin.TValue[string] {
	return &c.AddressType
}

func (c *mqlAwsWafIpset) GetAddresses() *plugin.TValue[interface{}] {
	return &c.Addresses
}

// mqlAwsEfs for the aws.efs resource
type mqlAwsEfs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEfsInternal it will be used here
	Filesystems plugin.TValue[[]interface{}]
}

// createAwsEfs creates a new instance of this resource
func createAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfs) MqlName() string {
	return "aws.efs"
}

func (c *mqlAwsEfs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfs) GetFilesystems() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Filesystems, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs", c.__id, "filesystems")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.filesystems()
	})
}

// mqlAwsEfsFilesystem for the aws.efs.filesystem resource
type mqlAwsEfsFilesystem struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEfsFilesystemInternal
	Name plugin.TValue[string]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	BackupPolicy plugin.TValue[interface{}]
	Region plugin.TValue[string]
	AvailabilityZone plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsEfsFilesystem creates a new instance of this resource
func createAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsFilesystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.filesystem", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsFilesystem) MqlName() string {
	return "aws.efs.filesystem"
}

func (c *mqlAwsEfsFilesystem) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsFilesystem) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEfsFilesystem) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEfsFilesystem) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEfsFilesystem) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEfsFilesystem) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsEfsFilesystem) GetBackupPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.BackupPolicy, func() (interface{}, error) {
		return c.backupPolicy()
	})
}

func (c *mqlAwsEfsFilesystem) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEfsFilesystem) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEfsFilesystem) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEfsFilesystem) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsKms for the aws.kms resource
type mqlAwsKms struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsInternal it will be used here
	Keys plugin.TValue[[]interface{}]
}

// createAwsKms creates a new instance of this resource
func createAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKms) MqlName() string {
	return "aws.kms"
}

func (c *mqlAwsKms) MqlID() string {
	return c.__id
}

func (c *mqlAwsKms) GetKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Keys, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.kms", c.__id, "keys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.keys()
	})
}

// mqlAwsKmsKey for the aws.kms.key resource
type mqlAwsKmsKey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsKeyInternal it will be used here
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	KeyRotationEnabled plugin.TValue[bool]
	Metadata plugin.TValue[interface{}]
}

// createAwsKmsKey creates a new instance of this resource
func createAwsKmsKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKmsKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms.key", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKmsKey) MqlName() string {
	return "aws.kms.key"
}

func (c *mqlAwsKmsKey) MqlID() string {
	return c.__id
}

func (c *mqlAwsKmsKey) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsKmsKey) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsKmsKey) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsKmsKey) GetKeyRotationEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.KeyRotationEnabled, func() (bool, error) {
		return c.keyRotationEnabled()
	})
}

func (c *mqlAwsKmsKey) GetMetadata() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Metadata, func() (interface{}, error) {
		return c.metadata()
	})
}

// mqlAwsIam for the aws.iam resource
type mqlAwsIam struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamInternal it will be used here
	Users plugin.TValue[[]interface{}]
	Roles plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	CredentialReport plugin.TValue[[]interface{}]
	AccountPasswordPolicy plugin.TValue[interface{}]
	AccountSummary plugin.TValue[map[string]interface{}]
	VirtualMfaDevices plugin.TValue[[]interface{}]
	ServerCertificates plugin.TValue[[]interface{}]
}

// createAwsIam creates a new instance of this resource
func createAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIam{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIam) MqlName() string {
	return "aws.iam"
}

func (c *mqlAwsIam) MqlID() string {
	return c.__id
}

func (c *mqlAwsIam) GetUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Users, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "users")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.users()
	})
}

func (c *mqlAwsIam) GetRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Roles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "roles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.roles()
	})
}

func (c *mqlAwsIam) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

func (c *mqlAwsIam) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "policies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.policies()
	})
}

func (c *mqlAwsIam) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIam) GetCredentialReport() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CredentialReport, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "credentialReport")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.credentialReport()
	})
}

func (c *mqlAwsIam) GetAccountPasswordPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.AccountPasswordPolicy, func() (interface{}, error) {
		return c.accountPasswordPolicy()
	})
}

func (c *mqlAwsIam) GetAccountSummary() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.AccountSummary, func() (map[string]interface{}, error) {
		return c.accountSummary()
	})
}

func (c *mqlAwsIam) GetVirtualMfaDevices() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.VirtualMfaDevices, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "virtualMfaDevices")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.virtualMfaDevices()
	})
}

func (c *mqlAwsIam) GetServerCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ServerCertificates, func() ([]interface{}, error) {
		return c.serverCertificates()
	})
}

// mqlAwsIamUsercredentialreportentry for the aws.iam.usercredentialreportentry resource
type mqlAwsIamUsercredentialreportentry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUsercredentialreportentryInternal it will be used here
	Properties plugin.TValue[map[string]interface{}]
	Arn plugin.TValue[string]
	AccessKey1Active plugin.TValue[bool]
	AccessKey1LastRotated plugin.TValue[*time.Time]
	AccessKey1LastUsedDate plugin.TValue[*time.Time]
	AccessKey1LastUsedRegion plugin.TValue[string]
	AccessKey1LastUsedService plugin.TValue[string]
	AccessKey2Active plugin.TValue[bool]
	AccessKey2LastRotated plugin.TValue[*time.Time]
	AccessKey2LastUsedDate plugin.TValue[*time.Time]
	AccessKey2LastUsedRegion plugin.TValue[string]
	AccessKey2LastUsedService plugin.TValue[string]
	Cert1Active plugin.TValue[bool]
	Cert1LastRotated plugin.TValue[*time.Time]
	Cert2Active plugin.TValue[bool]
	Cert2LastRotated plugin.TValue[*time.Time]
	MfaActive plugin.TValue[bool]
	PasswordEnabled plugin.TValue[bool]
	PasswordLastChanged plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	PasswordNextRotation plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
	UserCreationTime plugin.TValue[*time.Time]
}

// createAwsIamUsercredentialreportentry creates a new instance of this resource
func createAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUsercredentialreportentry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.usercredentialreportentry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUsercredentialreportentry) MqlName() string {
	return "aws.iam.usercredentialreportentry"
}

func (c *mqlAwsIamUsercredentialreportentry) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUsercredentialreportentry) GetProperties() *plugin.TValue[map[string]interface{}] {
	return &c.Properties
}

func (c *mqlAwsIamUsercredentialreportentry) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey1Active, func() (bool, error) {
		return c.accessKey1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastRotated, func() (*time.Time, error) {
		return c.accessKey1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastUsedDate, func() (*time.Time, error) {
		return c.accessKey1LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedRegion, func() (string, error) {
		return c.accessKey1LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedService, func() (string, error) {
		return c.accessKey1LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey2Active, func() (bool, error) {
		return c.accessKey2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastRotated, func() (*time.Time, error) {
		return c.accessKey2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastUsedDate, func() (*time.Time, error) {
		return c.accessKey2LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedRegion, func() (string, error) {
		return c.accessKey2LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedService, func() (string, error) {
		return c.accessKey2LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert1Active, func() (bool, error) {
		return c.cert1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert1LastRotated, func() (*time.Time, error) {
		return c.cert1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert2Active, func() (bool, error) {
		return c.cert2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert2LastRotated, func() (*time.Time, error) {
		return c.cert2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetMfaActive() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.MfaActive, func() (bool, error) {
		return c.mfaActive()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.PasswordEnabled, func() (bool, error) {
		return c.passwordEnabled()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastChanged() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastChanged, func() (*time.Time, error) {
		return c.passwordLastChanged()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastUsed, func() (*time.Time, error) {
		return c.passwordLastUsed()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordNextRotation() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordNextRotation, func() (*time.Time, error) {
		return c.passwordNextRotation()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.usercredentialreportentry", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUserCreationTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UserCreationTime, func() (*time.Time, error) {
		return c.userCreationTime()
	})
}

// mqlAwsIamUser for the aws.iam.user resource
type mqlAwsIamUser struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUserInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	AccessKeys plugin.TValue[[]interface{}]
	LoginProfile plugin.TValue[*mqlAwsIamLoginProfile]
}

// createAwsIamUser creates a new instance of this resource
func createAwsIamUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUser) MqlName() string {
	return "aws.iam.user"
}

func (c *mqlAwsIamUser) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUser) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamUser) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamUser) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamUser) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return &c.PasswordLastUsed
}

func (c *mqlAwsIamUser) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamUser) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		return c.policies()
	})
}

func (c *mqlAwsIamUser) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIamUser) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		return c.groups()
	})
}

func (c *mqlAwsIamUser) GetAccessKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AccessKeys, func() ([]interface{}, error) {
		return c.accessKeys()
	})
}

func (c *mqlAwsIamUser) GetLoginProfile() *plugin.TValue[*mqlAwsIamLoginProfile] {
	return plugin.GetOrCompute[*mqlAwsIamLoginProfile](&c.LoginProfile, func() (*mqlAwsIamLoginProfile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "loginProfile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamLoginProfile), nil
			}
		}

		return c.loginProfile()
	})
}

// mqlAwsIamLoginProfile for the aws.iam.loginProfile resource
type mqlAwsIamLoginProfile struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamLoginProfileInternal it will be used here
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsIamLoginProfile creates a new instance of this resource
func createAwsIamLoginProfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamLoginProfile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.loginProfile", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamLoginProfile) MqlName() string {
	return "aws.iam.loginProfile"
}

func (c *mqlAwsIamLoginProfile) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamLoginProfile) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIamPolicy for the aws.iam.policy resource
type mqlAwsIamPolicy struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsIamPolicyInternal
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	PolicyId plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	IsAttachable plugin.TValue[bool]
	AttachmentCount plugin.TValue[int64]
	CreateDate plugin.TValue[*time.Time]
	UpdateDate plugin.TValue[*time.Time]
	Scope plugin.TValue[string]
	Versions plugin.TValue[[]interface{}]
	DefaultVersion plugin.TValue[*mqlAwsIamPolicyversion]
	AttachedUsers plugin.TValue[[]interface{}]
	AttachedRoles plugin.TValue[[]interface{}]
	AttachedGroups plugin.TValue[[]interface{}]
}

// createAwsIamPolicy creates a new instance of this resource
func createAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicy) MqlName() string {
	return "aws.iam.policy"
}

func (c *mqlAwsIamPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicy) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicy) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamPolicy) GetPolicyId() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.PolicyId, func() (string, error) {
		return c.policyId()
	})
}

func (c *mqlAwsIamPolicy) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlAwsIamPolicy) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsIamPolicy) GetIsAttachable() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachable, func() (bool, error) {
		return c.isAttachable()
	})
}

func (c *mqlAwsIamPolicy) GetAttachmentCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.AttachmentCount, func() (int64, error) {
		return c.attachmentCount()
	})
}

func (c *mqlAwsIamPolicy) GetCreateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreateDate, func() (*time.Time, error) {
		return c.createDate()
	})
}

func (c *mqlAwsIamPolicy) GetUpdateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UpdateDate, func() (*time.Time, error) {
		return c.updateDate()
	})
}

func (c *mqlAwsIamPolicy) GetScope() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Scope, func() (string, error) {
		return c.scope()
	})
}

func (c *mqlAwsIamPolicy) GetVersions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Versions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "versions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.versions()
	})
}

func (c *mqlAwsIamPolicy) GetDefaultVersion() *plugin.TValue[*mqlAwsIamPolicyversion] {
	return plugin.GetOrCompute[*mqlAwsIamPolicyversion](&c.DefaultVersion, func() (*mqlAwsIamPolicyversion, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "defaultVersion")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamPolicyversion), nil
			}
		}

		return c.defaultVersion()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedUsers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedUsers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedUsers()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedRoles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedRoles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedRoles()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedGroups()
	})
}

// mqlAwsIamPolicyversion for the aws.iam.policyversion resource
type mqlAwsIamPolicyversion struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamPolicyversionInternal it will be used here
	Arn plugin.TValue[string]
	VersionId plugin.TValue[string]
	IsDefaultVersion plugin.TValue[bool]
	Document plugin.TValue[interface{}]
	CreateDate plugin.TValue[*time.Time]
}

// createAwsIamPolicyversion creates a new instance of this resource
func createAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicyversion{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policyversion", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicyversion) MqlName() string {
	return "aws.iam.policyversion"
}

func (c *mqlAwsIamPolicyversion) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicyversion) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicyversion) GetVersionId() *plugin.TValue[string] {
	return &c.VersionId
}

func (c *mqlAwsIamPolicyversion) GetIsDefaultVersion() *plugin.TValue[bool] {
	return &c.IsDefaultVersion
}

func (c *mqlAwsIamPolicyversion) GetDocument() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Document, func() (interface{}, error) {
		return c.document()
	})
}

func (c *mqlAwsIamPolicyversion) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

// mqlAwsIamRole for the aws.iam.role resource
type mqlAwsIamRole struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamRoleInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreateDate plugin.TValue[*time.Time]
	AssumeRolePolicyDocument plugin.TValue[interface{}]
}

// createAwsIamRole creates a new instance of this resource
func createAwsIamRole(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamRole{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.role", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamRole) MqlName() string {
	return "aws.iam.role"
}

func (c *mqlAwsIamRole) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamRole) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamRole) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamRole) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamRole) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsIamRole) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamRole) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamRole) GetAssumeRolePolicyDocument() *plugin.TValue[interface{}] {
	return &c.AssumeRolePolicyDocument
}

// mqlAwsIamGroup for the aws.iam.group resource
type mqlAwsIamGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamGroupInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	Usernames plugin.TValue[[]interface{}]
}

// createAwsIamGroup creates a new instance of this resource
func createAwsIamGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamGroup) MqlName() string {
	return "aws.iam.group"
}

func (c *mqlAwsIamGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamGroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamGroup) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamGroup) GetUsernames() *plugin.TValue[[]interface{}] {
	return &c.Usernames
}

// mqlAwsIamVirtualmfadevice for the aws.iam.virtualmfadevice resource
type mqlAwsIamVirtualmfadevice struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsIamVirtualmfadeviceInternal
	SerialNumber plugin.TValue[string]
	EnableDate plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
}

// createAwsIamVirtualmfadevice creates a new instance of this resource
func createAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamVirtualmfadevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.virtualmfadevice", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamVirtualmfadevice) MqlName() string {
	return "aws.iam.virtualmfadevice"
}

func (c *mqlAwsIamVirtualmfadevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamVirtualmfadevice) GetSerialNumber() *plugin.TValue[string] {
	return &c.SerialNumber
}

func (c *mqlAwsIamVirtualmfadevice) GetEnableDate() *plugin.TValue[*time.Time] {
	return &c.EnableDate
}

func (c *mqlAwsIamVirtualmfadevice) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.virtualmfadevice", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

// mqlAwsIamAccessAnalyzer for the aws.iam.accessAnalyzer resource
type mqlAwsIamAccessAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamAccessAnalyzerInternal it will be used here
	Analyzers plugin.TValue[[]interface{}]
	Findings plugin.TValue[[]interface{}]
}

// createAwsIamAccessAnalyzer creates a new instance of this resource
func createAwsIamAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessAnalyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessAnalyzer) MqlName() string {
	return "aws.iam.accessAnalyzer"
}

func (c *mqlAwsIamAccessAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessAnalyzer) GetAnalyzers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Analyzers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.accessAnalyzer", c.__id, "analyzers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.analyzers()
	})
}

func (c *mqlAwsIamAccessAnalyzer) GetFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Findings, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.accessAnalyzer", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.findings()
	})
}

// mqlAwsIamAccessanalyzerAnalyzer for the aws.iam.accessanalyzer.analyzer resource
type mqlAwsIamAccessanalyzerAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamAccessanalyzerAnalyzerInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Type plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	LastResourceAnalyzed plugin.TValue[string]
	LastResourceAnalyzedAt plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsIamAccessanalyzerAnalyzer creates a new instance of this resource
func createAwsIamAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessanalyzerAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessanalyzer.analyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) MqlName() string {
	return "aws.iam.accessanalyzer.analyzer"
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetLastResourceAnalyzed() *plugin.TValue[string] {
	return &c.LastResourceAnalyzed
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetLastResourceAnalyzedAt() *plugin.TValue[*time.Time] {
	return &c.LastResourceAnalyzedAt
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIamAccessanalyzerFinding for the aws.iam.accessanalyzer.finding resource
type mqlAwsIamAccessanalyzerFinding struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamAccessanalyzerFindingInternal it will be used here
	Id plugin.TValue[string]
	Error plugin.TValue[string]
	ResourceArn plugin.TValue[string]
	ResourceOwnerAccount plugin.TValue[string]
	ResourceType plugin.TValue[string]
	Type plugin.TValue[string]
	Status plugin.TValue[string]
	AnalyzedAt plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
	Region plugin.TValue[string]
	AnalyzerArn plugin.TValue[string]
}

// createAwsIamAccessanalyzerFinding creates a new instance of this resource
func createAwsIamAccessanalyzerFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessanalyzerFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessanalyzer.finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessanalyzerFinding) MqlName() string {
	return "aws.iam.accessanalyzer.finding"
}

func (c *mqlAwsIamAccessanalyzerFinding) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessanalyzerFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamAccessanalyzerFinding) GetError() *plugin.TValue[string] {
	return &c.Error
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceArn() *plugin.TValue[string] {
	return &c.ResourceArn
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceOwnerAccount() *plugin.TValue[string] {
	return &c.ResourceOwnerAccount
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsIamAccessanalyzerFinding) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsIamAccessanalyzerFinding) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsIamAccessanalyzerFinding) GetAnalyzedAt() *plugin.TValue[*time.Time] {
	return &c.AnalyzedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsIamAccessanalyzerFinding) GetAnalyzerArn() *plugin.TValue[string] {
	return &c.AnalyzerArn
}

// mqlAwsSagemaker for the aws.sagemaker resource
type mqlAwsSagemaker struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerInternal it will be used here
	Endpoints plugin.TValue[[]interface{}]
	NotebookInstances plugin.TValue[[]interface{}]
}

// createAwsSagemaker creates a new instance of this resource
func createAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemaker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemaker) MqlName() string {
	return "aws.sagemaker"
}

func (c *mqlAwsSagemaker) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemaker) GetEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Endpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsSagemaker) GetNotebookInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NotebookInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "notebookInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.notebookInstances()
	})
}

// mqlAwsSagemakerNotebookinstance for the aws.sagemaker.notebookinstance resource
type mqlAwsSagemakerNotebookinstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerNotebookinstanceInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Details plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerNotebookinstance creates a new instance of this resource
func createAwsSagemakerNotebookinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstance) MqlName() string {
	return "aws.sagemaker.notebookinstance"
}

func (c *mqlAwsSagemakerNotebookinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerNotebookinstance) GetDetails() *plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails] {
	return plugin.GetOrCompute[*mqlAwsSagemakerNotebookinstanceDetails](&c.Details, func() (*mqlAwsSagemakerNotebookinstanceDetails, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance", c.__id, "details")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSagemakerNotebookinstanceDetails), nil
			}
		}

		return c.details()
	})
}

func (c *mqlAwsSagemakerNotebookinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerNotebookinstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSagemakerNotebookinstanceDetails for the aws.sagemaker.notebookinstance.details resource
type mqlAwsSagemakerNotebookinstanceDetails struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsSagemakerNotebookinstanceDetailsInternal
	Arn plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	DirectInternetAccess plugin.TValue[string]
}

// createAwsSagemakerNotebookinstanceDetails creates a new instance of this resource
func createAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstanceDetails{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance.details", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlName() string {
	return "aws.sagemaker.notebookinstance.details"
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance.details", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetDirectInternetAccess() *plugin.TValue[string] {
	return &c.DirectInternetAccess
}

// mqlAwsSagemakerEndpoint for the aws.sagemaker.endpoint resource
type mqlAwsSagemakerEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerEndpointInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Config plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerEndpoint creates a new instance of this resource
func createAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerEndpoint) MqlName() string {
	return "aws.sagemaker.endpoint"
}

func (c *mqlAwsSagemakerEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerEndpoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerEndpoint) GetConfig() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Config, func() (interface{}, error) {
		return c.config()
	})
}

func (c *mqlAwsSagemakerEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerEndpoint) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSns for the aws.sns resource
type mqlAwsSns struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsInternal it will be used here
	Topics plugin.TValue[[]interface{}]
}

// createAwsSns creates a new instance of this resource
func createAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSns{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSns) MqlName() string {
	return "aws.sns"
}

func (c *mqlAwsSns) MqlID() string {
	return c.__id
}

func (c *mqlAwsSns) GetTopics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Topics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns", c.__id, "topics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.topics()
	})
}

// mqlAwsSnsTopic for the aws.sns.topic resource
type mqlAwsSnsTopic struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsTopicInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Subscriptions plugin.TValue[[]interface{}]
	Attributes plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSnsTopic creates a new instance of this resource
func createAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsTopic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.topic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsTopic) MqlName() string {
	return "aws.sns.topic"
}

func (c *mqlAwsSnsTopic) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsTopic) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsTopic) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSnsTopic) GetSubscriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subscriptions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns.topic", c.__id, "subscriptions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subscriptions()
	})
}

func (c *mqlAwsSnsTopic) GetAttributes() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Attributes, func() (interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsSnsTopic) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsSnsSubscription for the aws.sns.subscription resource
type mqlAwsSnsSubscription struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsSubscriptionInternal it will be used here
	Arn plugin.TValue[string]
	Protocol plugin.TValue[string]
}

// createAwsSnsSubscription creates a new instance of this resource
func createAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsSubscription{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.subscription", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsSubscription) MqlName() string {
	return "aws.sns.subscription"
}

func (c *mqlAwsSnsSubscription) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsSubscription) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsSubscription) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsEs for the aws.es resource
type mqlAwsEs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsInternal it will be used here
	Domains plugin.TValue[[]interface{}]
}

// createAwsEs creates a new instance of this resource
func createAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEs) MqlName() string {
	return "aws.es"
}

func (c *mqlAwsEs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEs) GetDomains() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Domains, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.es", c.__id, "domains")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.domains()
	})
}

// mqlAwsEsDomain for the aws.es.domain resource
type mqlAwsEsDomain struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsDomainInternal it will be used here
	Arn plugin.TValue[string]
	EncryptionAtRestEnabled plugin.TValue[bool]
	NodeToNodeEncryptionEnabled plugin.TValue[bool]
	Name plugin.TValue[string]
	Endpoint plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	ElasticsearchVersion plugin.TValue[string]
	DomainId plugin.TValue[string]
	DomainName plugin.TValue[string]
}

// createAwsEsDomain creates a new instance of this resource
func createAwsEsDomain(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEsDomain{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es.domain", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEsDomain) MqlName() string {
	return "aws.es.domain"
}

func (c *mqlAwsEsDomain) MqlID() string {
	return c.__id
}

func (c *mqlAwsEsDomain) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEsDomain) GetEncryptionAtRestEnabled() *plugin.TValue[bool] {
	return &c.EncryptionAtRestEnabled
}

func (c *mqlAwsEsDomain) GetNodeToNodeEncryptionEnabled() *plugin.TValue[bool] {
	return &c.NodeToNodeEncryptionEnabled
}

func (c *mqlAwsEsDomain) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEsDomain) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEsDomain) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEsDomain) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEsDomain) GetElasticsearchVersion() *plugin.TValue[string] {
	return &c.ElasticsearchVersion
}

func (c *mqlAwsEsDomain) GetDomainId() *plugin.TValue[string] {
	return &c.DomainId
}

func (c *mqlAwsEsDomain) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

// mqlAwsAcm for the aws.acm resource
type mqlAwsAcm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmInternal it will be used here
	Certificates plugin.TValue[[]interface{}]
}

// createAwsAcm creates a new instance of this resource
func createAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcm) MqlName() string {
	return "aws.acm"
}

func (c *mqlAwsAcm) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcm) GetCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Certificates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm", c.__id, "certificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.certificates()
	})
}

// mqlAwsAcmCertificate for the aws.acm.certificate resource
type mqlAwsAcmCertificate struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmCertificateInternal it will be used here
	Arn plugin.TValue[string]
	NotBefore plugin.TValue[*time.Time]
	NotAfter plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
	DomainName plugin.TValue[string]
	Status plugin.TValue[string]
	Subject plugin.TValue[string]
	Certificate plugin.TValue[plugin.Resource]
	Tags plugin.TValue[map[string]interface{}]
	KeyAlgorithm plugin.TValue[string]
	Serial plugin.TValue[string]
	Source plugin.TValue[string]
	Issuer plugin.TValue[string]
	IssuedAt plugin.TValue[*time.Time]
	ImportedAt plugin.TValue[*time.Time]
}

// createAwsAcmCertificate creates a new instance of this resource
func createAwsAcmCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcmCertificate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm.certificate", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcmCertificate) MqlName() string {
	return "aws.acm.certificate"
}

func (c *mqlAwsAcmCertificate) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcmCertificate) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAcmCertificate) GetNotBefore() *plugin.TValue[*time.Time] {
	return &c.NotBefore
}

func (c *mqlAwsAcmCertificate) GetNotAfter() *plugin.TValue[*time.Time] {
	return &c.NotAfter
}

func (c *mqlAwsAcmCertificate) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAcmCertificate) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsAcmCertificate) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAcmCertificate) GetSubject() *plugin.TValue[string] {
	return &c.Subject
}

func (c *mqlAwsAcmCertificate) GetCertificate() *plugin.TValue[plugin.Resource] {
	return plugin.GetOrCompute[plugin.Resource](&c.Certificate, func() (plugin.Resource, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm.certificate", c.__id, "certificate")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(plugin.Resource), nil
			}
		}

		return c.certificate()
	})
}

func (c *mqlAwsAcmCertificate) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsAcmCertificate) GetKeyAlgorithm() *plugin.TValue[string] {
	return &c.KeyAlgorithm
}

func (c *mqlAwsAcmCertificate) GetSerial() *plugin.TValue[string] {
	return &c.Serial
}

func (c *mqlAwsAcmCertificate) GetSource() *plugin.TValue[string] {
	return &c.Source
}

func (c *mqlAwsAcmCertificate) GetIssuer() *plugin.TValue[string] {
	return &c.Issuer
}

func (c *mqlAwsAcmCertificate) GetIssuedAt() *plugin.TValue[*time.Time] {
	return &c.IssuedAt
}

func (c *mqlAwsAcmCertificate) GetImportedAt() *plugin.TValue[*time.Time] {
	return &c.ImportedAt
}

// mqlAwsAutoscaling for the aws.autoscaling resource
type mqlAwsAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAutoscalingInternal it will be used here
	Groups plugin.TValue[[]interface{}]
}

// createAwsAutoscaling creates a new instance of this resource
func createAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscaling) MqlName() string {
	return "aws.autoscaling"
}

func (c *mqlAwsAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscaling) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

// mqlAwsAutoscalingGroup for the aws.autoscaling.group resource
type mqlAwsAutoscalingGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsAutoscalingGroupInternal
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	LoadBalancerNames plugin.TValue[[]interface{}]
	HealthCheckType plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
	MinSize plugin.TValue[int64]
	MaxSize plugin.TValue[int64]
	DefaultCooldown plugin.TValue[int64]
	LaunchConfigurationName plugin.TValue[string]
	HealthCheckGracePeriod plugin.TValue[int64]
	CreatedAt plugin.TValue[*time.Time]
	MaxInstanceLifetime plugin.TValue[int64]
	DesiredCapacity plugin.TValue[int64]
	AvailabilityZones plugin.TValue[[]interface{}]
	CapacityRebalance plugin.TValue[bool]
	DefaultInstanceWarmup plugin.TValue[int64]
	Instances plugin.TValue[[]interface{}]
}

// createAwsAutoscalingGroup creates a new instance of this resource
func createAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscalingGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscalingGroup) MqlName() string {
	return "aws.autoscaling.group"
}

func (c *mqlAwsAutoscalingGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscalingGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAutoscalingGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAutoscalingGroup) GetLoadBalancerNames() *plugin.TValue[[]interface{}] {
	return &c.LoadBalancerNames
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckType() *plugin.TValue[string] {
	return &c.HealthCheckType
}

func (c *mqlAwsAutoscalingGroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsAutoscalingGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsAutoscalingGroup) GetMinSize() *plugin.TValue[int64] {
	return &c.MinSize
}

func (c *mqlAwsAutoscalingGroup) GetMaxSize() *plugin.TValue[int64] {
	return &c.MaxSize
}

func (c *mqlAwsAutoscalingGroup) GetDefaultCooldown() *plugin.TValue[int64] {
	return &c.DefaultCooldown
}

func (c *mqlAwsAutoscalingGroup) GetLaunchConfigurationName() *plugin.TValue[string] {
	return &c.LaunchConfigurationName
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckGracePeriod() *plugin.TValue[int64] {
	return &c.HealthCheckGracePeriod
}

func (c *mqlAwsAutoscalingGroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAutoscalingGroup) GetMaxInstanceLifetime() *plugin.TValue[int64] {
	return &c.MaxInstanceLifetime
}

func (c *mqlAwsAutoscalingGroup) GetDesiredCapacity() *plugin.TValue[int64] {
	return &c.DesiredCapacity
}

func (c *mqlAwsAutoscalingGroup) GetAvailabilityZones() *plugin.TValue[[]interface{}] {
	return &c.AvailabilityZones
}

func (c *mqlAwsAutoscalingGroup) GetCapacityRebalance() *plugin.TValue[bool] {
	return &c.CapacityRebalance
}

func (c *mqlAwsAutoscalingGroup) GetDefaultInstanceWarmup() *plugin.TValue[int64] {
	return &c.DefaultInstanceWarmup
}

func (c *mqlAwsAutoscalingGroup) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling.group", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

// mqlAwsElb for the aws.elb resource
type mqlAwsElb struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbInternal it will be used here
	ClassicLoadBalancers plugin.TValue[[]interface{}]
	LoadBalancers plugin.TValue[[]interface{}]
}

// createAwsElb creates a new instance of this resource
func createAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElb) MqlName() string {
	return "aws.elb"
}

func (c *mqlAwsElb) MqlID() string {
	return c.__id
}

func (c *mqlAwsElb) GetClassicLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ClassicLoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "classicLoadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.classicLoadBalancers()
	})
}

func (c *mqlAwsElb) GetLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "loadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.loadBalancers()
	})
}

// mqlAwsElbTargetgroup for the aws.elb.targetgroup resource
type mqlAwsElbTargetgroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsElbTargetgroupInternal
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	Port plugin.TValue[int64]
	Protocol plugin.TValue[string]
	ProtocolVersion plugin.TValue[string]
	IpAddressType plugin.TValue[string]
	HealthCheckEnabled plugin.TValue[bool]
	HealthCheckIntervalSeconds plugin.TValue[int64]
	HealthCheckPath plugin.TValue[string]
	HealthCheckPort plugin.TValue[string]
	HealthCheckProtocol plugin.TValue[string]
	HealthCheckTimeoutSeconds plugin.TValue[int64]
	TargetType plugin.TValue[string]
	UnhealthyThresholdCount plugin.TValue[int64]
	Vpc plugin.TValue[*mqlAwsVpc]
	Ec2Targets plugin.TValue[[]interface{}]
	LambdaTargets plugin.TValue[[]interface{}]
}

// createAwsElbTargetgroup creates a new instance of this resource
func createAwsElbTargetgroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbTargetgroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.targetgroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbTargetgroup) MqlName() string {
	return "aws.elb.targetgroup"
}

func (c *mqlAwsElbTargetgroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbTargetgroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbTargetgroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbTargetgroup) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsElbTargetgroup) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlAwsElbTargetgroup) GetProtocolVersion() *plugin.TValue[string] {
	return &c.ProtocolVersion
}

func (c *mqlAwsElbTargetgroup) GetIpAddressType() *plugin.TValue[string] {
	return &c.IpAddressType
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckEnabled() *plugin.TValue[bool] {
	return &c.HealthCheckEnabled
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckIntervalSeconds() *plugin.TValue[int64] {
	return &c.HealthCheckIntervalSeconds
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckPath() *plugin.TValue[string] {
	return &c.HealthCheckPath
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckPort() *plugin.TValue[string] {
	return &c.HealthCheckPort
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckProtocol() *plugin.TValue[string] {
	return &c.HealthCheckProtocol
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckTimeoutSeconds() *plugin.TValue[int64] {
	return &c.HealthCheckTimeoutSeconds
}

func (c *mqlAwsElbTargetgroup) GetTargetType() *plugin.TValue[string] {
	return &c.TargetType
}

func (c *mqlAwsElbTargetgroup) GetUnhealthyThresholdCount() *plugin.TValue[int64] {
	return &c.UnhealthyThresholdCount
}

func (c *mqlAwsElbTargetgroup) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsElbTargetgroup) GetEc2Targets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Ec2Targets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "ec2Targets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.ec2Targets()
	})
}

func (c *mqlAwsElbTargetgroup) GetLambdaTargets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LambdaTargets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "lambdaTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.lambdaTargets()
	})
}

// mqlAwsElbLoadbalancer for the aws.elb.loadbalancer resource
type mqlAwsElbLoadbalancer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbLoadbalancerInternal it will be used here
	Arn plugin.TValue[string]
	DnsName plugin.TValue[string]
	ListenerDescriptions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
	Scheme plugin.TValue[string]
	Attributes plugin.TValue[[]interface{}]
	VpcId plugin.TValue[string]
	CreatedTime plugin.TValue[*time.Time]
	AvailabilityZones plugin.TValue[[]interface{}]
	SecurityGroups plugin.TValue[[]interface{}]
	HostedZoneId plugin.TValue[string]
	Region plugin.TValue[string]
	ElbType plugin.TValue[string]
	Vpc plugin.TValue[*mqlAwsVpc]
	TargetGroups plugin.TValue[[]interface{}]
}

// createAwsElbLoadbalancer creates a new instance of this resource
func createAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbLoadbalancer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.loadbalancer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbLoadbalancer) MqlName() string {
	return "aws.elb.loadbalancer"
}

func (c *mqlAwsElbLoadbalancer) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbLoadbalancer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbLoadbalancer) GetDnsName() *plugin.TValue[string] {
	return &c.DnsName
}

func (c *mqlAwsElbLoadbalancer) GetListenerDescriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ListenerDescriptions, func() ([]interface{}, error) {
		return c.listenerDescriptions()
	})
}

func (c *mqlAwsElbLoadbalancer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbLoadbalancer) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlAwsElbLoadbalancer) GetAttributes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Attributes, func() ([]interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsElbLoadbalancer) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsElbLoadbalancer) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsElbLoadbalancer) GetAvailabilityZones() *plugin.TValue[[]interface{}] {
	return &c.AvailabilityZones
}

func (c *mqlAwsElbLoadbalancer) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.SecurityGroups
}

func (c *mqlAwsElbLoadbalancer) GetHostedZoneId() *plugin.TValue[string] {
	return &c.HostedZoneId
}

func (c *mqlAwsElbLoadbalancer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElbLoadbalancer) GetElbType() *plugin.TValue[string] {
	return &c.ElbType
}

func (c *mqlAwsElbLoadbalancer) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return &c.Vpc
}

func (c *mqlAwsElbLoadbalancer) GetTargetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.TargetGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.loadbalancer", c.__id, "targetGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.targetGroups()
	})
}

// mqlAwsCodebuild for the aws.codebuild resource
type mqlAwsCodebuild struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildInternal it will be used here
	Projects plugin.TValue[[]interface{}]
}

// createAwsCodebuild creates a new instance of this resource
func createAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuild{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuild) MqlName() string {
	return "aws.codebuild"
}

func (c *mqlAwsCodebuild) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuild) GetProjects() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Projects, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codebuild", c.__id, "projects")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.projects()
	})
}

// mqlAwsCodebuildProject for the aws.codebuild.project resource
type mqlAwsCodebuildProject struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildProjectInternal it will be used here
	Arn plugin.TValue[string]
	Description plugin.TValue[string]
	Name plugin.TValue[string]
	Environment plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Source plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsCodebuildProject creates a new instance of this resource
func createAwsCodebuildProject(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuildProject{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild.project", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuildProject) MqlName() string {
	return "aws.codebuild.project"
}

func (c *mqlAwsCodebuildProject) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuildProject) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodebuildProject) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsCodebuildProject) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCodebuildProject) GetEnvironment() *plugin.TValue[interface{}] {
	return &c.Environment
}

func (c *mqlAwsCodebuildProject) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodebuildProject) GetSource() *plugin.TValue[interface{}] {
	return &c.Source
}

func (c *mqlAwsCodebuildProject) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsGuardduty for the aws.guardduty resource
type mqlAwsGuardduty struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyInternal it will be used here
	Findings plugin.TValue[[]interface{}]
	Detectors plugin.TValue[[]interface{}]
}

// createAwsGuardduty creates a new instance of this resource
func createAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuardduty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuardduty) MqlName() string {
	return "aws.guardduty"
}

func (c *mqlAwsGuardduty) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuardduty) GetFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Findings, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlAwsGuardduty) GetDetectors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Detectors, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "detectors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.detectors()
	})
}

// mqlAwsGuarddutyDetector for the aws.guardduty.detector resource
type mqlAwsGuarddutyDetector struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyDetectorInternal it will be used here
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	Features plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
	FindingPublishingFrequency plugin.TValue[string]
	Findings plugin.TValue[[]interface{}]
	UnarchivedFindings plugin.TValue[[]interface{}]
}

// createAwsGuarddutyDetector creates a new instance of this resource
func createAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyDetector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.detector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyDetector) MqlName() string {
	return "aws.guardduty.detector"
}

func (c *mqlAwsGuarddutyDetector) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyDetector) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyDetector) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyDetector) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFeatures() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Features, func() ([]interface{}, error) {
		return c.features()
	})
}

func (c *mqlAwsGuarddutyDetector) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFindingPublishingFrequency() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.FindingPublishingFrequency, func() (string, error) {
		return c.findingPublishingFrequency()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Findings, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty.detector", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlAwsGuarddutyDetector) GetUnarchivedFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.UnarchivedFindings, func() ([]interface{}, error) {
		return c.unarchivedFindings()
	})
}

// mqlAwsGuarddutyFinding for the aws.guardduty.finding resource
type mqlAwsGuarddutyFinding struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyFindingInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Title plugin.TValue[string]
	Description plugin.TValue[string]
	Severity plugin.TValue[float64]
	Confidence plugin.TValue[float64]
	Type plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
}

// createAwsGuarddutyFinding creates a new instance of this resource
func createAwsGuarddutyFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyFinding) MqlName() string {
	return "aws.guardduty.finding"
}

func (c *mqlAwsGuarddutyFinding) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyFinding) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsGuarddutyFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyFinding) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyFinding) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlAwsGuarddutyFinding) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsGuarddutyFinding) GetSeverity() *plugin.TValue[float64] {
	return &c.Severity
}

func (c *mqlAwsGuarddutyFinding) GetConfidence() *plugin.TValue[float64] {
	return &c.Confidence
}

func (c *mqlAwsGuarddutyFinding) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsGuarddutyFinding) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsGuarddutyFinding) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

// mqlAwsSecurityhub for the aws.securityhub resource
type mqlAwsSecurityhub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubInternal it will be used here
	Hubs plugin.TValue[[]interface{}]
}

// createAwsSecurityhub creates a new instance of this resource
func createAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhub) MqlName() string {
	return "aws.securityhub"
}

func (c *mqlAwsSecurityhub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhub) GetHubs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hubs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.securityhub", c.__id, "hubs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.hubs()
	})
}

// mqlAwsSecurityhubHub for the aws.securityhub.hub resource
type mqlAwsSecurityhubHub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubHubInternal it will be used here
	Arn plugin.TValue[string]
	SubscribedAt plugin.TValue[string]
}

// createAwsSecurityhubHub creates a new instance of this resource
func createAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhubHub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub.hub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhubHub) MqlName() string {
	return "aws.securityhub.hub"
}

func (c *mqlAwsSecurityhubHub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhubHub) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecurityhubHub) GetSubscribedAt() *plugin.TValue[string] {
	return &c.SubscribedAt
}

// mqlAwsSecretsmanager for the aws.secretsmanager resource
type mqlAwsSecretsmanager struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerInternal it will be used here
	Secrets plugin.TValue[[]interface{}]
}

// createAwsSecretsmanager creates a new instance of this resource
func createAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanager{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanager) MqlName() string {
	return "aws.secretsmanager"
}

func (c *mqlAwsSecretsmanager) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanager) GetSecrets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Secrets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.secretsmanager", c.__id, "secrets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.secrets()
	})
}

// mqlAwsSecretsmanagerSecret for the aws.secretsmanager.secret resource
type mqlAwsSecretsmanagerSecret struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerSecretInternal it will be used here
	Arn plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	Description plugin.TValue[string]
	LastChangedDate plugin.TValue[*time.Time]
	LastRotatedDate plugin.TValue[*time.Time]
	Name plugin.TValue[string]
	NextRotationDate plugin.TValue[*time.Time]
	PrimaryRegion plugin.TValue[string]
	RotationEnabled plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSecretsmanagerSecret creates a new instance of this resource
func createAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanagerSecret{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager.secret", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanagerSecret) MqlName() string {
	return "aws.secretsmanager.secret"
}

func (c *mqlAwsSecretsmanagerSecret) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanagerSecret) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecretsmanagerSecret) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsSecretsmanagerSecret) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsSecretsmanagerSecret) GetLastChangedDate() *plugin.TValue[*time.Time] {
	return &c.LastChangedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetLastRotatedDate() *plugin.TValue[*time.Time] {
	return &c.LastRotatedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSecretsmanagerSecret) GetNextRotationDate() *plugin.TValue[*time.Time] {
	return &c.NextRotationDate
}

func (c *mqlAwsSecretsmanagerSecret) GetPrimaryRegion() *plugin.TValue[string] {
	return &c.PrimaryRegion
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationEnabled() *plugin.TValue[bool] {
	return &c.RotationEnabled
}

func (c *mqlAwsSecretsmanagerSecret) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsEcs for the aws.ecs resource
type mqlAwsEcs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	Containers plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
}

// createAwsEcs creates a new instance of this resource
func createAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcs) MqlName() string {
	return "aws.ecs"
}

func (c *mqlAwsEcs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcs) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsEcs) GetContainers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Containers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containers()
	})
}

func (c *mqlAwsEcs) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

// mqlAwsEcsCluster for the aws.ecs.cluster resource
type mqlAwsEcsCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	RunningTasksCount plugin.TValue[int64]
	PendingTasksCount plugin.TValue[int64]
	RegisteredContainerInstancesCount plugin.TValue[int64]
	Configuration plugin.TValue[interface{}]
	Status plugin.TValue[string]
	Tasks plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
}

// createAwsEcsCluster creates a new instance of this resource
func createAwsEcsCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsCluster) MqlName() string {
	return "aws.ecs.cluster"
}

func (c *mqlAwsEcsCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsCluster) GetRunningTasksCount() *plugin.TValue[int64] {
	return &c.RunningTasksCount
}

func (c *mqlAwsEcsCluster) GetPendingTasksCount() *plugin.TValue[int64] {
	return &c.PendingTasksCount
}

func (c *mqlAwsEcsCluster) GetRegisteredContainerInstancesCount() *plugin.TValue[int64] {
	return &c.RegisteredContainerInstancesCount
}

func (c *mqlAwsEcsCluster) GetConfiguration() *plugin.TValue[interface{}] {
	return &c.Configuration
}

func (c *mqlAwsEcsCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsCluster) GetTasks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tasks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "tasks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tasks()
	})
}

func (c *mqlAwsEcsCluster) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

func (c *mqlAwsEcsCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsInstance for the aws.ecs.instance resource
type mqlAwsEcsInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInstanceInternal it will be used here
	AgentConnected plugin.TValue[bool]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	CapacityProvider plugin.TValue[string]
	Ec2Instance plugin.TValue[*mqlAwsEc2Instance]
	Region plugin.TValue[string]
}

// createAwsEcsInstance creates a new instance of this resource
func createAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsInstance) MqlName() string {
	return "aws.ecs.instance"
}

func (c *mqlAwsEcsInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsInstance) GetAgentConnected() *plugin.TValue[bool] {
	return &c.AgentConnected
}

func (c *mqlAwsEcsInstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEcsInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsInstance) GetCapacityProvider() *plugin.TValue[string] {
	return &c.CapacityProvider
}

func (c *mqlAwsEcsInstance) GetEc2Instance() *plugin.TValue[*mqlAwsEc2Instance] {
	return plugin.GetOrCompute[*mqlAwsEc2Instance](&c.Ec2Instance, func() (*mqlAwsEc2Instance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.instance", c.__id, "ec2Instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Instance), nil
			}
		}

		return c.ec2Instance()
	})
}

func (c *mqlAwsEcsInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsTask for the aws.ecs.task resource
type mqlAwsEcsTask struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEcsTaskInternal
	Arn plugin.TValue[string]
	ClusterName plugin.TValue[string]
	Connectivity plugin.TValue[interface{}]
	LastStatus plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Containers plugin.TValue[[]interface{}]
}

// createAwsEcsTask creates a new instance of this resource
func createAwsEcsTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTask{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.task", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTask) MqlName() string {
	return "aws.ecs.task"
}

func (c *mqlAwsEcsTask) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTask) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTask) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsTask) GetConnectivity() *plugin.TValue[interface{}] {
	return &c.Connectivity
}

func (c *mqlAwsEcsTask) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsEcsTask) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsTask) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsTask) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsTask) GetContainers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Containers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.task", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containers()
	})
}

// mqlAwsEcsContainer for the aws.ecs.container resource
type mqlAwsEcsContainer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsContainerInternal it will be used here
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	PublicIp plugin.TValue[string]
	Image plugin.TValue[string]
	ClusterName plugin.TValue[string]
	TaskDefinitionArn plugin.TValue[string]
	LogDriver plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Status plugin.TValue[string]
	Region plugin.TValue[string]
	Command plugin.TValue[[]interface{}]
	TaskArn plugin.TValue[string]
	RuntimeId plugin.TValue[string]
	ContainerName plugin.TValue[string]
}

// createAwsEcsContainer creates a new instance of this resource
func createAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsContainer) MqlName() string {
	return "aws.ecs.container"
}

func (c *mqlAwsEcsContainer) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsContainer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsContainer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsContainer) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEcsContainer) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlAwsEcsContainer) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsContainer) GetTaskDefinitionArn() *plugin.TValue[string] {
	return &c.TaskDefinitionArn
}

func (c *mqlAwsEcsContainer) GetLogDriver() *plugin.TValue[string] {
	return &c.LogDriver
}

func (c *mqlAwsEcsContainer) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsContainer) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsContainer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsContainer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcsContainer) GetCommand() *plugin.TValue[[]interface{}] {
	return &c.Command
}

func (c *mqlAwsEcsContainer) GetTaskArn() *plugin.TValue[string] {
	return &c.TaskArn
}

func (c *mqlAwsEcsContainer) GetRuntimeId() *plugin.TValue[string] {
	return &c.RuntimeId
}

func (c *mqlAwsEcsContainer) GetContainerName() *plugin.TValue[string] {
	return &c.ContainerName
}

// mqlAwsEmr for the aws.emr resource
type mqlAwsEmr struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsEmr creates a new instance of this resource
func createAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmr) MqlName() string {
	return "aws.emr"
}

func (c *mqlAwsEmr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmr) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.emr", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEmrCluster for the aws.emr.cluster resource
type mqlAwsEmrCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	NormalizedInstanceHours plugin.TValue[int64]
	OutpostArn plugin.TValue[string]
	Status plugin.TValue[interface{}]
	MasterInstances plugin.TValue[[]interface{}]
	Id plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsEmrCluster creates a new instance of this resource
func createAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmrCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmrCluster) MqlName() string {
	return "aws.emr.cluster"
}

func (c *mqlAwsEmrCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmrCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEmrCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEmrCluster) GetNormalizedInstanceHours() *plugin.TValue[int64] {
	return &c.NormalizedInstanceHours
}

func (c *mqlAwsEmrCluster) GetOutpostArn() *plugin.TValue[string] {
	return &c.OutpostArn
}

func (c *mqlAwsEmrCluster) GetStatus() *plugin.TValue[interface{}] {
	return &c.Status
}

func (c *mqlAwsEmrCluster) GetMasterInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MasterInstances, func() ([]interface{}, error) {
		return c.masterInstances()
	})
}

func (c *mqlAwsEmrCluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEmrCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsCloudwatch for the aws.cloudwatch resource
type mqlAwsCloudwatch struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchInternal it will be used here
	LogGroups plugin.TValue[[]interface{}]
	Alarms plugin.TValue[[]interface{}]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatch creates a new instance of this resource
func createAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatch) MqlName() string {
	return "aws.cloudwatch"
}

func (c *mqlAwsCloudwatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatch) GetLogGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LogGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "logGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.logGroups()
	})
}

func (c *mqlAwsCloudwatch) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatch) GetMetrics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Metrics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "metrics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metrics()
	})
}

// mqlAwsCloudwatchMetricsalarm for the aws.cloudwatch.metricsalarm resource
type mqlAwsCloudwatchMetricsalarm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricsalarmInternal it will be used here
	Arn plugin.TValue[string]
	MetricName plugin.TValue[string]
	MetricNamespace plugin.TValue[string]
	Region plugin.TValue[string]
	Actions plugin.TValue[[]interface{}]
	State plugin.TValue[string]
	StateReason plugin.TValue[string]
	InsufficientDataActions plugin.TValue[[]interface{}]
	OkActions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
}

// createAwsCloudwatchMetricsalarm creates a new instance of this resource
func createAwsCloudwatchMetricsalarm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricsalarm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricsalarm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlName() string {
	return "aws.cloudwatch.metricsalarm"
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricsalarm) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricName() *plugin.TValue[string] {
	return &c.MetricName
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricNamespace() *plugin.TValue[string] {
	return &c.MetricNamespace
}

func (c *mqlAwsCloudwatchMetricsalarm) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricsalarm) GetActions() *plugin.TValue[[]interface{}] {
	return &c.Actions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsCloudwatchMetricsalarm) GetStateReason() *plugin.TValue[string] {
	return &c.StateReason
}

func (c *mqlAwsCloudwatchMetricsalarm) GetInsufficientDataActions() *plugin.TValue[[]interface{}] {
	return &c.InsufficientDataActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetOkActions() *plugin.TValue[[]interface{}] {
	return &c.OkActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsCloudwatchMetric for the aws.cloudwatch.metric resource
type mqlAwsCloudwatchMetric struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricInternal it will be used here
	Name plugin.TValue[string]
	Namespace plugin.TValue[string]
	Region plugin.TValue[string]
	Alarms plugin.TValue[[]interface{}]
	Dimensions plugin.TValue[[]interface{}]
	Statistics plugin.TValue[*mqlAwsCloudwatchMetricstatistics]
}

// createAwsCloudwatchMetric creates a new instance of this resource
func createAwsCloudwatchMetric(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetric{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetric) MqlName() string {
	return "aws.cloudwatch.metric"
}

func (c *mqlAwsCloudwatchMetric) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetric) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetric) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetric) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetric) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatchMetric) GetDimensions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Dimensions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "dimensions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dimensions()
	})
}

func (c *mqlAwsCloudwatchMetric) GetStatistics() *plugin.TValue[*mqlAwsCloudwatchMetricstatistics] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchMetricstatistics](&c.Statistics, func() (*mqlAwsCloudwatchMetricstatistics, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "statistics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchMetricstatistics), nil
			}
		}

		return c.statistics()
	})
}

// mqlAwsCloudwatchMetricdimension for the aws.cloudwatch.metricdimension resource
type mqlAwsCloudwatchMetricdimension struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricdimensionInternal it will be used here
	Name plugin.TValue[string]
	Value plugin.TValue[string]
}

// createAwsCloudwatchMetricdimension creates a new instance of this resource
func createAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricdimension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricdimension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricdimension) MqlName() string {
	return "aws.cloudwatch.metricdimension"
}

func (c *mqlAwsCloudwatchMetricdimension) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricdimension) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricdimension) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlAwsCloudwatchMetricstatistics for the aws.cloudwatch.metricstatistics resource
type mqlAwsCloudwatchMetricstatistics struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricstatisticsInternal it will be used here
	Namespace plugin.TValue[string]
	Name plugin.TValue[string]
	Region plugin.TValue[string]
	Label plugin.TValue[string]
	Datapoints plugin.TValue[[]interface{}]
}

// createAwsCloudwatchMetricstatistics creates a new instance of this resource
func createAwsCloudwatchMetricstatistics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricstatistics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricstatistics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlName() string {
	return "aws.cloudwatch.metricstatistics"
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricstatistics) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetricstatistics) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricstatistics) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricstatistics) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAwsCloudwatchMetricstatistics) GetDatapoints() *plugin.TValue[[]interface{}] {
	return &c.Datapoints
}

// mqlAwsCloudwatchMetricDatapoint for the aws.cloudwatch.metric.datapoint resource
type mqlAwsCloudwatchMetricDatapoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricDatapointInternal it will be used here
	Id plugin.TValue[string]
	Timestamp plugin.TValue[*time.Time]
	Maximum plugin.TValue[float64]
	Minimum plugin.TValue[float64]
	Average plugin.TValue[float64]
	Sum plugin.TValue[float64]
	Unit plugin.TValue[string]
}

// createAwsCloudwatchMetricDatapoint creates a new instance of this resource
func createAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricDatapoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric.datapoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlName() string {
	return "aws.cloudwatch.metric.datapoint"
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetTimestamp() *plugin.TValue[*time.Time] {
	return &c.Timestamp
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMaximum() *plugin.TValue[float64] {
	return &c.Maximum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMinimum() *plugin.TValue[float64] {
	return &c.Minimum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetAverage() *plugin.TValue[float64] {
	return &c.Average
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetSum() *plugin.TValue[float64] {
	return &c.Sum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetUnit() *plugin.TValue[string] {
	return &c.Unit
}

// mqlAwsCloudwatchLoggroup for the aws.cloudwatch.loggroup resource
type mqlAwsCloudwatchLoggroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	MetricsFilters plugin.TValue[[]interface{}]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	Region plugin.TValue[string]
	RetentionInDays plugin.TValue[int64]
}

// createAwsCloudwatchLoggroup creates a new instance of this resource
func createAwsCloudwatchLoggroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroup) MqlName() string {
	return "aws.cloudwatch.loggroup"
}

func (c *mqlAwsCloudwatchLoggroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchLoggroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchLoggroup) GetMetricsFilters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MetricsFilters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "metricsFilters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metricsFilters()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchLoggroup) GetRetentionInDays() *plugin.TValue[int64] {
	return &c.RetentionInDays
}

// mqlAwsCloudwatchLoggroupMetricsfilter for the aws.cloudwatch.loggroup.metricsfilter resource
type mqlAwsCloudwatchLoggroupMetricsfilter struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupMetricsfilterInternal it will be used here
	Id plugin.TValue[string]
	FilterName plugin.TValue[string]
	FilterPattern plugin.TValue[string]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatchLoggroupMetricsfilter creates a new instance of this resource
func createAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroupMetricsfilter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup.metricsfilter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlName() string {
	return "aws.cloudwatch.loggroup.metricsfilter"
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterName() *plugin.TValue[string] {
	return &c.FilterName
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterPattern() *plugin.TValue[string] {
	return &c.FilterPattern
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetMetrics() *plugin.TValue[[]interface{}] {
	return &c.Metrics
}

// mqlAwsCloudfront for the aws.cloudfront resource
type mqlAwsCloudfront struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontInternal it will be used here
	Distributions plugin.TValue[[]interface{}]
	Functions plugin.TValue[[]interface{}]
}

// createAwsCloudfront creates a new instance of this resource
func createAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfront{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfront) MqlName() string {
	return "aws.cloudfront"
}

func (c *mqlAwsCloudfront) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfront) GetDistributions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Distributions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "distributions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.distributions()
	})
}

func (c *mqlAwsCloudfront) GetFunctions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Functions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsCloudfrontDistribution for the aws.cloudfront.distribution resource
type mqlAwsCloudfrontDistribution struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontDistributionInternal it will be used here
	Arn plugin.TValue[string]
	Status plugin.TValue[string]
	DomainName plugin.TValue[string]
	Origins plugin.TValue[[]interface{}]
	DefaultCacheBehavior plugin.TValue[interface{}]
	CacheBehaviors plugin.TValue[[]interface{}]
	HttpVersion plugin.TValue[string]
	IsIPV6Enabled plugin.TValue[bool]
	Enabled plugin.TValue[bool]
	PriceClass plugin.TValue[string]
	Cnames plugin.TValue[[]interface{}]
}

// createAwsCloudfrontDistribution creates a new instance of this resource
func createAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistribution{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistribution) MqlName() string {
	return "aws.cloudfront.distribution"
}

func (c *mqlAwsCloudfrontDistribution) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistribution) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontDistribution) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontDistribution) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistribution) GetOrigins() *plugin.TValue[[]interface{}] {
	return &c.Origins
}

func (c *mqlAwsCloudfrontDistribution) GetDefaultCacheBehavior() *plugin.TValue[interface{}] {
	return &c.DefaultCacheBehavior
}

func (c *mqlAwsCloudfrontDistribution) GetCacheBehaviors() *plugin.TValue[[]interface{}] {
	return &c.CacheBehaviors
}

func (c *mqlAwsCloudfrontDistribution) GetHttpVersion() *plugin.TValue[string] {
	return &c.HttpVersion
}

func (c *mqlAwsCloudfrontDistribution) GetIsIPV6Enabled() *plugin.TValue[bool] {
	return &c.IsIPV6Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetPriceClass() *plugin.TValue[string] {
	return &c.PriceClass
}

func (c *mqlAwsCloudfrontDistribution) GetCnames() *plugin.TValue[[]interface{}] {
	return &c.Cnames
}

// mqlAwsCloudfrontDistributionOrigin for the aws.cloudfront.distribution.origin resource
type mqlAwsCloudfrontDistributionOrigin struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontDistributionOriginInternal it will be used here
	DomainName plugin.TValue[string]
	Id plugin.TValue[string]
	ConnectionAttempts plugin.TValue[int64]
	ConnectionTimeout plugin.TValue[int64]
	OriginPath plugin.TValue[string]
	Account plugin.TValue[string]
}

// createAwsCloudfrontDistributionOrigin creates a new instance of this resource
func createAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistributionOrigin{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution.origin", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlName() string {
	return "aws.cloudfront.distribution.origin"
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionAttempts() *plugin.TValue[int64] {
	return &c.ConnectionAttempts
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionTimeout() *plugin.TValue[int64] {
	return &c.ConnectionTimeout
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetOriginPath() *plugin.TValue[string] {
	return &c.OriginPath
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetAccount() *plugin.TValue[string] {
	return &c.Account
}

// mqlAwsCloudfrontFunction for the aws.cloudfront.function resource
type mqlAwsCloudfrontFunction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontFunctionInternal it will be used here
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Arn plugin.TValue[string]
	LastModifiedTime plugin.TValue[*time.Time]
	CreatedTime plugin.TValue[*time.Time]
	Stage plugin.TValue[string]
	Comment plugin.TValue[string]
	Runtime plugin.TValue[string]
}

// createAwsCloudfrontFunction creates a new instance of this resource
func createAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontFunction) MqlName() string {
	return "aws.cloudfront.function"
}

func (c *mqlAwsCloudfrontFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudfrontFunction) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontFunction) GetLastModifiedTime() *plugin.TValue[*time.Time] {
	return &c.LastModifiedTime
}

func (c *mqlAwsCloudfrontFunction) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsCloudfrontFunction) GetStage() *plugin.TValue[string] {
	return &c.Stage
}

func (c *mqlAwsCloudfrontFunction) GetComment() *plugin.TValue[string] {
	return &c.Comment
}

func (c *mqlAwsCloudfrontFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

// mqlAwsCloudtrail for the aws.cloudtrail resource
type mqlAwsCloudtrail struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudtrailInternal it will be used here
	Trails plugin.TValue[[]interface{}]
}

// createAwsCloudtrail creates a new instance of this resource
func createAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrail) MqlName() string {
	return "aws.cloudtrail"
}

func (c *mqlAwsCloudtrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrail) GetTrails() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Trails, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail", c.__id, "trails")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.trails()
	})
}

// mqlAwsCloudtrailTrail for the aws.cloudtrail.trail resource
type mqlAwsCloudtrailTrail struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsCloudtrailTrailInternal
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	IsMultiRegionTrail plugin.TValue[bool]
	IsOrganizationTrail plugin.TValue[bool]
	LogFileValidationEnabled plugin.TValue[bool]
	IncludeGlobalServiceEvents plugin.TValue[bool]
	S3bucket plugin.TValue[*mqlAwsS3Bucket]
	SnsTopicARN plugin.TValue[string]
	Status plugin.TValue[interface{}]
	LogGroup plugin.TValue[*mqlAwsCloudwatchLoggroup]
	CloudWatchLogsRoleArn plugin.TValue[string]
	CloudWatchLogsLogGroupArn plugin.TValue[string]
	EventSelectors plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
}

// createAwsCloudtrailTrail creates a new instance of this resource
func createAwsCloudtrailTrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrailTrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail.trail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrailTrail) MqlName() string {
	return "aws.cloudtrail.trail"
}

func (c *mqlAwsCloudtrailTrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrailTrail) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudtrailTrail) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudtrailTrail) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudtrailTrail) GetIsMultiRegionTrail() *plugin.TValue[bool] {
	return &c.IsMultiRegionTrail
}

func (c *mqlAwsCloudtrailTrail) GetIsOrganizationTrail() *plugin.TValue[bool] {
	return &c.IsOrganizationTrail
}

func (c *mqlAwsCloudtrailTrail) GetLogFileValidationEnabled() *plugin.TValue[bool] {
	return &c.LogFileValidationEnabled
}

func (c *mqlAwsCloudtrailTrail) GetIncludeGlobalServiceEvents() *plugin.TValue[bool] {
	return &c.IncludeGlobalServiceEvents
}

func (c *mqlAwsCloudtrailTrail) GetS3bucket() *plugin.TValue[*mqlAwsS3Bucket] {
	return plugin.GetOrCompute[*mqlAwsS3Bucket](&c.S3bucket, func() (*mqlAwsS3Bucket, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "s3bucket")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3Bucket), nil
			}
		}

		return c.s3bucket()
	})
}

func (c *mqlAwsCloudtrailTrail) GetSnsTopicARN() *plugin.TValue[string] {
	return &c.SnsTopicARN
}

func (c *mqlAwsCloudtrailTrail) GetStatus() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Status, func() (interface{}, error) {
		return c.status()
	})
}

func (c *mqlAwsCloudtrailTrail) GetLogGroup() *plugin.TValue[*mqlAwsCloudwatchLoggroup] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchLoggroup](&c.LogGroup, func() (*mqlAwsCloudwatchLoggroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "logGroup")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchLoggroup), nil
			}
		}

		return c.logGroup()
	})
}

func (c *mqlAwsCloudtrailTrail) GetCloudWatchLogsRoleArn() *plugin.TValue[string] {
	return &c.CloudWatchLogsRoleArn
}

func (c *mqlAwsCloudtrailTrail) GetCloudWatchLogsLogGroupArn() *plugin.TValue[string] {
	return &c.CloudWatchLogsLogGroupArn
}

func (c *mqlAwsCloudtrailTrail) GetEventSelectors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.EventSelectors, func() ([]interface{}, error) {
		return c.eventSelectors()
	})
}

func (c *mqlAwsCloudtrailTrail) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsS3control for the aws.s3control resource
type mqlAwsS3control struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3controlInternal it will be used here
	AccountPublicAccessBlock plugin.TValue[interface{}]
}

// createAwsS3control creates a new instance of this resource
func createAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3control{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3control", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3control) MqlName() string {
	return "aws.s3control"
}

func (c *mqlAwsS3control) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3control) GetAccountPublicAccessBlock() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.AccountPublicAccessBlock, func() (interface{}, error) {
		return c.accountPublicAccessBlock()
	})
}

// mqlAwsS3 for the aws.s3 resource
type mqlAwsS3 struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3Internal it will be used here
	Buckets plugin.TValue[[]interface{}]
}

// createAwsS3 creates a new instance of this resource
func createAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3) MqlName() string {
	return "aws.s3"
}

func (c *mqlAwsS3) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3) GetBuckets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Buckets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3", c.__id, "buckets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.buckets()
	})
}

// mqlAwsS3Bucket for the aws.s3.bucket resource
type mqlAwsS3Bucket struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Policy plugin.TValue[*mqlAwsS3BucketPolicy]
	Tags plugin.TValue[map[string]interface{}]
	Acl plugin.TValue[[]interface{}]
	Owner plugin.TValue[map[string]interface{}]
	Public plugin.TValue[bool]
	Cors plugin.TValue[[]interface{}]
	Location plugin.TValue[string]
	Versioning plugin.TValue[map[string]interface{}]
	Logging plugin.TValue[map[string]interface{}]
	StaticWebsiteHosting plugin.TValue[map[string]interface{}]
	DefaultLock plugin.TValue[string]
	Replication plugin.TValue[interface{}]
	Encryption plugin.TValue[interface{}]
	PublicAccessBlock plugin.TValue[interface{}]
	Exists plugin.TValue[bool]
	CreatedTime plugin.TValue[*time.Time]
}

// createAwsS3Bucket creates a new instance of this resource
func createAwsS3Bucket(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3Bucket{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3Bucket) MqlName() string {
	return "aws.s3.bucket"
}

func (c *mqlAwsS3Bucket) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3Bucket) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsS3Bucket) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3Bucket) GetPolicy() *plugin.TValue[*mqlAwsS3BucketPolicy] {
	return plugin.GetOrCompute[*mqlAwsS3BucketPolicy](&c.Policy, func() (*mqlAwsS3BucketPolicy, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "policy")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3BucketPolicy), nil
			}
		}

		return c.policy()
	})
}

func (c *mqlAwsS3Bucket) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsS3Bucket) GetAcl() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Acl, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "acl")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.acl()
	})
}

func (c *mqlAwsS3Bucket) GetOwner() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Owner, func() (map[string]interface{}, error) {
		return c.owner()
	})
}

func (c *mqlAwsS3Bucket) GetPublic() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Public, func() (bool, error) {
		return c.public()
	})
}

func (c *mqlAwsS3Bucket) GetCors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Cors, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "cors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.cors()
	})
}

func (c *mqlAwsS3Bucket) GetLocation() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Location, func() (string, error) {
		return c.location()
	})
}

func (c *mqlAwsS3Bucket) GetVersioning() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Versioning, func() (map[string]interface{}, error) {
		return c.versioning()
	})
}

func (c *mqlAwsS3Bucket) GetLogging() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Logging, func() (map[string]interface{}, error) {
		return c.logging()
	})
}

func (c *mqlAwsS3Bucket) GetStaticWebsiteHosting() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.StaticWebsiteHosting, func() (map[string]interface{}, error) {
		return c.staticWebsiteHosting()
	})
}

func (c *mqlAwsS3Bucket) GetDefaultLock() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.DefaultLock, func() (string, error) {
		return c.defaultLock()
	})
}

func (c *mqlAwsS3Bucket) GetReplication() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Replication, func() (interface{}, error) {
		return c.replication()
	})
}

func (c *mqlAwsS3Bucket) GetEncryption() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Encryption, func() (interface{}, error) {
		return c.encryption()
	})
}

func (c *mqlAwsS3Bucket) GetPublicAccessBlock() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.PublicAccessBlock, func() (interface{}, error) {
		return c.publicAccessBlock()
	})
}

func (c *mqlAwsS3Bucket) GetExists() *plugin.TValue[bool] {
	return &c.Exists
}

func (c *mqlAwsS3Bucket) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

// mqlAwsS3BucketGrant for the aws.s3.bucket.grant resource
type mqlAwsS3BucketGrant struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketGrantInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Permission plugin.TValue[string]
	Grantee plugin.TValue[map[string]interface{}]
}

// createAwsS3BucketGrant creates a new instance of this resource
func createAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketGrant{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.grant", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketGrant) MqlName() string {
	return "aws.s3.bucket.grant"
}

func (c *mqlAwsS3BucketGrant) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketGrant) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketGrant) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketGrant) GetPermission() *plugin.TValue[string] {
	return &c.Permission
}

func (c *mqlAwsS3BucketGrant) GetGrantee() *plugin.TValue[map[string]interface{}] {
	return &c.Grantee
}

// mqlAwsS3BucketCorsrule for the aws.s3.bucket.corsrule resource
type mqlAwsS3BucketCorsrule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketCorsruleInternal it will be used here
	Name plugin.TValue[string]
	AllowedHeaders plugin.TValue[[]interface{}]
	AllowedMethods plugin.TValue[[]interface{}]
	AllowedOrigins plugin.TValue[[]interface{}]
	ExposeHeaders plugin.TValue[[]interface{}]
	MaxAgeSeconds plugin.TValue[int64]
}

// createAwsS3BucketCorsrule creates a new instance of this resource
func createAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketCorsrule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.corsrule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketCorsrule) MqlName() string {
	return "aws.s3.bucket.corsrule"
}

func (c *mqlAwsS3BucketCorsrule) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketCorsrule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedHeaders() *plugin.TValue[[]interface{}] {
	return &c.AllowedHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedMethods() *plugin.TValue[[]interface{}] {
	return &c.AllowedMethods
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedOrigins() *plugin.TValue[[]interface{}] {
	return &c.AllowedOrigins
}

func (c *mqlAwsS3BucketCorsrule) GetExposeHeaders() *plugin.TValue[[]interface{}] {
	return &c.ExposeHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetMaxAgeSeconds() *plugin.TValue[int64] {
	return &c.MaxAgeSeconds
}

// mqlAwsS3BucketPolicy for the aws.s3.bucket.policy resource
type mqlAwsS3BucketPolicy struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketPolicyInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Document plugin.TValue[string]
	Version plugin.TValue[string]
	Statements plugin.TValue[[]interface{}]
}

// createAwsS3BucketPolicy creates a new instance of this resource
func createAwsS3BucketPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketPolicy) MqlName() string {
	return "aws.s3.bucket.policy"
}

func (c *mqlAwsS3BucketPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketPolicy) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketPolicy) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketPolicy) GetDocument() *plugin.TValue[string] {
	return &c.Document
}

func (c *mqlAwsS3BucketPolicy) GetVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Version, func() (string, error) {
		return c.version()
	})
}

func (c *mqlAwsS3BucketPolicy) GetStatements() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Statements, func() ([]interface{}, error) {
		return c.statements()
	})
}

// mqlAwsApplicationAutoscaling for the aws.applicationAutoscaling resource
type mqlAwsApplicationAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApplicationAutoscalingInternal it will be used here
	Namespace plugin.TValue[string]
	ScalableTargets plugin.TValue[[]interface{}]
}

// createAwsApplicationAutoscaling creates a new instance of this resource
func createAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscaling) MqlName() string {
	return "aws.applicationAutoscaling"
}

func (c *mqlAwsApplicationAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscaling) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscaling) GetScalableTargets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ScalableTargets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.applicationAutoscaling", c.__id, "scalableTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.scalableTargets()
	})
}

// mqlAwsApplicationautoscalingTarget for the aws.applicationautoscaling.target resource
type mqlAwsApplicationautoscalingTarget struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApplicationautoscalingTargetInternal it will be used here
	Namespace plugin.TValue[string]
	Arn plugin.TValue[string]
	ScalableDimension plugin.TValue[string]
	MinCapacity plugin.TValue[int64]
	MaxCapacity plugin.TValue[int64]
	SuspendedState plugin.TValue[interface{}]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsApplicationautoscalingTarget creates a new instance of this resource
func createAwsApplicationautoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationautoscalingTarget{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationautoscaling.target", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationautoscalingTarget) MqlName() string {
	return "aws.applicationautoscaling.target"
}

func (c *mqlAwsApplicationautoscalingTarget) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationautoscalingTarget) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationautoscalingTarget) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApplicationautoscalingTarget) GetScalableDimension() *plugin.TValue[string] {
	return &c.ScalableDimension
}

func (c *mqlAwsApplicationautoscalingTarget) GetMinCapacity() *plugin.TValue[int64] {
	return &c.MinCapacity
}

func (c *mqlAwsApplicationautoscalingTarget) GetMaxCapacity() *plugin.TValue[int64] {
	return &c.MaxCapacity
}

func (c *mqlAwsApplicationautoscalingTarget) GetSuspendedState() *plugin.TValue[interface{}] {
	return &c.SuspendedState
}

func (c *mqlAwsApplicationautoscalingTarget) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsBackup for the aws.backup resource
type mqlAwsBackup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupInternal it will be used here
	Vaults plugin.TValue[[]interface{}]
}

// createAwsBackup creates a new instance of this resource
func createAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackup) MqlName() string {
	return "aws.backup"
}

func (c *mqlAwsBackup) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackup) GetVaults() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vaults, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup", c.__id, "vaults")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vaults()
	})
}

// mqlAwsBackupVault for the aws.backup.vault resource
type mqlAwsBackupVault struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupVaultInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	RecoveryPoints plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	Locked plugin.TValue[bool]
	EncryptionKeyArn plugin.TValue[string]
}

// createAwsBackupVault creates a new instance of this resource
func createAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVault{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vault", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVault) MqlName() string {
	return "aws.backup.vault"
}

func (c *mqlAwsBackupVault) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVault) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVault) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsBackupVault) GetRecoveryPoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RecoveryPoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup.vault", c.__id, "recoveryPoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.recoveryPoints()
	})
}

func (c *mqlAwsBackupVault) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsBackupVault) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsBackupVault) GetLocked() *plugin.TValue[bool] {
	return &c.Locked
}

func (c *mqlAwsBackupVault) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

// mqlAwsBackupVaultRecoveryPoint for the aws.backup.vaultRecoveryPoint resource
type mqlAwsBackupVaultRecoveryPoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupVaultRecoveryPointInternal it will be used here
	Arn plugin.TValue[string]
	ResourceType plugin.TValue[string]
	CreatedBy plugin.TValue[interface{}]
	IamRoleArn plugin.TValue[string]
	Status plugin.TValue[string]
	CreationDate plugin.TValue[*time.Time]
	CompletionDate plugin.TValue[*time.Time]
	EncryptionKeyArn plugin.TValue[string]
	IsEncrypted plugin.TValue[bool]
}

// createAwsBackupVaultRecoveryPoint creates a new instance of this resource
func createAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVaultRecoveryPoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vaultRecoveryPoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlName() string {
	return "aws.backup.vaultRecoveryPoint"
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreatedBy() *plugin.TValue[interface{}] {
	return &c.CreatedBy
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIamRoleArn() *plugin.TValue[string] {
	return &c.IamRoleArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreationDate() *plugin.TValue[*time.Time] {
	return &c.CreationDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCompletionDate() *plugin.TValue[*time.Time] {
	return &c.CompletionDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIsEncrypted() *plugin.TValue[bool] {
	return &c.IsEncrypted
}

// mqlAwsDynamodb for the aws.dynamodb resource
type mqlAwsDynamodb struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbInternal it will be used here
	Backups plugin.TValue[[]interface{}]
	GlobalTables plugin.TValue[[]interface{}]
	Tables plugin.TValue[[]interface{}]
	Limits plugin.TValue[[]interface{}]
	Exports plugin.TValue[[]interface{}]
}

// createAwsDynamodb creates a new instance of this resource
func createAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodb) MqlName() string {
	return "aws.dynamodb"
}

func (c *mqlAwsDynamodb) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodb) GetBackups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Backups, func() ([]interface{}, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodb) GetGlobalTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.GlobalTables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "globalTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.globalTables()
	})
}

func (c *mqlAwsDynamodb) GetTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tables()
	})
}

func (c *mqlAwsDynamodb) GetLimits() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Limits, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "limits")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.limits()
	})
}

func (c *mqlAwsDynamodb) GetExports() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Exports, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "exports")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.exports()
	})
}

// mqlAwsDynamodbExport for the aws.dynamodb.export resource
type mqlAwsDynamodbExport struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsDynamodbExportInternal
	Table plugin.TValue[*mqlAwsDynamodbTable]
	S3Bucket plugin.TValue[*mqlAwsS3Bucket]
	S3Prefix plugin.TValue[string]
	ItemCount plugin.TValue[int64]
	Type plugin.TValue[string]
	Status plugin.TValue[string]
	Format plugin.TValue[string]
	StartTime plugin.TValue[*time.Time]
	EndTime plugin.TValue[*time.Time]
	S3SseAlgorithm plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	Arn plugin.TValue[string]
}

// createAwsDynamodbExport creates a new instance of this resource
func createAwsDynamodbExport(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbExport{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.export", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbExport) MqlName() string {
	return "aws.dynamodb.export"
}

func (c *mqlAwsDynamodbExport) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbExport) GetTable() *plugin.TValue[*mqlAwsDynamodbTable] {
	return plugin.GetOrCompute[*mqlAwsDynamodbTable](&c.Table, func() (*mqlAwsDynamodbTable, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "table")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsDynamodbTable), nil
			}
		}

		return c.table()
	})
}

func (c *mqlAwsDynamodbExport) GetS3Bucket() *plugin.TValue[*mqlAwsS3Bucket] {
	return plugin.GetOrCompute[*mqlAwsS3Bucket](&c.S3Bucket, func() (*mqlAwsS3Bucket, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "s3Bucket")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3Bucket), nil
			}
		}

		return c.s3Bucket()
	})
}

func (c *mqlAwsDynamodbExport) GetS3Prefix() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.S3Prefix, func() (string, error) {
		return c.s3Prefix()
	})
}

func (c *mqlAwsDynamodbExport) GetItemCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.ItemCount, func() (int64, error) {
		return c.itemCount()
	})
}

func (c *mqlAwsDynamodbExport) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsDynamodbExport) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsDynamodbExport) GetFormat() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Format, func() (string, error) {
		return c.format()
	})
}

func (c *mqlAwsDynamodbExport) GetStartTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.StartTime, func() (*time.Time, error) {
		return c.startTime()
	})
}

func (c *mqlAwsDynamodbExport) GetEndTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.EndTime, func() (*time.Time, error) {
		return c.endTime()
	})
}

func (c *mqlAwsDynamodbExport) GetS3SseAlgorithm() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.S3SseAlgorithm, func() (string, error) {
		return c.s3SseAlgorithm()
	})
}

func (c *mqlAwsDynamodbExport) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsDynamodbExport) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

// mqlAwsDynamodbLimit for the aws.dynamodb.limit resource
type mqlAwsDynamodbLimit struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbLimitInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	AccountMaxRead plugin.TValue[int64]
	AccountMaxWrite plugin.TValue[int64]
	TableMaxRead plugin.TValue[int64]
	TableMaxWrite plugin.TValue[int64]
}

// createAwsDynamodbLimit creates a new instance of this resource
func createAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbLimit{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.limit", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbLimit) MqlName() string {
	return "aws.dynamodb.limit"
}

func (c *mqlAwsDynamodbLimit) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbLimit) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbLimit) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxRead() *plugin.TValue[int64] {
	return &c.AccountMaxRead
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxWrite() *plugin.TValue[int64] {
	return &c.AccountMaxWrite
}

func (c *mqlAwsDynamodbLimit) GetTableMaxRead() *plugin.TValue[int64] {
	return &c.TableMaxRead
}

func (c *mqlAwsDynamodbLimit) GetTableMaxWrite() *plugin.TValue[int64] {
	return &c.TableMaxWrite
}

// mqlAwsDynamodbGlobaltable for the aws.dynamodb.globaltable resource
type mqlAwsDynamodbGlobaltable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbGlobaltableInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	ReplicaSettings plugin.TValue[[]interface{}]
}

// createAwsDynamodbGlobaltable creates a new instance of this resource
func createAwsDynamodbGlobaltable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbGlobaltable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.globaltable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbGlobaltable) MqlName() string {
	return "aws.dynamodb.globaltable"
}

func (c *mqlAwsDynamodbGlobaltable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbGlobaltable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbGlobaltable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbGlobaltable) GetReplicaSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ReplicaSettings, func() ([]interface{}, error) {
		return c.replicaSettings()
	})
}

// mqlAwsDynamodbTable for the aws.dynamodb.table resource
type mqlAwsDynamodbTable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbTableInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Region plugin.TValue[string]
	Backups plugin.TValue[[]interface{}]
	SseDescription plugin.TValue[interface{}]
	ProvisionedThroughput plugin.TValue[interface{}]
	ContinuousBackups plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
	CreatedTime plugin.TValue[*time.Time]
	DeletionProtectionEnabled plugin.TValue[bool]
	GlobalTableVersion plugin.TValue[string]
	Items plugin.TValue[int64]
	SizeBytes plugin.TValue[int64]
	LatestStreamArn plugin.TValue[string]
	Status plugin.TValue[string]
}

// createAwsDynamodbTable creates a new instance of this resource
func createAwsDynamodbTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbTable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.table", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbTable) MqlName() string {
	return "aws.dynamodb.table"
}

func (c *mqlAwsDynamodbTable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbTable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbTable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsDynamodbTable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbTable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbTable) GetBackups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Backups, func() ([]interface{}, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodbTable) GetSseDescription() *plugin.TValue[interface{}] {
	return &c.SseDescription
}

func (c *mqlAwsDynamodbTable) GetProvisionedThroughput() *plugin.TValue[interface{}] {
	return &c.ProvisionedThroughput
}

func (c *mqlAwsDynamodbTable) GetContinuousBackups() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.ContinuousBackups, func() (interface{}, error) {
		return c.continuousBackups()
	})
}

func (c *mqlAwsDynamodbTable) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsDynamodbTable) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsDynamodbTable) GetDeletionProtectionEnabled() *plugin.TValue[bool] {
	return &c.DeletionProtectionEnabled
}

func (c *mqlAwsDynamodbTable) GetGlobalTableVersion() *plugin.TValue[string] {
	return &c.GlobalTableVersion
}

func (c *mqlAwsDynamodbTable) GetItems() *plugin.TValue[int64] {
	return &c.Items
}

func (c *mqlAwsDynamodbTable) GetSizeBytes() *plugin.TValue[int64] {
	return &c.SizeBytes
}

func (c *mqlAwsDynamodbTable) GetLatestStreamArn() *plugin.TValue[string] {
	return &c.LatestStreamArn
}

func (c *mqlAwsDynamodbTable) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

// mqlAwsSqs for the aws.sqs resource
type mqlAwsSqs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSqsInternal it will be used here
	Queues plugin.TValue[[]interface{}]
}

// createAwsSqs creates a new instance of this resource
func createAwsSqs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSqs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sqs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSqs) MqlName() string {
	return "aws.sqs"
}

func (c *mqlAwsSqs) MqlID() string {
	return c.__id
}

func (c *mqlAwsSqs) GetQueues() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Queues, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs", c.__id, "queues")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.queues()
	})
}

// mqlAwsSqsQueue for the aws.sqs.queue resource
type mqlAwsSqsQueue struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsSqsQueueInternal
	Arn plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	DeadLetterQueue plugin.TValue[*mqlAwsSqsQueue]
	DeliveryDelaySeconds plugin.TValue[int64]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	LastModified plugin.TValue[*time.Time]
	MaxReceiveCount plugin.TValue[int64]
	MaximumMessageSize plugin.TValue[int64]
	MessageRetentionPeriodSeconds plugin.TValue[int64]
	ReceiveMessageWaitTimeSeconds plugin.TValue[int64]
	Region plugin.TValue[string]
	SqsManagedSseEnabled plugin.TValue[bool]
	QueueType plugin.TValue[string]
	Url plugin.TValue[string]
	VisibilityTimeoutSeconds plugin.TValue[int64]
}

// createAwsSqsQueue creates a new instance of this resource
func createAwsSqsQueue(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSqsQueue{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sqs.queue", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSqsQueue) MqlName() string {
	return "aws.sqs.queue"
}

func (c *mqlAwsSqsQueue) MqlID() string {
	return c.__id
}

func (c *mqlAwsSqsQueue) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsSqsQueue) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsSqsQueue) GetDeadLetterQueue() *plugin.TValue[*mqlAwsSqsQueue] {
	return plugin.GetOrCompute[*mqlAwsSqsQueue](&c.DeadLetterQueue, func() (*mqlAwsSqsQueue, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs.queue", c.__id, "deadLetterQueue")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSqsQueue), nil
			}
		}

		return c.deadLetterQueue()
	})
}

func (c *mqlAwsSqsQueue) GetDeliveryDelaySeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.DeliveryDelaySeconds, func() (int64, error) {
		return c.deliveryDelaySeconds()
	})
}

func (c *mqlAwsSqsQueue) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs.queue", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSqsQueue) GetLastModified() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.LastModified, func() (*time.Time, error) {
		return c.lastModified()
	})
}

func (c *mqlAwsSqsQueue) GetMaxReceiveCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MaxReceiveCount, func() (int64, error) {
		return c.maxReceiveCount()
	})
}

func (c *mqlAwsSqsQueue) GetMaximumMessageSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MaximumMessageSize, func() (int64, error) {
		return c.maximumMessageSize()
	})
}

func (c *mqlAwsSqsQueue) GetMessageRetentionPeriodSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MessageRetentionPeriodSeconds, func() (int64, error) {
		return c.messageRetentionPeriodSeconds()
	})
}

func (c *mqlAwsSqsQueue) GetReceiveMessageWaitTimeSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.ReceiveMessageWaitTimeSeconds, func() (int64, error) {
		return c.receiveMessageWaitTimeSeconds()
	})
}

func (c *mqlAwsSqsQueue) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSqsQueue) GetSqsManagedSseEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.SqsManagedSseEnabled, func() (bool, error) {
		return c.sqsManagedSseEnabled()
	})
}

func (c *mqlAwsSqsQueue) GetQueueType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.QueueType, func() (string, error) {
		return c.queueType()
	})
}

func (c *mqlAwsSqsQueue) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlAwsSqsQueue) GetVisibilityTimeoutSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.VisibilityTimeoutSeconds, func() (int64, error) {
		return c.visibilityTimeoutSeconds()
	})
}

// mqlAwsRds for the aws.rds resource
type mqlAwsRds struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsInternal it will be used here
	DbInstances plugin.TValue[[]interface{}]
	Instances plugin.TValue[[]interface{}]
	DbClusters plugin.TValue[[]interface{}]
	Clusters plugin.TValue[[]interface{}]
	AllPendingMaintenanceActions plugin.TValue[[]interface{}]
}

// createAwsRds creates a new instance of this resource
func createAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRds{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRds) MqlName() string {
	return "aws.rds"
}

func (c *mqlAwsRds) MqlID() string {
	return c.__id
}

func (c *mqlAwsRds) GetDbInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DbInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "dbInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dbInstances()
	})
}

func (c *mqlAwsRds) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsRds) GetDbClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DbClusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "dbClusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dbClusters()
	})
}

func (c *mqlAwsRds) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsRds) GetAllPendingMaintenanceActions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AllPendingMaintenanceActions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "allPendingMaintenanceActions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.allPendingMaintenanceActions()
	})
}

// mqlAwsRdsBackupsetting for the aws.rds.backupsetting resource
type mqlAwsRdsBackupsetting struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsRdsBackupsettingInternal
	Target plugin.TValue[string]
	RetentionPeriod plugin.TValue[int64]
	DedicatedLogVolume plugin.TValue[bool]
	Encrypted plugin.TValue[bool]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	Timezone plugin.TValue[string]
	EarliestRestoreAvailable plugin.TValue[*time.Time]
	LatestRestoreAvailable plugin.TValue[*time.Time]
}

// createAwsRdsBackupsetting creates a new instance of this resource
func createAwsRdsBackupsetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsBackupsetting{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.backupsetting", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsBackupsetting) MqlName() string {
	return "aws.rds.backupsetting"
}

func (c *mqlAwsRdsBackupsetting) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsBackupsetting) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlAwsRdsBackupsetting) GetRetentionPeriod() *plugin.TValue[int64] {
	return &c.RetentionPeriod
}

func (c *mqlAwsRdsBackupsetting) GetDedicatedLogVolume() *plugin.TValue[bool] {
	return &c.DedicatedLogVolume
}

func (c *mqlAwsRdsBackupsetting) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRdsBackupsetting) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.backupsetting", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsRdsBackupsetting) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsBackupsetting) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsBackupsetting) GetTimezone() *plugin.TValue[string] {
	return &c.Timezone
}

func (c *mqlAwsRdsBackupsetting) GetEarliestRestoreAvailable() *plugin.TValue[*time.Time] {
	return &c.EarliestRestoreAvailable
}

func (c *mqlAwsRdsBackupsetting) GetLatestRestoreAvailable() *plugin.TValue[*time.Time] {
	return &c.LatestRestoreAvailable
}

// mqlAwsRdsDbcluster for the aws.rds.dbcluster resource
type mqlAwsRdsDbcluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsRdsDbclusterInternal
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Id plugin.TValue[string]
	Members plugin.TValue[[]interface{}]
	Snapshots plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
	StorageEncrypted plugin.TValue[bool]
	StorageAllocated plugin.TValue[int64]
	StorageIops plugin.TValue[int64]
	StorageType plugin.TValue[string]
	Status plugin.TValue[string]
	CreatedTime plugin.TValue[*time.Time]
	BackupRetentionPeriod plugin.TValue[int64]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	ClusterDbInstanceClass plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	PubliclyAccessible plugin.TValue[bool]
	MultiAZ plugin.TValue[bool]
	DeletionProtection plugin.TValue[bool]
	SecurityGroups plugin.TValue[[]interface{}]
	AvailabilityZones plugin.TValue[[]interface{}]
	Port plugin.TValue[int64]
	Endpoint plugin.TValue[string]
	HostedZoneId plugin.TValue[string]
	MasterUsername plugin.TValue[string]
	LatestRestorableTime plugin.TValue[*time.Time]
	BackupSettings plugin.TValue[[]interface{}]
	EngineLifecycleSupport plugin.TValue[string]
	CertificateExpiresAt plugin.TValue[*time.Time]
	CertificateAuthority plugin.TValue[string]
	IamDatabaseAuthentication plugin.TValue[bool]
	ActivityStreamMode plugin.TValue[string]
	ActivityStreamStatus plugin.TValue[string]
	MonitoringInterval plugin.TValue[int64]
	NetworkType plugin.TValue[string]
	PreferredMaintenanceWindow plugin.TValue[string]
	PreferredBackupWindow plugin.TValue[string]
}

// createAwsRdsDbcluster creates a new instance of this resource
func createAwsRdsDbcluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbcluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbcluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbcluster) MqlName() string {
	return "aws.rds.dbcluster"
}

func (c *mqlAwsRdsDbcluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbcluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbcluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbcluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbcluster) GetMembers() *plugin.TValue[[]interface{}] {
	return &c.Members
}

func (c *mqlAwsRdsDbcluster) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbcluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRdsDbcluster) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsRdsDbcluster) GetStorageAllocated() *plugin.TValue[int64] {
	return &c.StorageAllocated
}

func (c *mqlAwsRdsDbcluster) GetStorageIops() *plugin.TValue[int64] {
	return &c.StorageIops
}

func (c *mqlAwsRdsDbcluster) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsRdsDbcluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsDbcluster) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsRdsDbcluster) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsRdsDbcluster) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsRdsDbcluster) GetClusterDbInstanceClass() *plugin.TValue[string] {
	return &c.ClusterDbInstanceClass
}

func (c *mqlAwsRdsDbcluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsDbcluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsDbcluster) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRdsDbcluster) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsRdsDbcluster) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsRdsDbcluster) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsRdsDbcluster) GetAvailabilityZones() *plugin.TValue[[]interface{}] {
	return &c.AvailabilityZones
}

func (c *mqlAwsRdsDbcluster) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsDbcluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsRdsDbcluster) GetHostedZoneId() *plugin.TValue[string] {
	return &c.HostedZoneId
}

func (c *mqlAwsRdsDbcluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRdsDbcluster) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsRdsDbcluster) GetBackupSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.BackupSettings, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "backupSettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.backupSettings()
	})
}

func (c *mqlAwsRdsDbcluster) GetEngineLifecycleSupport() *plugin.TValue[string] {
	return &c.EngineLifecycleSupport
}

func (c *mqlAwsRdsDbcluster) GetCertificateExpiresAt() *plugin.TValue[*time.Time] {
	return &c.CertificateExpiresAt
}

func (c *mqlAwsRdsDbcluster) GetCertificateAuthority() *plugin.TValue[string] {
	return &c.CertificateAuthority
}

func (c *mqlAwsRdsDbcluster) GetIamDatabaseAuthentication() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthentication
}

func (c *mqlAwsRdsDbcluster) GetActivityStreamMode() *plugin.TValue[string] {
	return &c.ActivityStreamMode
}

func (c *mqlAwsRdsDbcluster) GetActivityStreamStatus() *plugin.TValue[string] {
	return &c.ActivityStreamStatus
}

func (c *mqlAwsRdsDbcluster) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsRdsDbcluster) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsRdsDbcluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRdsDbcluster) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

// mqlAwsRdsSnapshot for the aws.rds.snapshot resource
type mqlAwsRdsSnapshot struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsSnapshotInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attributes plugin.TValue[[]interface{}]
	Type plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	Region plugin.TValue[string]
	IsClusterSnapshot plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	Status plugin.TValue[string]
	Port plugin.TValue[int64]
	AllocatedStorage plugin.TValue[int64]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsRdsSnapshot creates a new instance of this resource
func createAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsSnapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsSnapshot) MqlName() string {
	return "aws.rds.snapshot"
}

func (c *mqlAwsRdsSnapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsSnapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsSnapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsSnapshot) GetAttributes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Attributes, func() ([]interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsRdsSnapshot) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsRdsSnapshot) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRdsSnapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsSnapshot) GetIsClusterSnapshot() *plugin.TValue[bool] {
	return &c.IsClusterSnapshot
}

func (c *mqlAwsRdsSnapshot) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRdsSnapshot) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsSnapshot) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsSnapshot) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsSnapshot) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsSnapshot) GetAllocatedStorage() *plugin.TValue[int64] {
	return &c.AllocatedStorage
}

func (c *mqlAwsRdsSnapshot) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsRdsDbinstance for the aws.rds.dbinstance resource
type mqlAwsRdsDbinstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsRdsDbinstanceInternal
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	BackupRetentionPeriod plugin.TValue[int64]
	Snapshots plugin.TValue[[]interface{}]
	StorageEncrypted plugin.TValue[bool]
	StorageAllocated plugin.TValue[int64]
	StorageIops plugin.TValue[int64]
	StorageType plugin.TValue[string]
	Region plugin.TValue[string]
	AvailabilityZone plugin.TValue[string]
	PubliclyAccessible plugin.TValue[bool]
	EnabledCloudwatchLogsExports plugin.TValue[[]interface{}]
	DeletionProtection plugin.TValue[bool]
	MultiAZ plugin.TValue[bool]
	MonitoringInterval plugin.TValue[int64]
	EnhancedMonitoringResourceArn plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	DbInstanceClass plugin.TValue[string]
	DbInstanceIdentifier plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	Status plugin.TValue[string]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	CreatedTime plugin.TValue[*time.Time]
	Port plugin.TValue[int64]
	Endpoint plugin.TValue[string]
	MasterUsername plugin.TValue[string]
	LatestRestorableTime plugin.TValue[*time.Time]
	BackupSettings plugin.TValue[[]interface{}]
	Subnets plugin.TValue[[]interface{}]
	EngineLifecycleSupport plugin.TValue[string]
	CertificateExpiresAt plugin.TValue[*time.Time]
	CertificateAuthority plugin.TValue[string]
	IamDatabaseAuthentication plugin.TValue[bool]
	CustomIamInstanceProfile plugin.TValue[string]
	ActivityStreamMode plugin.TValue[string]
	ActivityStreamStatus plugin.TValue[string]
	PendingMaintenanceActions plugin.TValue[[]interface{}]
	NetworkType plugin.TValue[string]
	PreferredMaintenanceWindow plugin.TValue[string]
	PreferredBackupWindow plugin.TValue[string]
}

// createAwsRdsDbinstance creates a new instance of this resource
func createAwsRdsDbinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbinstance) MqlName() string {
	return "aws.rds.dbinstance"
}

func (c *mqlAwsRdsDbinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbinstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsDbinstance) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsRdsDbinstance) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbinstance) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsRdsDbinstance) GetStorageAllocated() *plugin.TValue[int64] {
	return &c.StorageAllocated
}

func (c *mqlAwsRdsDbinstance) GetStorageIops() *plugin.TValue[int64] {
	return &c.StorageIops
}

func (c *mqlAwsRdsDbinstance) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsRdsDbinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbinstance) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRdsDbinstance) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRdsDbinstance) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]interface{}] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsRdsDbinstance) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsRdsDbinstance) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsRdsDbinstance) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsRdsDbinstance) GetEnhancedMonitoringResourceArn() *plugin.TValue[string] {
	return &c.EnhancedMonitoringResourceArn
}

func (c *mqlAwsRdsDbinstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceClass() *plugin.TValue[string] {
	return &c.DbInstanceClass
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceIdentifier() *plugin.TValue[string] {
	return &c.DbInstanceIdentifier
}

func (c *mqlAwsRdsDbinstance) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsDbinstance) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsDbinstance) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsRdsDbinstance) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsDbinstance) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsRdsDbinstance) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsRdsDbinstance) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsDbinstance) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsRdsDbinstance) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRdsDbinstance) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsRdsDbinstance) GetBackupSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.BackupSettings, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "backupSettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.backupSettings()
	})
}

func (c *mqlAwsRdsDbinstance) GetSubnets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subnets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subnets()
	})
}

func (c *mqlAwsRdsDbinstance) GetEngineLifecycleSupport() *plugin.TValue[string] {
	return &c.EngineLifecycleSupport
}

func (c *mqlAwsRdsDbinstance) GetCertificateExpiresAt() *plugin.TValue[*time.Time] {
	return &c.CertificateExpiresAt
}

func (c *mqlAwsRdsDbinstance) GetCertificateAuthority() *plugin.TValue[string] {
	return &c.CertificateAuthority
}

func (c *mqlAwsRdsDbinstance) GetIamDatabaseAuthentication() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthentication
}

func (c *mqlAwsRdsDbinstance) GetCustomIamInstanceProfile() *plugin.TValue[string] {
	return &c.CustomIamInstanceProfile
}

func (c *mqlAwsRdsDbinstance) GetActivityStreamMode() *plugin.TValue[string] {
	return &c.ActivityStreamMode
}

func (c *mqlAwsRdsDbinstance) GetActivityStreamStatus() *plugin.TValue[string] {
	return &c.ActivityStreamStatus
}

func (c *mqlAwsRdsDbinstance) GetPendingMaintenanceActions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PendingMaintenanceActions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "pendingMaintenanceActions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.pendingMaintenanceActions()
	})
}

func (c *mqlAwsRdsDbinstance) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsRdsDbinstance) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRdsDbinstance) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

// mqlAwsRdsPendingMaintenanceAction for the aws.rds.pendingMaintenanceAction resource
type mqlAwsRdsPendingMaintenanceAction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsPendingMaintenanceActionInternal it will be used here
	ResourceArn plugin.TValue[string]
	Action plugin.TValue[string]
	Description plugin.TValue[string]
	AutoAppliedAfterDate plugin.TValue[*time.Time]
	CurrentApplyDate plugin.TValue[*time.Time]
	ForcedApplyDate plugin.TValue[*time.Time]
	OptInStatus plugin.TValue[string]
}

// createAwsRdsPendingMaintenanceAction creates a new instance of this resource
func createAwsRdsPendingMaintenanceAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsPendingMaintenanceAction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.pendingMaintenanceAction", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsPendingMaintenanceAction) MqlName() string {
	return "aws.rds.pendingMaintenanceAction"
}

func (c *mqlAwsRdsPendingMaintenanceAction) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetResourceArn() *plugin.TValue[string] {
	return &c.ResourceArn
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetAction() *plugin.TValue[string] {
	return &c.Action
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetAutoAppliedAfterDate() *plugin.TValue[*time.Time] {
	return &c.AutoAppliedAfterDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetCurrentApplyDate() *plugin.TValue[*time.Time] {
	return &c.CurrentApplyDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetForcedApplyDate() *plugin.TValue[*time.Time] {
	return &c.ForcedApplyDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetOptInStatus() *plugin.TValue[string] {
	return &c.OptInStatus
}

// mqlAwsElasticache for the aws.elasticache resource
type mqlAwsElasticache struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElasticacheInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	CacheClusters plugin.TValue[[]interface{}]
	ServerlessCaches plugin.TValue[[]interface{}]
}

// createAwsElasticache creates a new instance of this resource
func createAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticache) MqlName() string {
	return "aws.elasticache"
}

func (c *mqlAwsElasticache) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticache) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		return c.clusters()
	})
}

func (c *mqlAwsElasticache) GetCacheClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CacheClusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache", c.__id, "cacheClusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.cacheClusters()
	})
}

func (c *mqlAwsElasticache) GetServerlessCaches() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ServerlessCaches, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache", c.__id, "serverlessCaches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.serverlessCaches()
	})
}

// mqlAwsElasticacheCluster for the aws.elasticache.cluster resource
type mqlAwsElasticacheCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsElasticacheClusterInternal
	Arn plugin.TValue[string]
	AtRestEncryptionEnabled plugin.TValue[bool]
	AuthTokenEnabled plugin.TValue[bool]
	AuthTokenLastModifiedDate plugin.TValue[*time.Time]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	CacheClusterCreateTime plugin.TValue[*time.Time]
	CacheClusterId plugin.TValue[string]
	CacheClusterStatus plugin.TValue[string]
	CacheNodeType plugin.TValue[string]
	CacheNodes plugin.TValue[[]interface{}]
	CacheSecurityGroups plugin.TValue[[]interface{}]
	CacheSubnetGroupName plugin.TValue[string]
	ClientDownloadLandingPage plugin.TValue[string]
	NodeType plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	IpDiscovery plugin.TValue[string]
	LogDeliveryConfigurations plugin.TValue[[]interface{}]
	NetworkType plugin.TValue[string]
	NotificationConfiguration plugin.TValue[string]
	NumCacheNodes plugin.TValue[int64]
	PreferredAvailabilityZone plugin.TValue[string]
	Region plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	SnapshotRetentionLimit plugin.TValue[int64]
	TransitEncryptionEnabled plugin.TValue[bool]
	TransitEncryptionMode plugin.TValue[string]
}

// createAwsElasticacheCluster creates a new instance of this resource
func createAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticacheCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticacheCluster) MqlName() string {
	return "aws.elasticache.cluster"
}

func (c *mqlAwsElasticacheCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticacheCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElasticacheCluster) GetAtRestEncryptionEnabled() *plugin.TValue[bool] {
	return &c.AtRestEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenEnabled() *plugin.TValue[bool] {
	return &c.AuthTokenEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenLastModifiedDate() *plugin.TValue[*time.Time] {
	return &c.AuthTokenLastModifiedDate
}

func (c *mqlAwsElasticacheCluster) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterCreateTime() *plugin.TValue[*time.Time] {
	return &c.CacheClusterCreateTime
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterId() *plugin.TValue[string] {
	return &c.CacheClusterId
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterStatus() *plugin.TValue[string] {
	return &c.CacheClusterStatus
}

func (c *mqlAwsElasticacheCluster) GetCacheNodeType() *plugin.TValue[string] {
	return &c.CacheNodeType
}

func (c *mqlAwsElasticacheCluster) GetCacheNodes() *plugin.TValue[[]interface{}] {
	return &c.CacheNodes
}

func (c *mqlAwsElasticacheCluster) GetCacheSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.CacheSecurityGroups
}

func (c *mqlAwsElasticacheCluster) GetCacheSubnetGroupName() *plugin.TValue[string] {
	return &c.CacheSubnetGroupName
}

func (c *mqlAwsElasticacheCluster) GetClientDownloadLandingPage() *plugin.TValue[string] {
	return &c.ClientDownloadLandingPage
}

func (c *mqlAwsElasticacheCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsElasticacheCluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsElasticacheCluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsElasticacheCluster) GetIpDiscovery() *plugin.TValue[string] {
	return &c.IpDiscovery
}

func (c *mqlAwsElasticacheCluster) GetLogDeliveryConfigurations() *plugin.TValue[[]interface{}] {
	return &c.LogDeliveryConfigurations
}

func (c *mqlAwsElasticacheCluster) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsElasticacheCluster) GetNotificationConfiguration() *plugin.TValue[string] {
	return &c.NotificationConfiguration
}

func (c *mqlAwsElasticacheCluster) GetNumCacheNodes() *plugin.TValue[int64] {
	return &c.NumCacheNodes
}

func (c *mqlAwsElasticacheCluster) GetPreferredAvailabilityZone() *plugin.TValue[string] {
	return &c.PreferredAvailabilityZone
}

func (c *mqlAwsElasticacheCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElasticacheCluster) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache.cluster", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsElasticacheCluster) GetSnapshotRetentionLimit() *plugin.TValue[int64] {
	return &c.SnapshotRetentionLimit
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionEnabled() *plugin.TValue[bool] {
	return &c.TransitEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionMode() *plugin.TValue[string] {
	return &c.TransitEncryptionMode
}

// mqlAwsElasticacheServerlessCache for the aws.elasticache.serverlessCache resource
type mqlAwsElasticacheServerlessCache struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsElasticacheServerlessCacheInternal
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	MajorEngineVersion plugin.TValue[string]
	KmsKeyId plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	SnapshotRetentionLimit plugin.TValue[int64]
	DailySnapshotTime plugin.TValue[string]
	Status plugin.TValue[string]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsElasticacheServerlessCache creates a new instance of this resource
func createAwsElasticacheServerlessCache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticacheServerlessCache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache.serverlessCache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticacheServerlessCache) MqlName() string {
	return "aws.elasticache.serverlessCache"
}

func (c *mqlAwsElasticacheServerlessCache) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticacheServerlessCache) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElasticacheServerlessCache) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElasticacheServerlessCache) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsElasticacheServerlessCache) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsElasticacheServerlessCache) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsElasticacheServerlessCache) GetMajorEngineVersion() *plugin.TValue[string] {
	return &c.MajorEngineVersion
}

func (c *mqlAwsElasticacheServerlessCache) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsElasticacheServerlessCache) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache.serverlessCache", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsElasticacheServerlessCache) GetSnapshotRetentionLimit() *plugin.TValue[int64] {
	return &c.SnapshotRetentionLimit
}

func (c *mqlAwsElasticacheServerlessCache) GetDailySnapshotTime() *plugin.TValue[string] {
	return &c.DailySnapshotTime
}

func (c *mqlAwsElasticacheServerlessCache) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsElasticacheServerlessCache) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElasticacheServerlessCache) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsRedshift for the aws.redshift resource
type mqlAwsRedshift struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRedshiftInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsRedshift creates a new instance of this resource
func createAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshift{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshift) MqlName() string {
	return "aws.redshift"
}

func (c *mqlAwsRedshift) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshift) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.redshift", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsRedshiftCluster for the aws.redshift.cluster resource
type mqlAwsRedshiftCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRedshiftClusterInternal it will be used here
	AllowVersionUpgrade plugin.TValue[bool]
	Arn plugin.TValue[string]
	AutomatedSnapshotRetentionPeriod plugin.TValue[int64]
	AvailabilityZone plugin.TValue[string]
	ClusterParameterGroupNames plugin.TValue[[]interface{}]
	ClusterRevisionNumber plugin.TValue[string]
	ClusterStatus plugin.TValue[string]
	ClusterSubnetGroupName plugin.TValue[string]
	ClusterVersion plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	DbName plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	EnhancedVpcRouting plugin.TValue[bool]
	Logging plugin.TValue[interface{}]
	MasterUsername plugin.TValue[string]
	Name plugin.TValue[string]
	NextMaintenanceWindowStartTime plugin.TValue[*time.Time]
	NodeType plugin.TValue[string]
	NumberOfNodes plugin.TValue[int64]
	Parameters plugin.TValue[[]interface{}]
	PreferredMaintenanceWindow plugin.TValue[string]
	PubliclyAccessible plugin.TValue[bool]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	VpcId plugin.TValue[string]
}

// createAwsRedshiftCluster creates a new instance of this resource
func createAwsRedshiftCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshiftCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshiftCluster) MqlName() string {
	return "aws.redshift.cluster"
}

func (c *mqlAwsRedshiftCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshiftCluster) GetAllowVersionUpgrade() *plugin.TValue[bool] {
	return &c.AllowVersionUpgrade
}

func (c *mqlAwsRedshiftCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRedshiftCluster) GetAutomatedSnapshotRetentionPeriod() *plugin.TValue[int64] {
	return &c.AutomatedSnapshotRetentionPeriod
}

func (c *mqlAwsRedshiftCluster) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRedshiftCluster) GetClusterParameterGroupNames() *plugin.TValue[[]interface{}] {
	return &c.ClusterParameterGroupNames
}

func (c *mqlAwsRedshiftCluster) GetClusterRevisionNumber() *plugin.TValue[string] {
	return &c.ClusterRevisionNumber
}

func (c *mqlAwsRedshiftCluster) GetClusterStatus() *plugin.TValue[string] {
	return &c.ClusterStatus
}

func (c *mqlAwsRedshiftCluster) GetClusterSubnetGroupName() *plugin.TValue[string] {
	return &c.ClusterSubnetGroupName
}

func (c *mqlAwsRedshiftCluster) GetClusterVersion() *plugin.TValue[string] {
	return &c.ClusterVersion
}

func (c *mqlAwsRedshiftCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsRedshiftCluster) GetDbName() *plugin.TValue[string] {
	return &c.DbName
}

func (c *mqlAwsRedshiftCluster) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRedshiftCluster) GetEnhancedVpcRouting() *plugin.TValue[bool] {
	return &c.EnhancedVpcRouting
}

func (c *mqlAwsRedshiftCluster) GetLogging() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Logging, func() (interface{}, error) {
		return c.logging()
	})
}

func (c *mqlAwsRedshiftCluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRedshiftCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRedshiftCluster) GetNextMaintenanceWindowStartTime() *plugin.TValue[*time.Time] {
	return &c.NextMaintenanceWindowStartTime
}

func (c *mqlAwsRedshiftCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsRedshiftCluster) GetNumberOfNodes() *plugin.TValue[int64] {
	return &c.NumberOfNodes
}

func (c *mqlAwsRedshiftCluster) GetParameters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Parameters, func() ([]interface{}, error) {
		return c.parameters()
	})
}

func (c *mqlAwsRedshiftCluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRedshiftCluster) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRedshiftCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRedshiftCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRedshiftCluster) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

// mqlAwsEcr for the aws.ecr resource
type mqlAwsEcr struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrInternal it will be used here
	PrivateRepositories plugin.TValue[[]interface{}]
	PublicRepositories plugin.TValue[[]interface{}]
	Images plugin.TValue[[]interface{}]
}

// createAwsEcr creates a new instance of this resource
func createAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcr) MqlName() string {
	return "aws.ecr"
}

func (c *mqlAwsEcr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcr) GetPrivateRepositories() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PrivateRepositories, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "privateRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.privateRepositories()
	})
}

func (c *mqlAwsEcr) GetPublicRepositories() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PublicRepositories, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "publicRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.publicRepositories()
	})
}

func (c *mqlAwsEcr) GetImages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Images, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.images()
	})
}

// mqlAwsEcrRepository for the aws.ecr.repository resource
type mqlAwsEcrRepository struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrRepositoryInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Uri plugin.TValue[string]
	RegistryId plugin.TValue[string]
	Public plugin.TValue[bool]
	Images plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	ImageScanOnPush plugin.TValue[bool]
}

// createAwsEcrRepository creates a new instance of this resource
func createAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrRepository) MqlName() string {
	return "aws.ecr.repository"
}

func (c *mqlAwsEcrRepository) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrRepository) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcrRepository) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

func (c *mqlAwsEcrRepository) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrRepository) GetPublic() *plugin.TValue[bool] {
	return &c.Public
}

func (c *mqlAwsEcrRepository) GetImages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Images, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr.repository", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.images()
	})
}

func (c *mqlAwsEcrRepository) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrRepository) GetImageScanOnPush() *plugin.TValue[bool] {
	return &c.ImageScanOnPush
}

// mqlAwsEcrImage for the aws.ecr.image resource
type mqlAwsEcrImage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrImageInternal it will be used here
	Digest plugin.TValue[string]
	MediaType plugin.TValue[string]
	Tags plugin.TValue[[]interface{}]
	RegistryId plugin.TValue[string]
	RepoName plugin.TValue[string]
	Region plugin.TValue[string]
	Arn plugin.TValue[string]
	Uri plugin.TValue[string]
}

// createAwsEcrImage creates a new instance of this resource
func createAwsEcrImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrImage) MqlName() string {
	return "aws.ecr.image"
}

func (c *mqlAwsEcrImage) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrImage) GetDigest() *plugin.TValue[string] {
	return &c.Digest
}

func (c *mqlAwsEcrImage) GetMediaType() *plugin.TValue[string] {
	return &c.MediaType
}

func (c *mqlAwsEcrImage) GetTags() *plugin.TValue[[]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcrImage) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrImage) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlAwsEcrImage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrImage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrImage) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

// mqlAwsDms for the aws.dms resource
type mqlAwsDms struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDmsInternal it will be used here
	ReplicationInstances plugin.TValue[[]interface{}]
}

// createAwsDms creates a new instance of this resource
func createAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDms) MqlName() string {
	return "aws.dms"
}

func (c *mqlAwsDms) MqlID() string {
	return c.__id
}

func (c *mqlAwsDms) GetReplicationInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ReplicationInstances, func() ([]interface{}, error) {
		return c.replicationInstances()
	})
}

// mqlAwsApigateway for the aws.apigateway resource
type mqlAwsApigateway struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayInternal it will be used here
	RestApis plugin.TValue[[]interface{}]
}

// createAwsApigateway creates a new instance of this resource
func createAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigateway) MqlName() string {
	return "aws.apigateway"
}

func (c *mqlAwsApigateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigateway) GetRestApis() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RestApis, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway", c.__id, "restApis")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.restApis()
	})
}

// mqlAwsApigatewayRestapi for the aws.apigateway.restapi resource
type mqlAwsApigatewayRestapi struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayRestapiInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreatedDate plugin.TValue[*time.Time]
	Description plugin.TValue[string]
	Stages plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsApigatewayRestapi creates a new instance of this resource
func createAwsApigatewayRestapi(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayRestapi{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.restapi", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayRestapi) MqlName() string {
	return "aws.apigateway.restapi"
}

func (c *mqlAwsApigatewayRestapi) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayRestapi) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayRestapi) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsApigatewayRestapi) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayRestapi) GetCreatedDate() *plugin.TValue[*time.Time] {
	return &c.CreatedDate
}

func (c *mqlAwsApigatewayRestapi) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayRestapi) GetStages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Stages, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway.restapi", c.__id, "stages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.stages()
	})
}

func (c *mqlAwsApigatewayRestapi) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsApigatewayRestapi) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsApigatewayStage for the aws.apigateway.stage resource
type mqlAwsApigatewayStage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayStageInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	TracingEnabled plugin.TValue[bool]
	Description plugin.TValue[string]
	DeploymentId plugin.TValue[string]
	MethodSettings plugin.TValue[interface{}]
}

// createAwsApigatewayStage creates a new instance of this resource
func createAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayStage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.stage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayStage) MqlName() string {
	return "aws.apigateway.stage"
}

func (c *mqlAwsApigatewayStage) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayStage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayStage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayStage) GetTracingEnabled() *plugin.TValue[bool] {
	return &c.TracingEnabled
}

func (c *mqlAwsApigatewayStage) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayStage) GetDeploymentId() *plugin.TValue[string] {
	return &c.DeploymentId
}

func (c *mqlAwsApigatewayStage) GetMethodSettings() *plugin.TValue[interface{}] {
	return &c.MethodSettings
}

// mqlAwsLambda for the aws.lambda resource
type mqlAwsLambda struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsLambdaInternal it will be used here
	Functions plugin.TValue[[]interface{}]
}

// createAwsLambda creates a new instance of this resource
func createAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambda{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambda) MqlName() string {
	return "aws.lambda"
}

func (c *mqlAwsLambda) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambda) GetFunctions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Functions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.lambda", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsLambdaFunction for the aws.lambda.function resource
type mqlAwsLambdaFunction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsLambdaFunctionInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Runtime plugin.TValue[string]
	Concurrency plugin.TValue[int64]
	DlqTargetArn plugin.TValue[string]
	Policy plugin.TValue[interface{}]
	VpcConfig plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsLambdaFunction creates a new instance of this resource
func createAwsLambdaFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambdaFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambdaFunction) MqlName() string {
	return "aws.lambda.function"
}

func (c *mqlAwsLambdaFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambdaFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsLambdaFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsLambdaFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

func (c *mqlAwsLambdaFunction) GetConcurrency() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Concurrency, func() (int64, error) {
		return c.concurrency()
	})
}

func (c *mqlAwsLambdaFunction) GetDlqTargetArn() *plugin.TValue[string] {
	return &c.DlqTargetArn
}

func (c *mqlAwsLambdaFunction) GetPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Policy, func() (interface{}, error) {
		return c.policy()
	})
}

func (c *mqlAwsLambdaFunction) GetVpcConfig() *plugin.TValue[interface{}] {
	return &c.VpcConfig
}

func (c *mqlAwsLambdaFunction) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsLambdaFunction) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSsm for the aws.ssm resource
type mqlAwsSsm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSsmInternal it will be used here
	Instances plugin.TValue[[]interface{}]
	Parameters plugin.TValue[[]interface{}]
}

// createAwsSsm creates a new instance of this resource
func createAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsm) MqlName() string {
	return "aws.ssm"
}

func (c *mqlAwsSsm) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsm) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsSsm) GetParameters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Parameters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm", c.__id, "parameters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.parameters()
	})
}

// mqlAwsSsmParameter for the aws.ssm.parameter resource
type mqlAwsSsmParameter struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsSsmParameterInternal
	AllowedPattern plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	DataType plugin.TValue[string]
	Description plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	LastModifiedDate plugin.TValue[*time.Time]
	Name plugin.TValue[string]
	Tier plugin.TValue[string]
	Type plugin.TValue[string]
	Version plugin.TValue[int64]
}

// createAwsSsmParameter creates a new instance of this resource
func createAwsSsmParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsmParameter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm.parameter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsmParameter) MqlName() string {
	return "aws.ssm.parameter"
}

func (c *mqlAwsSsmParameter) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsmParameter) GetAllowedPattern() *plugin.TValue[string] {
	return &c.AllowedPattern
}

func (c *mqlAwsSsmParameter) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSsmParameter) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSsmParameter) GetDataType() *plugin.TValue[string] {
	return &c.DataType
}

func (c *mqlAwsSsmParameter) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsSsmParameter) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm.parameter", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSsmParameter) GetLastModifiedDate() *plugin.TValue[*time.Time] {
	return &c.LastModifiedDate
}

func (c *mqlAwsSsmParameter) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSsmParameter) GetTier() *plugin.TValue[string] {
	return &c.Tier
}

func (c *mqlAwsSsmParameter) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsSsmParameter) GetVersion() *plugin.TValue[int64] {
	return &c.Version
}

// mqlAwsSsmInstance for the aws.ssm.instance resource
type mqlAwsSsmInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSsmInstanceInternal it will be used here
	InstanceId plugin.TValue[string]
	PingStatus plugin.TValue[string]
	IpAddress plugin.TValue[string]
	PlatformName plugin.TValue[string]
	PlatformType plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Region plugin.TValue[string]
	Arn plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSsmInstance creates a new instance of this resource
func createAwsSsmInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsmInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsmInstance) MqlName() string {
	return "aws.ssm.instance"
}

func (c *mqlAwsSsmInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsmInstance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsSsmInstance) GetPingStatus() *plugin.TValue[string] {
	return &c.PingStatus
}

func (c *mqlAwsSsmInstance) GetIpAddress() *plugin.TValue[string] {
	return &c.IpAddress
}

func (c *mqlAwsSsmInstance) GetPlatformName() *plugin.TValue[string] {
	return &c.PlatformName
}

func (c *mqlAwsSsmInstance) GetPlatformType() *plugin.TValue[string] {
	return &c.PlatformType
}

func (c *mqlAwsSsmInstance) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsSsmInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSsmInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSsmInstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsEc2 for the aws.ec2 resource
type mqlAwsEc2 struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2Internal it will be used here
	SecurityGroups plugin.TValue[[]interface{}]
	Instances plugin.TValue[[]interface{}]
	EbsEncryptionByDefault plugin.TValue[map[string]interface{}]
	Volumes plugin.TValue[[]interface{}]
	Snapshots plugin.TValue[[]interface{}]
	InternetGateways plugin.TValue[[]interface{}]
	VpnConnections plugin.TValue[[]interface{}]
	NetworkAcls plugin.TValue[[]interface{}]
	Keypairs plugin.TValue[[]interface{}]
	Eips plugin.TValue[[]interface{}]
}

// createAwsEc2 creates a new instance of this resource
func createAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2) MqlName() string {
	return "aws.ec2"
}

func (c *mqlAwsEc2) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsEc2) GetEbsEncryptionByDefault() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.EbsEncryptionByDefault, func() (map[string]interface{}, error) {
		return c.ebsEncryptionByDefault()
	})
}

func (c *mqlAwsEc2) GetVolumes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Volumes, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "volumes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.volumes()
	})
}

func (c *mqlAwsEc2) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsEc2) GetInternetGateways() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.InternetGateways, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "internetGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.internetGateways()
	})
}

func (c *mqlAwsEc2) GetVpnConnections() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.VpnConnections, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "vpnConnections")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vpnConnections()
	})
}

func (c *mqlAwsEc2) GetNetworkAcls() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NetworkAcls, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "networkAcls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.networkAcls()
	})
}

func (c *mqlAwsEc2) GetKeypairs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Keypairs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "keypairs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.keypairs()
	})
}

func (c *mqlAwsEc2) GetEips() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Eips, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "eips")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.eips()
	})
}

// mqlAwsEc2Eip for the aws.ec2.eip resource
type mqlAwsEc2Eip struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEc2EipInternal
	PublicIp plugin.TValue[string]
	Attached plugin.TValue[bool]
	Instance plugin.TValue[*mqlAwsEc2Instance]
	NetworkInterfaceId plugin.TValue[string]
	NetworkInterfaceOwnerId plugin.TValue[string]
	PrivateIpAddress plugin.TValue[string]
	PublicIpv4Pool plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
}

// createAwsEc2Eip creates a new instance of this resource
func createAwsEc2Eip(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Eip{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.eip", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Eip) MqlName() string {
	return "aws.ec2.eip"
}

func (c *mqlAwsEc2Eip) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Eip) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEc2Eip) GetAttached() *plugin.TValue[bool] {
	return &c.Attached
}

func (c *mqlAwsEc2Eip) GetInstance() *plugin.TValue[*mqlAwsEc2Instance] {
	return plugin.GetOrCompute[*mqlAwsEc2Instance](&c.Instance, func() (*mqlAwsEc2Instance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.eip", c.__id, "instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Instance), nil
			}
		}

		return c.instance()
	})
}

func (c *mqlAwsEc2Eip) GetNetworkInterfaceId() *plugin.TValue[string] {
	return &c.NetworkInterfaceId
}

func (c *mqlAwsEc2Eip) GetNetworkInterfaceOwnerId() *plugin.TValue[string] {
	return &c.NetworkInterfaceOwnerId
}

func (c *mqlAwsEc2Eip) GetPrivateIpAddress() *plugin.TValue[string] {
	return &c.PrivateIpAddress
}

func (c *mqlAwsEc2Eip) GetPublicIpv4Pool() *plugin.TValue[string] {
	return &c.PublicIpv4Pool
}

func (c *mqlAwsEc2Eip) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Eip) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsVpcNatgateway for the aws.vpc.natgateway resource
type mqlAwsVpcNatgateway struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsVpcNatgatewayInternal
	CreatedAt plugin.TValue[*time.Time]
	NatGatewayId plugin.TValue[string]
	State plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Vpc plugin.TValue[*mqlAwsVpc]
	Addresses plugin.TValue[[]interface{}]
	Subnet plugin.TValue[*mqlAwsVpcSubnet]
}

// createAwsVpcNatgateway creates a new instance of this resource
func createAwsVpcNatgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcNatgateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.natgateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcNatgateway) MqlName() string {
	return "aws.vpc.natgateway"
}

func (c *mqlAwsVpcNatgateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcNatgateway) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsVpcNatgateway) GetNatGatewayId() *plugin.TValue[string] {
	return &c.NatGatewayId
}

func (c *mqlAwsVpcNatgateway) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcNatgateway) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsVpcNatgateway) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsVpcNatgateway) GetAddresses() *plugin.TValue[[]interface{}] {
	return &c.Addresses
}

func (c *mqlAwsVpcNatgateway) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

// mqlAwsVpcNatgatewayAddress for the aws.vpc.natgateway.address resource
type mqlAwsVpcNatgatewayAddress struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsVpcNatgatewayAddressInternal
	AllocationId plugin.TValue[string]
	NetworkInterfaceId plugin.TValue[string]
	PrivateIp plugin.TValue[string]
	PublicIp plugin.TValue[*mqlAwsEc2Eip]
	IsPrimary plugin.TValue[bool]
}

// createAwsVpcNatgatewayAddress creates a new instance of this resource
func createAwsVpcNatgatewayAddress(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcNatgatewayAddress{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.natgateway.address", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcNatgatewayAddress) MqlName() string {
	return "aws.vpc.natgateway.address"
}

func (c *mqlAwsVpcNatgatewayAddress) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcNatgatewayAddress) GetAllocationId() *plugin.TValue[string] {
	return &c.AllocationId
}

func (c *mqlAwsVpcNatgatewayAddress) GetNetworkInterfaceId() *plugin.TValue[string] {
	return &c.NetworkInterfaceId
}

func (c *mqlAwsVpcNatgatewayAddress) GetPrivateIp() *plugin.TValue[string] {
	return &c.PrivateIp
}

func (c *mqlAwsVpcNatgatewayAddress) GetPublicIp() *plugin.TValue[*mqlAwsEc2Eip] {
	return plugin.GetOrCompute[*mqlAwsEc2Eip](&c.PublicIp, func() (*mqlAwsEc2Eip, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway.address", c.__id, "publicIp")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Eip), nil
			}
		}

		return c.publicIp()
	})
}

func (c *mqlAwsVpcNatgatewayAddress) GetIsPrimary() *plugin.TValue[bool] {
	return &c.IsPrimary
}

// mqlAwsVpcServiceEndpoint for the aws.vpc.serviceEndpoint resource
type mqlAwsVpcServiceEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcServiceEndpointInternal it will be used here
	AcceptanceRequired plugin.TValue[bool]
	AvailabilityZones plugin.TValue[[]interface{}]
	DnsNames plugin.TValue[[]interface{}]
	Id plugin.TValue[string]
	ManagesVpcEndpoints plugin.TValue[bool]
	Name plugin.TValue[string]
	Owner plugin.TValue[string]
	PayerResponsibility plugin.TValue[string]
	PrivateDnsNameVerificationState plugin.TValue[string]
	PrivateDnsNames plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
	Type plugin.TValue[string]
	VpcEndpointPolicySupported plugin.TValue[bool]
}

// createAwsVpcServiceEndpoint creates a new instance of this resource
func createAwsVpcServiceEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcServiceEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.serviceEndpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcServiceEndpoint) MqlName() string {
	return "aws.vpc.serviceEndpoint"
}

func (c *mqlAwsVpcServiceEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcServiceEndpoint) GetAcceptanceRequired() *plugin.TValue[bool] {
	return &c.AcceptanceRequired
}

func (c *mqlAwsVpcServiceEndpoint) GetAvailabilityZones() *plugin.TValue[[]interface{}] {
	return &c.AvailabilityZones
}

func (c *mqlAwsVpcServiceEndpoint) GetDnsNames() *plugin.TValue[[]interface{}] {
	return &c.DnsNames
}

func (c *mqlAwsVpcServiceEndpoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcServiceEndpoint) GetManagesVpcEndpoints() *plugin.TValue[bool] {
	return &c.ManagesVpcEndpoints
}

func (c *mqlAwsVpcServiceEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsVpcServiceEndpoint) GetOwner() *plugin.TValue[string] {
	return &c.Owner
}

func (c *mqlAwsVpcServiceEndpoint) GetPayerResponsibility() *plugin.TValue[string] {
	return &c.PayerResponsibility
}

func (c *mqlAwsVpcServiceEndpoint) GetPrivateDnsNameVerificationState() *plugin.TValue[string] {
	return &c.PrivateDnsNameVerificationState
}

func (c *mqlAwsVpcServiceEndpoint) GetPrivateDnsNames() *plugin.TValue[[]interface{}] {
	return &c.PrivateDnsNames
}

func (c *mqlAwsVpcServiceEndpoint) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsVpcServiceEndpoint) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcServiceEndpoint) GetVpcEndpointPolicySupported() *plugin.TValue[bool] {
	return &c.VpcEndpointPolicySupported
}

// mqlAwsVpcPeeringConnection for the aws.vpc.peeringConnection resource
type mqlAwsVpcPeeringConnection struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsVpcPeeringConnectionInternal
	AcceptorVpc plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc]
	ExpirationTime plugin.TValue[*time.Time]
	Id plugin.TValue[string]
	RequestorVpc plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc]
	Status plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpcPeeringConnection creates a new instance of this resource
func createAwsVpcPeeringConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcPeeringConnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.peeringConnection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcPeeringConnection) MqlName() string {
	return "aws.vpc.peeringConnection"
}

func (c *mqlAwsVpcPeeringConnection) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcPeeringConnection) GetAcceptorVpc() *plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc] {
	return plugin.GetOrCompute[*mqlAwsVpcPeeringConnectionPeeringVpc](&c.AcceptorVpc, func() (*mqlAwsVpcPeeringConnectionPeeringVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection", c.__id, "acceptorVpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcPeeringConnectionPeeringVpc), nil
			}
		}

		return c.acceptorVpc()
	})
}

func (c *mqlAwsVpcPeeringConnection) GetExpirationTime() *plugin.TValue[*time.Time] {
	return &c.ExpirationTime
}

func (c *mqlAwsVpcPeeringConnection) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcPeeringConnection) GetRequestorVpc() *plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc] {
	return plugin.GetOrCompute[*mqlAwsVpcPeeringConnectionPeeringVpc](&c.RequestorVpc, func() (*mqlAwsVpcPeeringConnectionPeeringVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection", c.__id, "requestorVpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcPeeringConnectionPeeringVpc), nil
			}
		}

		return c.requestorVpc()
	})
}

func (c *mqlAwsVpcPeeringConnection) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcPeeringConnection) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsVpcPeeringConnectionPeeringVpc for the aws.vpc.peeringConnection.peeringVpc resource
type mqlAwsVpcPeeringConnectionPeeringVpc struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcPeeringConnectionPeeringVpcInternal it will be used here
	AllowDnsResolutionFromRemoteVpc plugin.TValue[bool]
	AllowEgressFromLocalClassicLinkToRemoteVpc plugin.TValue[bool]
	AllowEgressFromLocalVpcToRemoteClassicLink plugin.TValue[bool]
	Ipv4CiderBlocks plugin.TValue[[]interface{}]
	Ipv6CiderBlocks plugin.TValue[[]interface{}]
	OwnerID plugin.TValue[string]
	Region plugin.TValue[string]
	Vpc plugin.TValue[*mqlAwsVpc]
	VpcId plugin.TValue[string]
}

// createAwsVpcPeeringConnectionPeeringVpc creates a new instance of this resource
func createAwsVpcPeeringConnectionPeeringVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcPeeringConnectionPeeringVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.peeringConnection.peeringVpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) MqlName() string {
	return "aws.vpc.peeringConnection.peeringVpc"
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetAllowDnsResolutionFromRemoteVpc() *plugin.TValue[bool] {
	return &c.AllowDnsResolutionFromRemoteVpc
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetAllowEgressFromLocalClassicLinkToRemoteVpc() *plugin.TValue[bool] {
	return &c.AllowEgressFromLocalClassicLinkToRemoteVpc
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetAllowEgressFromLocalVpcToRemoteClassicLink() *plugin.TValue[bool] {
	return &c.AllowEgressFromLocalVpcToRemoteClassicLink
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetIpv4CiderBlocks() *plugin.TValue[[]interface{}] {
	return &c.Ipv4CiderBlocks
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetIpv6CiderBlocks() *plugin.TValue[[]interface{}] {
	return &c.Ipv6CiderBlocks
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetOwnerID() *plugin.TValue[string] {
	return &c.OwnerID
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection.peeringVpc", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

// mqlAwsEc2Networkacl for the aws.ec2.networkacl resource
type mqlAwsEc2Networkacl struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Entries plugin.TValue[[]interface{}]
	IsDefault plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
	Associations plugin.TValue[[]interface{}]
}

// createAwsEc2Networkacl creates a new instance of this resource
func createAwsEc2Networkacl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Networkacl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Networkacl) MqlName() string {
	return "aws.ec2.networkacl"
}

func (c *mqlAwsEc2Networkacl) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Networkacl) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Networkacl) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Networkacl) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Networkacl) GetEntries() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Entries, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl", c.__id, "entries")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.entries()
	})
}

func (c *mqlAwsEc2Networkacl) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsEc2Networkacl) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Networkacl) GetAssociations() *plugin.TValue[[]interface{}] {
	return &c.Associations
}

// mqlAwsEc2NetworkaclAssociation for the aws.ec2.networkacl.association resource
type mqlAwsEc2NetworkaclAssociation struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclAssociationInternal it will be used here
	AssociationId plugin.TValue[string]
	NetworkAclId plugin.TValue[string]
	SubnetId plugin.TValue[string]
}

// createAwsEc2NetworkaclAssociation creates a new instance of this resource
func createAwsEc2NetworkaclAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclAssociation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.association", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclAssociation) MqlName() string {
	return "aws.ec2.networkacl.association"
}

func (c *mqlAwsEc2NetworkaclAssociation) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclAssociation) GetAssociationId() *plugin.TValue[string] {
	return &c.AssociationId
}

func (c *mqlAwsEc2NetworkaclAssociation) GetNetworkAclId() *plugin.TValue[string] {
	return &c.NetworkAclId
}

func (c *mqlAwsEc2NetworkaclAssociation) GetSubnetId() *plugin.TValue[string] {
	return &c.SubnetId
}

// mqlAwsEc2NetworkaclEntry for the aws.ec2.networkacl.entry resource
type mqlAwsEc2NetworkaclEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclEntryInternal it will be used here
	Egress plugin.TValue[bool]
	RuleAction plugin.TValue[string]
	RuleNumber plugin.TValue[int64]
	PortRange plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange]
	CidrBlock plugin.TValue[string]
	Ipv6CidrBlock plugin.TValue[string]
	Id plugin.TValue[string]
}

// createAwsEc2NetworkaclEntry creates a new instance of this resource
func createAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntry) MqlName() string {
	return "aws.ec2.networkacl.entry"
}

func (c *mqlAwsEc2NetworkaclEntry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntry) GetEgress() *plugin.TValue[bool] {
	return &c.Egress
}

func (c *mqlAwsEc2NetworkaclEntry) GetRuleAction() *plugin.TValue[string] {
	return &c.RuleAction
}

func (c *mqlAwsEc2NetworkaclEntry) GetRuleNumber() *plugin.TValue[int64] {
	return &c.RuleNumber
}

func (c *mqlAwsEc2NetworkaclEntry) GetPortRange() *plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange] {
	return plugin.GetOrCompute[*mqlAwsEc2NetworkaclEntryPortrange](&c.PortRange, func() (*mqlAwsEc2NetworkaclEntryPortrange, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl.entry", c.__id, "portRange")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2NetworkaclEntryPortrange), nil
			}
		}

		return c.portRange()
	})
}

func (c *mqlAwsEc2NetworkaclEntry) GetCidrBlock() *plugin.TValue[string] {
	return &c.CidrBlock
}

func (c *mqlAwsEc2NetworkaclEntry) GetIpv6CidrBlock() *plugin.TValue[string] {
	return &c.Ipv6CidrBlock
}

func (c *mqlAwsEc2NetworkaclEntry) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2NetworkaclEntryPortrange for the aws.ec2.networkacl.entry.portrange resource
type mqlAwsEc2NetworkaclEntryPortrange struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclEntryPortrangeInternal it will be used here
	From plugin.TValue[int64]
	To plugin.TValue[int64]
	Id plugin.TValue[string]
}

// createAwsEc2NetworkaclEntryPortrange creates a new instance of this resource
func createAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntryPortrange{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry.portrange", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlName() string {
	return "aws.ec2.networkacl.entry.portrange"
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetFrom() *plugin.TValue[int64] {
	return &c.From
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetTo() *plugin.TValue[int64] {
	return &c.To
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2Vpnconnection for the aws.ec2.vpnconnection resource
type mqlAwsEc2Vpnconnection struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VpnconnectionInternal it will be used here
	Arn plugin.TValue[string]
	VgwTelemetry plugin.TValue[[]interface{}]
}

// createAwsEc2Vpnconnection creates a new instance of this resource
func createAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vpnconnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vpnconnection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vpnconnection) MqlName() string {
	return "aws.ec2.vpnconnection"
}

func (c *mqlAwsEc2Vpnconnection) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vpnconnection) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Vpnconnection) GetVgwTelemetry() *plugin.TValue[[]interface{}] {
	return &c.VgwTelemetry
}

// mqlAwsEc2Vgwtelemetry for the aws.ec2.vgwtelemetry resource
type mqlAwsEc2Vgwtelemetry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VgwtelemetryInternal it will be used here
	OutsideIpAddress plugin.TValue[string]
	Status plugin.TValue[string]
	StatusMessage plugin.TValue[string]
}

// createAwsEc2Vgwtelemetry creates a new instance of this resource
func createAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vgwtelemetry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vgwtelemetry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vgwtelemetry) MqlName() string {
	return "aws.ec2.vgwtelemetry"
}

func (c *mqlAwsEc2Vgwtelemetry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vgwtelemetry) GetOutsideIpAddress() *plugin.TValue[string] {
	return &c.OutsideIpAddress
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatusMessage() *plugin.TValue[string] {
	return &c.StatusMessage
}

// mqlAwsEc2Internetgateway for the aws.ec2.internetgateway resource
type mqlAwsEc2Internetgateway struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2InternetgatewayInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attachments plugin.TValue[[]interface{}]
}

// createAwsEc2Internetgateway creates a new instance of this resource
func createAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Internetgateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.internetgateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Internetgateway) MqlName() string {
	return "aws.ec2.internetgateway"
}

func (c *mqlAwsEc2Internetgateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Internetgateway) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Internetgateway) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Internetgateway) GetAttachments() *plugin.TValue[[]interface{}] {
	return &c.Attachments
}

// mqlAwsEc2Snapshot for the aws.ec2.snapshot resource
type mqlAwsEc2Snapshot struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2SnapshotInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	CreateVolumePermission plugin.TValue[[]interface{}]
	VolumeId plugin.TValue[string]
	StartTime plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	State plugin.TValue[string]
	VolumeSize plugin.TValue[int64]
	Description plugin.TValue[string]
	Encrypted plugin.TValue[bool]
}

// createAwsEc2Snapshot creates a new instance of this resource
func createAwsEc2Snapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Snapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Snapshot) MqlName() string {
	return "aws.ec2.snapshot"
}

func (c *mqlAwsEc2Snapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Snapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Snapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Snapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Snapshot) GetCreateVolumePermission() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CreateVolumePermission, func() ([]interface{}, error) {
		return c.createVolumePermission()
	})
}

func (c *mqlAwsEc2Snapshot) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2Snapshot) GetStartTime() *plugin.TValue[*time.Time] {
	return &c.StartTime
}

func (c *mqlAwsEc2Snapshot) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Snapshot) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Snapshot) GetVolumeSize() *plugin.TValue[int64] {
	return &c.VolumeSize
}

func (c *mqlAwsEc2Snapshot) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Snapshot) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

// mqlAwsEc2Volume for the aws.ec2.volume resource
type mqlAwsEc2Volume struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VolumeInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attachments plugin.TValue[[]interface{}]
	Encrypted plugin.TValue[bool]
	State plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	AvailabilityZone plugin.TValue[string]
	VolumeType plugin.TValue[string]
	CreateTime plugin.TValue[*time.Time]
	Region plugin.TValue[string]
	MultiAttachEnabled plugin.TValue[bool]
	Throughput plugin.TValue[int64]
	Size plugin.TValue[int64]
	Iops plugin.TValue[int64]
}

// createAwsEc2Volume creates a new instance of this resource
func createAwsEc2Volume(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Volume{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.volume", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Volume) MqlName() string {
	return "aws.ec2.volume"
}

func (c *mqlAwsEc2Volume) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Volume) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Volume) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Volume) GetAttachments() *plugin.TValue[[]interface{}] {
	return &c.Attachments
}

func (c *mqlAwsEc2Volume) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEc2Volume) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Volume) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Volume) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEc2Volume) GetVolumeType() *plugin.TValue[string] {
	return &c.VolumeType
}

func (c *mqlAwsEc2Volume) GetCreateTime() *plugin.TValue[*time.Time] {
	return &c.CreateTime
}

func (c *mqlAwsEc2Volume) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Volume) GetMultiAttachEnabled() *plugin.TValue[bool] {
	return &c.MultiAttachEnabled
}

func (c *mqlAwsEc2Volume) GetThroughput() *plugin.TValue[int64] {
	return &c.Throughput
}

func (c *mqlAwsEc2Volume) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlAwsEc2Volume) GetIops() *plugin.TValue[int64] {
	return &c.Iops
}

// mqlAwsInspector for the aws.inspector resource
type mqlAwsInspector struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInspectorInternal it will be used here
	Coverages plugin.TValue[[]interface{}]
}

// createAwsInspector creates a new instance of this resource
func createAwsInspector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspector) MqlName() string {
	return "aws.inspector"
}

func (c *mqlAwsInspector) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspector) GetCoverages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Coverages, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector", c.__id, "coverages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.coverages()
	})
}

// mqlAwsInspectorCoverage for the aws.inspector.coverage resource
type mqlAwsInspectorCoverage struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsInspectorCoverageInternal
	AccountId plugin.TValue[string]
	ResourceId plugin.TValue[string]
	ResourceType plugin.TValue[string]
	LastScannedAt plugin.TValue[*time.Time]
	StatusReason plugin.TValue[string]
	StatusCode plugin.TValue[string]
	ScanType plugin.TValue[string]
	Region plugin.TValue[string]
	Ec2Instance plugin.TValue[*mqlAwsInspectorCoverageInstance]
	EcrImage plugin.TValue[*mqlAwsInspectorCoverageImage]
	EcrRepo plugin.TValue[*mqlAwsInspectorCoverageRepository]
	Lambda plugin.TValue[*mqlAwsLambdaFunction]
}

// createAwsInspectorCoverage creates a new instance of this resource
func createAwsInspectorCoverage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverage) MqlName() string {
	return "aws.inspector.coverage"
}

func (c *mqlAwsInspectorCoverage) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverage) GetAccountId() *plugin.TValue[string] {
	return &c.AccountId
}

func (c *mqlAwsInspectorCoverage) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsInspectorCoverage) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsInspectorCoverage) GetLastScannedAt() *plugin.TValue[*time.Time] {
	return &c.LastScannedAt
}

func (c *mqlAwsInspectorCoverage) GetStatusReason() *plugin.TValue[string] {
	return &c.StatusReason
}

func (c *mqlAwsInspectorCoverage) GetStatusCode() *plugin.TValue[string] {
	return &c.StatusCode
}

func (c *mqlAwsInspectorCoverage) GetScanType() *plugin.TValue[string] {
	return &c.ScanType
}

func (c *mqlAwsInspectorCoverage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsInspectorCoverage) GetEc2Instance() *plugin.TValue[*mqlAwsInspectorCoverageInstance] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageInstance](&c.Ec2Instance, func() (*mqlAwsInspectorCoverageInstance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ec2Instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageInstance), nil
			}
		}

		return c.ec2Instance()
	})
}

func (c *mqlAwsInspectorCoverage) GetEcrImage() *plugin.TValue[*mqlAwsInspectorCoverageImage] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageImage](&c.EcrImage, func() (*mqlAwsInspectorCoverageImage, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ecrImage")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageImage), nil
			}
		}

		return c.ecrImage()
	})
}

func (c *mqlAwsInspectorCoverage) GetEcrRepo() *plugin.TValue[*mqlAwsInspectorCoverageRepository] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageRepository](&c.EcrRepo, func() (*mqlAwsInspectorCoverageRepository, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ecrRepo")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageRepository), nil
			}
		}

		return c.ecrRepo()
	})
}

func (c *mqlAwsInspectorCoverage) GetLambda() *plugin.TValue[*mqlAwsLambdaFunction] {
	return plugin.GetOrCompute[*mqlAwsLambdaFunction](&c.Lambda, func() (*mqlAwsLambdaFunction, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "lambda")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsLambdaFunction), nil
			}
		}

		return c.lambda()
	})
}

// mqlAwsInspectorCoverageInstance for the aws.inspector.coverage.instance resource
type mqlAwsInspectorCoverageInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsInspectorCoverageInstanceInternal
	Platform plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Image plugin.TValue[*mqlAwsEc2Image]
	Region plugin.TValue[string]
}

// createAwsInspectorCoverageInstance creates a new instance of this resource
func createAwsInspectorCoverageInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageInstance) MqlName() string {
	return "aws.inspector.coverage.instance"
}

func (c *mqlAwsInspectorCoverageInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageInstance) GetPlatform() *plugin.TValue[string] {
	return &c.Platform
}

func (c *mqlAwsInspectorCoverageInstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsInspectorCoverageInstance) GetImage() *plugin.TValue[*mqlAwsEc2Image] {
	return &c.Image
}

func (c *mqlAwsInspectorCoverageInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsInspectorCoverageImage for the aws.inspector.coverage.image resource
type mqlAwsInspectorCoverageImage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInspectorCoverageImageInternal it will be used here
	ImagePulledAt plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
}

// createAwsInspectorCoverageImage creates a new instance of this resource
func createAwsInspectorCoverageImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageImage) MqlName() string {
	return "aws.inspector.coverage.image"
}

func (c *mqlAwsInspectorCoverageImage) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageImage) GetImagePulledAt() *plugin.TValue[*time.Time] {
	return &c.ImagePulledAt
}

func (c *mqlAwsInspectorCoverageImage) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsInspectorCoverageImage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsInspectorCoverageRepository for the aws.inspector.coverage.repository resource
type mqlAwsInspectorCoverageRepository struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInspectorCoverageRepositoryInternal it will be used here
	Name plugin.TValue[string]
	ScanFrequency plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsInspectorCoverageRepository creates a new instance of this resource
func createAwsInspectorCoverageRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageRepository) MqlName() string {
	return "aws.inspector.coverage.repository"
}

func (c *mqlAwsInspectorCoverageRepository) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsInspectorCoverageRepository) GetScanFrequency() *plugin.TValue[string] {
	return &c.ScanFrequency
}

func (c *mqlAwsInspectorCoverageRepository) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEc2Instance for the aws.ec2.instance resource
type mqlAwsEc2Instance struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEc2InstanceInternal
	Arn plugin.TValue[string]
	InstanceId plugin.TValue[string]
	DetailedMonitoring plugin.TValue[string]
	Region plugin.TValue[string]
	PublicIp plugin.TValue[string]
	Ssm plugin.TValue[interface{}]
	Vpc plugin.TValue[*mqlAwsVpc]
	HttpTokens plugin.TValue[string]
	HttpEndpoint plugin.TValue[string]
	PatchState plugin.TValue[interface{}]
	State plugin.TValue[string]
	DeviceMappings plugin.TValue[[]interface{}]
	SecurityGroups plugin.TValue[[]interface{}]
	PlatformDetails plugin.TValue[string]
	PublicDnsName plugin.TValue[string]
	InstanceStatus plugin.TValue[interface{}]
	StateReason plugin.TValue[interface{}]
	StateTransitionReason plugin.TValue[string]
	EbsOptimized plugin.TValue[bool]
	EnaSupported plugin.TValue[bool]
	InstanceType plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Image plugin.TValue[*mqlAwsEc2Image]
	LaunchTime plugin.TValue[*time.Time]
	PrivateIp plugin.TValue[string]
	PrivateDnsName plugin.TValue[string]
	Keypair plugin.TValue[*mqlAwsEc2Keypair]
	StateTransitionTime plugin.TValue[*time.Time]
	VpcArn plugin.TValue[string]
	Hypervisor plugin.TValue[string]
	InstanceLifecycle plugin.TValue[string]
	RootDeviceType plugin.TValue[string]
	RootDeviceName plugin.TValue[string]
	Architecture plugin.TValue[string]
	TpmSupport plugin.TValue[string]
	NetworkInterfaces plugin.TValue[[]interface{}]
}

// createAwsEc2Instance creates a new instance of this resource
func createAwsEc2Instance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Instance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Instance) MqlName() string {
	return "aws.ec2.instance"
}

func (c *mqlAwsEc2Instance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Instance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Instance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsEc2Instance) GetDetailedMonitoring() *plugin.TValue[string] {
	return &c.DetailedMonitoring
}

func (c *mqlAwsEc2Instance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Instance) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEc2Instance) GetSsm() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Ssm, func() (interface{}, error) {
		return c.ssm()
	})
}

func (c *mqlAwsEc2Instance) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Instance) GetHttpTokens() *plugin.TValue[string] {
	return &c.HttpTokens
}

func (c *mqlAwsEc2Instance) GetHttpEndpoint() *plugin.TValue[string] {
	return &c.HttpEndpoint
}

func (c *mqlAwsEc2Instance) GetPatchState() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.PatchState, func() (interface{}, error) {
		return c.patchState()
	})
}

func (c *mqlAwsEc2Instance) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Instance) GetDeviceMappings() *plugin.TValue[[]interface{}] {
	return &c.DeviceMappings
}

func (c *mqlAwsEc2Instance) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2Instance) GetPlatformDetails() *plugin.TValue[string] {
	return &c.PlatformDetails
}

func (c *mqlAwsEc2Instance) GetPublicDnsName() *plugin.TValue[string] {
	return &c.PublicDnsName
}

func (c *mqlAwsEc2Instance) GetInstanceStatus() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.InstanceStatus, func() (interface{}, error) {
		return c.instanceStatus()
	})
}

func (c *mqlAwsEc2Instance) GetStateReason() *plugin.TValue[interface{}] {
	return &c.StateReason
}

func (c *mqlAwsEc2Instance) GetStateTransitionReason() *plugin.TValue[string] {
	return &c.StateTransitionReason
}

func (c *mqlAwsEc2Instance) GetEbsOptimized() *plugin.TValue[bool] {
	return &c.EbsOptimized
}

func (c *mqlAwsEc2Instance) GetEnaSupported() *plugin.TValue[bool] {
	return &c.EnaSupported
}

func (c *mqlAwsEc2Instance) GetInstanceType() *plugin.TValue[string] {
	return &c.InstanceType
}

func (c *mqlAwsEc2Instance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Instance) GetImage() *plugin.TValue[*mqlAwsEc2Image] {
	return plugin.GetOrCompute[*mqlAwsEc2Image](&c.Image, func() (*mqlAwsEc2Image, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "image")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Image), nil
			}
		}

		return c.image()
	})
}

func (c *mqlAwsEc2Instance) GetLaunchTime() *plugin.TValue[*time.Time] {
	return &c.LaunchTime
}

func (c *mqlAwsEc2Instance) GetPrivateIp() *plugin.TValue[string] {
	return &c.PrivateIp
}

func (c *mqlAwsEc2Instance) GetPrivateDnsName() *plugin.TValue[string] {
	return &c.PrivateDnsName
}

func (c *mqlAwsEc2Instance) GetKeypair() *plugin.TValue[*mqlAwsEc2Keypair] {
	return plugin.GetOrCompute[*mqlAwsEc2Keypair](&c.Keypair, func() (*mqlAwsEc2Keypair, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "keypair")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Keypair), nil
			}
		}

		return c.keypair()
	})
}

func (c *mqlAwsEc2Instance) GetStateTransitionTime() *plugin.TValue[*time.Time] {
	return &c.StateTransitionTime
}

func (c *mqlAwsEc2Instance) GetVpcArn() *plugin.TValue[string] {
	return &c.VpcArn
}

func (c *mqlAwsEc2Instance) GetHypervisor() *plugin.TValue[string] {
	return &c.Hypervisor
}

func (c *mqlAwsEc2Instance) GetInstanceLifecycle() *plugin.TValue[string] {
	return &c.InstanceLifecycle
}

func (c *mqlAwsEc2Instance) GetRootDeviceType() *plugin.TValue[string] {
	return &c.RootDeviceType
}

func (c *mqlAwsEc2Instance) GetRootDeviceName() *plugin.TValue[string] {
	return &c.RootDeviceName
}

func (c *mqlAwsEc2Instance) GetArchitecture() *plugin.TValue[string] {
	return &c.Architecture
}

func (c *mqlAwsEc2Instance) GetTpmSupport() *plugin.TValue[string] {
	return &c.TpmSupport
}

func (c *mqlAwsEc2Instance) GetNetworkInterfaces() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NetworkInterfaces, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "networkInterfaces")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.networkInterfaces()
	})
}

// mqlAwsEc2Networkinterface for the aws.ec2.networkinterface resource
type mqlAwsEc2Networkinterface struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEc2NetworkinterfaceInternal
	Id plugin.TValue[string]
	Description plugin.TValue[string]
	Subnet plugin.TValue[*mqlAwsVpcSubnet]
	Vpc plugin.TValue[*mqlAwsVpc]
	Status plugin.TValue[string]
	SourceDestCheck plugin.TValue[bool]
	RequesterManaged plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
	AvailabilityZone plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	Ipv6Native plugin.TValue[bool]
	MacAddress plugin.TValue[string]
	PrivateDnsName plugin.TValue[string]
	PrivateIpAddress plugin.TValue[string]
}

// createAwsEc2Networkinterface creates a new instance of this resource
func createAwsEc2Networkinterface(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Networkinterface{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkinterface", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Networkinterface) MqlName() string {
	return "aws.ec2.networkinterface"
}

func (c *mqlAwsEc2Networkinterface) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Networkinterface) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Networkinterface) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Networkinterface) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

func (c *mqlAwsEc2Networkinterface) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Networkinterface) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2Networkinterface) GetSourceDestCheck() *plugin.TValue[bool] {
	return &c.SourceDestCheck
}

func (c *mqlAwsEc2Networkinterface) GetRequesterManaged() *plugin.TValue[bool] {
	return &c.RequesterManaged
}

func (c *mqlAwsEc2Networkinterface) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Networkinterface) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEc2Networkinterface) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2Networkinterface) GetIpv6Native() *plugin.TValue[bool] {
	return &c.Ipv6Native
}

func (c *mqlAwsEc2Networkinterface) GetMacAddress() *plugin.TValue[string] {
	return &c.MacAddress
}

func (c *mqlAwsEc2Networkinterface) GetPrivateDnsName() *plugin.TValue[string] {
	return &c.PrivateDnsName
}

func (c *mqlAwsEc2Networkinterface) GetPrivateIpAddress() *plugin.TValue[string] {
	return &c.PrivateIpAddress
}

// mqlAwsEc2Keypair for the aws.ec2.keypair resource
type mqlAwsEc2Keypair struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2KeypairInternal it will be used here
	Arn plugin.TValue[string]
	Fingerprint plugin.TValue[string]
	Name plugin.TValue[string]
	Type plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsEc2Keypair creates a new instance of this resource
func createAwsEc2Keypair(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Keypair{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.keypair", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Keypair) MqlName() string {
	return "aws.ec2.keypair"
}

func (c *mqlAwsEc2Keypair) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Keypair) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Keypair) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlAwsEc2Keypair) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Keypair) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsEc2Keypair) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Keypair) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Keypair) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsEc2Image for the aws.ec2.image resource
type mqlAwsEc2Image struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2ImageInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Architecture plugin.TValue[string]
	OwnerId plugin.TValue[string]
	OwnerAlias plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	DeprecatedAt plugin.TValue[*time.Time]
}

// createAwsEc2Image creates a new instance of this resource
func createAwsEc2Image(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Image{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Image) MqlName() string {
	return "aws.ec2.image"
}

func (c *mqlAwsEc2Image) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Image) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Image) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Image) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Image) GetArchitecture() *plugin.TValue[string] {
	return &c.Architecture
}

func (c *mqlAwsEc2Image) GetOwnerId() *plugin.TValue[string] {
	return &c.OwnerId
}

func (c *mqlAwsEc2Image) GetOwnerAlias() *plugin.TValue[string] {
	return &c.OwnerAlias
}

func (c *mqlAwsEc2Image) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEc2Image) GetDeprecatedAt() *plugin.TValue[*time.Time] {
	return &c.DeprecatedAt
}

// mqlAwsEc2InstanceDevice for the aws.ec2.instance.device resource
type mqlAwsEc2InstanceDevice struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2InstanceDeviceInternal it will be used here
	DeleteOnTermination plugin.TValue[bool]
	Status plugin.TValue[string]
	VolumeId plugin.TValue[string]
	DeviceName plugin.TValue[string]
}

// createAwsEc2InstanceDevice creates a new instance of this resource
func createAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2InstanceDevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance.device", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2InstanceDevice) MqlName() string {
	return "aws.ec2.instance.device"
}

func (c *mqlAwsEc2InstanceDevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2InstanceDevice) GetDeleteOnTermination() *plugin.TValue[bool] {
	return &c.DeleteOnTermination
}

func (c *mqlAwsEc2InstanceDevice) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2InstanceDevice) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2InstanceDevice) GetDeviceName() *plugin.TValue[string] {
	return &c.DeviceName
}

// mqlAwsEc2Securitygroup for the aws.ec2.securitygroup resource
type mqlAwsEc2Securitygroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEc2SecuritygroupInternal
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Vpc plugin.TValue[*mqlAwsVpc]
	IpPermissions plugin.TValue[[]interface{}]
	IpPermissionsEgress plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	IsAttachedToNetworkInterface plugin.TValue[bool]
}

// createAwsEc2Securitygroup creates a new instance of this resource
func createAwsEc2Securitygroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Securitygroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Securitygroup) MqlName() string {
	return "aws.ec2.securitygroup"
}

func (c *mqlAwsEc2Securitygroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Securitygroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Securitygroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Securitygroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Securitygroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Securitygroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Securitygroup) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.IpPermissions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "ipPermissions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.ipPermissions()
	})
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissionsEgress() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.IpPermissionsEgress, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "ipPermissionsEgress")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.ipPermissionsEgress()
	})
}

func (c *mqlAwsEc2Securitygroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Securitygroup) GetIsAttachedToNetworkInterface() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachedToNetworkInterface, func() (bool, error) {
		return c.isAttachedToNetworkInterface()
	})
}

// mqlAwsEc2SecuritygroupIppermission for the aws.ec2.securitygroup.ippermission resource
type mqlAwsEc2SecuritygroupIppermission struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2SecuritygroupIppermissionInternal it will be used here
	Id plugin.TValue[string]
	FromPort plugin.TValue[int64]
	ToPort plugin.TValue[int64]
	IpProtocol plugin.TValue[string]
	IpRanges plugin.TValue[[]interface{}]
	Ipv6Ranges plugin.TValue[[]interface{}]
	PrefixListIds plugin.TValue[[]interface{}]
	UserIdGroupPairs plugin.TValue[[]interface{}]
}

// createAwsEc2SecuritygroupIppermission creates a new instance of this resource
func createAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2SecuritygroupIppermission{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup.ippermission", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlName() string {
	return "aws.ec2.securitygroup.ippermission"
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetFromPort() *plugin.TValue[int64] {
	return &c.FromPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetToPort() *plugin.TValue[int64] {
	return &c.ToPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpProtocol() *plugin.TValue[string] {
	return &c.IpProtocol
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpRanges() *plugin.TValue[[]interface{}] {
	return &c.IpRanges
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpv6Ranges() *plugin.TValue[[]interface{}] {
	return &c.Ipv6Ranges
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetPrefixListIds() *plugin.TValue[[]interface{}] {
	return &c.PrefixListIds
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetUserIdGroupPairs() *plugin.TValue[[]interface{}] {
	return &c.UserIdGroupPairs
}

// mqlAwsConfig for the aws.config resource
type mqlAwsConfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigInternal it will be used here
	Recorders plugin.TValue[[]interface{}]
	Rules plugin.TValue[[]interface{}]
	DeliveryChannels plugin.TValue[[]interface{}]
}

// createAwsConfig creates a new instance of this resource
func createAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfig) MqlName() string {
	return "aws.config"
}

func (c *mqlAwsConfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfig) GetRecorders() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Recorders, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "recorders")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.recorders()
	})
}

func (c *mqlAwsConfig) GetRules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Rules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsConfig) GetDeliveryChannels() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DeliveryChannels, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "deliveryChannels")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.deliveryChannels()
	})
}

// mqlAwsConfigRule for the aws.config.rule resource
type mqlAwsConfigRule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigRuleInternal it will be used here
	Arn plugin.TValue[string]
	State plugin.TValue[string]
	Source plugin.TValue[interface{}]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsConfigRule creates a new instance of this resource
func createAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.rule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRule) MqlName() string {
	return "aws.config.rule"
}

func (c *mqlAwsConfigRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRule) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsConfigRule) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsConfigRule) GetSource() *plugin.TValue[interface{}] {
	return &c.Source
}

func (c *mqlAwsConfigRule) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsConfigRule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigRule) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsConfigRule) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsConfigRecorder for the aws.config.recorder resource
type mqlAwsConfigRecorder struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigRecorderInternal it will be used here
	Name plugin.TValue[string]
	RoleArn plugin.TValue[string]
	AllSupported plugin.TValue[bool]
	IncludeGlobalResourceTypes plugin.TValue[bool]
	Recording plugin.TValue[bool]
	LastStatus plugin.TValue[string]
	Region plugin.TValue[string]
	ResourceTypes plugin.TValue[[]interface{}]
}

// createAwsConfigRecorder creates a new instance of this resource
func createAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRecorder{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.recorder", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRecorder) MqlName() string {
	return "aws.config.recorder"
}

func (c *mqlAwsConfigRecorder) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRecorder) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigRecorder) GetRoleArn() *plugin.TValue[string] {
	return &c.RoleArn
}

func (c *mqlAwsConfigRecorder) GetAllSupported() *plugin.TValue[bool] {
	return &c.AllSupported
}

func (c *mqlAwsConfigRecorder) GetIncludeGlobalResourceTypes() *plugin.TValue[bool] {
	return &c.IncludeGlobalResourceTypes
}

func (c *mqlAwsConfigRecorder) GetRecording() *plugin.TValue[bool] {
	return &c.Recording
}

func (c *mqlAwsConfigRecorder) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsConfigRecorder) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsConfigRecorder) GetResourceTypes() *plugin.TValue[[]interface{}] {
	return &c.ResourceTypes
}

// mqlAwsConfigDeliverychannel for the aws.config.deliverychannel resource
type mqlAwsConfigDeliverychannel struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigDeliverychannelInternal it will be used here
	Name plugin.TValue[string]
	S3BucketName plugin.TValue[string]
	S3KeyPrefix plugin.TValue[string]
	SnsTopicARN plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsConfigDeliverychannel creates a new instance of this resource
func createAwsConfigDeliverychannel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigDeliverychannel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.deliverychannel", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigDeliverychannel) MqlName() string {
	return "aws.config.deliverychannel"
}

func (c *mqlAwsConfigDeliverychannel) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigDeliverychannel) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigDeliverychannel) GetS3BucketName() *plugin.TValue[string] {
	return &c.S3BucketName
}

func (c *mqlAwsConfigDeliverychannel) GetS3KeyPrefix() *plugin.TValue[string] {
	return &c.S3KeyPrefix
}

func (c *mqlAwsConfigDeliverychannel) GetSnsTopicARN() *plugin.TValue[string] {
	return &c.SnsTopicARN
}

func (c *mqlAwsConfigDeliverychannel) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEks for the aws.eks resource
type mqlAwsEks struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEksInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsEks creates a new instance of this resource
func createAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEks{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEks) MqlName() string {
	return "aws.eks"
}

func (c *mqlAwsEks) MqlID() string {
	return c.__id
}

func (c *mqlAwsEks) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEksNodegroup for the aws.eks.nodegroup resource
type mqlAwsEksNodegroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEksNodegroupInternal
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	ModifiedAt plugin.TValue[*time.Time]
	Status plugin.TValue[string]
	CapacityType plugin.TValue[string]
	ScalingConfig plugin.TValue[interface{}]
	InstanceTypes plugin.TValue[[]interface{}]
	AmiType plugin.TValue[string]
	NodeRole plugin.TValue[*mqlAwsIamRole]
	DiskSize plugin.TValue[int64]
	Labels plugin.TValue[map[string]interface{}]
	Tags plugin.TValue[map[string]interface{}]
	AutoscalingGroups plugin.TValue[[]interface{}]
}

// createAwsEksNodegroup creates a new instance of this resource
func createAwsEksNodegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksNodegroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.nodegroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksNodegroup) MqlName() string {
	return "aws.eks.nodegroup"
}

func (c *mqlAwsEksNodegroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksNodegroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksNodegroup) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsEksNodegroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEksNodegroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsEksNodegroup) GetModifiedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ModifiedAt, func() (*time.Time, error) {
		return c.modifiedAt()
	})
}

func (c *mqlAwsEksNodegroup) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsEksNodegroup) GetCapacityType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.CapacityType, func() (string, error) {
		return c.capacityType()
	})
}

func (c *mqlAwsEksNodegroup) GetScalingConfig() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.ScalingConfig, func() (interface{}, error) {
		return c.scalingConfig()
	})
}

func (c *mqlAwsEksNodegroup) GetInstanceTypes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.InstanceTypes, func() ([]interface{}, error) {
		return c.instanceTypes()
	})
}

func (c *mqlAwsEksNodegroup) GetAmiType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AmiType, func() (string, error) {
		return c.amiType()
	})
}

func (c *mqlAwsEksNodegroup) GetNodeRole() *plugin.TValue[*mqlAwsIamRole] {
	return plugin.GetOrCompute[*mqlAwsIamRole](&c.NodeRole, func() (*mqlAwsIamRole, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.nodegroup", c.__id, "nodeRole")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamRole), nil
			}
		}

		return c.nodeRole()
	})
}

func (c *mqlAwsEksNodegroup) GetDiskSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.DiskSize, func() (int64, error) {
		return c.diskSize()
	})
}

func (c *mqlAwsEksNodegroup) GetLabels() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Labels, func() (map[string]interface{}, error) {
		return c.labels()
	})
}

func (c *mqlAwsEksNodegroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsEksNodegroup) GetAutoscalingGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AutoscalingGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.nodegroup", c.__id, "autoscalingGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.autoscalingGroups()
	})
}

// mqlAwsEksAddon for the aws.eks.addon resource
type mqlAwsEksAddon struct {
	MqlRuntime *plugin.Runtime
	__id string
	mqlAwsEksAddonInternal
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	Status plugin.TValue[string]
	AddonVersion plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	ModifiedAt plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	Publisher plugin.TValue[string]
	Owner plugin.TValue[string]
	ConfigurationValues plugin.TValue[string]
}

// createAwsEksAddon creates a new instance of this resource
func createAwsEksAddon(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksAddon{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.addon", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksAddon) MqlName() string {
	return "aws.eks.addon"
}

func (c *mqlAwsEksAddon) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksAddon) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksAddon) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsEksAddon) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsEksAddon) GetAddonVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AddonVersion, func() (string, error) {
		return c.addonVersion()
	})
}

func (c *mqlAwsEksAddon) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsEksAddon) GetModifiedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ModifiedAt, func() (*time.Time, error) {
		return c.modifiedAt()
	})
}

func (c *mqlAwsEksAddon) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsEksAddon) GetPublisher() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Publisher, func() (string, error) {
		return c.publisher()
	})
}

func (c *mqlAwsEksAddon) GetOwner() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Owner, func() (string, error) {
		return c.owner()
	})
}

func (c *mqlAwsEksAddon) GetConfigurationValues() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.ConfigurationValues, func() (string, error) {
		return c.configurationValues()
	})
}

// mqlAwsEksCluster for the aws.eks.cluster resource
type mqlAwsEksCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEksClusterInternal it will be used here
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Endpoint plugin.TValue[string]
	Version plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Status plugin.TValue[string]
	EncryptionConfig plugin.TValue[[]interface{}]
	Logging plugin.TValue[interface{}]
	NetworkConfig plugin.TValue[interface{}]
	ResourcesVpcConfig plugin.TValue[interface{}]
	CreatedAt plugin.TValue[*time.Time]
	NodeGroups plugin.TValue[[]interface{}]
	Addons plugin.TValue[[]interface{}]
	IamRole plugin.TValue[*mqlAwsIamRole]
	SupportType plugin.TValue[string]
	AuthenticationMode plugin.TValue[string]
}

// createAwsEksCluster creates a new instance of this resource
func createAwsEksCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksCluster) MqlName() string {
	return "aws.eks.cluster"
}

func (c *mqlAwsEksCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEksCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEksCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEksCluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEksCluster) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlAwsEksCluster) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEksCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEksCluster) GetEncryptionConfig() *plugin.TValue[[]interface{}] {
	return &c.EncryptionConfig
}

func (c *mqlAwsEksCluster) GetLogging() *plugin.TValue[interface{}] {
	return &c.Logging
}

func (c *mqlAwsEksCluster) GetNetworkConfig() *plugin.TValue[interface{}] {
	return &c.NetworkConfig
}

func (c *mqlAwsEksCluster) GetResourcesVpcConfig() *plugin.TValue[interface{}] {
	return &c.ResourcesVpcConfig
}

func (c *mqlAwsEksCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEksCluster) GetNodeGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NodeGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.cluster", c.__id, "nodeGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.nodeGroups()
	})
}

func (c *mqlAwsEksCluster) GetAddons() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Addons, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.cluster", c.__id, "addons")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.addons()
	})
}

func (c *mqlAwsEksCluster) GetIamRole() *plugin.TValue[*mqlAwsIamRole] {
	return &c.IamRole
}

func (c *mqlAwsEksCluster) GetSupportType() *plugin.TValue[string] {
	return &c.SupportType
}

func (c *mqlAwsEksCluster) GetAuthenticationMode() *plugin.TValue[string] {
	return &c.AuthenticationMode
}

// mqlAwsNeptune for the aws.neptune resource
type mqlAwsNeptune struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsNeptuneInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	Instances plugin.TValue[[]interface{}]
}

// createAwsNeptune creates a new instance of this resource
func createAwsNeptune(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptune{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptune) MqlName() string {
	return "aws.neptune"
}

func (c *mqlAwsNeptune) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptune) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.neptune", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsNeptune) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.neptune", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

// mqlAwsNeptuneCluster for the aws.neptune.cluster resource
type mqlAwsNeptuneCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsNeptuneClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	ClusterIdentifier plugin.TValue[string]
	GlobalClusterIdentifier plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	KmsKeyId plugin.TValue[string]
	Region plugin.TValue[string]
	AutomaticRestartTime plugin.TValue[*time.Time]
	AvailabilityZones plugin.TValue[[]interface{}]
	BackupRetentionPeriod plugin.TValue[int64]
	CreatedAt plugin.TValue[*time.Time]
	CrossAccountClone plugin.TValue[bool]
	ClusterParameterGroup plugin.TValue[string]
	SubnetGroup plugin.TValue[string]
	ClusterResourceId plugin.TValue[string]
	DeletionProtection plugin.TValue[bool]
	EarliestRestorableTime plugin.TValue[*time.Time]
	EnabledCloudwatchLogsExports plugin.TValue[[]interface{}]
	Endpoint plugin.TValue[string]
	IamDatabaseAuthenticationEnabled plugin.TValue[bool]
	LatestRestorableTime plugin.TValue[*time.Time]
	MasterUsername plugin.TValue[string]
	MultiAZ plugin.TValue[bool]
	Port plugin.TValue[int64]
	PreferredBackupWindow plugin.TValue[string]
	PreferredMaintenanceWindow plugin.TValue[string]
	Status plugin.TValue[string]
	StorageEncrypted plugin.TValue[bool]
	StorageType plugin.TValue[string]
}

// createAwsNeptuneCluster creates a new instance of this resource
func createAwsNeptuneCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptuneCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptuneCluster) MqlName() string {
	return "aws.neptune.cluster"
}

func (c *mqlAwsNeptuneCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptuneCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsNeptuneCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsNeptuneCluster) GetClusterIdentifier() *plugin.TValue[string] {
	return &c.ClusterIdentifier
}

func (c *mqlAwsNeptuneCluster) GetGlobalClusterIdentifier() *plugin.TValue[string] {
	return &c.GlobalClusterIdentifier
}

func (c *mqlAwsNeptuneCluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsNeptuneCluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsNeptuneCluster) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsNeptuneCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsNeptuneCluster) GetAutomaticRestartTime() *plugin.TValue[*time.Time] {
	return &c.AutomaticRestartTime
}

func (c *mqlAwsNeptuneCluster) GetAvailabilityZones() *plugin.TValue[[]interface{}] {
	return &c.AvailabilityZones
}

func (c *mqlAwsNeptuneCluster) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsNeptuneCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsNeptuneCluster) GetCrossAccountClone() *plugin.TValue[bool] {
	return &c.CrossAccountClone
}

func (c *mqlAwsNeptuneCluster) GetClusterParameterGroup() *plugin.TValue[string] {
	return &c.ClusterParameterGroup
}

func (c *mqlAwsNeptuneCluster) GetSubnetGroup() *plugin.TValue[string] {
	return &c.SubnetGroup
}

func (c *mqlAwsNeptuneCluster) GetClusterResourceId() *plugin.TValue[string] {
	return &c.ClusterResourceId
}

func (c *mqlAwsNeptuneCluster) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsNeptuneCluster) GetEarliestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.EarliestRestorableTime
}

func (c *mqlAwsNeptuneCluster) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]interface{}] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsNeptuneCluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsNeptuneCluster) GetIamDatabaseAuthenticationEnabled() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthenticationEnabled
}

func (c *mqlAwsNeptuneCluster) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsNeptuneCluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsNeptuneCluster) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsNeptuneCluster) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsNeptuneCluster) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsNeptuneCluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsNeptuneCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsNeptuneCluster) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsNeptuneCluster) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

// mqlAwsNeptuneInstance for the aws.neptune.instance resource
type mqlAwsNeptuneInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsNeptuneInstanceInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	ClusterIdentifier plugin.TValue[string]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	AvailabilityZone plugin.TValue[string]
	BackupRetentionPeriod plugin.TValue[int64]
	InstanceClass plugin.TValue[string]
	Status plugin.TValue[string]
	Port plugin.TValue[int64]
	DeletionProtection plugin.TValue[bool]
	EnabledCloudwatchLogsExports plugin.TValue[[]interface{}]
	Endpoint plugin.TValue[interface{}]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	EnhancedMonitoringResourceArn plugin.TValue[string]
	IamDatabaseAuthenticationEnabled plugin.TValue[bool]
	CreatedAt plugin.TValue[*time.Time]
	KmsKeyId plugin.TValue[string]
	LatestRestorableTime plugin.TValue[*time.Time]
	MasterUsername plugin.TValue[string]
	MonitoringInterval plugin.TValue[int64]
	MonitoringRoleArn plugin.TValue[string]
	MultiAZ plugin.TValue[bool]
	PreferredBackupWindow plugin.TValue[string]
	PreferredMaintenanceWindow plugin.TValue[string]
	PromotionTier plugin.TValue[int64]
	Region plugin.TValue[string]
	StorageEncrypted plugin.TValue[bool]
	StorageType plugin.TValue[string]
	TdeCredentialArn plugin.TValue[string]
}

// createAwsNeptuneInstance creates a new instance of this resource
func createAwsNeptuneInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptuneInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptuneInstance) MqlName() string {
	return "aws.neptune.instance"
}

func (c *mqlAwsNeptuneInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptuneInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsNeptuneInstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsNeptuneInstance) GetClusterIdentifier() *plugin.TValue[string] {
	return &c.ClusterIdentifier
}

func (c *mqlAwsNeptuneInstance) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsNeptuneInstance) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsNeptuneInstance) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsNeptuneInstance) GetInstanceClass() *plugin.TValue[string] {
	return &c.InstanceClass
}

func (c *mqlAwsNeptuneInstance) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsNeptuneInstance) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsNeptuneInstance) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsNeptuneInstance) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]interface{}] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsNeptuneInstance) GetEndpoint() *plugin.TValue[interface{}] {
	return &c.Endpoint
}

func (c *mqlAwsNeptuneInstance) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsNeptuneInstance) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsNeptuneInstance) GetEnhancedMonitoringResourceArn() *plugin.TValue[string] {
	return &c.EnhancedMonitoringResourceArn
}

func (c *mqlAwsNeptuneInstance) GetIamDatabaseAuthenticationEnabled() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthenticationEnabled
}

func (c *mqlAwsNeptuneInstance) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsNeptuneInstance) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsNeptuneInstance) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsNeptuneInstance) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsNeptuneInstance) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsNeptuneInstance) GetMonitoringRoleArn() *plugin.TValue[string] {
	return &c.MonitoringRoleArn
}

func (c *mqlAwsNeptuneInstance) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsNeptuneInstance) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsNeptuneInstance) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsNeptuneInstance) GetPromotionTier() *plugin.TValue[int64] {
	return &c.PromotionTier
}

func (c *mqlAwsNeptuneInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsNeptuneInstance) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsNeptuneInstance) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsNeptuneInstance) GetTdeCredentialArn() *plugin.TValue[string] {
	return &c.TdeCredentialArn
}

// mqlAwsTimestreamLiveanalytics for the aws.timestream.liveanalytics resource
type mqlAwsTimestreamLiveanalytics struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsTimestreamLiveanalyticsInternal it will be used here
	Databases plugin.TValue[[]interface{}]
	Tables plugin.TValue[[]interface{}]
}

// createAwsTimestreamLiveanalytics creates a new instance of this resource
func createAwsTimestreamLiveanalytics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalytics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalytics) MqlName() string {
	return "aws.timestream.liveanalytics"
}

func (c *mqlAwsTimestreamLiveanalytics) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalytics) GetDatabases() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Databases, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.timestream.liveanalytics", c.__id, "databases")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.databases()
	})
}

func (c *mqlAwsTimestreamLiveanalytics) GetTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.timestream.liveanalytics", c.__id, "tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tables()
	})
}

// mqlAwsTimestreamLiveanalyticsDatabase for the aws.timestream.liveanalytics.database resource
type mqlAwsTimestreamLiveanalyticsDatabase struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsTimestreamLiveanalyticsDatabaseInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	KmsKeyId plugin.TValue[string]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
	TableCount plugin.TValue[int64]
}

// createAwsTimestreamLiveanalyticsDatabase creates a new instance of this resource
func createAwsTimestreamLiveanalyticsDatabase(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalyticsDatabase{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics.database", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) MqlName() string {
	return "aws.timestream.liveanalytics.database"
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetTableCount() *plugin.TValue[int64] {
	return &c.TableCount
}

// mqlAwsTimestreamLiveanalyticsTable for the aws.timestream.liveanalytics.table resource
type mqlAwsTimestreamLiveanalyticsTable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsTimestreamLiveanalyticsTableInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	DatabaseName plugin.TValue[string]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	UpdatedAt plugin.TValue[*time.Time]
	MagneticStoreWriteProperties plugin.TValue[interface{}]
	RetentionProperties plugin.TValue[interface{}]
}

// createAwsTimestreamLiveanalyticsTable creates a new instance of this resource
func createAwsTimestreamLiveanalyticsTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalyticsTable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics.table", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalyticsTable) MqlName() string {
	return "aws.timestream.liveanalytics.table"
}

func (c *mqlAwsTimestreamLiveanalyticsTable) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetDatabaseName() *plugin.TValue[string] {
	return &c.DatabaseName
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetMagneticStoreWriteProperties() *plugin.TValue[interface{}] {
	return &c.MagneticStoreWriteProperties
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetRetentionProperties() *plugin.TValue[interface{}] {
	return &c.RetentionProperties
}
