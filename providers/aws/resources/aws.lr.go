// Code generated by resources. DO NOT EDIT.
package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/llx"
	"go.mondoo.com/cnquery/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"aws": {
			// to override args, implement: initAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAws,
		},
		"aws.account": {
			// to override args, implement: initAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccount,
		},
		"aws.organization": {
			// to override args, implement: initAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsOrganization,
		},
		"aws.vpc": {
			// to override args, implement: initAwsVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpc,
		},
		"aws.vpc.routetable": {
			// to override args, implement: initAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetable,
		},
		"aws.vpc.flowlog": {
			// to override args, implement: initAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcFlowlog,
		},
		"aws.accessAnalyzer": {
			// to override args, implement: initAwsAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccessAnalyzer,
		},
		"aws.accessanalyzer.analyzer": {
			// to override args, implement: initAwsAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccessanalyzerAnalyzer,
		},
		"aws.efs": {
			// to override args, implement: initAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfs,
		},
		"aws.efs.filesystem": {
			// to override args, implement: initAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfsFilesystem,
		},
		"aws.kms": {
			// to override args, implement: initAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsKms,
		},
		"aws.kms.key": {
			Init: initAwsKmsKey,
			Create: createAwsKmsKey,
		},
		"aws.iam": {
			// to override args, implement: initAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIam,
		},
		"aws.iam.usercredentialreportentry": {
			// to override args, implement: initAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamUsercredentialreportentry,
		},
		"aws.iam.user": {
			Init: initAwsIamUser,
			Create: createAwsIamUser,
		},
		"aws.iam.policy": {
			// to override args, implement: initAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicy,
		},
		"aws.iam.policyversion": {
			// to override args, implement: initAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicyversion,
		},
		"aws.iam.role": {
			Init: initAwsIamRole,
			Create: createAwsIamRole,
		},
		"aws.iam.group": {
			Init: initAwsIamGroup,
			Create: createAwsIamGroup,
		},
		"aws.iam.virtualmfadevice": {
			// to override args, implement: initAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamVirtualmfadevice,
		},
		"aws.sagemaker": {
			// to override args, implement: initAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemaker,
		},
		"aws.sagemaker.notebookinstance": {
			Init: initAwsSagemakerNotebookinstance,
			Create: createAwsSagemakerNotebookinstance,
		},
		"aws.sagemaker.notebookinstance.details": {
			// to override args, implement: initAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerNotebookinstanceDetails,
		},
		"aws.sagemaker.endpoint": {
			// to override args, implement: initAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerEndpoint,
		},
		"aws.sns": {
			// to override args, implement: initAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSns,
		},
		"aws.sns.topic": {
			// to override args, implement: initAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsTopic,
		},
		"aws.sns.subscription": {
			// to override args, implement: initAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsSubscription,
		},
		"aws.es": {
			// to override args, implement: initAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEs,
		},
		"aws.es.domain": {
			Init: initAwsEsDomain,
			Create: createAwsEsDomain,
		},
		"aws.acm": {
			// to override args, implement: initAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAcm,
		},
		"aws.acm.certificate": {
			Init: initAwsAcmCertificate,
			Create: createAwsAcmCertificate,
		},
		"aws.autoscaling": {
			// to override args, implement: initAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscaling,
		},
		"aws.autoscaling.group": {
			// to override args, implement: initAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscalingGroup,
		},
		"aws.elb": {
			// to override args, implement: initAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElb,
		},
		"aws.elb.loadbalancer": {
			// to override args, implement: initAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElbLoadbalancer,
		},
		"aws.codebuild": {
			// to override args, implement: initAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodebuild,
		},
		"aws.codebuild.project": {
			Init: initAwsCodebuildProject,
			Create: createAwsCodebuildProject,
		},
		"aws.guardduty": {
			// to override args, implement: initAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuardduty,
		},
		"aws.guardduty.detector": {
			Init: initAwsGuarddutyDetector,
			Create: createAwsGuarddutyDetector,
		},
		"aws.securityhub": {
			// to override args, implement: initAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhub,
		},
		"aws.securityhub.hub": {
			// to override args, implement: initAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhubHub,
		},
		"aws.secretsmanager": {
			// to override args, implement: initAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanager,
		},
		"aws.secretsmanager.secret": {
			// to override args, implement: initAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanagerSecret,
		},
		"aws.ecs": {
			// to override args, implement: initAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcs,
		},
		"aws.ecs.cluster": {
			Init: initAwsEcsCluster,
			Create: createAwsEcsCluster,
		},
		"aws.ecs.instance": {
			// to override args, implement: initAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsInstance,
		},
		"aws.ecs.task": {
			Init: initAwsEcsTask,
			Create: createAwsEcsTask,
		},
		"aws.ecs.container": {
			Init: initAwsEcsContainer,
			Create: createAwsEcsContainer,
		},
		"aws.emr": {
			// to override args, implement: initAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmr,
		},
		"aws.emr.cluster": {
			// to override args, implement: initAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmrCluster,
		},
		"aws.cloudwatch": {
			// to override args, implement: initAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatch,
		},
		"aws.cloudwatch.metricsalarm": {
			Init: initAwsCloudwatchMetricsalarm,
			Create: createAwsCloudwatchMetricsalarm,
		},
		"aws.cloudwatch.metric": {
			Init: initAwsCloudwatchMetric,
			Create: createAwsCloudwatchMetric,
		},
		"aws.cloudwatch.metricdimension": {
			// to override args, implement: initAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricdimension,
		},
		"aws.cloudwatch.metricstatistics": {
			Init: initAwsCloudwatchMetricstatistics,
			Create: createAwsCloudwatchMetricstatistics,
		},
		"aws.cloudwatch.metric.datapoint": {
			// to override args, implement: initAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricDatapoint,
		},
		"aws.cloudwatch.loggroup": {
			Init: initAwsCloudwatchLoggroup,
			Create: createAwsCloudwatchLoggroup,
		},
		"aws.cloudwatch.loggroup.metricsfilter": {
			// to override args, implement: initAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchLoggroupMetricsfilter,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources[id]; ok {
				return x, nil
			}
			runtime.Resources[id] = res
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources[id]; ok {
		return x, nil
	}

	runtime.Resources[id] = res
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"aws.vpcs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetVpcs()).ToDataRes(types.Array(types.Resource("aws.vpc")))
	},
	"aws.regions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetRegions()).ToDataRes(types.Array(types.String))
	},
	"aws.account.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetId()).ToDataRes(types.String)
	},
	"aws.account.aliases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetAliases()).ToDataRes(types.Array(types.String))
	},
	"aws.account.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetOrganization()).ToDataRes(types.Resource("aws.organization"))
	},
	"aws.organization.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetArn()).ToDataRes(types.String)
	},
	"aws.organization.featureSet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetFeatureSet()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountId()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountEmail()).ToDataRes(types.String)
	},
	"aws.vpc.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.vpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.flowLogs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetFlowLogs()).ToDataRes(types.Array(types.Resource("aws.vpc.flowlog")))
	},
	"aws.vpc.routeTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRouteTables()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable")))
	},
	"aws.vpc.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.routetable.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetRoutes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.vpc.flowlog.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.accessAnalyzer.analyzers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessAnalyzer).GetAnalyzers()).ToDataRes(types.Array(types.Resource("aws.accessanalyzer.analyzer")))
	},
	"aws.accessanalyzer.analyzer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetArn()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetName()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetStatus()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetType()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.efs.filesystems": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfs).GetFilesystems()).ToDataRes(types.Array(types.Resource("aws.efs.filesystem")))
	},
	"aws.efs.filesystem.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetName()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetId()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetArn()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetBackupPolicy()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystem.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetRegion()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.kms.keys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKms).GetKeys()).ToDataRes(types.Array(types.Resource("aws.kms.key")))
	},
	"aws.kms.key.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetId()).ToDataRes(types.String)
	},
	"aws.kms.key.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetArn()).ToDataRes(types.String)
	},
	"aws.kms.key.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetRegion()).ToDataRes(types.String)
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetKeyRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.kms.key.metadata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetMetadata()).ToDataRes(types.Dict)
	},
	"aws.iam.users": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.roles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.credentialReport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetCredentialReport()).ToDataRes(types.Array(types.Resource("aws.iam.usercredentialreportentry")))
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountPasswordPolicy()).ToDataRes(types.Dict)
	},
	"aws.iam.accountSummary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountSummary()).ToDataRes(types.Map(types.String, types.Int))
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetVirtualMfaDevices()).ToDataRes(types.Array(types.Resource("aws.iam.virtualmfadevice")))
	},
	"aws.iam.serverCertificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetServerCertificates()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetMfaActive()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordEnabled()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastChanged()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordNextRotation()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUserCreationTime()).ToDataRes(types.Time)
	},
	"aws.iam.user.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetId()).ToDataRes(types.String)
	},
	"aws.iam.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetName()).ToDataRes(types.String)
	},
	"aws.iam.user.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.user.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.user.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPolicies()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.user.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAccessKeys()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.policy.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.iam.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.iam.policy.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetIsAttachable()).ToDataRes(types.Bool)
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachmentCount()).ToDataRes(types.Int)
	},
	"aws.iam.policy.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetUpdateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetScope()).ToDataRes(types.String)
	},
	"aws.iam.policy.versions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetVersions()).ToDataRes(types.Array(types.Resource("aws.iam.policyversion")))
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDefaultVersion()).ToDataRes(types.Resource("aws.iam.policyversion"))
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policyversion.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetVersionId()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetIsDefaultVersion()).ToDataRes(types.Bool)
	},
	"aws.iam.policyversion.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.role.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.role.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetId()).ToDataRes(types.String)
	},
	"aws.iam.role.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetName()).ToDataRes(types.String)
	},
	"aws.iam.role.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.role.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.role.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.group.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetId()).ToDataRes(types.String)
	},
	"aws.iam.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetName()).ToDataRes(types.String)
	},
	"aws.iam.group.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.group.usernames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetUsernames()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetSerialNumber()).ToDataRes(types.String)
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetEnableDate()).ToDataRes(types.Time)
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.sagemaker.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.sagemaker.endpoint")))
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetNotebookInstances()).ToDataRes(types.Array(types.Resource("aws.sagemaker.notebookinstance")))
	},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetDetails()).ToDataRes(types.Resource("aws.sagemaker.notebookinstance.details"))
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetDirectInternetAccess()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetConfig()).ToDataRes(types.Dict)
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.topics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSns).GetTopics()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.sns.topic.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.topic.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetRegion()).ToDataRes(types.String)
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetSubscriptions()).ToDataRes(types.Array(types.Resource("aws.sns.subscription")))
	},
	"aws.sns.topic.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetAttributes()).ToDataRes(types.Dict)
	},
	"aws.sns.topic.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.subscription.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetProtocol()).ToDataRes(types.String)
	},
	"aws.es.domains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEs).GetDomains()).ToDataRes(types.Array(types.Resource("aws.es.domain")))
	},
	"aws.es.domain.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetArn()).ToDataRes(types.String)
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEncryptionAtRestEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetNodeToNodeEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetName()).ToDataRes(types.String)
	},
	"aws.es.domain.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.es.domain.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetRegion()).ToDataRes(types.String)
	},
	"aws.es.domain.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.acm.certificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcm).GetCertificates()).ToDataRes(types.Array(types.Resource("aws.acm.certificate")))
	},
	"aws.acm.certificate.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetArn()).ToDataRes(types.String)
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotBefore()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotAfter()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificate.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetStatus()).ToDataRes(types.String)
	},
	"aws.acm.certificate.subject": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSubject()).ToDataRes(types.String)
	},
	"aws.acm.certificate.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.autoscaling.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscaling).GetGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.autoscaling.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLoadBalancerNames()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckType()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetClassicLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetDnsName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetListenerDescriptions()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetScheme()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.codebuild.projects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuild).GetProjects()).ToDataRes(types.Array(types.Resource("aws.codebuild.project")))
	},
	"aws.codebuild.project.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetArn()).ToDataRes(types.String)
	},
	"aws.codebuild.project.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetDescription()).ToDataRes(types.String)
	},
	"aws.codebuild.project.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetName()).ToDataRes(types.String)
	},
	"aws.codebuild.project.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetEnvironment()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetRegion()).ToDataRes(types.String)
	},
	"aws.codebuild.project.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetSource()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.detectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetDetectors()).ToDataRes(types.Array(types.Resource("aws.guardduty.detector")))
	},
	"aws.guardduty.detector.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetStatus()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindingPublishingFrequency()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetUnarchivedFindings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.securityhub.hubs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhub).GetHubs()).ToDataRes(types.Array(types.Resource("aws.securityhub.hub")))
	},
	"aws.securityhub.hub.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetArn()).ToDataRes(types.String)
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetSubscribedAt()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanager).GetSecrets()).ToDataRes(types.Array(types.Resource("aws.secretsmanager.secret")))
	},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetArn()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetName()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetClusters()).ToDataRes(types.Array(types.Resource("aws.ecs.cluster")))
	},
	"aws.ecs.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRunningTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetPendingTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegisteredContainerInstancesCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTasks()).ToDataRes(types.Array(types.Resource("aws.ecs.task")))
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetAgentConnected()).ToDataRes(types.Bool)
	},
	"aws.ecs.instance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetId()).ToDataRes(types.String)
	},
	"aws.ecs.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetCapacityProvider()).ToDataRes(types.String)
	},
	"aws.ecs.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.task.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetConnectivity()).ToDataRes(types.Dict)
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.task.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.task.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.container.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.container.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.container.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetImage()).ToDataRes(types.String)
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskDefinitionArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetLogDriver()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.container.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.container.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.container.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetCommand()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRuntimeId()).ToDataRes(types.String)
	},
	"aws.ecs.container.containerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetContainerName()).ToDataRes(types.String)
	},
	"aws.emr.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmr).GetClusters()).ToDataRes(types.Array(types.Resource("aws.emr.cluster")))
	},
	"aws.emr.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetName()).ToDataRes(types.String)
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetNormalizedInstanceHours()).ToDataRes(types.Int)
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetOutpostArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetMasterInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.emr.cluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetId()).ToDataRes(types.String)
	},
	"aws.emr.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.cloudwatch.logGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetLogGroups()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup")))
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetState()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetStateReason()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetInsufficientDataActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetOkActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetDimensions()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricdimension")))
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetStatistics()).ToDataRes(types.Resource("aws.cloudwatch.metricstatistics"))
	},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetValue()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetLabel()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetDatapoints()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric.datapoint")))
	},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetTimestamp()).ToDataRes(types.Time)
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMaximum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMinimum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetAverage()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetSum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetUnit()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetMetricsFilters()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup.metricsfilter")))
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterPattern()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"aws.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAws).__id, ok = v.Value.(string)
			return
		},
	"aws.vpcs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Vpcs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.regions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Regions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccount).__id, ok = v.Value.(string)
			return
		},
	"aws.account.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.aliases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Aliases, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Organization, ok = plugin.RawToTValue[*mqlAwsOrganization](v.Value, v.Error)
		return
	},
	"aws.organization.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsOrganization).__id, ok = v.Value.(string)
			return
		},
	"aws.organization.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.featureSet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).FeatureSet, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountEmail, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpc).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowLogs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).FlowLogs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routeTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).RouteTables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcRoutetable).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.routetable.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Routes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcFlowlog).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.flowlog.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.accessAnalyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccessAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.accessAnalyzer.analyzers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessAnalyzer).Analyzers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccessanalyzerAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.accessanalyzer.analyzer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfs).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystems": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfs).Filesystems, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfsFilesystem).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystem.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).BackupPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.kms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKms).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.keys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKms).Keys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.kms.key.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKmsKey).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.key.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).KeyRotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.kms.key.metadata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Metadata, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIam).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.users": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Users, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.roles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Roles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.credentialReport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).CredentialReport, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountPasswordPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountSummary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountSummary, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).VirtualMfaDevices, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.serverCertificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).ServerCertificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUsercredentialreportentry).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Properties, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).MfaActive, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastChanged, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordNextRotation, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).UserCreationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUser).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.user.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AccessKeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicy).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policy.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).IsAttachable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachmentCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.iam.policy.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).UpdateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.versions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Versions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).DefaultVersion, ok = plugin.RawToTValue[*mqlAwsIamPolicyversion](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedUsers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedRoles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicyversion).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policyversion.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).VersionId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).IsDefaultVersion, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Document, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamRole).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.role.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.role.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.usernames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Usernames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamVirtualmfadevice).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).SerialNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).EnableDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.sagemaker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemaker).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).Endpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).NotebookInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstance).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Details, ok = plugin.RawToTValue[*mqlAwsSagemakerNotebookinstanceDetails](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstanceDetails).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).DirectInternetAccess, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Config, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSns).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSns).Topics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsTopic).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topic.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Subscriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Attributes, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsSubscription).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.subscription.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEs).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEs).Domains, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.es.domain.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEsDomain).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domain.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).EncryptionAtRestEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).NodeToNodeEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.acm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcm).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcm).Certificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcmCertificate).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificate.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotBefore, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotAfter, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.subject": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Subject, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscaling).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscaling).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscalingGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LoadBalancerNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElb).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).ClassicLoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).LoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElbLoadbalancer).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).DnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ListenerDescriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Attributes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuild).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.projects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuild).Projects, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuildProject).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.project.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Environment, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Source, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuardduty).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.detectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Detectors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuarddutyDetector).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.detector.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).FindingPublishingFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).UnarchivedFindings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.securityhub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hubs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhub).Hubs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhubHub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hub.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).SubscribedAt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanager).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanager).Secrets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanagerSecret).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcs).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RunningTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).PendingTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RegisteredContainerInstancesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Configuration, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tasks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).AgentConnected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).CapacityProvider, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsTask).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.task.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Connectivity, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsContainer).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.container.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskDefinitionArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).LogDriver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Command, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).RuntimeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.containerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ContainerName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmr).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmr).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmrCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).NormalizedInstanceHours, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).OutpostArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Status, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).MasterInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatch).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.logGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).LogGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricsalarm).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricNamespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Actions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).StateReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).InsufficientDataActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).OkActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetric).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Dimensions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Statistics, ok = plugin.RawToTValue[*mqlAwsCloudwatchMetricstatistics](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricdimension).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricstatistics).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Datapoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricDatapoint).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Timestamp, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Maximum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Minimum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Average, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Sum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Unit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroup).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).MetricsFilters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroupMetricsfilter).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAws for the aws resource
type mqlAws struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInternal it will be used here
	Vpcs plugin.TValue[[]interface{}]
	Regions plugin.TValue[[]interface{}]
}

// createAws creates a new instance of this resource
func createAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAws{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAws) MqlName() string {
	return "aws"
}

func (c *mqlAws) MqlID() string {
	return c.__id
}

func (c *mqlAws) GetVpcs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vpcs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws", c.__id, "vpcs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vpcs()
	})
}

func (c *mqlAws) GetRegions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Regions, func() ([]interface{}, error) {
		return c.regions()
	})
}

// mqlAwsAccount for the aws.account resource
type mqlAwsAccount struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccountInternal it will be used here
	Id plugin.TValue[string]
	Aliases plugin.TValue[[]interface{}]
	Organization plugin.TValue[*mqlAwsOrganization]
}

// createAwsAccount creates a new instance of this resource
func createAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccount{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.account", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccount) MqlName() string {
	return "aws.account"
}

func (c *mqlAwsAccount) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccount) GetId() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Id, func() (string, error) {
		return c.id()
	})
}

func (c *mqlAwsAccount) GetAliases() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Aliases, func() ([]interface{}, error) {
		return c.aliases()
	})
}

func (c *mqlAwsAccount) GetOrganization() *plugin.TValue[*mqlAwsOrganization] {
	return plugin.GetOrCompute[*mqlAwsOrganization](&c.Organization, func() (*mqlAwsOrganization, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "organization")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsOrganization), nil
			}
		}

		return c.organization()
	})
}

// mqlAwsOrganization for the aws.organization resource
type mqlAwsOrganization struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsOrganizationInternal it will be used here
	Arn plugin.TValue[string]
	FeatureSet plugin.TValue[string]
	MasterAccountId plugin.TValue[string]
	MasterAccountEmail plugin.TValue[string]
}

// createAwsOrganization creates a new instance of this resource
func createAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOrganization{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.organization", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOrganization) MqlName() string {
	return "aws.organization"
}

func (c *mqlAwsOrganization) MqlID() string {
	return c.__id
}

func (c *mqlAwsOrganization) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsOrganization) GetFeatureSet() *plugin.TValue[string] {
	return &c.FeatureSet
}

func (c *mqlAwsOrganization) GetMasterAccountId() *plugin.TValue[string] {
	return &c.MasterAccountId
}

func (c *mqlAwsOrganization) GetMasterAccountEmail() *plugin.TValue[string] {
	return &c.MasterAccountEmail
}

// mqlAwsVpc for the aws.vpc resource
type mqlAwsVpc struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	State plugin.TValue[string]
	IsDefault plugin.TValue[bool]
	Region plugin.TValue[string]
	FlowLogs plugin.TValue[[]interface{}]
	RouteTables plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpc creates a new instance of this resource
func createAwsVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpc) MqlName() string {
	return "aws.vpc"
}

func (c *mqlAwsVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpc) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpc) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpc) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpc) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpc) GetFlowLogs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.FlowLogs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "flowLogs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.flowLogs()
	})
}

func (c *mqlAwsVpc) GetRouteTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RouteTables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "routeTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.routeTables()
	})
}

func (c *mqlAwsVpc) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsVpcRoutetable for the aws.vpc.routetable resource
type mqlAwsVpcRoutetable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcRoutetableInternal it will be used here
	Id plugin.TValue[string]
	Routes plugin.TValue[[]interface{}]
}

// createAwsVpcRoutetable creates a new instance of this resource
func createAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetable) MqlName() string {
	return "aws.vpc.routetable"
}

func (c *mqlAwsVpcRoutetable) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcRoutetable) GetRoutes() *plugin.TValue[[]interface{}] {
	return &c.Routes
}

// mqlAwsVpcFlowlog for the aws.vpc.flowlog resource
type mqlAwsVpcFlowlog struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcFlowlogInternal it will be used here
	Id plugin.TValue[string]
	Vpc plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpcFlowlog creates a new instance of this resource
func createAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcFlowlog{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.flowlog", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcFlowlog) MqlName() string {
	return "aws.vpc.flowlog"
}

func (c *mqlAwsVpcFlowlog) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcFlowlog) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcFlowlog) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcFlowlog) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcFlowlog) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcFlowlog) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsAccessAnalyzer for the aws.accessAnalyzer resource
type mqlAwsAccessAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccessAnalyzerInternal it will be used here
	Analyzers plugin.TValue[[]interface{}]
}

// createAwsAccessAnalyzer creates a new instance of this resource
func createAwsAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccessAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.accessAnalyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccessAnalyzer) MqlName() string {
	return "aws.accessAnalyzer"
}

func (c *mqlAwsAccessAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccessAnalyzer) GetAnalyzers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Analyzers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.accessAnalyzer", c.__id, "analyzers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.analyzers()
	})
}

// mqlAwsAccessanalyzerAnalyzer for the aws.accessanalyzer.analyzer resource
type mqlAwsAccessanalyzerAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccessanalyzerAnalyzerInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Type plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsAccessanalyzerAnalyzer creates a new instance of this resource
func createAwsAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccessanalyzerAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.accessanalyzer.analyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccessanalyzerAnalyzer) MqlName() string {
	return "aws.accessanalyzer.analyzer"
}

func (c *mqlAwsAccessanalyzerAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsEfs for the aws.efs resource
type mqlAwsEfs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEfsInternal it will be used here
	Filesystems plugin.TValue[[]interface{}]
}

// createAwsEfs creates a new instance of this resource
func createAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfs) MqlName() string {
	return "aws.efs"
}

func (c *mqlAwsEfs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfs) GetFilesystems() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Filesystems, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs", c.__id, "filesystems")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.filesystems()
	})
}

// mqlAwsEfsFilesystem for the aws.efs.filesystem resource
type mqlAwsEfsFilesystem struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEfsFilesystemInternal it will be used here
	Name plugin.TValue[string]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	BackupPolicy plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsEfsFilesystem creates a new instance of this resource
func createAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsFilesystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.filesystem", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsFilesystem) MqlName() string {
	return "aws.efs.filesystem"
}

func (c *mqlAwsEfsFilesystem) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsFilesystem) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEfsFilesystem) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEfsFilesystem) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEfsFilesystem) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEfsFilesystem) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsEfsFilesystem) GetBackupPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.BackupPolicy, func() (interface{}, error) {
		return c.backupPolicy()
	})
}

func (c *mqlAwsEfsFilesystem) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEfsFilesystem) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsKms for the aws.kms resource
type mqlAwsKms struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsInternal it will be used here
	Keys plugin.TValue[[]interface{}]
}

// createAwsKms creates a new instance of this resource
func createAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKms) MqlName() string {
	return "aws.kms"
}

func (c *mqlAwsKms) MqlID() string {
	return c.__id
}

func (c *mqlAwsKms) GetKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Keys, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.kms", c.__id, "keys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.keys()
	})
}

// mqlAwsKmsKey for the aws.kms.key resource
type mqlAwsKmsKey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsKeyInternal it will be used here
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	KeyRotationEnabled plugin.TValue[bool]
	Metadata plugin.TValue[interface{}]
}

// createAwsKmsKey creates a new instance of this resource
func createAwsKmsKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKmsKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms.key", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKmsKey) MqlName() string {
	return "aws.kms.key"
}

func (c *mqlAwsKmsKey) MqlID() string {
	return c.__id
}

func (c *mqlAwsKmsKey) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsKmsKey) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsKmsKey) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsKmsKey) GetKeyRotationEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.KeyRotationEnabled, func() (bool, error) {
		return c.keyRotationEnabled()
	})
}

func (c *mqlAwsKmsKey) GetMetadata() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Metadata, func() (interface{}, error) {
		return c.metadata()
	})
}

// mqlAwsIam for the aws.iam resource
type mqlAwsIam struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamInternal it will be used here
	Users plugin.TValue[[]interface{}]
	Roles plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	CredentialReport plugin.TValue[[]interface{}]
	AccountPasswordPolicy plugin.TValue[interface{}]
	AccountSummary plugin.TValue[map[string]interface{}]
	VirtualMfaDevices plugin.TValue[[]interface{}]
	ServerCertificates plugin.TValue[[]interface{}]
}

// createAwsIam creates a new instance of this resource
func createAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIam{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIam) MqlName() string {
	return "aws.iam"
}

func (c *mqlAwsIam) MqlID() string {
	return c.__id
}

func (c *mqlAwsIam) GetUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Users, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "users")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.users()
	})
}

func (c *mqlAwsIam) GetRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Roles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "roles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.roles()
	})
}

func (c *mqlAwsIam) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

func (c *mqlAwsIam) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "policies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.policies()
	})
}

func (c *mqlAwsIam) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIam) GetCredentialReport() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CredentialReport, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "credentialReport")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.credentialReport()
	})
}

func (c *mqlAwsIam) GetAccountPasswordPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.AccountPasswordPolicy, func() (interface{}, error) {
		return c.accountPasswordPolicy()
	})
}

func (c *mqlAwsIam) GetAccountSummary() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.AccountSummary, func() (map[string]interface{}, error) {
		return c.accountSummary()
	})
}

func (c *mqlAwsIam) GetVirtualMfaDevices() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.VirtualMfaDevices, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "virtualMfaDevices")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.virtualMfaDevices()
	})
}

func (c *mqlAwsIam) GetServerCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ServerCertificates, func() ([]interface{}, error) {
		return c.serverCertificates()
	})
}

// mqlAwsIamUsercredentialreportentry for the aws.iam.usercredentialreportentry resource
type mqlAwsIamUsercredentialreportentry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUsercredentialreportentryInternal it will be used here
	Properties plugin.TValue[map[string]interface{}]
	Arn plugin.TValue[string]
	AccessKey1Active plugin.TValue[bool]
	AccessKey1LastRotated plugin.TValue[*time.Time]
	AccessKey1LastUsedDate plugin.TValue[*time.Time]
	AccessKey1LastUsedRegion plugin.TValue[string]
	AccessKey1LastUsedService plugin.TValue[string]
	AccessKey2Active plugin.TValue[bool]
	AccessKey2LastRotated plugin.TValue[*time.Time]
	AccessKey2LastUsedDate plugin.TValue[*time.Time]
	AccessKey2LastUsedRegion plugin.TValue[string]
	AccessKey2LastUsedService plugin.TValue[string]
	Cert1Active plugin.TValue[bool]
	Cert1LastRotated plugin.TValue[*time.Time]
	Cert2Active plugin.TValue[bool]
	Cert2LastRotated plugin.TValue[*time.Time]
	MfaActive plugin.TValue[bool]
	PasswordEnabled plugin.TValue[bool]
	PasswordLastChanged plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	PasswordNextRotation plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
	UserCreationTime plugin.TValue[*time.Time]
}

// createAwsIamUsercredentialreportentry creates a new instance of this resource
func createAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUsercredentialreportentry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.usercredentialreportentry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUsercredentialreportentry) MqlName() string {
	return "aws.iam.usercredentialreportentry"
}

func (c *mqlAwsIamUsercredentialreportentry) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUsercredentialreportentry) GetProperties() *plugin.TValue[map[string]interface{}] {
	return &c.Properties
}

func (c *mqlAwsIamUsercredentialreportentry) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey1Active, func() (bool, error) {
		return c.accessKey1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastRotated, func() (*time.Time, error) {
		return c.accessKey1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastUsedDate, func() (*time.Time, error) {
		return c.accessKey1LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedRegion, func() (string, error) {
		return c.accessKey1LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedService, func() (string, error) {
		return c.accessKey1LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey2Active, func() (bool, error) {
		return c.accessKey2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastRotated, func() (*time.Time, error) {
		return c.accessKey2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastUsedDate, func() (*time.Time, error) {
		return c.accessKey2LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedRegion, func() (string, error) {
		return c.accessKey2LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedService, func() (string, error) {
		return c.accessKey2LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert1Active, func() (bool, error) {
		return c.cert1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert1LastRotated, func() (*time.Time, error) {
		return c.cert1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert2Active, func() (bool, error) {
		return c.cert2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert2LastRotated, func() (*time.Time, error) {
		return c.cert2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetMfaActive() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.MfaActive, func() (bool, error) {
		return c.mfaActive()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.PasswordEnabled, func() (bool, error) {
		return c.passwordEnabled()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastChanged() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastChanged, func() (*time.Time, error) {
		return c.passwordLastChanged()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastUsed, func() (*time.Time, error) {
		return c.passwordLastUsed()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordNextRotation() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordNextRotation, func() (*time.Time, error) {
		return c.passwordNextRotation()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.usercredentialreportentry", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUserCreationTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UserCreationTime, func() (*time.Time, error) {
		return c.userCreationTime()
	})
}

// mqlAwsIamUser for the aws.iam.user resource
type mqlAwsIamUser struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUserInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	AccessKeys plugin.TValue[[]interface{}]
}

// createAwsIamUser creates a new instance of this resource
func createAwsIamUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUser) MqlName() string {
	return "aws.iam.user"
}

func (c *mqlAwsIamUser) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUser) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamUser) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamUser) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamUser) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return &c.PasswordLastUsed
}

func (c *mqlAwsIamUser) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamUser) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		return c.policies()
	})
}

func (c *mqlAwsIamUser) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIamUser) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		return c.groups()
	})
}

func (c *mqlAwsIamUser) GetAccessKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AccessKeys, func() ([]interface{}, error) {
		return c.accessKeys()
	})
}

// mqlAwsIamPolicy for the aws.iam.policy resource
type mqlAwsIamPolicy struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamPolicyInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	IsAttachable plugin.TValue[bool]
	AttachmentCount plugin.TValue[int64]
	CreateDate plugin.TValue[*time.Time]
	UpdateDate plugin.TValue[*time.Time]
	Scope plugin.TValue[string]
	Versions plugin.TValue[[]interface{}]
	DefaultVersion plugin.TValue[*mqlAwsIamPolicyversion]
	AttachedUsers plugin.TValue[[]interface{}]
	AttachedRoles plugin.TValue[[]interface{}]
	AttachedGroups plugin.TValue[[]interface{}]
}

// createAwsIamPolicy creates a new instance of this resource
func createAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicy) MqlName() string {
	return "aws.iam.policy"
}

func (c *mqlAwsIamPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicy) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicy) GetId() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Id, func() (string, error) {
		return c.id()
	})
}

func (c *mqlAwsIamPolicy) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlAwsIamPolicy) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsIamPolicy) GetIsAttachable() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachable, func() (bool, error) {
		return c.isAttachable()
	})
}

func (c *mqlAwsIamPolicy) GetAttachmentCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.AttachmentCount, func() (int64, error) {
		return c.attachmentCount()
	})
}

func (c *mqlAwsIamPolicy) GetCreateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreateDate, func() (*time.Time, error) {
		return c.createDate()
	})
}

func (c *mqlAwsIamPolicy) GetUpdateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UpdateDate, func() (*time.Time, error) {
		return c.updateDate()
	})
}

func (c *mqlAwsIamPolicy) GetScope() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Scope, func() (string, error) {
		return c.scope()
	})
}

func (c *mqlAwsIamPolicy) GetVersions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Versions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "versions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.versions()
	})
}

func (c *mqlAwsIamPolicy) GetDefaultVersion() *plugin.TValue[*mqlAwsIamPolicyversion] {
	return plugin.GetOrCompute[*mqlAwsIamPolicyversion](&c.DefaultVersion, func() (*mqlAwsIamPolicyversion, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "defaultVersion")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamPolicyversion), nil
			}
		}

		return c.defaultVersion()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedUsers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedUsers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedUsers()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedRoles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedRoles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedRoles()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedGroups()
	})
}

// mqlAwsIamPolicyversion for the aws.iam.policyversion resource
type mqlAwsIamPolicyversion struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamPolicyversionInternal it will be used here
	Arn plugin.TValue[string]
	VersionId plugin.TValue[string]
	IsDefaultVersion plugin.TValue[bool]
	Document plugin.TValue[interface{}]
	CreateDate plugin.TValue[*time.Time]
}

// createAwsIamPolicyversion creates a new instance of this resource
func createAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicyversion{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policyversion", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicyversion) MqlName() string {
	return "aws.iam.policyversion"
}

func (c *mqlAwsIamPolicyversion) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicyversion) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicyversion) GetVersionId() *plugin.TValue[string] {
	return &c.VersionId
}

func (c *mqlAwsIamPolicyversion) GetIsDefaultVersion() *plugin.TValue[bool] {
	return &c.IsDefaultVersion
}

func (c *mqlAwsIamPolicyversion) GetDocument() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Document, func() (interface{}, error) {
		return c.document()
	})
}

func (c *mqlAwsIamPolicyversion) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

// mqlAwsIamRole for the aws.iam.role resource
type mqlAwsIamRole struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamRoleInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreateDate plugin.TValue[*time.Time]
}

// createAwsIamRole creates a new instance of this resource
func createAwsIamRole(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamRole{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.role", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamRole) MqlName() string {
	return "aws.iam.role"
}

func (c *mqlAwsIamRole) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamRole) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamRole) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamRole) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamRole) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsIamRole) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamRole) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

// mqlAwsIamGroup for the aws.iam.group resource
type mqlAwsIamGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamGroupInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	Usernames plugin.TValue[[]interface{}]
}

// createAwsIamGroup creates a new instance of this resource
func createAwsIamGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamGroup) MqlName() string {
	return "aws.iam.group"
}

func (c *mqlAwsIamGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamGroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamGroup) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamGroup) GetUsernames() *plugin.TValue[[]interface{}] {
	return &c.Usernames
}

// mqlAwsIamVirtualmfadevice for the aws.iam.virtualmfadevice resource
type mqlAwsIamVirtualmfadevice struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamVirtualmfadeviceInternal it will be used here
	SerialNumber plugin.TValue[string]
	EnableDate plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
}

// createAwsIamVirtualmfadevice creates a new instance of this resource
func createAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamVirtualmfadevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.virtualmfadevice", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamVirtualmfadevice) MqlName() string {
	return "aws.iam.virtualmfadevice"
}

func (c *mqlAwsIamVirtualmfadevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamVirtualmfadevice) GetSerialNumber() *plugin.TValue[string] {
	return &c.SerialNumber
}

func (c *mqlAwsIamVirtualmfadevice) GetEnableDate() *plugin.TValue[*time.Time] {
	return &c.EnableDate
}

func (c *mqlAwsIamVirtualmfadevice) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return &c.User
}

// mqlAwsSagemaker for the aws.sagemaker resource
type mqlAwsSagemaker struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerInternal it will be used here
	Endpoints plugin.TValue[[]interface{}]
	NotebookInstances plugin.TValue[[]interface{}]
}

// createAwsSagemaker creates a new instance of this resource
func createAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemaker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemaker) MqlName() string {
	return "aws.sagemaker"
}

func (c *mqlAwsSagemaker) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemaker) GetEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Endpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsSagemaker) GetNotebookInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NotebookInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "notebookInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.notebookInstances()
	})
}

// mqlAwsSagemakerNotebookinstance for the aws.sagemaker.notebookinstance resource
type mqlAwsSagemakerNotebookinstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerNotebookinstanceInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Details plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerNotebookinstance creates a new instance of this resource
func createAwsSagemakerNotebookinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstance) MqlName() string {
	return "aws.sagemaker.notebookinstance"
}

func (c *mqlAwsSagemakerNotebookinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerNotebookinstance) GetDetails() *plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails] {
	return plugin.GetOrCompute[*mqlAwsSagemakerNotebookinstanceDetails](&c.Details, func() (*mqlAwsSagemakerNotebookinstanceDetails, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance", c.__id, "details")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSagemakerNotebookinstanceDetails), nil
			}
		}

		return c.details()
	})
}

func (c *mqlAwsSagemakerNotebookinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerNotebookinstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSagemakerNotebookinstanceDetails for the aws.sagemaker.notebookinstance.details resource
type mqlAwsSagemakerNotebookinstanceDetails struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerNotebookinstanceDetailsInternal it will be used here
	Arn plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	DirectInternetAccess plugin.TValue[string]
}

// createAwsSagemakerNotebookinstanceDetails creates a new instance of this resource
func createAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstanceDetails{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance.details", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlName() string {
	return "aws.sagemaker.notebookinstance.details"
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance.details", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetDirectInternetAccess() *plugin.TValue[string] {
	return &c.DirectInternetAccess
}

// mqlAwsSagemakerEndpoint for the aws.sagemaker.endpoint resource
type mqlAwsSagemakerEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerEndpointInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Config plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerEndpoint creates a new instance of this resource
func createAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerEndpoint) MqlName() string {
	return "aws.sagemaker.endpoint"
}

func (c *mqlAwsSagemakerEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerEndpoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerEndpoint) GetConfig() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Config, func() (interface{}, error) {
		return c.config()
	})
}

func (c *mqlAwsSagemakerEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerEndpoint) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSns for the aws.sns resource
type mqlAwsSns struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsInternal it will be used here
	Topics plugin.TValue[[]interface{}]
}

// createAwsSns creates a new instance of this resource
func createAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSns{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSns) MqlName() string {
	return "aws.sns"
}

func (c *mqlAwsSns) MqlID() string {
	return c.__id
}

func (c *mqlAwsSns) GetTopics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Topics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns", c.__id, "topics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.topics()
	})
}

// mqlAwsSnsTopic for the aws.sns.topic resource
type mqlAwsSnsTopic struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsTopicInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Subscriptions plugin.TValue[[]interface{}]
	Attributes plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSnsTopic creates a new instance of this resource
func createAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsTopic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.topic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsTopic) MqlName() string {
	return "aws.sns.topic"
}

func (c *mqlAwsSnsTopic) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsTopic) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsTopic) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSnsTopic) GetSubscriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subscriptions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns.topic", c.__id, "subscriptions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subscriptions()
	})
}

func (c *mqlAwsSnsTopic) GetAttributes() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Attributes, func() (interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsSnsTopic) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsSnsSubscription for the aws.sns.subscription resource
type mqlAwsSnsSubscription struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsSubscriptionInternal it will be used here
	Arn plugin.TValue[string]
	Protocol plugin.TValue[string]
}

// createAwsSnsSubscription creates a new instance of this resource
func createAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsSubscription{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.subscription", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsSubscription) MqlName() string {
	return "aws.sns.subscription"
}

func (c *mqlAwsSnsSubscription) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsSubscription) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsSubscription) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsEs for the aws.es resource
type mqlAwsEs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsInternal it will be used here
	Domains plugin.TValue[[]interface{}]
}

// createAwsEs creates a new instance of this resource
func createAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEs) MqlName() string {
	return "aws.es"
}

func (c *mqlAwsEs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEs) GetDomains() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Domains, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.es", c.__id, "domains")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.domains()
	})
}

// mqlAwsEsDomain for the aws.es.domain resource
type mqlAwsEsDomain struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsDomainInternal it will be used here
	Arn plugin.TValue[string]
	EncryptionAtRestEnabled plugin.TValue[bool]
	NodeToNodeEncryptionEnabled plugin.TValue[bool]
	Name plugin.TValue[string]
	Endpoint plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsEsDomain creates a new instance of this resource
func createAwsEsDomain(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEsDomain{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es.domain", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEsDomain) MqlName() string {
	return "aws.es.domain"
}

func (c *mqlAwsEsDomain) MqlID() string {
	return c.__id
}

func (c *mqlAwsEsDomain) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEsDomain) GetEncryptionAtRestEnabled() *plugin.TValue[bool] {
	return &c.EncryptionAtRestEnabled
}

func (c *mqlAwsEsDomain) GetNodeToNodeEncryptionEnabled() *plugin.TValue[bool] {
	return &c.NodeToNodeEncryptionEnabled
}

func (c *mqlAwsEsDomain) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEsDomain) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEsDomain) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEsDomain) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsAcm for the aws.acm resource
type mqlAwsAcm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmInternal it will be used here
	Certificates plugin.TValue[[]interface{}]
}

// createAwsAcm creates a new instance of this resource
func createAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcm) MqlName() string {
	return "aws.acm"
}

func (c *mqlAwsAcm) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcm) GetCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Certificates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm", c.__id, "certificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.certificates()
	})
}

// mqlAwsAcmCertificate for the aws.acm.certificate resource
type mqlAwsAcmCertificate struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmCertificateInternal it will be used here
	Arn plugin.TValue[string]
	NotBefore plugin.TValue[*time.Time]
	NotAfter plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
	DomainName plugin.TValue[string]
	Status plugin.TValue[string]
	Subject plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsAcmCertificate creates a new instance of this resource
func createAwsAcmCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcmCertificate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm.certificate", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcmCertificate) MqlName() string {
	return "aws.acm.certificate"
}

func (c *mqlAwsAcmCertificate) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcmCertificate) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAcmCertificate) GetNotBefore() *plugin.TValue[*time.Time] {
	return &c.NotBefore
}

func (c *mqlAwsAcmCertificate) GetNotAfter() *plugin.TValue[*time.Time] {
	return &c.NotAfter
}

func (c *mqlAwsAcmCertificate) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAcmCertificate) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsAcmCertificate) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAcmCertificate) GetSubject() *plugin.TValue[string] {
	return &c.Subject
}

func (c *mqlAwsAcmCertificate) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsAutoscaling for the aws.autoscaling resource
type mqlAwsAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAutoscalingInternal it will be used here
	Groups plugin.TValue[[]interface{}]
}

// createAwsAutoscaling creates a new instance of this resource
func createAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscaling) MqlName() string {
	return "aws.autoscaling"
}

func (c *mqlAwsAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscaling) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

// mqlAwsAutoscalingGroup for the aws.autoscaling.group resource
type mqlAwsAutoscalingGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAutoscalingGroupInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	LoadBalancerNames plugin.TValue[[]interface{}]
	HealthCheckType plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsAutoscalingGroup creates a new instance of this resource
func createAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscalingGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscalingGroup) MqlName() string {
	return "aws.autoscaling.group"
}

func (c *mqlAwsAutoscalingGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscalingGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAutoscalingGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAutoscalingGroup) GetLoadBalancerNames() *plugin.TValue[[]interface{}] {
	return &c.LoadBalancerNames
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckType() *plugin.TValue[string] {
	return &c.HealthCheckType
}

func (c *mqlAwsAutoscalingGroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsElb for the aws.elb resource
type mqlAwsElb struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbInternal it will be used here
	ClassicLoadBalancers plugin.TValue[[]interface{}]
	LoadBalancers plugin.TValue[[]interface{}]
}

// createAwsElb creates a new instance of this resource
func createAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElb) MqlName() string {
	return "aws.elb"
}

func (c *mqlAwsElb) MqlID() string {
	return c.__id
}

func (c *mqlAwsElb) GetClassicLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ClassicLoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "classicLoadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.classicLoadBalancers()
	})
}

func (c *mqlAwsElb) GetLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "loadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.loadBalancers()
	})
}

// mqlAwsElbLoadbalancer for the aws.elb.loadbalancer resource
type mqlAwsElbLoadbalancer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbLoadbalancerInternal it will be used here
	Arn plugin.TValue[string]
	DnsName plugin.TValue[string]
	ListenerDescriptions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
	Scheme plugin.TValue[string]
	Attributes plugin.TValue[[]interface{}]
}

// createAwsElbLoadbalancer creates a new instance of this resource
func createAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbLoadbalancer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.loadbalancer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbLoadbalancer) MqlName() string {
	return "aws.elb.loadbalancer"
}

func (c *mqlAwsElbLoadbalancer) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbLoadbalancer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbLoadbalancer) GetDnsName() *plugin.TValue[string] {
	return &c.DnsName
}

func (c *mqlAwsElbLoadbalancer) GetListenerDescriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ListenerDescriptions, func() ([]interface{}, error) {
		return c.listenerDescriptions()
	})
}

func (c *mqlAwsElbLoadbalancer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbLoadbalancer) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlAwsElbLoadbalancer) GetAttributes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Attributes, func() ([]interface{}, error) {
		return c.attributes()
	})
}

// mqlAwsCodebuild for the aws.codebuild resource
type mqlAwsCodebuild struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildInternal it will be used here
	Projects plugin.TValue[[]interface{}]
}

// createAwsCodebuild creates a new instance of this resource
func createAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuild{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuild) MqlName() string {
	return "aws.codebuild"
}

func (c *mqlAwsCodebuild) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuild) GetProjects() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Projects, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codebuild", c.__id, "projects")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.projects()
	})
}

// mqlAwsCodebuildProject for the aws.codebuild.project resource
type mqlAwsCodebuildProject struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildProjectInternal it will be used here
	Arn plugin.TValue[string]
	Description plugin.TValue[string]
	Name plugin.TValue[string]
	Environment plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Source plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsCodebuildProject creates a new instance of this resource
func createAwsCodebuildProject(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuildProject{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild.project", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuildProject) MqlName() string {
	return "aws.codebuild.project"
}

func (c *mqlAwsCodebuildProject) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuildProject) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodebuildProject) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsCodebuildProject) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCodebuildProject) GetEnvironment() *plugin.TValue[interface{}] {
	return &c.Environment
}

func (c *mqlAwsCodebuildProject) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodebuildProject) GetSource() *plugin.TValue[interface{}] {
	return &c.Source
}

func (c *mqlAwsCodebuildProject) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsGuardduty for the aws.guardduty resource
type mqlAwsGuardduty struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyInternal it will be used here
	Detectors plugin.TValue[[]interface{}]
}

// createAwsGuardduty creates a new instance of this resource
func createAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuardduty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuardduty) MqlName() string {
	return "aws.guardduty"
}

func (c *mqlAwsGuardduty) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuardduty) GetDetectors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Detectors, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "detectors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.detectors()
	})
}

// mqlAwsGuarddutyDetector for the aws.guardduty.detector resource
type mqlAwsGuarddutyDetector struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyDetectorInternal it will be used here
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	FindingPublishingFrequency plugin.TValue[string]
	UnarchivedFindings plugin.TValue[[]interface{}]
}

// createAwsGuarddutyDetector creates a new instance of this resource
func createAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyDetector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.detector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyDetector) MqlName() string {
	return "aws.guardduty.detector"
}

func (c *mqlAwsGuarddutyDetector) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyDetector) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyDetector) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyDetector) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsGuarddutyDetector) GetFindingPublishingFrequency() *plugin.TValue[string] {
	return &c.FindingPublishingFrequency
}

func (c *mqlAwsGuarddutyDetector) GetUnarchivedFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.UnarchivedFindings, func() ([]interface{}, error) {
		return c.unarchivedFindings()
	})
}

// mqlAwsSecurityhub for the aws.securityhub resource
type mqlAwsSecurityhub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubInternal it will be used here
	Hubs plugin.TValue[[]interface{}]
}

// createAwsSecurityhub creates a new instance of this resource
func createAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhub) MqlName() string {
	return "aws.securityhub"
}

func (c *mqlAwsSecurityhub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhub) GetHubs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hubs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.securityhub", c.__id, "hubs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.hubs()
	})
}

// mqlAwsSecurityhubHub for the aws.securityhub.hub resource
type mqlAwsSecurityhubHub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubHubInternal it will be used here
	Arn plugin.TValue[string]
	SubscribedAt plugin.TValue[string]
}

// createAwsSecurityhubHub creates a new instance of this resource
func createAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhubHub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub.hub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhubHub) MqlName() string {
	return "aws.securityhub.hub"
}

func (c *mqlAwsSecurityhubHub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhubHub) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecurityhubHub) GetSubscribedAt() *plugin.TValue[string] {
	return &c.SubscribedAt
}

// mqlAwsSecretsmanager for the aws.secretsmanager resource
type mqlAwsSecretsmanager struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerInternal it will be used here
	Secrets plugin.TValue[[]interface{}]
}

// createAwsSecretsmanager creates a new instance of this resource
func createAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanager{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanager) MqlName() string {
	return "aws.secretsmanager"
}

func (c *mqlAwsSecretsmanager) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanager) GetSecrets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Secrets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.secretsmanager", c.__id, "secrets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.secrets()
	})
}

// mqlAwsSecretsmanagerSecret for the aws.secretsmanager.secret resource
type mqlAwsSecretsmanagerSecret struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerSecretInternal it will be used here
	Arn plugin.TValue[string]
	RotationEnabled plugin.TValue[bool]
	Name plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSecretsmanagerSecret creates a new instance of this resource
func createAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanagerSecret{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager.secret", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanagerSecret) MqlName() string {
	return "aws.secretsmanager.secret"
}

func (c *mqlAwsSecretsmanagerSecret) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanagerSecret) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationEnabled() *plugin.TValue[bool] {
	return &c.RotationEnabled
}

func (c *mqlAwsSecretsmanagerSecret) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSecretsmanagerSecret) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsEcs for the aws.ecs resource
type mqlAwsEcs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	Containers plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
}

// createAwsEcs creates a new instance of this resource
func createAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcs) MqlName() string {
	return "aws.ecs"
}

func (c *mqlAwsEcs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcs) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsEcs) GetContainers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Containers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containers()
	})
}

func (c *mqlAwsEcs) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

// mqlAwsEcsCluster for the aws.ecs.cluster resource
type mqlAwsEcsCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	RunningTasksCount plugin.TValue[int64]
	PendingTasksCount plugin.TValue[int64]
	RegisteredContainerInstancesCount plugin.TValue[int64]
	Configuration plugin.TValue[interface{}]
	Status plugin.TValue[string]
	Tasks plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
}

// createAwsEcsCluster creates a new instance of this resource
func createAwsEcsCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsCluster) MqlName() string {
	return "aws.ecs.cluster"
}

func (c *mqlAwsEcsCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsCluster) GetRunningTasksCount() *plugin.TValue[int64] {
	return &c.RunningTasksCount
}

func (c *mqlAwsEcsCluster) GetPendingTasksCount() *plugin.TValue[int64] {
	return &c.PendingTasksCount
}

func (c *mqlAwsEcsCluster) GetRegisteredContainerInstancesCount() *plugin.TValue[int64] {
	return &c.RegisteredContainerInstancesCount
}

func (c *mqlAwsEcsCluster) GetConfiguration() *plugin.TValue[interface{}] {
	return &c.Configuration
}

func (c *mqlAwsEcsCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsCluster) GetTasks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tasks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "tasks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tasks()
	})
}

func (c *mqlAwsEcsCluster) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

// mqlAwsEcsInstance for the aws.ecs.instance resource
type mqlAwsEcsInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInstanceInternal it will be used here
	AgentConnected plugin.TValue[bool]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	CapacityProvider plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsEcsInstance creates a new instance of this resource
func createAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsInstance) MqlName() string {
	return "aws.ecs.instance"
}

func (c *mqlAwsEcsInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsInstance) GetAgentConnected() *plugin.TValue[bool] {
	return &c.AgentConnected
}

func (c *mqlAwsEcsInstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEcsInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsInstance) GetCapacityProvider() *plugin.TValue[string] {
	return &c.CapacityProvider
}

func (c *mqlAwsEcsInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsTask for the aws.ecs.task resource
type mqlAwsEcsTask struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsTaskInternal it will be used here
	Arn plugin.TValue[string]
	ClusterName plugin.TValue[string]
	Connectivity plugin.TValue[interface{}]
	LastStatus plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Containers plugin.TValue[[]interface{}]
}

// createAwsEcsTask creates a new instance of this resource
func createAwsEcsTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTask{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.task", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTask) MqlName() string {
	return "aws.ecs.task"
}

func (c *mqlAwsEcsTask) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTask) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTask) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsTask) GetConnectivity() *plugin.TValue[interface{}] {
	return &c.Connectivity
}

func (c *mqlAwsEcsTask) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsEcsTask) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsTask) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsTask) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsTask) GetContainers() *plugin.TValue[[]interface{}] {
	return &c.Containers
}

// mqlAwsEcsContainer for the aws.ecs.container resource
type mqlAwsEcsContainer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsContainerInternal it will be used here
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	PublicIp plugin.TValue[string]
	Image plugin.TValue[string]
	ClusterName plugin.TValue[string]
	TaskDefinitionArn plugin.TValue[string]
	LogDriver plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Status plugin.TValue[string]
	Region plugin.TValue[string]
	Command plugin.TValue[[]interface{}]
	TaskArn plugin.TValue[string]
	RuntimeId plugin.TValue[string]
	ContainerName plugin.TValue[string]
}

// createAwsEcsContainer creates a new instance of this resource
func createAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsContainer) MqlName() string {
	return "aws.ecs.container"
}

func (c *mqlAwsEcsContainer) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsContainer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsContainer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsContainer) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEcsContainer) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlAwsEcsContainer) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsContainer) GetTaskDefinitionArn() *plugin.TValue[string] {
	return &c.TaskDefinitionArn
}

func (c *mqlAwsEcsContainer) GetLogDriver() *plugin.TValue[string] {
	return &c.LogDriver
}

func (c *mqlAwsEcsContainer) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsContainer) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsContainer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsContainer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcsContainer) GetCommand() *plugin.TValue[[]interface{}] {
	return &c.Command
}

func (c *mqlAwsEcsContainer) GetTaskArn() *plugin.TValue[string] {
	return &c.TaskArn
}

func (c *mqlAwsEcsContainer) GetRuntimeId() *plugin.TValue[string] {
	return &c.RuntimeId
}

func (c *mqlAwsEcsContainer) GetContainerName() *plugin.TValue[string] {
	return &c.ContainerName
}

// mqlAwsEmr for the aws.emr resource
type mqlAwsEmr struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsEmr creates a new instance of this resource
func createAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmr) MqlName() string {
	return "aws.emr"
}

func (c *mqlAwsEmr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmr) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.emr", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEmrCluster for the aws.emr.cluster resource
type mqlAwsEmrCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	NormalizedInstanceHours plugin.TValue[int64]
	OutpostArn plugin.TValue[string]
	Status plugin.TValue[interface{}]
	MasterInstances plugin.TValue[[]interface{}]
	Id plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsEmrCluster creates a new instance of this resource
func createAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmrCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmrCluster) MqlName() string {
	return "aws.emr.cluster"
}

func (c *mqlAwsEmrCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmrCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEmrCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEmrCluster) GetNormalizedInstanceHours() *plugin.TValue[int64] {
	return &c.NormalizedInstanceHours
}

func (c *mqlAwsEmrCluster) GetOutpostArn() *plugin.TValue[string] {
	return &c.OutpostArn
}

func (c *mqlAwsEmrCluster) GetStatus() *plugin.TValue[interface{}] {
	return &c.Status
}

func (c *mqlAwsEmrCluster) GetMasterInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MasterInstances, func() ([]interface{}, error) {
		return c.masterInstances()
	})
}

func (c *mqlAwsEmrCluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEmrCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsCloudwatch for the aws.cloudwatch resource
type mqlAwsCloudwatch struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchInternal it will be used here
	LogGroups plugin.TValue[[]interface{}]
	Alarms plugin.TValue[[]interface{}]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatch creates a new instance of this resource
func createAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatch) MqlName() string {
	return "aws.cloudwatch"
}

func (c *mqlAwsCloudwatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatch) GetLogGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LogGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "logGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.logGroups()
	})
}

func (c *mqlAwsCloudwatch) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatch) GetMetrics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Metrics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "metrics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metrics()
	})
}

// mqlAwsCloudwatchMetricsalarm for the aws.cloudwatch.metricsalarm resource
type mqlAwsCloudwatchMetricsalarm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricsalarmInternal it will be used here
	Arn plugin.TValue[string]
	MetricName plugin.TValue[string]
	MetricNamespace plugin.TValue[string]
	Region plugin.TValue[string]
	Actions plugin.TValue[[]interface{}]
	State plugin.TValue[string]
	StateReason plugin.TValue[string]
	InsufficientDataActions plugin.TValue[[]interface{}]
	OkActions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
}

// createAwsCloudwatchMetricsalarm creates a new instance of this resource
func createAwsCloudwatchMetricsalarm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricsalarm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricsalarm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlName() string {
	return "aws.cloudwatch.metricsalarm"
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricsalarm) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricName() *plugin.TValue[string] {
	return &c.MetricName
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricNamespace() *plugin.TValue[string] {
	return &c.MetricNamespace
}

func (c *mqlAwsCloudwatchMetricsalarm) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricsalarm) GetActions() *plugin.TValue[[]interface{}] {
	return &c.Actions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsCloudwatchMetricsalarm) GetStateReason() *plugin.TValue[string] {
	return &c.StateReason
}

func (c *mqlAwsCloudwatchMetricsalarm) GetInsufficientDataActions() *plugin.TValue[[]interface{}] {
	return &c.InsufficientDataActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetOkActions() *plugin.TValue[[]interface{}] {
	return &c.OkActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsCloudwatchMetric for the aws.cloudwatch.metric resource
type mqlAwsCloudwatchMetric struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricInternal it will be used here
	Name plugin.TValue[string]
	Namespace plugin.TValue[string]
	Region plugin.TValue[string]
	Alarms plugin.TValue[[]interface{}]
	Dimensions plugin.TValue[[]interface{}]
	Statistics plugin.TValue[*mqlAwsCloudwatchMetricstatistics]
}

// createAwsCloudwatchMetric creates a new instance of this resource
func createAwsCloudwatchMetric(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetric{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetric) MqlName() string {
	return "aws.cloudwatch.metric"
}

func (c *mqlAwsCloudwatchMetric) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetric) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetric) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetric) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetric) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatchMetric) GetDimensions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Dimensions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "dimensions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dimensions()
	})
}

func (c *mqlAwsCloudwatchMetric) GetStatistics() *plugin.TValue[*mqlAwsCloudwatchMetricstatistics] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchMetricstatistics](&c.Statistics, func() (*mqlAwsCloudwatchMetricstatistics, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "statistics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchMetricstatistics), nil
			}
		}

		return c.statistics()
	})
}

// mqlAwsCloudwatchMetricdimension for the aws.cloudwatch.metricdimension resource
type mqlAwsCloudwatchMetricdimension struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricdimensionInternal it will be used here
	Name plugin.TValue[string]
	Value plugin.TValue[string]
}

// createAwsCloudwatchMetricdimension creates a new instance of this resource
func createAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricdimension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricdimension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricdimension) MqlName() string {
	return "aws.cloudwatch.metricdimension"
}

func (c *mqlAwsCloudwatchMetricdimension) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricdimension) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricdimension) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlAwsCloudwatchMetricstatistics for the aws.cloudwatch.metricstatistics resource
type mqlAwsCloudwatchMetricstatistics struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricstatisticsInternal it will be used here
	Namespace plugin.TValue[string]
	Name plugin.TValue[string]
	Region plugin.TValue[string]
	Label plugin.TValue[string]
	Datapoints plugin.TValue[[]interface{}]
}

// createAwsCloudwatchMetricstatistics creates a new instance of this resource
func createAwsCloudwatchMetricstatistics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricstatistics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricstatistics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlName() string {
	return "aws.cloudwatch.metricstatistics"
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricstatistics) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetricstatistics) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricstatistics) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricstatistics) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAwsCloudwatchMetricstatistics) GetDatapoints() *plugin.TValue[[]interface{}] {
	return &c.Datapoints
}

// mqlAwsCloudwatchMetricDatapoint for the aws.cloudwatch.metric.datapoint resource
type mqlAwsCloudwatchMetricDatapoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricDatapointInternal it will be used here
	Id plugin.TValue[string]
	Timestamp plugin.TValue[*time.Time]
	Maximum plugin.TValue[float64]
	Minimum plugin.TValue[float64]
	Average plugin.TValue[float64]
	Sum plugin.TValue[float64]
	Unit plugin.TValue[string]
}

// createAwsCloudwatchMetricDatapoint creates a new instance of this resource
func createAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricDatapoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric.datapoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlName() string {
	return "aws.cloudwatch.metric.datapoint"
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetTimestamp() *plugin.TValue[*time.Time] {
	return &c.Timestamp
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMaximum() *plugin.TValue[float64] {
	return &c.Maximum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMinimum() *plugin.TValue[float64] {
	return &c.Minimum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetAverage() *plugin.TValue[float64] {
	return &c.Average
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetSum() *plugin.TValue[float64] {
	return &c.Sum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetUnit() *plugin.TValue[string] {
	return &c.Unit
}

// mqlAwsCloudwatchLoggroup for the aws.cloudwatch.loggroup resource
type mqlAwsCloudwatchLoggroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	MetricsFilters plugin.TValue[[]interface{}]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	Region plugin.TValue[string]
}

// createAwsCloudwatchLoggroup creates a new instance of this resource
func createAwsCloudwatchLoggroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroup) MqlName() string {
	return "aws.cloudwatch.loggroup"
}

func (c *mqlAwsCloudwatchLoggroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchLoggroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchLoggroup) GetMetricsFilters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MetricsFilters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "metricsFilters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metricsFilters()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsCloudwatchLoggroupMetricsfilter for the aws.cloudwatch.loggroup.metricsfilter resource
type mqlAwsCloudwatchLoggroupMetricsfilter struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupMetricsfilterInternal it will be used here
	Id plugin.TValue[string]
	FilterName plugin.TValue[string]
	FilterPattern plugin.TValue[string]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatchLoggroupMetricsfilter creates a new instance of this resource
func createAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroupMetricsfilter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup.metricsfilter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlName() string {
	return "aws.cloudwatch.loggroup.metricsfilter"
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterName() *plugin.TValue[string] {
	return &c.FilterName
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterPattern() *plugin.TValue[string] {
	return &c.FilterPattern
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetMetrics() *plugin.TValue[[]interface{}] {
	return &c.Metrics
}
