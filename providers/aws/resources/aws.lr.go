// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"github.com/rs/zerolog/log"
	"go.mondoo.com/mql/v13/llx"
	"go.mondoo.com/mql/v13/providers-sdk/v1/plugin"
	"go.mondoo.com/mql/v13/types"
)

// The MQL type names exposed as public consts for ease of reference.
const (
	ResourceAws                                                                 string = "aws"
	ResourceAwsAccount                                                          string = "aws.account"
	ResourceAwsAccountAlternateContact                                          string = "aws.account.alternateContact"
	ResourceAwsOrganization                                                     string = "aws.organization"
	ResourceAwsVpc                                                              string = "aws.vpc"
	ResourceAwsVpcRoutetable                                                    string = "aws.vpc.routetable"
	ResourceAwsVpcRoutetableAssociation                                         string = "aws.vpc.routetable.association"
	ResourceAwsVpcSubnet                                                        string = "aws.vpc.subnet"
	ResourceAwsVpcEndpoint                                                      string = "aws.vpc.endpoint"
	ResourceAwsVpcFlowlog                                                       string = "aws.vpc.flowlog"
	ResourceAwsVpcVpnGateway                                                    string = "aws.vpc.vpnGateway"
	ResourceAwsWaf                                                              string = "aws.waf"
	ResourceAwsWafAcl                                                           string = "aws.waf.acl"
	ResourceAwsWafRulegroup                                                     string = "aws.waf.rulegroup"
	ResourceAwsWafRule                                                          string = "aws.waf.rule"
	ResourceAwsWafRuleAction                                                    string = "aws.waf.rule.action"
	ResourceAwsWafRuleStatement                                                 string = "aws.waf.rule.statement"
	ResourceAwsWafRuleStatementGeomatchstatement                                string = "aws.waf.rule.statement.geomatchstatement"
	ResourceAwsWafRuleStatementIpsetreferencestatement                          string = "aws.waf.rule.statement.ipsetreferencestatement"
	ResourceAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig    string = "aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig"
	ResourceAwsWafRuleStatementLabelmatchstatement                              string = "aws.waf.rule.statement.labelmatchstatement"
	ResourceAwsWafRuleStatementManagedrulegroupstatement                        string = "aws.waf.rule.statement.managedrulegroupstatement"
	ResourceAwsWafRuleStatementAndstatement                                     string = "aws.waf.rule.statement.andstatement"
	ResourceAwsWafRuleStatementNotstatement                                     string = "aws.waf.rule.statement.notstatement"
	ResourceAwsWafRuleStatementOrstatement                                      string = "aws.waf.rule.statement.orstatement"
	ResourceAwsWafRuleStatementRatebasedstatement                               string = "aws.waf.rule.statement.ratebasedstatement"
	ResourceAwsWafRuleStatementRegexpatternsetreferencestatement                string = "aws.waf.rule.statement.regexpatternsetreferencestatement"
	ResourceAwsWafRuleStatementRulegroupreferencestatement                      string = "aws.waf.rule.statement.rulegroupreferencestatement"
	ResourceAwsWafRuleStatementSizeconstraintstatement                          string = "aws.waf.rule.statement.sizeconstraintstatement"
	ResourceAwsWafRuleStatementRegexmatchstatement                              string = "aws.waf.rule.statement.regexmatchstatement"
	ResourceAwsWafRuleStatementBytematchstatement                               string = "aws.waf.rule.statement.bytematchstatement"
	ResourceAwsWafRuleFieldtomatch                                              string = "aws.waf.rule.fieldtomatch"
	ResourceAwsWafRuleFieldtomatchBody                                          string = "aws.waf.rule.fieldtomatch.body"
	ResourceAwsWafRuleFieldtomatchCookie                                        string = "aws.waf.rule.fieldtomatch.cookie"
	ResourceAwsWafRuleFieldtomatchHeaderorder                                   string = "aws.waf.rule.fieldtomatch.headerorder"
	ResourceAwsWafRuleFieldtomatchSingleheader                                  string = "aws.waf.rule.fieldtomatch.singleheader"
	ResourceAwsWafRuleFieldtomatchSinglequeryargument                           string = "aws.waf.rule.fieldtomatch.singlequeryargument"
	ResourceAwsWafRuleFieldtomatchJa3fingerprint                                string = "aws.waf.rule.fieldtomatch.ja3fingerprint"
	ResourceAwsWafRuleFieldtomatchJsonbody                                      string = "aws.waf.rule.fieldtomatch.jsonbody"
	ResourceAwsWafRuleFieldtomatchJsonbodyMatchpattern                          string = "aws.waf.rule.fieldtomatch.jsonbody.matchpattern"
	ResourceAwsWafRuleFieldtomatchHeaders                                       string = "aws.waf.rule.fieldtomatch.headers"
	ResourceAwsWafRuleFieldtomatchHeadersMatchpattern                           string = "aws.waf.rule.fieldtomatch.headers.matchpattern"
	ResourceAwsWafRuleStatementXssmatchstatement                                string = "aws.waf.rule.statement.xssmatchstatement"
	ResourceAwsWafRuleStatementSqlimatchstatement                               string = "aws.waf.rule.statement.sqlimatchstatement"
	ResourceAwsWafIpset                                                         string = "aws.waf.ipset"
	ResourceAwsEfs                                                              string = "aws.efs"
	ResourceAwsEfsFilesystem                                                    string = "aws.efs.filesystem"
	ResourceAwsEfsMountTarget                                                   string = "aws.efs.mountTarget"
	ResourceAwsEfsAccessPoint                                                   string = "aws.efs.accessPoint"
	ResourceAwsFsx                                                              string = "aws.fsx"
	ResourceAwsFsxFilesystem                                                    string = "aws.fsx.filesystem"
	ResourceAwsFsxCache                                                         string = "aws.fsx.cache"
	ResourceAwsFsxBackup                                                        string = "aws.fsx.backup"
	ResourceAwsKms                                                              string = "aws.kms"
	ResourceAwsKmsKey                                                           string = "aws.kms.key"
	ResourceAwsKmsGrant                                                         string = "aws.kms.grant"
	ResourceAwsIam                                                              string = "aws.iam"
	ResourceAwsIamUsercredentialreportentry                                     string = "aws.iam.usercredentialreportentry"
	ResourceAwsIamUser                                                          string = "aws.iam.user"
	ResourceAwsIamInstanceProfile                                               string = "aws.iam.instanceProfile"
	ResourceAwsIamLoginProfile                                                  string = "aws.iam.loginProfile"
	ResourceAwsIamPolicy                                                        string = "aws.iam.policy"
	ResourceAwsIamPolicyversion                                                 string = "aws.iam.policyversion"
	ResourceAwsIamRole                                                          string = "aws.iam.role"
	ResourceAwsIamGroup                                                         string = "aws.iam.group"
	ResourceAwsIamVirtualmfadevice                                              string = "aws.iam.virtualmfadevice"
	ResourceAwsIamSamlProvider                                                  string = "aws.iam.samlProvider"
	ResourceAwsIamOidcProvider                                                  string = "aws.iam.oidcProvider"
	ResourceAwsIamAccessAnalyzer                                                string = "aws.iam.accessAnalyzer"
	ResourceAwsIamAccessanalyzerAnalyzer                                        string = "aws.iam.accessanalyzer.analyzer"
	ResourceAwsIamAccessanalyzerFinding                                         string = "aws.iam.accessanalyzer.finding"
	ResourceAwsSagemaker                                                        string = "aws.sagemaker"
	ResourceAwsSagemakerNotebookinstance                                        string = "aws.sagemaker.notebookinstance"
	ResourceAwsSagemakerNotebookinstancedetails                                 string = "aws.sagemaker.notebookinstancedetails"
	ResourceAwsSagemakerEndpoint                                                string = "aws.sagemaker.endpoint"
	ResourceAwsSns                                                              string = "aws.sns"
	ResourceAwsSnsTopic                                                         string = "aws.sns.topic"
	ResourceAwsSnsSubscription                                                  string = "aws.sns.subscription"
	ResourceAwsEs                                                               string = "aws.es"
	ResourceAwsEsDomain                                                         string = "aws.es.domain"
	ResourceAwsOpensearch                                                       string = "aws.opensearch"
	ResourceAwsOpensearchDomain                                                 string = "aws.opensearch.domain"
	ResourceAwsAcm                                                              string = "aws.acm"
	ResourceAwsAcmCertificate                                                   string = "aws.acm.certificate"
	ResourceAwsAutoscaling                                                      string = "aws.autoscaling"
	ResourceAwsAutoscalingGroup                                                 string = "aws.autoscaling.group"
	ResourceAwsAutoscalingGroupTag                                              string = "aws.autoscaling.group.tag"
	ResourceAwsElb                                                              string = "aws.elb"
	ResourceAwsElbTargetgroup                                                   string = "aws.elb.targetgroup"
	ResourceAwsElbLoadbalancer                                                  string = "aws.elb.loadbalancer"
	ResourceAwsCodebuild                                                        string = "aws.codebuild"
	ResourceAwsCodebuildProject                                                 string = "aws.codebuild.project"
	ResourceAwsGuardduty                                                        string = "aws.guardduty"
	ResourceAwsGuarddutyDetector                                                string = "aws.guardduty.detector"
	ResourceAwsGuarddutyFinding                                                 string = "aws.guardduty.finding"
	ResourceAwsMacie                                                            string = "aws.macie"
	ResourceAwsMacieSession                                                     string = "aws.macie.session"
	ResourceAwsMacieClassificationJob                                           string = "aws.macie.classificationJob"
	ResourceAwsMacieFinding                                                     string = "aws.macie.finding"
	ResourceAwsMacieCustomDataIdentifier                                        string = "aws.macie.customDataIdentifier"
	ResourceAwsSecurityhub                                                      string = "aws.securityhub"
	ResourceAwsSecurityhubHub                                                   string = "aws.securityhub.hub"
	ResourceAwsSecretsmanager                                                   string = "aws.secretsmanager"
	ResourceAwsSecretsmanagerSecret                                             string = "aws.secretsmanager.secret"
	ResourceAwsSecretsmanagerSecretRotationRules                                string = "aws.secretsmanager.secret.rotationRules"
	ResourceAwsEcs                                                              string = "aws.ecs"
	ResourceAwsEcsCluster                                                       string = "aws.ecs.cluster"
	ResourceAwsEcsInstance                                                      string = "aws.ecs.instance"
	ResourceAwsEcsTask                                                          string = "aws.ecs.task"
	ResourceAwsEcsContainer                                                     string = "aws.ecs.container"
	ResourceAwsEcsTaskDefinition                                                string = "aws.ecs.taskDefinition"
	ResourceAwsEcsService                                                       string = "aws.ecs.service"
	ResourceAwsEcsTaskSet                                                       string = "aws.ecs.taskSet"
	ResourceAwsEcsTaskSetNetworkConfiguration                                   string = "aws.ecs.taskSet.networkConfiguration"
	ResourceAwsEcsServiceDeploymentConfiguration                                string = "aws.ecs.service.deploymentConfiguration"
	ResourceAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker        string = "aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker"
	ResourceAwsEcsServiceNetworkConfiguration                                   string = "aws.ecs.service.networkConfiguration"
	ResourceAwsEcsServiceNetworkConfigurationAwsVpcConfiguration                string = "aws.ecs.service.networkConfiguration.awsVpcConfiguration"
	ResourceAwsEcsTaskDefinitionContainerDefinition                             string = "aws.ecs.taskDefinition.containerDefinition"
	ResourceAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable          string = "aws.ecs.taskDefinition.containerDefinition.environmentVariable"
	ResourceAwsEcsTaskDefinitionContainerDefinitionSecret                       string = "aws.ecs.taskDefinition.containerDefinition.secret"
	ResourceAwsEcsTaskDefinitionContainerDefinitionLogConfiguration             string = "aws.ecs.taskDefinition.containerDefinition.logConfiguration"
	ResourceAwsEcsTaskDefinitionContainerDefinitionPortMapping                  string = "aws.ecs.taskDefinition.containerDefinition.portMapping"
	ResourceAwsEcsTaskDefinitionVolume                                          string = "aws.ecs.taskDefinition.volume"
	ResourceAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration                    string = "aws.ecs.taskDefinition.volume.efsVolumeConfiguration"
	ResourceAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig string = "aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig"
	ResourceAwsEcsTaskDefinitionVolumeHost                                      string = "aws.ecs.taskDefinition.volume.host"
	ResourceAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration                 string = "aws.ecs.taskDefinition.volume.dockerVolumeConfiguration"
	ResourceAwsEcsTaskDefinitionEphemeralStorage                                string = "aws.ecs.taskDefinition.ephemeralStorage"
	ResourceAwsEmr                                                              string = "aws.emr"
	ResourceAwsEmrCluster                                                       string = "aws.emr.cluster"
	ResourceAwsCloudwatch                                                       string = "aws.cloudwatch"
	ResourceAwsCloudwatchMetricsalarm                                           string = "aws.cloudwatch.metricsalarm"
	ResourceAwsCloudwatchMetric                                                 string = "aws.cloudwatch.metric"
	ResourceAwsCloudwatchMetricdimension                                        string = "aws.cloudwatch.metricdimension"
	ResourceAwsCloudwatchMetricstatistics                                       string = "aws.cloudwatch.metricstatistics"
	ResourceAwsCloudwatchMetricDatapoint                                        string = "aws.cloudwatch.metric.datapoint"
	ResourceAwsCloudwatchLoggroup                                               string = "aws.cloudwatch.loggroup"
	ResourceAwsCloudwatchLoggroupMetricsfilter                                  string = "aws.cloudwatch.loggroup.metricsfilter"
	ResourceAwsCloudfront                                                       string = "aws.cloudfront"
	ResourceAwsCloudfrontDistribution                                           string = "aws.cloudfront.distribution"
	ResourceAwsCloudfrontDistributionOrigin                                     string = "aws.cloudfront.distribution.origin"
	ResourceAwsCloudfrontFunction                                               string = "aws.cloudfront.function"
	ResourceAwsCloudtrail                                                       string = "aws.cloudtrail"
	ResourceAwsCloudtrailTrail                                                  string = "aws.cloudtrail.trail"
	ResourceAwsS3control                                                        string = "aws.s3control"
	ResourceAwsS3                                                               string = "aws.s3"
	ResourceAwsS3Bucket                                                         string = "aws.s3.bucket"
	ResourceAwsS3BucketGrant                                                    string = "aws.s3.bucket.grant"
	ResourceAwsS3BucketCorsrule                                                 string = "aws.s3.bucket.corsrule"
	ResourceAwsS3BucketPolicy                                                   string = "aws.s3.bucket.policy"
	ResourceAwsS3BucketWebsiteConfiguration                                     string = "aws.s3.bucket.websiteConfiguration"
	ResourceAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf            string = "aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf"
	ResourceAwsS3BucketWebsiteConfigurationRoutingRule                          string = "aws.s3.bucket.websiteConfiguration.routingRule"
	ResourceAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf              string = "aws.s3.bucket.websiteConfiguration.routingRule.redirectConf"
	ResourceAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf             string = "aws.s3.bucket.websiteConfiguration.routingRule.conditionConf"
	ResourceAwsApplicationAutoscaling                                           string = "aws.applicationAutoscaling"
	ResourceAwsApplicationAutoscalingTarget                                     string = "aws.applicationAutoscaling.target"
	ResourceAwsApplicationAutoscalingPolicy                                     string = "aws.applicationAutoscaling.policy"
	ResourceAwsApplicationAutoscalingScheduledAction                            string = "aws.applicationAutoscaling.scheduledAction"
	ResourceAwsDrs                                                              string = "aws.drs"
	ResourceAwsDrsSourceServer                                                  string = "aws.drs.sourceServer"
	ResourceAwsDrsJob                                                           string = "aws.drs.job"
	ResourceAwsDrsReplicationConfiguration                                      string = "aws.drs.replicationConfiguration"
	ResourceAwsDrsLaunchConfiguration                                           string = "aws.drs.launchConfiguration"
	ResourceAwsBackup                                                           string = "aws.backup"
	ResourceAwsBackupVault                                                      string = "aws.backup.vault"
	ResourceAwsBackupVaultRecoveryPoint                                         string = "aws.backup.vaultRecoveryPoint"
	ResourceAwsDynamodb                                                         string = "aws.dynamodb"
	ResourceAwsDynamodbExport                                                   string = "aws.dynamodb.export"
	ResourceAwsDynamodbLimit                                                    string = "aws.dynamodb.limit"
	ResourceAwsDynamodbGlobaltable                                              string = "aws.dynamodb.globaltable"
	ResourceAwsDynamodbTable                                                    string = "aws.dynamodb.table"
	ResourceAwsSqs                                                              string = "aws.sqs"
	ResourceAwsSqsQueue                                                         string = "aws.sqs.queue"
	ResourceAwsRds                                                              string = "aws.rds"
	ResourceAwsRdsBackupsetting                                                 string = "aws.rds.backupsetting"
	ResourceAwsRdsDbcluster                                                     string = "aws.rds.dbcluster"
	ResourceAwsRdsSnapshot                                                      string = "aws.rds.snapshot"
	ResourceAwsRdsDbinstance                                                    string = "aws.rds.dbinstance"
	ResourceAwsRdsPendingMaintenanceAction                                      string = "aws.rds.pendingMaintenanceAction"
	ResourceAwsRdsClusterParameterGroup                                         string = "aws.rds.clusterParameterGroup"
	ResourceAwsRdsParameterGroup                                                string = "aws.rds.parameterGroup"
	ResourceAwsRdsParameterGroupParameter                                       string = "aws.rds.parameterGroup.parameter"
	ResourceAwsElasticache                                                      string = "aws.elasticache"
	ResourceAwsElasticacheCluster                                               string = "aws.elasticache.cluster"
	ResourceAwsElasticacheServerlessCache                                       string = "aws.elasticache.serverlessCache"
	ResourceAwsRedshift                                                         string = "aws.redshift"
	ResourceAwsRedshiftCluster                                                  string = "aws.redshift.cluster"
	ResourceAwsEcr                                                              string = "aws.ecr"
	ResourceAwsEcrRepository                                                    string = "aws.ecr.repository"
	ResourceAwsEcrImage                                                         string = "aws.ecr.image"
	ResourceAwsDms                                                              string = "aws.dms"
	ResourceAwsApigateway                                                       string = "aws.apigateway"
	ResourceAwsApigatewayRestapi                                                string = "aws.apigateway.restapi"
	ResourceAwsApigatewayStage                                                  string = "aws.apigateway.stage"
	ResourceAwsLambda                                                           string = "aws.lambda"
	ResourceAwsLambdaFunction                                                   string = "aws.lambda.function"
	ResourceAwsLambdaFunctionUrlConfig                                          string = "aws.lambda.function.urlConfig"
	ResourceAwsSsm                                                              string = "aws.ssm"
	ResourceAwsSsmParameter                                                     string = "aws.ssm.parameter"
	ResourceAwsSsmInstance                                                      string = "aws.ssm.instance"
	ResourceAwsEc2                                                              string = "aws.ec2"
	ResourceAwsEc2Eip                                                           string = "aws.ec2.eip"
	ResourceAwsVpcNatgateway                                                    string = "aws.vpc.natgateway"
	ResourceAwsVpcNatgatewayAddress                                             string = "aws.vpc.natgateway.address"
	ResourceAwsVpcServiceEndpoint                                               string = "aws.vpc.serviceEndpoint"
	ResourceAwsVpcPeeringConnection                                             string = "aws.vpc.peeringConnection"
	ResourceAwsVpcPeeringConnectionPeeringVpc                                   string = "aws.vpc.peeringConnection.peeringVpc"
	ResourceAwsEc2Networkacl                                                    string = "aws.ec2.networkacl"
	ResourceAwsEc2NetworkaclAssociation                                         string = "aws.ec2.networkacl.association"
	ResourceAwsEc2NetworkaclEntry                                               string = "aws.ec2.networkacl.entry"
	ResourceAwsEc2NetworkaclEntryPortrange                                      string = "aws.ec2.networkacl.entry.portrange"
	ResourceAwsEc2Vpnconnection                                                 string = "aws.ec2.vpnconnection"
	ResourceAwsEc2Vgwtelemetry                                                  string = "aws.ec2.vgwtelemetry"
	ResourceAwsEc2Internetgateway                                               string = "aws.ec2.internetgateway"
	ResourceAwsEc2Snapshot                                                      string = "aws.ec2.snapshot"
	ResourceAwsEc2Volume                                                        string = "aws.ec2.volume"
	ResourceAwsInspector                                                        string = "aws.inspector"
	ResourceAwsInspectorCoverage                                                string = "aws.inspector.coverage"
	ResourceAwsInspectorCoverageInstance                                        string = "aws.inspector.coverage.instance"
	ResourceAwsInspectorCoverageImage                                           string = "aws.inspector.coverage.image"
	ResourceAwsInspectorCoverageRepository                                      string = "aws.inspector.coverage.repository"
	ResourceAwsEc2Instance                                                      string = "aws.ec2.instance"
	ResourceAwsEc2Networkinterface                                              string = "aws.ec2.networkinterface"
	ResourceAwsEc2Keypair                                                       string = "aws.ec2.keypair"
	ResourceAwsEc2Image                                                         string = "aws.ec2.image"
	ResourceAwsEc2ImageLaunchPermission                                         string = "aws.ec2.image.launchPermission"
	ResourceAwsEc2ImageBlockDeviceMapping                                       string = "aws.ec2.image.blockDeviceMapping"
	ResourceAwsEc2ImageEbsBlockDevice                                           string = "aws.ec2.image.ebsBlockDevice"
	ResourceAwsEc2InstanceDevice                                                string = "aws.ec2.instance.device"
	ResourceAwsEc2Securitygroup                                                 string = "aws.ec2.securitygroup"
	ResourceAwsEc2SecuritygroupIppermission                                     string = "aws.ec2.securitygroup.ippermission"
	ResourceAwsConfig                                                           string = "aws.config"
	ResourceAwsConfigRule                                                       string = "aws.config.rule"
	ResourceAwsConfigRecorder                                                   string = "aws.config.recorder"
	ResourceAwsConfigDeliverychannel                                            string = "aws.config.deliverychannel"
	ResourceAwsEks                                                              string = "aws.eks"
	ResourceAwsEksNodegroup                                                     string = "aws.eks.nodegroup"
	ResourceAwsEksAddon                                                         string = "aws.eks.addon"
	ResourceAwsEksCluster                                                       string = "aws.eks.cluster"
	ResourceAwsNeptune                                                          string = "aws.neptune"
	ResourceAwsNeptuneCluster                                                   string = "aws.neptune.cluster"
	ResourceAwsNeptuneInstance                                                  string = "aws.neptune.instance"
	ResourceAwsTimestreamLiveanalytics                                          string = "aws.timestream.liveanalytics"
	ResourceAwsTimestreamLiveanalyticsDatabase                                  string = "aws.timestream.liveanalytics.database"
	ResourceAwsTimestreamLiveanalyticsTable                                     string = "aws.timestream.liveanalytics.table"
	ResourceAwsCodedeploy                                                       string = "aws.codedeploy"
	ResourceAwsCodedeployApplication                                            string = "aws.codedeploy.application"
	ResourceAwsCodedeployDeploymentGroup                                        string = "aws.codedeploy.deploymentGroup"
	ResourceAwsCodedeployDeployment                                             string = "aws.codedeploy.deployment"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory{
		"aws": {
			// to override args, implement: initAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAws,
		},
		"aws.account": {
			Init:   initAwsAccount,
			Create: createAwsAccount,
		},
		"aws.account.alternateContact": {
			Init:   initAwsAccountAlternateContact,
			Create: createAwsAccountAlternateContact,
		},
		"aws.organization": {
			// to override args, implement: initAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsOrganization,
		},
		"aws.vpc": {
			Init:   initAwsVpc,
			Create: createAwsVpc,
		},
		"aws.vpc.routetable": {
			// to override args, implement: initAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetable,
		},
		"aws.vpc.routetable.association": {
			// to override args, implement: initAwsVpcRoutetableAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetableAssociation,
		},
		"aws.vpc.subnet": {
			Init:   initAwsVpcSubnet,
			Create: createAwsVpcSubnet,
		},
		"aws.vpc.endpoint": {
			// to override args, implement: initAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcEndpoint,
		},
		"aws.vpc.flowlog": {
			// to override args, implement: initAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcFlowlog,
		},
		"aws.vpc.vpnGateway": {
			// to override args, implement: initAwsVpcVpnGateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcVpnGateway,
		},
		"aws.waf": {
			Init:   initAwsWaf,
			Create: createAwsWaf,
		},
		"aws.waf.acl": {
			// to override args, implement: initAwsWafAcl(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafAcl,
		},
		"aws.waf.rulegroup": {
			// to override args, implement: initAwsWafRulegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRulegroup,
		},
		"aws.waf.rule": {
			// to override args, implement: initAwsWafRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRule,
		},
		"aws.waf.rule.action": {
			// to override args, implement: initAwsWafRuleAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleAction,
		},
		"aws.waf.rule.statement": {
			// to override args, implement: initAwsWafRuleStatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatement,
		},
		"aws.waf.rule.statement.geomatchstatement": {
			// to override args, implement: initAwsWafRuleStatementGeomatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementGeomatchstatement,
		},
		"aws.waf.rule.statement.ipsetreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementIpsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementIpsetreferencestatement,
		},
		"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig": {
			// to override args, implement: initAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig,
		},
		"aws.waf.rule.statement.labelmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementLabelmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementLabelmatchstatement,
		},
		"aws.waf.rule.statement.managedrulegroupstatement": {
			// to override args, implement: initAwsWafRuleStatementManagedrulegroupstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementManagedrulegroupstatement,
		},
		"aws.waf.rule.statement.andstatement": {
			// to override args, implement: initAwsWafRuleStatementAndstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementAndstatement,
		},
		"aws.waf.rule.statement.notstatement": {
			// to override args, implement: initAwsWafRuleStatementNotstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementNotstatement,
		},
		"aws.waf.rule.statement.orstatement": {
			// to override args, implement: initAwsWafRuleStatementOrstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementOrstatement,
		},
		"aws.waf.rule.statement.ratebasedstatement": {
			// to override args, implement: initAwsWafRuleStatementRatebasedstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRatebasedstatement,
		},
		"aws.waf.rule.statement.regexpatternsetreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementRegexpatternsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRegexpatternsetreferencestatement,
		},
		"aws.waf.rule.statement.rulegroupreferencestatement": {
			// to override args, implement: initAwsWafRuleStatementRulegroupreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRulegroupreferencestatement,
		},
		"aws.waf.rule.statement.sizeconstraintstatement": {
			// to override args, implement: initAwsWafRuleStatementSizeconstraintstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementSizeconstraintstatement,
		},
		"aws.waf.rule.statement.regexmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementRegexmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementRegexmatchstatement,
		},
		"aws.waf.rule.statement.bytematchstatement": {
			// to override args, implement: initAwsWafRuleStatementBytematchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementBytematchstatement,
		},
		"aws.waf.rule.fieldtomatch": {
			// to override args, implement: initAwsWafRuleFieldtomatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatch,
		},
		"aws.waf.rule.fieldtomatch.body": {
			// to override args, implement: initAwsWafRuleFieldtomatchBody(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchBody,
		},
		"aws.waf.rule.fieldtomatch.cookie": {
			// to override args, implement: initAwsWafRuleFieldtomatchCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchCookie,
		},
		"aws.waf.rule.fieldtomatch.headerorder": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeaderorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeaderorder,
		},
		"aws.waf.rule.fieldtomatch.singleheader": {
			// to override args, implement: initAwsWafRuleFieldtomatchSingleheader(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchSingleheader,
		},
		"aws.waf.rule.fieldtomatch.singlequeryargument": {
			// to override args, implement: initAwsWafRuleFieldtomatchSinglequeryargument(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchSinglequeryargument,
		},
		"aws.waf.rule.fieldtomatch.ja3fingerprint": {
			// to override args, implement: initAwsWafRuleFieldtomatchJa3fingerprint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJa3fingerprint,
		},
		"aws.waf.rule.fieldtomatch.jsonbody": {
			// to override args, implement: initAwsWafRuleFieldtomatchJsonbody(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJsonbody,
		},
		"aws.waf.rule.fieldtomatch.jsonbody.matchpattern": {
			// to override args, implement: initAwsWafRuleFieldtomatchJsonbodyMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchJsonbodyMatchpattern,
		},
		"aws.waf.rule.fieldtomatch.headers": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeaders(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeaders,
		},
		"aws.waf.rule.fieldtomatch.headers.matchpattern": {
			// to override args, implement: initAwsWafRuleFieldtomatchHeadersMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleFieldtomatchHeadersMatchpattern,
		},
		"aws.waf.rule.statement.xssmatchstatement": {
			// to override args, implement: initAwsWafRuleStatementXssmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementXssmatchstatement,
		},
		"aws.waf.rule.statement.sqlimatchstatement": {
			// to override args, implement: initAwsWafRuleStatementSqlimatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafRuleStatementSqlimatchstatement,
		},
		"aws.waf.ipset": {
			// to override args, implement: initAwsWafIpset(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsWafIpset,
		},
		"aws.efs": {
			// to override args, implement: initAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfs,
		},
		"aws.efs.filesystem": {
			Init:   initAwsEfsFilesystem,
			Create: createAwsEfsFilesystem,
		},
		"aws.efs.mountTarget": {
			// to override args, implement: initAwsEfsMountTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfsMountTarget,
		},
		"aws.efs.accessPoint": {
			// to override args, implement: initAwsEfsAccessPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfsAccessPoint,
		},
		"aws.fsx": {
			// to override args, implement: initAwsFsx(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsFsx,
		},
		"aws.fsx.filesystem": {
			Init:   initAwsFsxFilesystem,
			Create: createAwsFsxFilesystem,
		},
		"aws.fsx.cache": {
			Init:   initAwsFsxCache,
			Create: createAwsFsxCache,
		},
		"aws.fsx.backup": {
			Init:   initAwsFsxBackup,
			Create: createAwsFsxBackup,
		},
		"aws.kms": {
			// to override args, implement: initAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsKms,
		},
		"aws.kms.key": {
			Init:   initAwsKmsKey,
			Create: createAwsKmsKey,
		},
		"aws.kms.grant": {
			// to override args, implement: initAwsKmsGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsKmsGrant,
		},
		"aws.iam": {
			// to override args, implement: initAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIam,
		},
		"aws.iam.usercredentialreportentry": {
			// to override args, implement: initAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamUsercredentialreportentry,
		},
		"aws.iam.user": {
			Init:   initAwsIamUser,
			Create: createAwsIamUser,
		},
		"aws.iam.instanceProfile": {
			Init:   initAwsIamInstanceProfile,
			Create: createAwsIamInstanceProfile,
		},
		"aws.iam.loginProfile": {
			// to override args, implement: initAwsIamLoginProfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamLoginProfile,
		},
		"aws.iam.policy": {
			// to override args, implement: initAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicy,
		},
		"aws.iam.policyversion": {
			// to override args, implement: initAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicyversion,
		},
		"aws.iam.role": {
			Init:   initAwsIamRole,
			Create: createAwsIamRole,
		},
		"aws.iam.group": {
			Init:   initAwsIamGroup,
			Create: createAwsIamGroup,
		},
		"aws.iam.virtualmfadevice": {
			// to override args, implement: initAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamVirtualmfadevice,
		},
		"aws.iam.samlProvider": {
			// to override args, implement: initAwsIamSamlProvider(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamSamlProvider,
		},
		"aws.iam.oidcProvider": {
			// to override args, implement: initAwsIamOidcProvider(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamOidcProvider,
		},
		"aws.iam.accessAnalyzer": {
			// to override args, implement: initAwsIamAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessAnalyzer,
		},
		"aws.iam.accessanalyzer.analyzer": {
			// to override args, implement: initAwsIamAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessanalyzerAnalyzer,
		},
		"aws.iam.accessanalyzer.finding": {
			// to override args, implement: initAwsIamAccessanalyzerFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamAccessanalyzerFinding,
		},
		"aws.sagemaker": {
			// to override args, implement: initAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemaker,
		},
		"aws.sagemaker.notebookinstance": {
			Init:   initAwsSagemakerNotebookinstance,
			Create: createAwsSagemakerNotebookinstance,
		},
		"aws.sagemaker.notebookinstancedetails": {
			// to override args, implement: initAwsSagemakerNotebookinstancedetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerNotebookinstancedetails,
		},
		"aws.sagemaker.endpoint": {
			// to override args, implement: initAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerEndpoint,
		},
		"aws.sns": {
			// to override args, implement: initAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSns,
		},
		"aws.sns.topic": {
			// to override args, implement: initAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsTopic,
		},
		"aws.sns.subscription": {
			// to override args, implement: initAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsSubscription,
		},
		"aws.es": {
			// to override args, implement: initAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEs,
		},
		"aws.es.domain": {
			Init:   initAwsEsDomain,
			Create: createAwsEsDomain,
		},
		"aws.opensearch": {
			// to override args, implement: initAwsOpensearch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsOpensearch,
		},
		"aws.opensearch.domain": {
			Init:   initAwsOpensearchDomain,
			Create: createAwsOpensearchDomain,
		},
		"aws.acm": {
			// to override args, implement: initAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAcm,
		},
		"aws.acm.certificate": {
			Init:   initAwsAcmCertificate,
			Create: createAwsAcmCertificate,
		},
		"aws.autoscaling": {
			// to override args, implement: initAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscaling,
		},
		"aws.autoscaling.group": {
			Init:   initAwsAutoscalingGroup,
			Create: createAwsAutoscalingGroup,
		},
		"aws.autoscaling.group.tag": {
			// to override args, implement: initAwsAutoscalingGroupTag(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscalingGroupTag,
		},
		"aws.elb": {
			// to override args, implement: initAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElb,
		},
		"aws.elb.targetgroup": {
			// to override args, implement: initAwsElbTargetgroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElbTargetgroup,
		},
		"aws.elb.loadbalancer": {
			Init:   initAwsElbLoadbalancer,
			Create: createAwsElbLoadbalancer,
		},
		"aws.codebuild": {
			// to override args, implement: initAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodebuild,
		},
		"aws.codebuild.project": {
			Init:   initAwsCodebuildProject,
			Create: createAwsCodebuildProject,
		},
		"aws.guardduty": {
			// to override args, implement: initAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuardduty,
		},
		"aws.guardduty.detector": {
			// to override args, implement: initAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuarddutyDetector,
		},
		"aws.guardduty.finding": {
			// to override args, implement: initAwsGuarddutyFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuarddutyFinding,
		},
		"aws.macie": {
			// to override args, implement: initAwsMacie(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsMacie,
		},
		"aws.macie.session": {
			// to override args, implement: initAwsMacieSession(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsMacieSession,
		},
		"aws.macie.classificationJob": {
			// to override args, implement: initAwsMacieClassificationJob(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsMacieClassificationJob,
		},
		"aws.macie.finding": {
			// to override args, implement: initAwsMacieFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsMacieFinding,
		},
		"aws.macie.customDataIdentifier": {
			// to override args, implement: initAwsMacieCustomDataIdentifier(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsMacieCustomDataIdentifier,
		},
		"aws.securityhub": {
			// to override args, implement: initAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhub,
		},
		"aws.securityhub.hub": {
			// to override args, implement: initAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhubHub,
		},
		"aws.secretsmanager": {
			// to override args, implement: initAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanager,
		},
		"aws.secretsmanager.secret": {
			Init:   initAwsSecretsmanagerSecret,
			Create: createAwsSecretsmanagerSecret,
		},
		"aws.secretsmanager.secret.rotationRules": {
			// to override args, implement: initAwsSecretsmanagerSecretRotationRules(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanagerSecretRotationRules,
		},
		"aws.ecs": {
			// to override args, implement: initAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcs,
		},
		"aws.ecs.cluster": {
			Init:   initAwsEcsCluster,
			Create: createAwsEcsCluster,
		},
		"aws.ecs.instance": {
			// to override args, implement: initAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsInstance,
		},
		"aws.ecs.task": {
			Init:   initAwsEcsTask,
			Create: createAwsEcsTask,
		},
		"aws.ecs.container": {
			// to override args, implement: initAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsContainer,
		},
		"aws.ecs.taskDefinition": {
			// to override args, implement: initAwsEcsTaskDefinition(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinition,
		},
		"aws.ecs.service": {
			Init:   initAwsEcsService,
			Create: createAwsEcsService,
		},
		"aws.ecs.taskSet": {
			// to override args, implement: initAwsEcsTaskSet(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskSet,
		},
		"aws.ecs.taskSet.networkConfiguration": {
			// to override args, implement: initAwsEcsTaskSetNetworkConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskSetNetworkConfiguration,
		},
		"aws.ecs.service.deploymentConfiguration": {
			// to override args, implement: initAwsEcsServiceDeploymentConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsServiceDeploymentConfiguration,
		},
		"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker": {
			// to override args, implement: initAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker,
		},
		"aws.ecs.service.networkConfiguration": {
			// to override args, implement: initAwsEcsServiceNetworkConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsServiceNetworkConfiguration,
		},
		"aws.ecs.service.networkConfiguration.awsVpcConfiguration": {
			// to override args, implement: initAwsEcsServiceNetworkConfigurationAwsVpcConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsServiceNetworkConfigurationAwsVpcConfiguration,
		},
		"aws.ecs.taskDefinition.containerDefinition": {
			// to override args, implement: initAwsEcsTaskDefinitionContainerDefinition(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionContainerDefinition,
		},
		"aws.ecs.taskDefinition.containerDefinition.environmentVariable": {
			// to override args, implement: initAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable,
		},
		"aws.ecs.taskDefinition.containerDefinition.secret": {
			// to override args, implement: initAwsEcsTaskDefinitionContainerDefinitionSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionContainerDefinitionSecret,
		},
		"aws.ecs.taskDefinition.containerDefinition.logConfiguration": {
			// to override args, implement: initAwsEcsTaskDefinitionContainerDefinitionLogConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionContainerDefinitionLogConfiguration,
		},
		"aws.ecs.taskDefinition.containerDefinition.portMapping": {
			// to override args, implement: initAwsEcsTaskDefinitionContainerDefinitionPortMapping(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionContainerDefinitionPortMapping,
		},
		"aws.ecs.taskDefinition.volume": {
			// to override args, implement: initAwsEcsTaskDefinitionVolume(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionVolume,
		},
		"aws.ecs.taskDefinition.volume.efsVolumeConfiguration": {
			// to override args, implement: initAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration,
		},
		"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig": {
			// to override args, implement: initAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig,
		},
		"aws.ecs.taskDefinition.volume.host": {
			// to override args, implement: initAwsEcsTaskDefinitionVolumeHost(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionVolumeHost,
		},
		"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration": {
			// to override args, implement: initAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration,
		},
		"aws.ecs.taskDefinition.ephemeralStorage": {
			// to override args, implement: initAwsEcsTaskDefinitionEphemeralStorage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsTaskDefinitionEphemeralStorage,
		},
		"aws.emr": {
			// to override args, implement: initAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmr,
		},
		"aws.emr.cluster": {
			// to override args, implement: initAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmrCluster,
		},
		"aws.cloudwatch": {
			// to override args, implement: initAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatch,
		},
		"aws.cloudwatch.metricsalarm": {
			Init:   initAwsCloudwatchMetricsalarm,
			Create: createAwsCloudwatchMetricsalarm,
		},
		"aws.cloudwatch.metric": {
			Init:   initAwsCloudwatchMetric,
			Create: createAwsCloudwatchMetric,
		},
		"aws.cloudwatch.metricdimension": {
			// to override args, implement: initAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricdimension,
		},
		"aws.cloudwatch.metricstatistics": {
			Init:   initAwsCloudwatchMetricstatistics,
			Create: createAwsCloudwatchMetricstatistics,
		},
		"aws.cloudwatch.metric.datapoint": {
			// to override args, implement: initAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricDatapoint,
		},
		"aws.cloudwatch.loggroup": {
			Init:   initAwsCloudwatchLoggroup,
			Create: createAwsCloudwatchLoggroup,
		},
		"aws.cloudwatch.loggroup.metricsfilter": {
			// to override args, implement: initAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchLoggroupMetricsfilter,
		},
		"aws.cloudfront": {
			// to override args, implement: initAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfront,
		},
		"aws.cloudfront.distribution": {
			// to override args, implement: initAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistribution,
		},
		"aws.cloudfront.distribution.origin": {
			// to override args, implement: initAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistributionOrigin,
		},
		"aws.cloudfront.function": {
			// to override args, implement: initAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontFunction,
		},
		"aws.cloudtrail": {
			// to override args, implement: initAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudtrail,
		},
		"aws.cloudtrail.trail": {
			Init:   initAwsCloudtrailTrail,
			Create: createAwsCloudtrailTrail,
		},
		"aws.s3control": {
			// to override args, implement: initAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3control,
		},
		"aws.s3": {
			// to override args, implement: initAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3,
		},
		"aws.s3.bucket": {
			Init:   initAwsS3Bucket,
			Create: createAwsS3Bucket,
		},
		"aws.s3.bucket.grant": {
			// to override args, implement: initAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketGrant,
		},
		"aws.s3.bucket.corsrule": {
			// to override args, implement: initAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketCorsrule,
		},
		"aws.s3.bucket.policy": {
			Init:   initAwsS3BucketPolicy,
			Create: createAwsS3BucketPolicy,
		},
		"aws.s3.bucket.websiteConfiguration": {
			// to override args, implement: initAwsS3BucketWebsiteConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketWebsiteConfiguration,
		},
		"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf": {
			// to override args, implement: initAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf,
		},
		"aws.s3.bucket.websiteConfiguration.routingRule": {
			// to override args, implement: initAwsS3BucketWebsiteConfigurationRoutingRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketWebsiteConfigurationRoutingRule,
		},
		"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf": {
			// to override args, implement: initAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf,
		},
		"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf": {
			// to override args, implement: initAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf,
		},
		"aws.applicationAutoscaling": {
			// to override args, implement: initAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscaling,
		},
		"aws.applicationAutoscaling.target": {
			// to override args, implement: initAwsApplicationAutoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscalingTarget,
		},
		"aws.applicationAutoscaling.policy": {
			// to override args, implement: initAwsApplicationAutoscalingPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscalingPolicy,
		},
		"aws.applicationAutoscaling.scheduledAction": {
			// to override args, implement: initAwsApplicationAutoscalingScheduledAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscalingScheduledAction,
		},
		"aws.drs": {
			// to override args, implement: initAwsDrs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDrs,
		},
		"aws.drs.sourceServer": {
			// to override args, implement: initAwsDrsSourceServer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDrsSourceServer,
		},
		"aws.drs.job": {
			// to override args, implement: initAwsDrsJob(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDrsJob,
		},
		"aws.drs.replicationConfiguration": {
			// to override args, implement: initAwsDrsReplicationConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDrsReplicationConfiguration,
		},
		"aws.drs.launchConfiguration": {
			// to override args, implement: initAwsDrsLaunchConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDrsLaunchConfiguration,
		},
		"aws.backup": {
			// to override args, implement: initAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackup,
		},
		"aws.backup.vault": {
			// to override args, implement: initAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVault,
		},
		"aws.backup.vaultRecoveryPoint": {
			// to override args, implement: initAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVaultRecoveryPoint,
		},
		"aws.dynamodb": {
			// to override args, implement: initAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodb,
		},
		"aws.dynamodb.export": {
			// to override args, implement: initAwsDynamodbExport(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodbExport,
		},
		"aws.dynamodb.limit": {
			// to override args, implement: initAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodbLimit,
		},
		"aws.dynamodb.globaltable": {
			Init:   initAwsDynamodbGlobaltable,
			Create: createAwsDynamodbGlobaltable,
		},
		"aws.dynamodb.table": {
			Init:   initAwsDynamodbTable,
			Create: createAwsDynamodbTable,
		},
		"aws.sqs": {
			// to override args, implement: initAwsSqs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSqs,
		},
		"aws.sqs.queue": {
			// to override args, implement: initAwsSqsQueue(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSqsQueue,
		},
		"aws.rds": {
			// to override args, implement: initAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRds,
		},
		"aws.rds.backupsetting": {
			// to override args, implement: initAwsRdsBackupsetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsBackupsetting,
		},
		"aws.rds.dbcluster": {
			Init:   initAwsRdsDbcluster,
			Create: createAwsRdsDbcluster,
		},
		"aws.rds.snapshot": {
			// to override args, implement: initAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsSnapshot,
		},
		"aws.rds.dbinstance": {
			Init:   initAwsRdsDbinstance,
			Create: createAwsRdsDbinstance,
		},
		"aws.rds.pendingMaintenanceAction": {
			// to override args, implement: initAwsRdsPendingMaintenanceAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsPendingMaintenanceAction,
		},
		"aws.rds.clusterParameterGroup": {
			// to override args, implement: initAwsRdsClusterParameterGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsClusterParameterGroup,
		},
		"aws.rds.parameterGroup": {
			// to override args, implement: initAwsRdsParameterGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsParameterGroup,
		},
		"aws.rds.parameterGroup.parameter": {
			// to override args, implement: initAwsRdsParameterGroupParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsParameterGroupParameter,
		},
		"aws.elasticache": {
			// to override args, implement: initAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticache,
		},
		"aws.elasticache.cluster": {
			// to override args, implement: initAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticacheCluster,
		},
		"aws.elasticache.serverlessCache": {
			// to override args, implement: initAwsElasticacheServerlessCache(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticacheServerlessCache,
		},
		"aws.redshift": {
			// to override args, implement: initAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRedshift,
		},
		"aws.redshift.cluster": {
			Init:   initAwsRedshiftCluster,
			Create: createAwsRedshiftCluster,
		},
		"aws.ecr": {
			// to override args, implement: initAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcr,
		},
		"aws.ecr.repository": {
			// to override args, implement: initAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcrRepository,
		},
		"aws.ecr.image": {
			Init:   initAwsEcrImage,
			Create: createAwsEcrImage,
		},
		"aws.dms": {
			// to override args, implement: initAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDms,
		},
		"aws.apigateway": {
			// to override args, implement: initAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigateway,
		},
		"aws.apigateway.restapi": {
			Init:   initAwsApigatewayRestapi,
			Create: createAwsApigatewayRestapi,
		},
		"aws.apigateway.stage": {
			// to override args, implement: initAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigatewayStage,
		},
		"aws.lambda": {
			// to override args, implement: initAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsLambda,
		},
		"aws.lambda.function": {
			Init:   initAwsLambdaFunction,
			Create: createAwsLambdaFunction,
		},
		"aws.lambda.function.urlConfig": {
			// to override args, implement: initAwsLambdaFunctionUrlConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsLambdaFunctionUrlConfig,
		},
		"aws.ssm": {
			// to override args, implement: initAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSsm,
		},
		"aws.ssm.parameter": {
			// to override args, implement: initAwsSsmParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSsmParameter,
		},
		"aws.ssm.instance": {
			Init:   initAwsSsmInstance,
			Create: createAwsSsmInstance,
		},
		"aws.ec2": {
			// to override args, implement: initAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2,
		},
		"aws.ec2.eip": {
			Init:   initAwsEc2Eip,
			Create: createAwsEc2Eip,
		},
		"aws.vpc.natgateway": {
			// to override args, implement: initAwsVpcNatgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcNatgateway,
		},
		"aws.vpc.natgateway.address": {
			// to override args, implement: initAwsVpcNatgatewayAddress(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcNatgatewayAddress,
		},
		"aws.vpc.serviceEndpoint": {
			// to override args, implement: initAwsVpcServiceEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcServiceEndpoint,
		},
		"aws.vpc.peeringConnection": {
			// to override args, implement: initAwsVpcPeeringConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcPeeringConnection,
		},
		"aws.vpc.peeringConnection.peeringVpc": {
			// to override args, implement: initAwsVpcPeeringConnectionPeeringVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcPeeringConnectionPeeringVpc,
		},
		"aws.ec2.networkacl": {
			Init:   initAwsEc2Networkacl,
			Create: createAwsEc2Networkacl,
		},
		"aws.ec2.networkacl.association": {
			// to override args, implement: initAwsEc2NetworkaclAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclAssociation,
		},
		"aws.ec2.networkacl.entry": {
			// to override args, implement: initAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntry,
		},
		"aws.ec2.networkacl.entry.portrange": {
			// to override args, implement: initAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntryPortrange,
		},
		"aws.ec2.vpnconnection": {
			// to override args, implement: initAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vpnconnection,
		},
		"aws.ec2.vgwtelemetry": {
			// to override args, implement: initAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vgwtelemetry,
		},
		"aws.ec2.internetgateway": {
			// to override args, implement: initAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Internetgateway,
		},
		"aws.ec2.snapshot": {
			Init:   initAwsEc2Snapshot,
			Create: createAwsEc2Snapshot,
		},
		"aws.ec2.volume": {
			Init:   initAwsEc2Volume,
			Create: createAwsEc2Volume,
		},
		"aws.inspector": {
			// to override args, implement: initAwsInspector(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspector,
		},
		"aws.inspector.coverage": {
			// to override args, implement: initAwsInspectorCoverage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverage,
		},
		"aws.inspector.coverage.instance": {
			// to override args, implement: initAwsInspectorCoverageInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageInstance,
		},
		"aws.inspector.coverage.image": {
			// to override args, implement: initAwsInspectorCoverageImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageImage,
		},
		"aws.inspector.coverage.repository": {
			// to override args, implement: initAwsInspectorCoverageRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsInspectorCoverageRepository,
		},
		"aws.ec2.instance": {
			Init:   initAwsEc2Instance,
			Create: createAwsEc2Instance,
		},
		"aws.ec2.networkinterface": {
			// to override args, implement: initAwsEc2Networkinterface(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Networkinterface,
		},
		"aws.ec2.keypair": {
			Init:   initAwsEc2Keypair,
			Create: createAwsEc2Keypair,
		},
		"aws.ec2.image": {
			Init:   initAwsEc2Image,
			Create: createAwsEc2Image,
		},
		"aws.ec2.image.launchPermission": {
			// to override args, implement: initAwsEc2ImageLaunchPermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2ImageLaunchPermission,
		},
		"aws.ec2.image.blockDeviceMapping": {
			// to override args, implement: initAwsEc2ImageBlockDeviceMapping(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2ImageBlockDeviceMapping,
		},
		"aws.ec2.image.ebsBlockDevice": {
			// to override args, implement: initAwsEc2ImageEbsBlockDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2ImageEbsBlockDevice,
		},
		"aws.ec2.instance.device": {
			// to override args, implement: initAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2InstanceDevice,
		},
		"aws.ec2.securitygroup": {
			Init:   initAwsEc2Securitygroup,
			Create: createAwsEc2Securitygroup,
		},
		"aws.ec2.securitygroup.ippermission": {
			// to override args, implement: initAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2SecuritygroupIppermission,
		},
		"aws.config": {
			// to override args, implement: initAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfig,
		},
		"aws.config.rule": {
			// to override args, implement: initAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRule,
		},
		"aws.config.recorder": {
			// to override args, implement: initAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRecorder,
		},
		"aws.config.deliverychannel": {
			// to override args, implement: initAwsConfigDeliverychannel(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigDeliverychannel,
		},
		"aws.eks": {
			// to override args, implement: initAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEks,
		},
		"aws.eks.nodegroup": {
			// to override args, implement: initAwsEksNodegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksNodegroup,
		},
		"aws.eks.addon": {
			// to override args, implement: initAwsEksAddon(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksAddon,
		},
		"aws.eks.cluster": {
			Init:   initAwsEksCluster,
			Create: createAwsEksCluster,
		},
		"aws.neptune": {
			// to override args, implement: initAwsNeptune(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptune,
		},
		"aws.neptune.cluster": {
			// to override args, implement: initAwsNeptuneCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptuneCluster,
		},
		"aws.neptune.instance": {
			// to override args, implement: initAwsNeptuneInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsNeptuneInstance,
		},
		"aws.timestream.liveanalytics": {
			// to override args, implement: initAwsTimestreamLiveanalytics(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalytics,
		},
		"aws.timestream.liveanalytics.database": {
			// to override args, implement: initAwsTimestreamLiveanalyticsDatabase(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalyticsDatabase,
		},
		"aws.timestream.liveanalytics.table": {
			// to override args, implement: initAwsTimestreamLiveanalyticsTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsTimestreamLiveanalyticsTable,
		},
		"aws.codedeploy": {
			// to override args, implement: initAwsCodedeploy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodedeploy,
		},
		"aws.codedeploy.application": {
			Init:   initAwsCodedeployApplication,
			Create: createAwsCodedeployApplication,
		},
		"aws.codedeploy.deploymentGroup": {
			// to override args, implement: initAwsCodedeployDeploymentGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodedeployDeploymentGroup,
		},
		"aws.codedeploy.deployment": {
			// to override args, implement: initAwsCodedeployDeployment(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodedeployDeployment,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			mqlId := res.MqlID()
			if mqlId == "" {
				log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
			}
			id := name + "\x00" + mqlId
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	mqlId := res.MqlID()
	if mqlId == "" {
		log.Debug().Msgf("resource %s has no MQL ID defined, this is usually an issue with the resource, please open a GitHub issue at https://github.com/mondoohq/mql/issues", name)
	}
	id := name + "\x00" + mqlId
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"aws.vpcs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetVpcs()).ToDataRes(types.Array(types.Resource("aws.vpc")))
	},
	"aws.regions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetRegions()).ToDataRes(types.Array(types.String))
	},
	"aws.account.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetId()).ToDataRes(types.String)
	},
	"aws.account.aliases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetAliases()).ToDataRes(types.Array(types.String))
	},
	"aws.account.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetOrganization()).ToDataRes(types.Resource("aws.organization"))
	},
	"aws.account.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.account.contactInformation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetContactInformation()).ToDataRes(types.Dict)
	},
	"aws.account.alternateContacts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetAlternateContacts()).ToDataRes(types.Array(types.Resource("aws.account.alternateContact")))
	},
	"aws.account.securityContact": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetSecurityContact()).ToDataRes(types.Resource("aws.account.alternateContact"))
	},
	"aws.account.billingContact": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetBillingContact()).ToDataRes(types.Resource("aws.account.alternateContact"))
	},
	"aws.account.operationsContact": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetOperationsContact()).ToDataRes(types.Resource("aws.account.alternateContact"))
	},
	"aws.account.alternateContact.accountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetAccountId()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.contactType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetContactType()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.emailAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetEmailAddress()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetName()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.phoneNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetPhoneNumber()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetTitle()).ToDataRes(types.String)
	},
	"aws.account.alternateContact.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccountAlternateContact).GetExists()).ToDataRes(types.Bool)
	},
	"aws.organization.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetArn()).ToDataRes(types.String)
	},
	"aws.organization.featureSet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetFeatureSet()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountId()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountEmail()).ToDataRes(types.String)
	},
	"aws.organization.accounts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetAccounts()).ToDataRes(types.Array(types.Resource("aws.account")))
	},
	"aws.organization.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetName()).ToDataRes(types.String)
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetCidrBlock()).ToDataRes(types.String)
	},
	"aws.vpc.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetInstanceTenancy()).ToDataRes(types.String)
	},
	"aws.vpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.vpc.endpoint")))
	},
	"aws.vpc.flowLogs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetFlowLogs()).ToDataRes(types.Array(types.Resource("aws.vpc.flowlog")))
	},
	"aws.vpc.routeTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRouteTables()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable")))
	},
	"aws.vpc.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.vpc.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.natGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetNatGateways()).ToDataRes(types.Array(types.Resource("aws.vpc.natgateway")))
	},
	"aws.vpc.serviceEndpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetServiceEndpoints()).ToDataRes(types.Array(types.Resource("aws.vpc.serviceEndpoint")))
	},
	"aws.vpc.peeringConnections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetPeeringConnections()).ToDataRes(types.Array(types.Resource("aws.vpc.peeringConnection")))
	},
	"aws.vpc.internetGatewayBlockMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetInternetGatewayBlockMode()).ToDataRes(types.String)
	},
	"aws.vpc.dhcpOptionsId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetDhcpOptionsId()).ToDataRes(types.String)
	},
	"aws.vpc.internetGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetInternetGateways()).ToDataRes(types.Array(types.Resource("aws.ec2.internetgateway")))
	},
	"aws.vpc.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.vpc.networkAcls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetNetworkAcls()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl")))
	},
	"aws.vpc.vpnGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetVpnGateways()).ToDataRes(types.Array(types.Resource("aws.vpc.vpnGateway")))
	},
	"aws.vpc.routetable.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.associations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetAssociations()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable.association")))
	},
	"aws.vpc.routetable.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetRoutes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.vpc.routetable.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.routetable.association.routeTableAssociationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetRouteTableAssociationId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.associationsState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetAssociationsState()).ToDataRes(types.Dict)
	},
	"aws.vpc.routetable.association.gatewayId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetGatewayId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.main": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetMain()).ToDataRes(types.Bool)
	},
	"aws.vpc.routetable.association.routeTableId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetRouteTableId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.association.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetableAssociation).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.vpc.subnet.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetName()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetCidrs()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetMapPublicIpOnLaunch()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetDefaultForAvailabilityZone()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.assignIpv6AddressOnCreation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAssignIpv6AddressOnCreation()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.availableIpAddressCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAvailableIpAddressCount()).ToDataRes(types.Int)
	},
	"aws.vpc.subnet.internetGatewayBlockMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetInternetGatewayBlockMode()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.subnet.routeTable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetRouteTable()).ToDataRes(types.Resource("aws.vpc.routetable"))
	},
	"aws.vpc.endpoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetServiceName()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetPolicyDocument()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetSubnets()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.endpoint.privateDnsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetPrivateDnsEnabled()).ToDataRes(types.Bool)
	},
	"aws.vpc.endpoint.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.flowlog.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.flowlog.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.flowlog.destination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDestination()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.destinationType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDestinationType()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.deliverLogsStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetDeliverLogsStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.logFormat": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetLogFormat()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.maxAggregationInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetMaxAggregationInterval()).ToDataRes(types.Int)
	},
	"aws.vpc.flowlog.trafficType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTrafficType()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.amazonSideAsn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetAmazonSideAsn()).ToDataRes(types.Int)
	},
	"aws.vpc.vpnGateway.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.vpc.vpnGateway.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.vpc.vpnGateway.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcVpnGateway).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.waf.acls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetAcls()).ToDataRes(types.Array(types.Resource("aws.waf.acl")))
	},
	"aws.waf.ruleGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetRuleGroups()).ToDataRes(types.Array(types.Resource("aws.waf.rulegroup")))
	},
	"aws.waf.ipSets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetIpSets()).ToDataRes(types.Array(types.Resource("aws.waf.ipset")))
	},
	"aws.waf.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWaf).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.acl.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.acl.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetId()).ToDataRes(types.String)
	},
	"aws.waf.acl.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetName()).ToDataRes(types.String)
	},
	"aws.waf.acl.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.acl.managedByFirewallManager": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetManagedByFirewallManager()).ToDataRes(types.Bool)
	},
	"aws.waf.acl.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetRules()).ToDataRes(types.Array(types.Resource("aws.waf.rule")))
	},
	"aws.waf.acl.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafAcl).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.rulegroup.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetRules()).ToDataRes(types.Array(types.Resource("aws.waf.rule")))
	},
	"aws.waf.rulegroup.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRulegroup).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.priority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetPriority()).ToDataRes(types.Int)
	},
	"aws.waf.rule.statement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetStatement()).ToDataRes(types.Resource("aws.waf.rule.statement"))
	},
	"aws.waf.rule.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetAction()).ToDataRes(types.Resource("aws.waf.rule.action"))
	},
	"aws.waf.rule.belongsTo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRule).GetBelongsTo()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetAction()).ToDataRes(types.String)
	},
	"aws.waf.rule.action.responseCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleAction).GetResponseCode()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetId()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.kind": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetKind()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.json": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetJson()).ToDataRes(types.Dict)
	},
	"aws.waf.rule.statement.sqliMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetSqliMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.sqlimatchstatement"))
	},
	"aws.waf.rule.statement.xssMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetXssMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.xssmatchstatement"))
	},
	"aws.waf.rule.statement.byteMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetByteMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.bytematchstatement"))
	},
	"aws.waf.rule.statement.regexMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRegexMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.regexmatchstatement"))
	},
	"aws.waf.rule.statement.geoMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetGeoMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.geomatchstatement"))
	},
	"aws.waf.rule.statement.ipSetReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetIpSetReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.ipsetreferencestatement"))
	},
	"aws.waf.rule.statement.labelMatchStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetLabelMatchStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.labelmatchstatement"))
	},
	"aws.waf.rule.statement.managedRuleGroupStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetManagedRuleGroupStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.managedrulegroupstatement"))
	},
	"aws.waf.rule.statement.notStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetNotStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.notstatement"))
	},
	"aws.waf.rule.statement.orStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetOrStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.orstatement"))
	},
	"aws.waf.rule.statement.andStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetAndStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.andstatement"))
	},
	"aws.waf.rule.statement.rateBasedStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRateBasedStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.ratebasedstatement"))
	},
	"aws.waf.rule.statement.regexPatternSetReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRegexPatternSetReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.regexpatternsetreferencestatement"))
	},
	"aws.waf.rule.statement.ruleGroupReferenceStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetRuleGroupReferenceStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.rulegroupreferencestatement"))
	},
	"aws.waf.rule.statement.sizeConstraintStatement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatement).GetSizeConstraintStatement()).ToDataRes(types.Resource("aws.waf.rule.statement.sizeconstraintstatement"))
	},
	"aws.waf.rule.statement.geomatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.geomatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.geomatchstatement.countryCodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementGeomatchstatement).GetCountryCodes()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipSetForwardedIPConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatement).GetIpSetForwardedIPConfig()).ToDataRes(types.Resource("aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig"))
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.headerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetHeaderName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.position": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetPosition()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.fallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).GetFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetKey()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.labelmatchstatement.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementLabelmatchstatement).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.managedrulegroupstatement.vendorName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).GetVendorName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.andstatement.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementAndstatement).GetStatements()).ToDataRes(types.Array(types.Resource("aws.waf.rule.statement")))
	},
	"aws.waf.rule.statement.notstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.notstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.notstatement.statement": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementNotstatement).GetStatement()).ToDataRes(types.Resource("aws.waf.rule.statement"))
	},
	"aws.waf.rule.statement.orstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.orstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.orstatement.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementOrstatement).GetStatements()).ToDataRes(types.Array(types.Resource("aws.waf.rule.statement")))
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.excludeRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).GetExcludeRules()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.sizeconstraintstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetSize()).ToDataRes(types.Int)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.comparisonOperator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetComparisonOperator()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sizeconstraintstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSizeconstraintstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.regexmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.regexmatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.regexmatchstatement.regexString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementRegexmatchstatement).GetRegexString()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.bytematchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.bytematchstatement.searchString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementBytematchstatement).GetSearchString()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetTarget()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.method": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetMethod()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.uriPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetUriPath()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.queryString": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetQueryString()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.allQueryArguments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetAllQueryArguments()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.body": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetBody()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.body"))
	},
	"aws.waf.rule.fieldtomatch.cookie": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetCookie()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.cookie"))
	},
	"aws.waf.rule.fieldtomatch.singleHeader": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetSingleHeader()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.singleheader"))
	},
	"aws.waf.rule.fieldtomatch.headerOrder": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetHeaderOrder()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headerorder"))
	},
	"aws.waf.rule.fieldtomatch.headers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetHeaders()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headers"))
	},
	"aws.waf.rule.fieldtomatch.ja3Fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetJa3Fingerprint()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.ja3fingerprint"))
	},
	"aws.waf.rule.fieldtomatch.jsonBody": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetJsonBody()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.jsonbody"))
	},
	"aws.waf.rule.fieldtomatch.singleQueryArgument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatch).GetSingleQueryArgument()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.singlequeryargument"))
	},
	"aws.waf.rule.fieldtomatch.body.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.body.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.body.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchBody).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.cookie.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchCookie).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headerorder.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaderorder).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singleheader.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSingleheader).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).GetName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.fallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).GetFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchScope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetMatchScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.invalidFallbackBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetInvalidFallbackBehavior()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbody).GetMatchPattern()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.jsonbody.matchpattern"))
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.all": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetAll()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.includePaths": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).GetIncludePaths()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.fieldtomatch.headers.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchScope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetMatchScope()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.overSizeHandling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetOverSizeHandling()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeaders).GetMatchPattern()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch.headers.matchpattern"))
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.all": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetAll()).ToDataRes(types.Bool)
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.includeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetIncludeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.excludeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).GetExcludeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.waf.rule.statement.xssmatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.xssmatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.xssmatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementXssmatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.sqlimatchstatement.ruleName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetRuleName()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sqlimatchstatement.statementID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetStatementID()).ToDataRes(types.String)
	},
	"aws.waf.rule.statement.sqlimatchstatement.fieldToMatch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetFieldToMatch()).ToDataRes(types.Resource("aws.waf.rule.fieldtomatch"))
	},
	"aws.waf.rule.statement.sqlimatchstatement.sensitivityLevel": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafRuleStatementSqlimatchstatement).GetSensitivityLevel()).ToDataRes(types.String)
	},
	"aws.waf.ipset.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetArn()).ToDataRes(types.String)
	},
	"aws.waf.ipset.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetId()).ToDataRes(types.String)
	},
	"aws.waf.ipset.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetScope()).ToDataRes(types.String)
	},
	"aws.waf.ipset.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetName()).ToDataRes(types.String)
	},
	"aws.waf.ipset.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetDescription()).ToDataRes(types.String)
	},
	"aws.waf.ipset.addressType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetAddressType()).ToDataRes(types.String)
	},
	"aws.waf.ipset.addresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsWafIpset).GetAddresses()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystems": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfs).GetFilesystems()).ToDataRes(types.Array(types.Resource("aws.efs.filesystem")))
	},
	"aws.efs.filesystem.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetName()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetId()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetArn()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetBackupPolicy()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystem.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetRegion()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.efs.filesystem.mountTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetMountTargets()).ToDataRes(types.Array(types.Resource("aws.efs.mountTarget")))
	},
	"aws.efs.filesystem.accessPoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetAccessPoints()).ToDataRes(types.Array(types.Resource("aws.efs.accessPoint")))
	},
	"aws.efs.filesystem.fileSystemPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetFileSystemPolicy()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.mountTargetId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetMountTargetId()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.fileSystemId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetFileSystemId()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.subnetId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetSubnetId()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.ipAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetIpAddress()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.efs.mountTarget.lifecycleState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetLifecycleState()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.networkInterfaceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetNetworkInterfaceId()).ToDataRes(types.String)
	},
	"aws.efs.mountTarget.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsMountTarget).GetRegion()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.accessPointId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetAccessPointId()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetArn()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.fileSystemId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetFileSystemId()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetName()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.posixUser": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetPosixUser()).ToDataRes(types.Dict)
	},
	"aws.efs.accessPoint.rootDirectory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetRootDirectory()).ToDataRes(types.Dict)
	},
	"aws.efs.accessPoint.lifecycleState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetLifecycleState()).ToDataRes(types.String)
	},
	"aws.efs.accessPoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.efs.accessPoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsAccessPoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.fsx.fileSystems": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsx).GetFileSystems()).ToDataRes(types.Array(types.Resource("aws.fsx.filesystem")))
	},
	"aws.fsx.caches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsx).GetCaches()).ToDataRes(types.Array(types.Resource("aws.fsx.cache")))
	},
	"aws.fsx.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsx).GetBackups()).ToDataRes(types.Array(types.Resource("aws.fsx.backup")))
	},
	"aws.fsx.filesystem.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetId()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetArn()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetType()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.lifecycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetLifecycle()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.storageCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetStorageCapacity()).ToDataRes(types.Int)
	},
	"aws.fsx.filesystem.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetStorageType()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.fsx.filesystem.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetVpcId()).ToDataRes(types.String)
	},
	"aws.fsx.filesystem.subnetIds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetSubnetIds()).ToDataRes(types.Array(types.String))
	},
	"aws.fsx.filesystem.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.fsx.filesystem.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.fsx.filesystem.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxFilesystem).GetRegion()).ToDataRes(types.String)
	},
	"aws.fsx.cache.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetId()).ToDataRes(types.String)
	},
	"aws.fsx.cache.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetArn()).ToDataRes(types.String)
	},
	"aws.fsx.cache.lifecycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetLifecycle()).ToDataRes(types.String)
	},
	"aws.fsx.cache.storageCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetStorageCapacity()).ToDataRes(types.Int)
	},
	"aws.fsx.cache.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetVpcId()).ToDataRes(types.String)
	},
	"aws.fsx.cache.subnetIds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetSubnetIds()).ToDataRes(types.Array(types.String))
	},
	"aws.fsx.cache.lustreConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetLustreConfiguration()).ToDataRes(types.Dict)
	},
	"aws.fsx.cache.dataRepositoryAssociations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetDataRepositoryAssociations()).ToDataRes(types.Array(types.Dict))
	},
	"aws.fsx.cache.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxCache).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.fsx.backup.backupId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetBackupId()).ToDataRes(types.String)
	},
	"aws.fsx.backup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetArn()).ToDataRes(types.String)
	},
	"aws.fsx.backup.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetType()).ToDataRes(types.String)
	},
	"aws.fsx.backup.lifecycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetLifecycle()).ToDataRes(types.String)
	},
	"aws.fsx.backup.fileSystemId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetFileSystemId()).ToDataRes(types.String)
	},
	"aws.fsx.backup.fileSystemType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetFileSystemType()).ToDataRes(types.String)
	},
	"aws.fsx.backup.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.fsx.backup.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.fsx.backup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsFsxBackup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.kms.keys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKms).GetKeys()).ToDataRes(types.Array(types.Resource("aws.kms.key")))
	},
	"aws.kms.key.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetId()).ToDataRes(types.String)
	},
	"aws.kms.key.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetArn()).ToDataRes(types.String)
	},
	"aws.kms.key.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetRegion()).ToDataRes(types.String)
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetKeyRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.kms.key.metadata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetMetadata()).ToDataRes(types.Dict)
	},
	"aws.kms.key.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.kms.key.aliases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetAliases()).ToDataRes(types.Array(types.String))
	},
	"aws.kms.key.keyState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetKeyState()).ToDataRes(types.String)
	},
	"aws.kms.key.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.kms.key.deletedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetDeletedAt()).ToDataRes(types.Time)
	},
	"aws.kms.key.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetEnabled()).ToDataRes(types.Bool)
	},
	"aws.kms.key.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetDescription()).ToDataRes(types.String)
	},
	"aws.kms.key.grants": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetGrants()).ToDataRes(types.Array(types.Resource("aws.kms.grant")))
	},
	"aws.kms.grant.grantId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetGrantId()).ToDataRes(types.String)
	},
	"aws.kms.grant.keyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetKeyArn()).ToDataRes(types.String)
	},
	"aws.kms.grant.granteePrincipal": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetGranteePrincipal()).ToDataRes(types.String)
	},
	"aws.kms.grant.retiringPrincipal": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetRetiringPrincipal()).ToDataRes(types.String)
	},
	"aws.kms.grant.issuingAccount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetIssuingAccount()).ToDataRes(types.String)
	},
	"aws.kms.grant.operations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetOperations()).ToDataRes(types.Array(types.String))
	},
	"aws.kms.grant.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsGrant).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.users": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.roles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.credentialReport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetCredentialReport()).ToDataRes(types.Array(types.Resource("aws.iam.usercredentialreportentry")))
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountPasswordPolicy()).ToDataRes(types.Dict)
	},
	"aws.iam.accountSummary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountSummary()).ToDataRes(types.Map(types.String, types.Int))
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetVirtualMfaDevices()).ToDataRes(types.Array(types.Resource("aws.iam.virtualmfadevice")))
	},
	"aws.iam.serverCertificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetServerCertificates()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.instanceProfiles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetInstanceProfiles()).ToDataRes(types.Array(types.Resource("aws.iam.instanceProfile")))
	},
	"aws.iam.samlProviders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetSamlProviders()).ToDataRes(types.Array(types.Resource("aws.iam.samlProvider")))
	},
	"aws.iam.oidcProviders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetOidcProviders()).ToDataRes(types.Array(types.Resource("aws.iam.oidcProvider")))
	},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetMfaActive()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordEnabled()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastChanged()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordNextRotation()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.usercredentialreportentry.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.user.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetId()).ToDataRes(types.String)
	},
	"aws.iam.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetName()).ToDataRes(types.String)
	},
	"aws.iam.user.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.user.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.user.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPolicies()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.user.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAccessKeys()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.user.loginProfile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetLoginProfile()).ToDataRes(types.Resource("aws.iam.loginProfile"))
	},
	"aws.iam.instanceProfile.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.instanceProfile.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.instanceProfile.instanceProfileId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetInstanceProfileId()).ToDataRes(types.String)
	},
	"aws.iam.instanceProfile.instanceProfileName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetInstanceProfileName()).ToDataRes(types.String)
	},
	"aws.iam.instanceProfile.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.instanceProfile.iamRoles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamInstanceProfile).GetIamRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.loginProfile.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamLoginProfile).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.policy.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policy.policyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetPolicyId()).ToDataRes(types.String)
	},
	"aws.iam.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.iam.policy.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetIsAttachable()).ToDataRes(types.Bool)
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachmentCount()).ToDataRes(types.Int)
	},
	"aws.iam.policy.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.policy.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.policy.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetScope()).ToDataRes(types.String)
	},
	"aws.iam.policy.versions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetVersions()).ToDataRes(types.Array(types.Resource("aws.iam.policyversion")))
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDefaultVersion()).ToDataRes(types.Resource("aws.iam.policyversion"))
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policyversion.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetVersionId()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetIsDefaultVersion()).ToDataRes(types.Bool)
	},
	"aws.iam.policyversion.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.policyversion.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.role.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.role.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetId()).ToDataRes(types.String)
	},
	"aws.iam.role.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetName()).ToDataRes(types.String)
	},
	"aws.iam.role.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.role.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.role.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.role.assumeRolePolicyDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetAssumeRolePolicyDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.role.lastUsedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetLastUsedAt()).ToDataRes(types.Time)
	},
	"aws.iam.role.lastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetLastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.role.maxSessionDuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetMaxSessionDuration()).ToDataRes(types.Int)
	},
	"aws.iam.role.permissionsBoundaryArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetPermissionsBoundaryArn()).ToDataRes(types.String)
	},
	"aws.iam.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.group.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetId()).ToDataRes(types.String)
	},
	"aws.iam.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetName()).ToDataRes(types.String)
	},
	"aws.iam.group.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.group.usernames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetUsernames()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.group.inlinePolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetInlinePolicies()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetSerialNumber()).ToDataRes(types.String)
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetEnableDate()).ToDataRes(types.Time)
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.samlProvider.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.samlProvider.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetName()).ToDataRes(types.String)
	},
	"aws.iam.samlProvider.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.samlProvider.validUntil": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetValidUntil()).ToDataRes(types.Time)
	},
	"aws.iam.samlProvider.metadataDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetMetadataDocument()).ToDataRes(types.String)
	},
	"aws.iam.samlProvider.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamSamlProvider).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.oidcProvider.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.oidcProvider.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetUrl()).ToDataRes(types.String)
	},
	"aws.iam.oidcProvider.clientIds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetClientIds()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.oidcProvider.thumbprints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetThumbprints()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.oidcProvider.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.oidcProvider.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamOidcProvider).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.accessAnalyzer.analyzers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessAnalyzer).GetAnalyzers()).ToDataRes(types.Array(types.Resource("aws.iam.accessanalyzer.analyzer")))
	},
	"aws.iam.accessAnalyzer.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessAnalyzer).GetFindings()).ToDataRes(types.Array(types.Resource("aws.iam.accessanalyzer.finding")))
	},
	"aws.iam.accessanalyzer.analyzer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetName()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetStatus()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetRegion()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetLastResourceAnalyzed()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetLastResourceAnalyzedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.analyzer.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerAnalyzer).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetId()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.error": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetError()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceArn()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceOwnerAccount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceOwnerAccount()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetResourceType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetType()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetStatus()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.analyzedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetAnalyzedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.iam.accessanalyzer.finding.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetRegion()).ToDataRes(types.String)
	},
	"aws.iam.accessanalyzer.finding.analyzerArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamAccessanalyzerFinding).GetAnalyzerArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.sagemaker.endpoint")))
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetNotebookInstances()).ToDataRes(types.Array(types.Resource("aws.sagemaker.notebookinstance")))
	},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetDetails()).ToDataRes(types.Resource("aws.sagemaker.notebookinstancedetails"))
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sagemaker.notebookinstancedetails.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstancedetails).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstancedetails.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstancedetails).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sagemaker.notebookinstancedetails.directInternetAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstancedetails).GetDirectInternetAccess()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetConfig()).ToDataRes(types.Dict)
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.topics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSns).GetTopics()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.sns.topic.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.topic.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetRegion()).ToDataRes(types.String)
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetSubscriptions()).ToDataRes(types.Array(types.Resource("aws.sns.subscription")))
	},
	"aws.sns.topic.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetAttributes()).ToDataRes(types.Dict)
	},
	"aws.sns.topic.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.topic.signatureVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetSignatureVersion()).ToDataRes(types.String)
	},
	"aws.sns.subscription.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetProtocol()).ToDataRes(types.String)
	},
	"aws.es.domains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEs).GetDomains()).ToDataRes(types.Array(types.Resource("aws.es.domain")))
	},
	"aws.es.domain.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetArn()).ToDataRes(types.String)
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEncryptionAtRestEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetNodeToNodeEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetName()).ToDataRes(types.String)
	},
	"aws.es.domain.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.es.domain.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetRegion()).ToDataRes(types.String)
	},
	"aws.es.domain.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetElasticsearchVersion()).ToDataRes(types.String)
	},
	"aws.es.domain.domainId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainId()).ToDataRes(types.String)
	},
	"aws.es.domain.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainName()).ToDataRes(types.String)
	},
	"aws.opensearch.domains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearch).GetDomains()).ToDataRes(types.Array(types.Resource("aws.opensearch.domain")))
	},
	"aws.opensearch.domain.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetArn()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetName()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.domainId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetDomainId()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetRegion()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.encryptionAtRestEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEncryptionAtRestEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.encryptionAtRestKmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEncryptionAtRestKmsKeyId()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetNodeToNodeEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.dedicatedMasterEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetDedicatedMasterEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.dedicatedMasterType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetDedicatedMasterType()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.dedicatedMasterCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetDedicatedMasterCount()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.instanceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetInstanceType()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.instanceCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetInstanceCount()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.zoneAwarenessEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetZoneAwarenessEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.availabilityZoneCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetAvailabilityZoneCount()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.warmEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetWarmEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.warmType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetWarmType()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.warmCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetWarmCount()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.coldStorageEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetColdStorageEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.ebsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEbsEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.ebsVolumeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEbsVolumeType()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.ebsVolumeSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEbsVolumeSize()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.ebsIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEbsIops()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.ebsThroughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEbsThroughput()).ToDataRes(types.Int)
	},
	"aws.opensearch.domain.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetVpcId()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.enforceHTTPS": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetEnforceHTTPS()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.tlsSecurityPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetTlsSecurityPolicy()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.samlEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetSamlEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.anonymousAuthEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetAnonymousAuthEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.internalUserDatabaseEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetInternalUserDatabaseEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.advancedSecurityEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetAdvancedSecurityEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.processing": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetProcessing()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.upgradeProcessing": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetUpgradeProcessing()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.opensearch.domain.autoTuneState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetAutoTuneState()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.auditLogEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetAuditLogEnabled()).ToDataRes(types.Bool)
	},
	"aws.opensearch.domain.ipAddressType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetIpAddressType()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.serviceSoftwareNewVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetServiceSoftwareNewVersion()).ToDataRes(types.String)
	},
	"aws.opensearch.domain.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.opensearch.domain.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.opensearch.domain.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOpensearchDomain).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.acm.certificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcm).GetCertificates()).ToDataRes(types.Array(types.Resource("aws.acm.certificate")))
	},
	"aws.acm.certificate.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetArn()).ToDataRes(types.String)
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotBefore()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotAfter()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificate.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetStatus()).ToDataRes(types.String)
	},
	"aws.acm.certificate.subject": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSubject()).ToDataRes(types.String)
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCertificate()).ToDataRes(types.Resource("certificate"))
	},
	"aws.acm.certificate.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.acm.certificate.keyAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetKeyAlgorithm()).ToDataRes(types.String)
	},
	"aws.acm.certificate.serial": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSerial()).ToDataRes(types.String)
	},
	"aws.acm.certificate.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSource()).ToDataRes(types.String)
	},
	"aws.acm.certificate.issuer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetIssuer()).ToDataRes(types.String)
	},
	"aws.acm.certificate.issuedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetIssuedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.importedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetImportedAt()).ToDataRes(types.Time)
	},
	"aws.autoscaling.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscaling).GetGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.autoscaling.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLoadBalancerNames()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckType()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.autoscaling.group.tagSpecifications": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTagSpecifications()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group.tag")))
	},
	"aws.autoscaling.group.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.minSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMinSize()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.maxSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMaxSize()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.defaultCooldown": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDefaultCooldown()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.launchConfigurationName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLaunchConfigurationName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.healthCheckGracePeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckGracePeriod()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.autoscaling.group.maxInstanceLifetime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetMaxInstanceLifetime()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.desiredCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDesiredCapacity()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.capacityRebalance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetCapacityRebalance()).ToDataRes(types.Bool)
	},
	"aws.autoscaling.group.defaultInstanceWarmup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDefaultInstanceWarmup()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.autoscaling.group.desiredCapacityType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetDesiredCapacityType()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.warmPoolSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetWarmPoolSize()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.predictedCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetPredictedCapacity()).ToDataRes(types.Int)
	},
	"aws.autoscaling.group.placementGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetPlacementGroup()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.newInstancesProtectedFromScaleIn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetNewInstancesProtectedFromScaleIn()).ToDataRes(types.Bool)
	},
	"aws.autoscaling.group.targetGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTargetGroups()).ToDataRes(types.Array(types.Resource("aws.elb.targetgroup")))
	},
	"aws.autoscaling.group.tag.key": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroupTag).GetKey()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tag.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroupTag).GetValue()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tag.propagateAtLaunch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroupTag).GetPropagateAtLaunch()).ToDataRes(types.Bool)
	},
	"aws.autoscaling.group.tag.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroupTag).GetResourceId()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tag.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroupTag).GetResourceType()).ToDataRes(types.String)
	},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetClassicLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.targetgroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetName()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetPort()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetProtocol()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.protocolVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetProtocolVersion()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.ipAddressType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetIpAddressType()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckEnabled()).ToDataRes(types.Bool)
	},
	"aws.elb.targetgroup.healthCheckIntervalSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckIntervalSeconds()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.healthCheckPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckPath()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckPort()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckProtocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckProtocol()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.healthCheckTimeoutSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetHealthCheckTimeoutSeconds()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.targetType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetTargetType()).ToDataRes(types.String)
	},
	"aws.elb.targetgroup.unhealthyThresholdCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetUnhealthyThresholdCount()).ToDataRes(types.Int)
	},
	"aws.elb.targetgroup.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.elb.targetgroup.ec2Targets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetEc2Targets()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.elb.targetgroup.lambdaTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbTargetgroup).GetLambdaTargets()).ToDataRes(types.Array(types.Resource("aws.lambda.function")))
	},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetDnsName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetListenerDescriptions()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetScheme()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetVpcId()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.elb.loadbalancer.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.elb.loadbalancer.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.elb.loadbalancer.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elb.loadbalancer.hostedZoneId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetHostedZoneId()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetRegion()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.elbType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetElbType()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.elb.loadbalancer.targetGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetTargetGroups()).ToDataRes(types.Array(types.Resource("aws.elb.targetgroup")))
	},
	"aws.codebuild.projects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuild).GetProjects()).ToDataRes(types.Array(types.Resource("aws.codebuild.project")))
	},
	"aws.codebuild.project.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetArn()).ToDataRes(types.String)
	},
	"aws.codebuild.project.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetDescription()).ToDataRes(types.String)
	},
	"aws.codebuild.project.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetName()).ToDataRes(types.String)
	},
	"aws.codebuild.project.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetEnvironment()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetRegion()).ToDataRes(types.String)
	},
	"aws.codebuild.project.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetSource()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetFindings()).ToDataRes(types.Array(types.Resource("aws.guardduty.finding")))
	},
	"aws.guardduty.detectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetDetectors()).ToDataRes(types.Array(types.Resource("aws.guardduty.detector")))
	},
	"aws.guardduty.detector.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetStatus()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.features": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFeatures()).ToDataRes(types.Array(types.Dict))
	},
	"aws.guardduty.detector.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindingPublishingFrequency()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindings()).ToDataRes(types.Array(types.Resource("aws.guardduty.finding")))
	},
	"aws.guardduty.detector.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.guardduty.detector.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.guardduty.finding.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetArn()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetTitle()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetDescription()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetSeverity()).ToDataRes(types.Float)
	},
	"aws.guardduty.finding.confidence": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetConfidence()).ToDataRes(types.Float)
	},
	"aws.guardduty.finding.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetType()).ToDataRes(types.String)
	},
	"aws.guardduty.finding.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.guardduty.finding.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyFinding).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.sessions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacie).GetSessions()).ToDataRes(types.Array(types.Resource("aws.macie.session")))
	},
	"aws.macie.classificationJobs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacie).GetClassificationJobs()).ToDataRes(types.Array(types.Resource("aws.macie.classificationJob")))
	},
	"aws.macie.findings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacie).GetFindings()).ToDataRes(types.Array(types.Resource("aws.macie.finding")))
	},
	"aws.macie.customDataIdentifiers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacie).GetCustomDataIdentifiers()).ToDataRes(types.Array(types.Resource("aws.macie.customDataIdentifier")))
	},
	"aws.macie.session.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetArn()).ToDataRes(types.String)
	},
	"aws.macie.session.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetRegion()).ToDataRes(types.String)
	},
	"aws.macie.session.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetStatus()).ToDataRes(types.String)
	},
	"aws.macie.session.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.session.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.session.findingPublishingFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetFindingPublishingFrequency()).ToDataRes(types.String)
	},
	"aws.macie.session.serviceRole": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetServiceRole()).ToDataRes(types.String)
	},
	"aws.macie.session.s3BucketCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieSession).GetS3BucketCount()).ToDataRes(types.Int)
	},
	"aws.macie.classificationJob.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetArn()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.jobId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetJobId()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetName()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetRegion()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetStatus()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.jobType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetJobType()).ToDataRes(types.String)
	},
	"aws.macie.classificationJob.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.classificationJob.lastRunTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetLastRunTime()).ToDataRes(types.Time)
	},
	"aws.macie.classificationJob.samplingPercentage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetSamplingPercentage()).ToDataRes(types.Int)
	},
	"aws.macie.classificationJob.bucketDefinitions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetBucketDefinitions()).ToDataRes(types.Array(types.Dict))
	},
	"aws.macie.classificationJob.scheduleFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetScheduleFrequency()).ToDataRes(types.Dict)
	},
	"aws.macie.classificationJob.statistics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetStatistics()).ToDataRes(types.Dict)
	},
	"aws.macie.classificationJob.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieClassificationJob).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.macie.finding.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetId()).ToDataRes(types.String)
	},
	"aws.macie.finding.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetArn()).ToDataRes(types.String)
	},
	"aws.macie.finding.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetRegion()).ToDataRes(types.String)
	},
	"aws.macie.finding.accountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetAccountId()).ToDataRes(types.String)
	},
	"aws.macie.finding.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetType()).ToDataRes(types.String)
	},
	"aws.macie.finding.severity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetSeverity()).ToDataRes(types.Dict)
	},
	"aws.macie.finding.category": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetCategory()).ToDataRes(types.String)
	},
	"aws.macie.finding.archived": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetArchived()).ToDataRes(types.Bool)
	},
	"aws.macie.finding.count": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetCount()).ToDataRes(types.Int)
	},
	"aws.macie.finding.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.finding.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.finding.title": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetTitle()).ToDataRes(types.String)
	},
	"aws.macie.finding.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetDescription()).ToDataRes(types.String)
	},
	"aws.macie.finding.classificationDetails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetClassificationDetails()).ToDataRes(types.Dict)
	},
	"aws.macie.finding.resourcesAffected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieFinding).GetResourcesAffected()).ToDataRes(types.Dict)
	},
	"aws.macie.customDataIdentifier.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetId()).ToDataRes(types.String)
	},
	"aws.macie.customDataIdentifier.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetArn()).ToDataRes(types.String)
	},
	"aws.macie.customDataIdentifier.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetName()).ToDataRes(types.String)
	},
	"aws.macie.customDataIdentifier.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetDescription()).ToDataRes(types.String)
	},
	"aws.macie.customDataIdentifier.regex": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetRegex()).ToDataRes(types.String)
	},
	"aws.macie.customDataIdentifier.keywords": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetKeywords()).ToDataRes(types.Array(types.String))
	},
	"aws.macie.customDataIdentifier.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.macie.customDataIdentifier.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsMacieCustomDataIdentifier).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.securityhub.hubs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhub).GetHubs()).ToDataRes(types.Array(types.Resource("aws.securityhub.hub")))
	},
	"aws.securityhub.hub.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetArn()).ToDataRes(types.String)
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetSubscribedAt()).ToDataRes(types.String)
	},
	"aws.securityhub.hub.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetRegion()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanager).GetSecrets()).ToDataRes(types.Array(types.Resource("aws.secretsmanager.secret")))
	},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetArn()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetDescription()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.secretsmanager.secret.lastAccessedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastAccessedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastChangedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastRotatedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetName()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetNextRotationDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.owningService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetOwningService()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetPrimaryRegion()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.secretsmanager.secret.rotationLambda": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationLambda()).ToDataRes(types.Resource("aws.lambda.function"))
	},
	"aws.secretsmanager.secret.rotationRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationRules()).ToDataRes(types.Resource("aws.secretsmanager.secret.rotationRules"))
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.secretsmanager.secret.rotationRules.automaticallyAfterDays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecretRotationRules).GetAutomaticallyAfterDays()).ToDataRes(types.Int)
	},
	"aws.secretsmanager.secret.rotationRules.duration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecretRotationRules).GetDuration()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.rotationRules.scheduleExpression": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecretRotationRules).GetScheduleExpression()).ToDataRes(types.String)
	},
	"aws.ecs.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetClusters()).ToDataRes(types.Array(types.Resource("aws.ecs.cluster")))
	},
	"aws.ecs.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.taskDefinitions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetTaskDefinitions()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition")))
	},
	"aws.ecs.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRunningTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetPendingTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegisteredContainerInstancesCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTasks()).ToDataRes(types.Array(types.Resource("aws.ecs.task")))
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.cluster.services": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetServices()).ToDataRes(types.Array(types.Resource("aws.ecs.service")))
	},
	"aws.ecs.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.activeServicesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetActiveServicesCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.fargateEphemeralStorageKmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetFargateEphemeralStorageKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetAgentConnected()).ToDataRes(types.Bool)
	},
	"aws.ecs.instance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetId()).ToDataRes(types.String)
	},
	"aws.ecs.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetCapacityProvider()).ToDataRes(types.String)
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetEc2Instance()).ToDataRes(types.Resource("aws.ec2.instance"))
	},
	"aws.ecs.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.task.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetConnectivity()).ToDataRes(types.Dict)
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.task.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.task.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.container.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.container.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.container.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetImage()).ToDataRes(types.String)
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskDefinitionArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetLogDriver()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.container.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.container.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.container.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetCommand()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRuntimeId()).ToDataRes(types.String)
	},
	"aws.ecs.container.containerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetContainerName()).ToDataRes(types.String)
	},
	"aws.ecs.container.cpuUnits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetCpuUnits()).ToDataRes(types.String)
	},
	"aws.ecs.container.memorySoftLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetMemorySoftLimit()).ToDataRes(types.String)
	},
	"aws.ecs.container.memoryHardLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetMemoryHardLimit()).ToDataRes(types.String)
	},
	"aws.ecs.container.reason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetReason()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.family": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetFamily()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.revision": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetRevision()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.networkMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetNetworkMode()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.pidMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetPidMode()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.ipcMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetIpcMode()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.taskRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetTaskRoleArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.executionRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetExecutionRoleArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinitions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetContainerDefinitions()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition.containerDefinition")))
	},
	"aws.ecs.taskDefinition.volumes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetVolumes()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition.volume")))
	},
	"aws.ecs.taskDefinition.ephemeralStorage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetEphemeralStorage()).ToDataRes(types.Resource("aws.ecs.taskDefinition.ephemeralStorage"))
	},
	"aws.ecs.taskDefinition.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.taskDefinition.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinition).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.service.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.service.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.service.clusterArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetClusterArn()).ToDataRes(types.String)
	},
	"aws.ecs.service.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.service.desiredCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetDesiredCount()).ToDataRes(types.Int)
	},
	"aws.ecs.service.runningCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetRunningCount()).ToDataRes(types.Int)
	},
	"aws.ecs.service.taskDefinition": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetTaskDefinition()).ToDataRes(types.String)
	},
	"aws.ecs.service.launchType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetLaunchType()).ToDataRes(types.String)
	},
	"aws.ecs.service.deploymentConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetDeploymentConfiguration()).ToDataRes(types.Resource("aws.ecs.service.deploymentConfiguration"))
	},
	"aws.ecs.service.networkConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetNetworkConfiguration()).ToDataRes(types.Resource("aws.ecs.service.networkConfiguration"))
	},
	"aws.ecs.service.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.service.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ecs.service.createdBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetCreatedBy()).ToDataRes(types.String)
	},
	"aws.ecs.service.taskSets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsService).GetTaskSets()).ToDataRes(types.Array(types.Resource("aws.ecs.taskSet")))
	},
	"aws.ecs.taskSet.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetId()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.clusterArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetClusterArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.serviceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetServiceArn()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.taskDefinition": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetTaskDefinition()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.launchType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetLaunchType()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.networkConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetNetworkConfiguration()).ToDataRes(types.Resource("aws.ecs.taskSet.networkConfiguration"))
	},
	"aws.ecs.taskSet.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.taskSet.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ecs.taskSet.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.ecs.taskSet.runningCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetRunningCount()).ToDataRes(types.Int)
	},
	"aws.ecs.taskSet.pendingCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetPendingCount()).ToDataRes(types.Int)
	},
	"aws.ecs.taskSet.computedDesiredCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetComputedDesiredCount()).ToDataRes(types.Int)
	},
	"aws.ecs.taskSet.stabilityStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetStabilityStatus()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.externalId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetExternalId()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.startedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSet).GetStartedBy()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.networkConfiguration.assignPublicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSetNetworkConfiguration).GetAssignPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.taskSet.networkConfiguration.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSetNetworkConfiguration).GetSubnets()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.taskSet.networkConfiguration.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskSetNetworkConfiguration).GetSecurityGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.service.deploymentConfiguration.maximumPercent": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetMaximumPercent()).ToDataRes(types.Int)
	},
	"aws.ecs.service.deploymentConfiguration.minimumHealthyPercent": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetMinimumHealthyPercent()).ToDataRes(types.Int)
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetDeploymentCircuitBreaker()).ToDataRes(types.Resource("aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker"))
	},
	"aws.ecs.service.deploymentConfiguration.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetAlarms()).ToDataRes(types.Dict)
	},
	"aws.ecs.service.deploymentConfiguration.bakeTimeInMinutes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetBakeTimeInMinutes()).ToDataRes(types.Int)
	},
	"aws.ecs.service.deploymentConfiguration.canaryConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetCanaryConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.service.deploymentConfiguration.lifecycleHooks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetLifecycleHooks()).ToDataRes(types.Dict)
	},
	"aws.ecs.service.deploymentConfiguration.linearConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetLinearConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.service.deploymentConfiguration.strategy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfiguration).GetStrategy()).ToDataRes(types.String)
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker.enable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker).GetEnable()).ToDataRes(types.Bool)
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker.rollback": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker).GetRollback()).ToDataRes(types.Bool)
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceNetworkConfiguration).GetAwsVpcConfiguration()).ToDataRes(types.Resource("aws.ecs.service.networkConfiguration.awsVpcConfiguration"))
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).GetSubnets()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).GetSecurityGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.assignPublicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).GetAssignPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetImage()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.privileged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetPrivileged()).ToDataRes(types.Bool)
	},
	"aws.ecs.taskDefinition.containerDefinition.readonlyRootFilesystem": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetReadonlyRootFilesystem()).ToDataRes(types.Bool)
	},
	"aws.ecs.taskDefinition.containerDefinition.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetUser()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetEnvironment()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition.containerDefinition.environmentVariable")))
	},
	"aws.ecs.taskDefinition.containerDefinition.secrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetSecrets()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition.containerDefinition.secret")))
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetLogConfiguration()).ToDataRes(types.Resource("aws.ecs.taskDefinition.containerDefinition.logConfiguration"))
	},
	"aws.ecs.taskDefinition.containerDefinition.memory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetMemory()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.containerDefinition.cpu": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetCpu()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.containerDefinition.portMappings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinition).GetPortMappings()).ToDataRes(types.Array(types.Resource("aws.ecs.taskDefinition.containerDefinition.portMapping")))
	},
	"aws.ecs.taskDefinition.containerDefinition.environmentVariable.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.environmentVariable.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable).GetValue()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.secret.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionSecret).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.secret.valueFrom": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionSecret).GetValueFrom()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration.logDriver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration).GetLogDriver()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration.options": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration).GetOptions()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.containerPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).GetContainerPort()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.hostPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).GetHostPort()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).GetProtocol()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolume).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolume).GetEfsVolumeConfiguration()).ToDataRes(types.Resource("aws.ecs.taskDefinition.volume.efsVolumeConfiguration"))
	},
	"aws.ecs.taskDefinition.volume.host": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolume).GetHost()).ToDataRes(types.Resource("aws.ecs.taskDefinition.volume.host"))
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolume).GetDockerVolumeConfiguration()).ToDataRes(types.Resource("aws.ecs.taskDefinition.volume.dockerVolumeConfiguration"))
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.fileSystemId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).GetFileSystemId()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.rootDirectory": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).GetRootDirectory()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.transitEncryption": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).GetTransitEncryption()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.transitEncryptionPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).GetTransitEncryptionPort()).ToDataRes(types.Int)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).GetAuthorizationConfig()).ToDataRes(types.Resource("aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig"))
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig.accessPointId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig).GetAccessPointId()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig.iam": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig).GetIam()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.host.sourcePath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeHost).GetSourcePath()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).GetScope()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.autoprovision": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).GetAutoprovision()).ToDataRes(types.Bool)
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.driver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).GetDriver()).ToDataRes(types.String)
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.driverOpts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).GetDriverOpts()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).GetLabels()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.taskDefinition.ephemeralStorage.sizeInGiB": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTaskDefinitionEphemeralStorage).GetSizeInGiB()).ToDataRes(types.Int)
	},
	"aws.emr.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmr).GetClusters()).ToDataRes(types.Array(types.Resource("aws.emr.cluster")))
	},
	"aws.emr.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetName()).ToDataRes(types.String)
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetNormalizedInstanceHours()).ToDataRes(types.Int)
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetOutpostArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetMasterInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.emr.cluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetId()).ToDataRes(types.String)
	},
	"aws.emr.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.cloudwatch.logGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetLogGroups()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup")))
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetState()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetStateReason()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetInsufficientDataActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetOkActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetDimensions()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricdimension")))
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetStatistics()).ToDataRes(types.Resource("aws.cloudwatch.metricstatistics"))
	},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetValue()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetLabel()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetDatapoints()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric.datapoint")))
	},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetTimestamp()).ToDataRes(types.Time)
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMaximum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMinimum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetAverage()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetSum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetUnit()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetMetricsFilters()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup.metricsfilter")))
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.retentionInDays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRetentionInDays()).ToDataRes(types.Int)
	},
	"aws.cloudwatch.loggroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterPattern()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudfront.distributions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetDistributions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution")))
	},
	"aws.cloudfront.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.function")))
	},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetOrigins()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution.origin")))
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDefaultCacheBehavior()).ToDataRes(types.Dict)
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetCacheBehaviors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetHttpVersion()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetIsIPV6Enabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetPriceClass()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.cnames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetCnames()).ToDataRes(types.Array(types.String))
	},
	"aws.cloudfront.distribution.viewerProtocolPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetViewerProtocolPolicy()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.minimumProtocolVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetMinimumProtocolVersion()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.webAclId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetWebAclId()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.geoRestrictionType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetGeoRestrictionType()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.lastModifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetLastModifiedAt()).ToDataRes(types.Time)
	},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetId()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionAttempts()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionTimeout()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetOriginPath()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetAccount()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetName()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetLastModifiedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStage()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetComment()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrail).GetTrails()).ToDataRes(types.Array(types.Resource("aws.cloudtrail.trail")))
	},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetName()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsMultiRegionTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsOrganizationTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogFileValidationEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIncludeGlobalServiceEvents()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetS3bucket()).ToDataRes(types.Resource("aws.s3.bucket"))
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetSnsTopicARN()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogGroup()).ToDataRes(types.Resource("aws.cloudwatch.loggroup"))
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetCloudWatchLogsRoleArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.cloudWatchLogsLogGroupArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetCloudWatchLogsLogGroupArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetEventSelectors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.hasInsightSelectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetHasInsightSelectors()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.hasCustomEventSelectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetHasCustomEventSelectors()).ToDataRes(types.Bool)
	},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3control).GetAccountPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.buckets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3).GetBuckets()).ToDataRes(types.Array(types.Resource("aws.s3.bucket")))
	},
	"aws.s3.bucket.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetArn()).ToDataRes(types.String)
	},
	"aws.s3.bucket.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPolicy()).ToDataRes(types.Resource("aws.s3.bucket.policy"))
	},
	"aws.s3.bucket.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.acl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetAcl()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.grant")))
	},
	"aws.s3.bucket.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetOwner()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.cors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCors()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.corsrule")))
	},
	"aws.s3.bucket.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLocation()).ToDataRes(types.String)
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetVersioning()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLogging()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetStaticWebsiteHosting()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.website": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetWebsite()).ToDataRes(types.Resource("aws.s3.bucket.websiteConfiguration"))
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetDefaultLock()).ToDataRes(types.String)
	},
	"aws.s3.bucket.replication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetReplication()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetEncryption()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.objectLockEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetObjectLockEnabled()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetExists()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.s3.bucket.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.s3.bucket.grant.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetPermission()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetGrantee()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedMethods()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedOrigins()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetExposeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetMaxAgeSeconds()).ToDataRes(types.Int)
	},
	"aws.s3.bucket.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.bucketName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetBucketName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetDocument()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetVersion()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetStatements()).ToDataRes(types.Array(types.Dict))
	},
	"aws.s3.bucket.websiteConfiguration.indexDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfiguration).GetIndexDocument()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.errorDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfiguration).GetErrorDocument()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsTo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfiguration).GetRedirectAllRequestsTo()).ToDataRes(types.Resource("aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf"))
	},
	"aws.s3.bucket.websiteConfiguration.routingRules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfiguration).GetRoutingRules()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.websiteConfiguration.routingRule")))
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf.hostname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf).GetHostname()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf).GetProtocol()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirect": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRule).GetRedirect()).ToDataRes(types.Resource("aws.s3.bucket.websiteConfiguration.routingRule.redirectConf"))
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.condition": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRule).GetCondition()).ToDataRes(types.Resource("aws.s3.bucket.websiteConfiguration.routingRule.conditionConf"))
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.hostname": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).GetHostname()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.httpRedirectCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).GetHttpRedirectCode()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).GetProtocol()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.replaceKeyPrefixWith": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).GetReplaceKeyPrefixWith()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.replaceKeyWith": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).GetReplaceKeyWith()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf.httpErrorCodeReturnedEquals": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf).GetHttpErrorCodeReturnedEquals()).ToDataRes(types.String)
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf.keyPrefixEquals": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf).GetKeyPrefixEquals()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetScalableTargets()).ToDataRes(types.Array(types.Resource("aws.applicationAutoscaling.target")))
	},
	"aws.applicationAutoscaling.target.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.target.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetArn()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.target.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetResourceId()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.target.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetRegion()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.target.scalableDimension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetScalableDimension()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.target.minCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetMinCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationAutoscaling.target.maxCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetMaxCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationAutoscaling.target.suspendedState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetSuspendedState()).ToDataRes(types.Dict)
	},
	"aws.applicationAutoscaling.target.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.applicationAutoscaling.target.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetPolicies()).ToDataRes(types.Array(types.Resource("aws.applicationAutoscaling.policy")))
	},
	"aws.applicationAutoscaling.target.scheduledActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingTarget).GetScheduledActions()).ToDataRes(types.Array(types.Resource("aws.applicationAutoscaling.scheduledAction")))
	},
	"aws.applicationAutoscaling.policy.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetArn()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.policyType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetPolicyType()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetResourceId()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.scalableDimension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetScalableDimension()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.policy.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.applicationAutoscaling.policy.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetAlarms()).ToDataRes(types.Array(types.Dict))
	},
	"aws.applicationAutoscaling.policy.targetTrackingConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetTargetTrackingConfig()).ToDataRes(types.Dict)
	},
	"aws.applicationAutoscaling.policy.stepScalingConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetStepScalingConfig()).ToDataRes(types.Dict)
	},
	"aws.applicationAutoscaling.policy.predictiveScalingConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingPolicy).GetPredictiveScalingConfig()).ToDataRes(types.Dict)
	},
	"aws.applicationAutoscaling.scheduledAction.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetArn()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetName()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.schedule": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetSchedule()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.timezone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetTimezone()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetResourceId()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.scalableDimension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetScalableDimension()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scheduledAction.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.applicationAutoscaling.scheduledAction.startAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetStartAt()).ToDataRes(types.Time)
	},
	"aws.applicationAutoscaling.scheduledAction.endAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetEndAt()).ToDataRes(types.Time)
	},
	"aws.applicationAutoscaling.scheduledAction.scalableTargetAction": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscalingScheduledAction).GetScalableTargetAction()).ToDataRes(types.Dict)
	},
	"aws.drs.sourceServers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrs).GetSourceServers()).ToDataRes(types.Array(types.Resource("aws.drs.sourceServer")))
	},
	"aws.drs.jobs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrs).GetJobs()).ToDataRes(types.Array(types.Resource("aws.drs.job")))
	},
	"aws.drs.sourceServer.sourceServerID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetSourceServerID()).ToDataRes(types.String)
	},
	"aws.drs.sourceServer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetArn()).ToDataRes(types.String)
	},
	"aws.drs.sourceServer.dataReplicationInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetDataReplicationInfo()).ToDataRes(types.Dict)
	},
	"aws.drs.sourceServer.lastLaunchResult": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetLastLaunchResult()).ToDataRes(types.String)
	},
	"aws.drs.sourceServer.lifeCycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetLifeCycle()).ToDataRes(types.Dict)
	},
	"aws.drs.sourceServer.sourceProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetSourceProperties()).ToDataRes(types.Dict)
	},
	"aws.drs.sourceServer.stagingArea": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetStagingArea()).ToDataRes(types.Dict)
	},
	"aws.drs.sourceServer.replicationDirection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetReplicationDirection()).ToDataRes(types.String)
	},
	"aws.drs.sourceServer.recoveryInstanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetRecoveryInstanceId()).ToDataRes(types.String)
	},
	"aws.drs.sourceServer.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.drs.sourceServer.replicationConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetReplicationConfiguration()).ToDataRes(types.Resource("aws.drs.replicationConfiguration"))
	},
	"aws.drs.sourceServer.launchConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsSourceServer).GetLaunchConfiguration()).ToDataRes(types.Resource("aws.drs.launchConfiguration"))
	},
	"aws.drs.job.jobID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetJobID()).ToDataRes(types.String)
	},
	"aws.drs.job.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetArn()).ToDataRes(types.String)
	},
	"aws.drs.job.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetType()).ToDataRes(types.String)
	},
	"aws.drs.job.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetStatus()).ToDataRes(types.String)
	},
	"aws.drs.job.initiatedBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetInitiatedBy()).ToDataRes(types.String)
	},
	"aws.drs.job.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.drs.job.endedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetEndedAt()).ToDataRes(types.Time)
	},
	"aws.drs.job.participatingServers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsJob).GetParticipatingServers()).ToDataRes(types.Array(types.Dict))
	},
	"aws.drs.replicationConfiguration.sourceServerID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetSourceServerID()).ToDataRes(types.String)
	},
	"aws.drs.replicationConfiguration.stagingAreaSubnetId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetStagingAreaSubnetId()).ToDataRes(types.String)
	},
	"aws.drs.replicationConfiguration.stagingAreaTags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetStagingAreaTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.drs.replicationConfiguration.useDedicatedReplicationServer": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetUseDedicatedReplicationServer()).ToDataRes(types.Bool)
	},
	"aws.drs.replicationConfiguration.replicationServerInstanceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetReplicationServerInstanceType()).ToDataRes(types.String)
	},
	"aws.drs.replicationConfiguration.ebsEncryption": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetEbsEncryption()).ToDataRes(types.String)
	},
	"aws.drs.replicationConfiguration.ebsEncryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetEbsEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.drs.replicationConfiguration.replicatedDisks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetReplicatedDisks()).ToDataRes(types.Array(types.Dict))
	},
	"aws.drs.replicationConfiguration.bandwidthThrottling": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsReplicationConfiguration).GetBandwidthThrottling()).ToDataRes(types.Int)
	},
	"aws.drs.launchConfiguration.sourceServerID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetSourceServerID()).ToDataRes(types.String)
	},
	"aws.drs.launchConfiguration.targetInstanceTypeRightSizingMethod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetTargetInstanceTypeRightSizingMethod()).ToDataRes(types.String)
	},
	"aws.drs.launchConfiguration.launchDisposition": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetLaunchDisposition()).ToDataRes(types.String)
	},
	"aws.drs.launchConfiguration.copyPrivateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetCopyPrivateIp()).ToDataRes(types.Bool)
	},
	"aws.drs.launchConfiguration.copyTags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetCopyTags()).ToDataRes(types.Bool)
	},
	"aws.drs.launchConfiguration.ec2LaunchTemplateID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetEc2LaunchTemplateID()).ToDataRes(types.String)
	},
	"aws.drs.launchConfiguration.licensing": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetLicensing()).ToDataRes(types.Dict)
	},
	"aws.drs.launchConfiguration.postLaunchEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetPostLaunchEnabled()).ToDataRes(types.Bool)
	},
	"aws.drs.launchConfiguration.launchIntoInstanceProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDrsLaunchConfiguration).GetLaunchIntoInstanceProperties()).ToDataRes(types.Dict)
	},
	"aws.backup.vaults": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackup).GetVaults()).ToDataRes(types.Array(types.Resource("aws.backup.vault")))
	},
	"aws.backup.vault.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vault.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetName()).ToDataRes(types.String)
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRecoveryPoints()).ToDataRes(types.Array(types.Resource("aws.backup.vaultRecoveryPoint")))
	},
	"aws.backup.vault.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRegion()).ToDataRes(types.String)
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vault.locked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetLocked()).ToDataRes(types.Bool)
	},
	"aws.backup.vault.lockedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetLockedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vault.maxRetentionDays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetMaxRetentionDays()).ToDataRes(types.Int)
	},
	"aws.backup.vault.minRetentionDays": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetMinRetentionDays()).ToDataRes(types.Int)
	},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetResourceType()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreatedBy()).ToDataRes(types.Dict)
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIamRoleArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetStatus()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreationDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCompletionDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIsEncrypted()).ToDataRes(types.Bool)
	},
	"aws.dynamodb.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetGlobalTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.globaltable")))
	},
	"aws.dynamodb.tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.table")))
	},
	"aws.dynamodb.limits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetLimits()).ToDataRes(types.Array(types.Resource("aws.dynamodb.limit")))
	},
	"aws.dynamodb.exports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetExports()).ToDataRes(types.Array(types.Resource("aws.dynamodb.export")))
	},
	"aws.dynamodb.export.table": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetTable()).ToDataRes(types.Resource("aws.dynamodb.table"))
	},
	"aws.dynamodb.export.s3Bucket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3Bucket()).ToDataRes(types.Resource("aws.s3.bucket"))
	},
	"aws.dynamodb.export.s3Prefix": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3Prefix()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.itemCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetItemCount()).ToDataRes(types.Int)
	},
	"aws.dynamodb.export.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetType()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetStatus()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.format": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetFormat()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetStartTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.export.endTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetEndTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.export.s3SseAlgorithm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetS3SseAlgorithm()).ToDataRes(types.String)
	},
	"aws.dynamodb.export.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.dynamodb.export.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbExport).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetReplicaSettings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetId()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetSseDescription()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetProvisionedThroughput()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetContinuousBackups()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.dynamodb.table.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.dynamodb.table.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.dynamodb.table.deletionProtectionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetDeletionProtectionEnabled()).ToDataRes(types.Bool)
	},
	"aws.dynamodb.table.globalTableVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetGlobalTableVersion()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.items": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetItems()).ToDataRes(types.Int)
	},
	"aws.dynamodb.table.sizeBytes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetSizeBytes()).ToDataRes(types.Int)
	},
	"aws.dynamodb.table.latestStreamArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetLatestStreamArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetStatus()).ToDataRes(types.String)
	},
	"aws.sqs.queues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqs).GetQueues()).ToDataRes(types.Array(types.Resource("aws.sqs.queue")))
	},
	"aws.sqs.queue.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetArn()).ToDataRes(types.String)
	},
	"aws.sqs.queue.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.sqs.queue.deadLetterQueue": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetDeadLetterQueue()).ToDataRes(types.Resource("aws.sqs.queue"))
	},
	"aws.sqs.queue.deliveryDelaySeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetDeliveryDelaySeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sqs.queue.lastModified": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetLastModified()).ToDataRes(types.Time)
	},
	"aws.sqs.queue.maxReceiveCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMaxReceiveCount()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.maximumMessageSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMaximumMessageSize()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.messageRetentionPeriodSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetMessageRetentionPeriodSeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.receiveMessageWaitTimeSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetReceiveMessageWaitTimeSeconds()).ToDataRes(types.Int)
	},
	"aws.sqs.queue.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetRegion()).ToDataRes(types.String)
	},
	"aws.sqs.queue.sqsManagedSseEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetSqsManagedSseEnabled()).ToDataRes(types.Bool)
	},
	"aws.sqs.queue.queueType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetQueueType()).ToDataRes(types.String)
	},
	"aws.sqs.queue.url": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetUrl()).ToDataRes(types.String)
	},
	"aws.sqs.queue.visibilityTimeoutSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSqsQueue).GetVisibilityTimeoutSeconds()).ToDataRes(types.Int)
	},
	"aws.rds.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetInstances()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetClusters()).ToDataRes(types.Array(types.Resource("aws.rds.dbcluster")))
	},
	"aws.rds.allPendingMaintenanceActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetAllPendingMaintenanceActions()).ToDataRes(types.Array(types.Resource("aws.rds.pendingMaintenanceAction")))
	},
	"aws.rds.parameterGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetParameterGroups()).ToDataRes(types.Array(types.Resource("aws.rds.parameterGroup")))
	},
	"aws.rds.clusterParameterGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetClusterParameterGroups()).ToDataRes(types.Array(types.Resource("aws.rds.clusterParameterGroup")))
	},
	"aws.rds.backupsetting.target": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetTarget()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.retentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.backupsetting.dedicatedLogVolume": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetDedicatedLogVolume()).ToDataRes(types.Bool)
	},
	"aws.rds.backupsetting.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.backupsetting.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.backupsetting.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.timezone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetTimezone()).ToDataRes(types.String)
	},
	"aws.rds.backupsetting.earliestRestoreAvailable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetEarliestRestoreAvailable()).ToDataRes(types.Time)
	},
	"aws.rds.backupsetting.latestRestoreAvailable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsBackupsetting).GetLatestRestoreAvailable()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMembers()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbcluster.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.storageAllocated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageAllocated()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.storageIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageIops()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStorageType()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.clusterDbInstanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetClusterDbInstanceClass()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.rds.dbcluster.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.rds.dbcluster.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.hostedZoneId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetHostedZoneId()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.backupSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetBackupSettings()).ToDataRes(types.Array(types.Resource("aws.rds.backupsetting")))
	},
	"aws.rds.dbcluster.engineLifecycleSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetEngineLifecycleSupport()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.certificateExpiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCertificateExpiresAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbcluster.certificateAuthority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetCertificateAuthority()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.iamDatabaseAuthentication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetIamDatabaseAuthentication()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.activityStreamMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetActivityStreamMode()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.activityStreamStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetActivityStreamStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.rds.dbcluster.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.httpEndpointEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetHttpEndpointEnabled()).ToDataRes(types.Bool)
	},
	"aws.rds.dbcluster.parameterGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetParameterGroupName()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.globalClusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetGlobalClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.databaseInsightsMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetDatabaseInsightsMode()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.dbcluster.performanceInsightsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetPerformanceInsightsEnabled()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetId()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.rds.snapshot.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetType()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetIsClusterSnapshot()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.snapshot.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.snapshot.allocatedStorage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetAllocatedStorage()).ToDataRes(types.Int)
	},
	"aws.rds.snapshot.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.rds.snapshot.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.dbinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetName()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageAllocated()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageIops()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageType()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnhancedMonitoringResourceArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceClass()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceIdentifier()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPort()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.backupSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetBackupSettings()).ToDataRes(types.Array(types.Resource("aws.rds.backupsetting")))
	},
	"aws.rds.dbinstance.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.rds.dbinstance.engineLifecycleSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngineLifecycleSupport()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.certificateExpiresAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCertificateExpiresAt()).ToDataRes(types.Time)
	},
	"aws.rds.dbinstance.certificateAuthority": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCertificateAuthority()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.iamDatabaseAuthentication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetIamDatabaseAuthentication()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.customIamInstanceProfile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCustomIamInstanceProfile()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.activityStreamMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetActivityStreamMode()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.activityStreamStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetActivityStreamStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.pendingMaintenanceActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPendingMaintenanceActions()).ToDataRes(types.Array(types.Resource("aws.rds.pendingMaintenanceAction")))
	},
	"aws.rds.dbinstance.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.dbinstance.performanceInsightsEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPerformanceInsightsEnabled()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.copyTagsToSnapshot": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCopyTagsToSnapshot()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.performanceInsightsKmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPerformanceInsightsKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.rds.pendingMaintenanceAction.resourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetResourceArn()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.action": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetAction()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetDescription()).ToDataRes(types.String)
	},
	"aws.rds.pendingMaintenanceAction.autoAppliedAfterDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetAutoAppliedAfterDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.currentApplyDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetCurrentApplyDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.forcedApplyDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetForcedApplyDate()).ToDataRes(types.Time)
	},
	"aws.rds.pendingMaintenanceAction.optInStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsPendingMaintenanceAction).GetOptInStatus()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.family": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetFamily()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetName()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.clusterParameterGroup.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsClusterParameterGroup).GetParameters()).ToDataRes(types.Array(types.Resource("aws.rds.parameterGroup.parameter")))
	},
	"aws.rds.parameterGroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.family": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetFamily()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetName()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroup).GetParameters()).ToDataRes(types.Array(types.Resource("aws.rds.parameterGroup.parameter")))
	},
	"aws.rds.parameterGroup.parameter.allowedValues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetAllowedValues()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.applyMethod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetApplyMethod()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.applyType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetApplyType()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.dataType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetDataType()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetDescription()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.isModifiable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetIsModifiable()).ToDataRes(types.Bool)
	},
	"aws.rds.parameterGroup.parameter.minimumEngineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetMinimumEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetName()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetValue()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetSource()).ToDataRes(types.String)
	},
	"aws.rds.parameterGroup.parameter.supportedEngineModes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsParameterGroupParameter).GetSupportedEngineModes()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetCacheClusters()).ToDataRes(types.Array(types.Resource("aws.elasticache.cluster")))
	},
	"aws.elasticache.serverlessCaches": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetServerlessCaches()).ToDataRes(types.Array(types.Resource("aws.elasticache.serverlessCache")))
	},
	"aws.elasticache.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAtRestEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenLastModifiedDate()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterCreateTime()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterId()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodes()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSecurityGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetClientDownloadLandingPage()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetIpDiscovery()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetLogDeliveryConfigurations()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNotificationConfiguration()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNumCacheNodes()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetPreferredAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSnapshotRetentionLimit()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.snapshotWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSnapshotWindow()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionMode()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetArn()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetName()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetDescription()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetEngine()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.majorEngineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetMajorEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elasticache.serverlessCache.snapshotRetentionLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetSnapshotRetentionLimit()).ToDataRes(types.Int)
	},
	"aws.elasticache.serverlessCache.dailySnapshotTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetDailySnapshotTime()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetRegion()).ToDataRes(types.String)
	},
	"aws.elasticache.serverlessCache.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheServerlessCache).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.redshift.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshift).GetClusters()).ToDataRes(types.Array(types.Resource("aws.redshift.cluster")))
	},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAllowVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAutomatedSnapshotRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterParameterGroupNames()).ToDataRes(types.Array(types.String))
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterRevisionNumber()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterStatus()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterVersion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetDbName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEnhancedVpcRouting()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNextMaintenanceWindowStartTime()).ToDataRes(types.Time)
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNumberOfNodes()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetParameters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetVpcId()).ToDataRes(types.String)
	},
	"aws.ecr.privateRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPrivateRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPublicRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetName()).ToDataRes(types.String)
	},
	"aws.ecr.repository.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetUri()).ToDataRes(types.String)
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.repository.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.ecr.repository.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImageScanOnPush()).ToDataRes(types.Bool)
	},
	"aws.ecr.repository.imageTagMutability": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImageTagMutability()).ToDataRes(types.String)
	},
	"aws.ecr.repository.encryptionType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetEncryptionType()).ToDataRes(types.String)
	},
	"aws.ecr.repository.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ecr.repository.scanningFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetScanningFrequency()).ToDataRes(types.String)
	},
	"aws.ecr.image.digest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetDigest()).ToDataRes(types.String)
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetMediaType()).ToDataRes(types.String)
	},
	"aws.ecr.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetTags()).ToDataRes(types.Array(types.String))
	},
	"aws.ecr.image.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.image.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRepoName()).ToDataRes(types.String)
	},
	"aws.ecr.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.image.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetUri()).ToDataRes(types.String)
	},
	"aws.ecr.image.pushedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetPushedAt()).ToDataRes(types.Time)
	},
	"aws.ecr.image.sizeInBytes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetSizeInBytes()).ToDataRes(types.Int)
	},
	"aws.ecr.image.lastRecordedPullTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetLastRecordedPullTime()).ToDataRes(types.Time)
	},
	"aws.dms.replicationInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDms).GetReplicationInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.apigateway.restApis": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigateway).GetRestApis()).ToDataRes(types.Array(types.Resource("aws.apigateway.restapi")))
	},
	"aws.apigateway.restapi.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetId()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetCreatedDate()).ToDataRes(types.Time)
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetStages()).ToDataRes(types.Array(types.Resource("aws.apigateway.stage")))
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetRegion()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.apigateway.restapi.apiKeySource": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetApiKeySource()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.disableExecuteApiEndpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetDisableExecuteApiEndpoint()).ToDataRes(types.Bool)
	},
	"aws.apigateway.restapi.minimumCompressionSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetMinimumCompressionSize()).ToDataRes(types.Int)
	},
	"aws.apigateway.restapi.binaryMediaTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetBinaryMediaTypes()).ToDataRes(types.Array(types.String))
	},
	"aws.apigateway.restapi.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetVersion()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.securityPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetSecurityPolicy()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetPolicy()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetTracingEnabled()).ToDataRes(types.Bool)
	},
	"aws.apigateway.stage.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDeploymentId()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetMethodSettings()).ToDataRes(types.Dict)
	},
	"aws.apigateway.stage.cacheClusterEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetCacheClusterEnabled()).ToDataRes(types.Bool)
	},
	"aws.apigateway.stage.cacheClusterSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetCacheClusterSize()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.cacheClusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetCacheClusterStatus()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.clientCertificateId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetClientCertificateId()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.webAclArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetWebAclArn()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.apigateway.stage.lastUpdatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetLastUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.apigateway.stage.documentationVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDocumentationVersion()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.variables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetVariables()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.apigateway.stage.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.lambda.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambda).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.lambda.function")))
	},
	"aws.lambda.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetName()).ToDataRes(types.String)
	},
	"aws.lambda.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetConcurrency()).ToDataRes(types.Int)
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetDlqTargetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetPolicy()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRegion()).ToDataRes(types.String)
	},
	"aws.lambda.function.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.lambda.function.architectures": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetArchitectures()).ToDataRes(types.Array(types.String))
	},
	"aws.lambda.function.ephemeralStorageSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetEphemeralStorageSize()).ToDataRes(types.Int)
	},
	"aws.lambda.function.memorySize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetMemorySize()).ToDataRes(types.Int)
	},
	"aws.lambda.function.role": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRole()).ToDataRes(types.Resource("aws.iam.role"))
	},
	"aws.lambda.function.timeout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetTimeout()).ToDataRes(types.Int)
	},
	"aws.lambda.function.handler": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetHandler()).ToDataRes(types.String)
	},
	"aws.lambda.function.tracingMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetTracingMode()).ToDataRes(types.String)
	},
	"aws.lambda.function.packageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetPackageType()).ToDataRes(types.String)
	},
	"aws.lambda.function.codeSha256": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetCodeSha256()).ToDataRes(types.String)
	},
	"aws.lambda.function.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetDescription()).ToDataRes(types.String)
	},
	"aws.lambda.function.lastModifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetLastModifiedAt()).ToDataRes(types.Time)
	},
	"aws.lambda.function.urlConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetUrlConfig()).ToDataRes(types.Resource("aws.lambda.function.urlConfig"))
	},
	"aws.lambda.function.urlConfig.functionUrl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetFunctionUrl()).ToDataRes(types.String)
	},
	"aws.lambda.function.urlConfig.authType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetAuthType()).ToDataRes(types.String)
	},
	"aws.lambda.function.urlConfig.corsAllowOrigins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsAllowOrigins()).ToDataRes(types.Array(types.String))
	},
	"aws.lambda.function.urlConfig.corsAllowMethods": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsAllowMethods()).ToDataRes(types.Array(types.String))
	},
	"aws.lambda.function.urlConfig.corsAllowHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsAllowHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.lambda.function.urlConfig.corsAllowCredentials": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsAllowCredentials()).ToDataRes(types.Bool)
	},
	"aws.lambda.function.urlConfig.corsExposeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsExposeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.lambda.function.urlConfig.corsMaxAge": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCorsMaxAge()).ToDataRes(types.Int)
	},
	"aws.lambda.function.urlConfig.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.lambda.function.urlConfig.lastModifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunctionUrlConfig).GetLastModifiedAt()).ToDataRes(types.Time)
	},
	"aws.ssm.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsm).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ssm.instance")))
	},
	"aws.ssm.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsm).GetParameters()).ToDataRes(types.Array(types.Resource("aws.ssm.parameter")))
	},
	"aws.ssm.parameter.allowedPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetAllowedPattern()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetArn()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetRegion()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.dataType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetDataType()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetDescription()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.ssm.parameter.lastModifiedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetLastModifiedDate()).ToDataRes(types.Time)
	},
	"aws.ssm.parameter.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetName()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.tier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetTier()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetType()).ToDataRes(types.String)
	},
	"aws.ssm.parameter.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmParameter).GetVersion()).ToDataRes(types.Int)
	},
	"aws.ssm.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPingStatus()).ToDataRes(types.String)
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetIpAddress()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformName()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformType()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ssm.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ssm.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ssm.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetEbsEncryptionByDefault()).ToDataRes(types.Map(types.String, types.Bool))
	},
	"aws.ec2.volumes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVolumes()).ToDataRes(types.Array(types.Resource("aws.ec2.volume")))
	},
	"aws.ec2.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.ec2.snapshot")))
	},
	"aws.ec2.internetGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInternetGateways()).ToDataRes(types.Array(types.Resource("aws.ec2.internetgateway")))
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVpnConnections()).ToDataRes(types.Array(types.Resource("aws.ec2.vpnconnection")))
	},
	"aws.ec2.networkAcls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetNetworkAcls()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl")))
	},
	"aws.ec2.keypairs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetKeypairs()).ToDataRes(types.Array(types.Resource("aws.ec2.keypair")))
	},
	"aws.ec2.eips": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetEips()).ToDataRes(types.Array(types.Resource("aws.ec2.eip")))
	},
	"aws.ec2.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetImages()).ToDataRes(types.Array(types.Resource("aws.ec2.image")))
	},
	"aws.ec2.eip.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ec2.eip.attached": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetAttached()).ToDataRes(types.Bool)
	},
	"aws.ec2.eip.instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetInstance()).ToDataRes(types.Resource("aws.ec2.instance"))
	},
	"aws.ec2.eip.networkInterfaceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetNetworkInterfaceId()).ToDataRes(types.String)
	},
	"aws.ec2.eip.networkInterfaceOwnerId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetNetworkInterfaceOwnerId()).ToDataRes(types.String)
	},
	"aws.ec2.eip.privateIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPrivateIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.eip.publicIpv4Pool": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetPublicIpv4Pool()).ToDataRes(types.String)
	},
	"aws.ec2.eip.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.eip.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Eip).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.vpc.natgateway.natGatewayId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetNatGatewayId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.natgateway.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.vpc.natgateway.addresses": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetAddresses()).ToDataRes(types.Array(types.Resource("aws.vpc.natgateway.address")))
	},
	"aws.vpc.natgateway.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgateway).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.vpc.natgateway.address.allocationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetAllocationId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.networkInterfaceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetNetworkInterfaceId()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.privateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetPrivateIp()).ToDataRes(types.String)
	},
	"aws.vpc.natgateway.address.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetPublicIp()).ToDataRes(types.Resource("aws.ec2.eip"))
	},
	"aws.vpc.natgateway.address.isPrimary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcNatgatewayAddress).GetIsPrimary()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.acceptanceRequired": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetAcceptanceRequired()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.dnsNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetDnsNames()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.managesVpcEndpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetManagesVpcEndpoints()).ToDataRes(types.Bool)
	},
	"aws.vpc.serviceEndpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetOwner()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.payerResponsibility": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPayerResponsibility()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.privateDnsNameVerificationState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPrivateDnsNameVerificationState()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.privateDnsNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetPrivateDnsNames()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.serviceEndpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.serviceEndpoint.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.serviceEndpoint.vpcEndpointPolicySupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcServiceEndpoint).GetVpcEndpointPolicySupported()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.acceptorVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetAcceptorVpc()).ToDataRes(types.Resource("aws.vpc.peeringConnection.peeringVpc"))
	},
	"aws.vpc.peeringConnection.expirationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetExpirationTime()).ToDataRes(types.Time)
	},
	"aws.vpc.peeringConnection.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.requestorVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetRequestorVpc()).ToDataRes(types.Resource("aws.vpc.peeringConnection.peeringVpc"))
	},
	"aws.vpc.peeringConnection.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnection).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.allowDnsResolutionFromRemoteVpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetAllowDnsResolutionFromRemoteVpc()).ToDataRes(types.Bool)
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv4CiderBlocks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetIpv4CiderBlocks()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv6CiderBlocks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetIpv6CiderBlocks()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.peeringConnection.peeringVpc.ownerID": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetOwnerID()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.peeringVpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.peeringConnection.peeringVpc.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.vpc.peeringConnection.peeringVpc.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcPeeringConnectionPeeringVpc).GetVpcId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetEntries()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl.entry")))
	},
	"aws.ec2.networkacl.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkacl.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.networkacl.associations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetAssociations()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl.association")))
	},
	"aws.ec2.networkacl.association.associationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetAssociationId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.association.networkAclId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetNetworkAclId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.association.subnetId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclAssociation).GetSubnetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetEgress()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetRuleAction()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.ruleNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetRuleNumber()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetPortRange()).ToDataRes(types.Resource("aws.ec2.networkacl.entry.portrange"))
	},
	"aws.ec2.networkacl.entry.cidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetCidrBlock()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.ipv6CidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetIpv6CidrBlock()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetFrom()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetTo()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetVgwTelemetry()).ToDataRes(types.Array(types.Resource("aws.ec2.vgwtelemetry")))
	},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetOutsideIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatusMessage()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.internetgateway.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetCreateVolumePermission()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetStartTime()).ToDataRes(types.Time)
	},
	"aws.ec2.snapshot.completionTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetCompletionTime()).ToDataRes(types.Time)
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.volumeSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetVolumeSize()).ToDataRes(types.Int)
	},
	"aws.ec2.snapshot.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.snapshot.storageTier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetStorageTier()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.ec2.volume.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.volume.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.volume.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetVolumeType()).ToDataRes(types.String)
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetCreateTime()).ToDataRes(types.Time)
	},
	"aws.ec2.volume.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.volume.multiAttachEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetMultiAttachEnabled()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.throughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetThroughput()).ToDataRes(types.Int)
	},
	"aws.ec2.volume.size": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetSize()).ToDataRes(types.Int)
	},
	"aws.ec2.volume.iops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetIops()).ToDataRes(types.Int)
	},
	"aws.ec2.volume.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.inspector.coverages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspector).GetCoverages()).ToDataRes(types.Array(types.Resource("aws.inspector.coverage")))
	},
	"aws.inspector.coverage.accountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetAccountId()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.resourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetResourceId()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetResourceType()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.lastScannedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetLastScannedAt()).ToDataRes(types.Time)
	},
	"aws.inspector.coverage.statusReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetStatusReason()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.statusCode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetStatusCode()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.scanType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetScanType()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.ec2Instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEc2Instance()).ToDataRes(types.Resource("aws.inspector.coverage.instance"))
	},
	"aws.inspector.coverage.ecrImage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEcrImage()).ToDataRes(types.Resource("aws.inspector.coverage.image"))
	},
	"aws.inspector.coverage.ecrRepo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetEcrRepo()).ToDataRes(types.Resource("aws.inspector.coverage.repository"))
	},
	"aws.inspector.coverage.lambda": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverage).GetLambda()).ToDataRes(types.Resource("aws.lambda.function"))
	},
	"aws.inspector.coverage.instance.platform": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetPlatform()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.inspector.coverage.instance.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetImage()).ToDataRes(types.Resource("aws.ec2.image"))
	},
	"aws.inspector.coverage.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.image.imagePulledAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetImagePulledAt()).ToDataRes(types.Time)
	},
	"aws.inspector.coverage.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.inspector.coverage.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageImage).GetRegion()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetName()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.scanFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetScanFrequency()).ToDataRes(types.String)
	},
	"aws.inspector.coverage.repository.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsInspectorCoverageRepository).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDetailedMonitoring()).ToDataRes(types.String)
	},
	"aws.ec2.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSsm()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpTokens()).ToDataRes(types.String)
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpEndpoint()).ToDataRes(types.String)
	},
	"aws.ec2.instance.httpPutResponseHopLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpPutResponseHopLimit()).ToDataRes(types.Int)
	},
	"aws.ec2.instance.enclaveEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEnclaveEnabled()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPatchState()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDeviceMappings()).ToDataRes(types.Array(types.Resource("aws.ec2.instance.device")))
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPlatformDetails()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceStatus()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateReason()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionReason()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEbsOptimized()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.enaSupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEnaSupported()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceType()).ToDataRes(types.String)
	},
	"aws.ec2.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.instance.iamInstanceProfile": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetIamInstanceProfile()).ToDataRes(types.Resource("aws.iam.instanceProfile"))
	},
	"aws.ec2.instance.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetImage()).ToDataRes(types.Resource("aws.ec2.image"))
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetLaunchTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetKeypair()).ToDataRes(types.Resource("aws.ec2.keypair"))
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpcArn()).ToDataRes(types.String)
	},
	"aws.ec2.instance.hypervisor": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHypervisor()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceLifecycle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceLifecycle()).ToDataRes(types.String)
	},
	"aws.ec2.instance.rootDeviceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRootDeviceType()).ToDataRes(types.String)
	},
	"aws.ec2.instance.rootDeviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRootDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.architecture": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetArchitecture()).ToDataRes(types.String)
	},
	"aws.ec2.instance.tpmSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetTpmSupport()).ToDataRes(types.String)
	},
	"aws.ec2.instance.networkInterfaces": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetNetworkInterfaces()).ToDataRes(types.Array(types.Resource("aws.ec2.networkinterface")))
	},
	"aws.ec2.instance.disableApiTermination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDisableApiTermination()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.subnet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSubnet()).ToDataRes(types.Resource("aws.vpc.subnet"))
	},
	"aws.ec2.networkinterface.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.networkinterface.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.sourceDestCheck": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSourceDestCheck()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.requesterManaged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetRequesterManaged()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.networkinterface.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.networkinterface.ipv6Native": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetIpv6Native()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkinterface.macAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetMacAddress()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.privateDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetPrivateDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.networkinterface.privateIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkinterface).GetPrivateIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetFingerprint()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetType()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.keypair.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.image.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.image.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.image.architecture": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArchitecture()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerId()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerAlias()).ToDataRes(types.String)
	},
	"aws.ec2.image.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.image.deprecatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetDeprecatedAt()).ToDataRes(types.Time)
	},
	"aws.ec2.image.enaSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetEnaSupport()).ToDataRes(types.Bool)
	},
	"aws.ec2.image.tpmSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetTpmSupport()).ToDataRes(types.String)
	},
	"aws.ec2.image.imdsSupport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetImdsSupport()).ToDataRes(types.String)
	},
	"aws.ec2.image.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.image.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.ec2.image.rootDeviceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetRootDeviceType()).ToDataRes(types.String)
	},
	"aws.ec2.image.virtualizationType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetVirtualizationType()).ToDataRes(types.String)
	},
	"aws.ec2.image.blockDeviceMappings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetBlockDeviceMappings()).ToDataRes(types.Array(types.Resource("aws.ec2.image.blockDeviceMapping")))
	},
	"aws.ec2.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.image.launchPermissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetLaunchPermissions()).ToDataRes(types.Array(types.Resource("aws.ec2.image.launchPermission")))
	},
	"aws.ec2.image.launchPermission.userId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageLaunchPermission).GetUserId()).ToDataRes(types.String)
	},
	"aws.ec2.image.launchPermission.group": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageLaunchPermission).GetGroup()).ToDataRes(types.String)
	},
	"aws.ec2.image.launchPermission.organizationArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageLaunchPermission).GetOrganizationArn()).ToDataRes(types.String)
	},
	"aws.ec2.image.launchPermission.organizationalUnitArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageLaunchPermission).GetOrganizationalUnitArn()).ToDataRes(types.String)
	},
	"aws.ec2.image.blockDeviceMapping.deviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageBlockDeviceMapping).GetDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.image.blockDeviceMapping.virtualName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageBlockDeviceMapping).GetVirtualName()).ToDataRes(types.String)
	},
	"aws.ec2.image.blockDeviceMapping.noDevice": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageBlockDeviceMapping).GetNoDevice()).ToDataRes(types.Bool)
	},
	"aws.ec2.image.blockDeviceMapping.ebs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageBlockDeviceMapping).GetEbs()).ToDataRes(types.Resource("aws.ec2.image.ebsBlockDevice"))
	},
	"aws.ec2.image.ebsBlockDevice.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.image.ebsBlockDevice.snapshotId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetSnapshotId()).ToDataRes(types.String)
	},
	"aws.ec2.image.ebsBlockDevice.volumeSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetVolumeSize()).ToDataRes(types.Int)
	},
	"aws.ec2.image.ebsBlockDevice.volumeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetVolumeType()).ToDataRes(types.String)
	},
	"aws.ec2.image.ebsBlockDevice.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.ec2.image.ebsBlockDevice.iops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetIops()).ToDataRes(types.Int)
	},
	"aws.ec2.image.ebsBlockDevice.throughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetThroughput()).ToDataRes(types.Int)
	},
	"aws.ec2.image.ebsBlockDevice.deleteOnTermination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2ImageEbsBlockDevice).GetDeleteOnTermination()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeleteOnTermination()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissions()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissionsEgress()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIsAttachedToNetworkInterface()).ToDataRes(types.Bool)
	},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetFromPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetToPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpProtocol()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpRanges()).ToDataRes(types.Array(types.String))
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpv6Ranges()).ToDataRes(types.Array(types.String))
	},
	"aws.ec2.securitygroup.ippermission.prefixListIds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetPrefixListIds()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.securitygroup.ippermission.userIdGroupPairs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetUserIdGroupPairs()).ToDataRes(types.Array(types.Dict))
	},
	"aws.config.recorders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRecorders()).ToDataRes(types.Array(types.Resource("aws.config.recorder")))
	},
	"aws.config.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRules()).ToDataRes(types.Array(types.Resource("aws.config.rule")))
	},
	"aws.config.deliveryChannels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetDeliveryChannels()).ToDataRes(types.Array(types.Resource("aws.config.deliverychannel")))
	},
	"aws.config.rule.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetArn()).ToDataRes(types.String)
	},
	"aws.config.rule.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetState()).ToDataRes(types.String)
	},
	"aws.config.rule.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetSource()).ToDataRes(types.Dict)
	},
	"aws.config.rule.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetId()).ToDataRes(types.String)
	},
	"aws.config.rule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetName()).ToDataRes(types.String)
	},
	"aws.config.rule.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetDescription()).ToDataRes(types.String)
	},
	"aws.config.rule.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetRegion()).ToDataRes(types.String)
	},
	"aws.config.recorder.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetName()).ToDataRes(types.String)
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRoleArn()).ToDataRes(types.String)
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetAllSupported()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetIncludeGlobalResourceTypes()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.recording": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRecording()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.config.recorder.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRegion()).ToDataRes(types.String)
	},
	"aws.config.recorder.resourceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetResourceTypes()).ToDataRes(types.Array(types.String))
	},
	"aws.config.deliverychannel.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetName()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.s3BucketName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetS3BucketName()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.s3KeyPrefix": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetS3KeyPrefix()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.snsTopicARN": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetSnsTopicARN()).ToDataRes(types.String)
	},
	"aws.config.deliverychannel.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigDeliverychannel).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEks).GetClusters()).ToDataRes(types.Array(types.Resource("aws.eks.cluster")))
	},
	"aws.eks.nodegroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetName()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.nodegroup.modifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetModifiedAt()).ToDataRes(types.Time)
	},
	"aws.eks.nodegroup.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.capacityType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetCapacityType()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.scalingConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetScalingConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.nodegroup.instanceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetInstanceTypes()).ToDataRes(types.Array(types.String))
	},
	"aws.eks.nodegroup.amiType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetAmiType()).ToDataRes(types.String)
	},
	"aws.eks.nodegroup.nodeRole": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetNodeRole()).ToDataRes(types.Resource("aws.iam.role"))
	},
	"aws.eks.nodegroup.diskSize": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetDiskSize()).ToDataRes(types.Int)
	},
	"aws.eks.nodegroup.labels": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetLabels()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.nodegroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.nodegroup.autoscalingGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksNodegroup).GetAutoscalingGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.eks.addon.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetName()).ToDataRes(types.String)
	},
	"aws.eks.addon.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.addon.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.addon.addonVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetAddonVersion()).ToDataRes(types.String)
	},
	"aws.eks.addon.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.addon.modifiedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetModifiedAt()).ToDataRes(types.Time)
	},
	"aws.eks.addon.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.addon.publisher": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetPublisher()).ToDataRes(types.String)
	},
	"aws.eks.addon.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetOwner()).ToDataRes(types.String)
	},
	"aws.eks.addon.configurationValues": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksAddon).GetConfigurationValues()).ToDataRes(types.String)
	},
	"aws.eks.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetName()).ToDataRes(types.String)
	},
	"aws.eks.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.eks.cluster.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEncryptionConfig()).ToDataRes(types.Array(types.Dict))
	},
	"aws.eks.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetNetworkConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetResourcesVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.eks.cluster.nodeGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetNodeGroups()).ToDataRes(types.Array(types.Resource("aws.eks.nodegroup")))
	},
	"aws.eks.cluster.addons": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetAddons()).ToDataRes(types.Array(types.Resource("aws.eks.addon")))
	},
	"aws.eks.cluster.iamRole": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetIamRole()).ToDataRes(types.Resource("aws.iam.role"))
	},
	"aws.eks.cluster.supportType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetSupportType()).ToDataRes(types.String)
	},
	"aws.eks.cluster.authenticationMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetAuthenticationMode()).ToDataRes(types.String)
	},
	"aws.eks.cluster.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.eks.cluster.endpointPublicAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEndpointPublicAccess()).ToDataRes(types.Bool)
	},
	"aws.eks.cluster.endpointPrivateAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEndpointPrivateAccess()).ToDataRes(types.Bool)
	},
	"aws.eks.cluster.publicAccessCidrs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetPublicAccessCidrs()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptune).GetClusters()).ToDataRes(types.Array(types.Resource("aws.neptune.cluster")))
	},
	"aws.neptune.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptune).GetInstances()).ToDataRes(types.Array(types.Resource("aws.neptune.instance")))
	},
	"aws.neptune.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetName()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.clusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.globalClusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetGlobalClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.automaticRestartTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetAutomaticRestartTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.availabilityZones": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetAvailabilityZones()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.cluster.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.neptune.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.crossAccountClone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetCrossAccountClone()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.clusterParameterGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterParameterGroup()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.subnetGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetSubnetGroup()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.clusterResourceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetClusterResourceId()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.earliestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEarliestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.cluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.iamDatabaseAuthenticationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetIamDatabaseAuthenticationEnabled()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.cluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPort()).ToDataRes(types.Int)
	},
	"aws.neptune.cluster.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.neptune.cluster.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.neptune.cluster.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneCluster).GetStorageType()).ToDataRes(types.String)
	},
	"aws.neptune.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetName()).ToDataRes(types.String)
	},
	"aws.neptune.instance.clusterIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetClusterIdentifier()).ToDataRes(types.String)
	},
	"aws.neptune.instance.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.neptune.instance.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.instanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetInstanceClass()).ToDataRes(types.String)
	},
	"aws.neptune.instance.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStatus()).ToDataRes(types.String)
	},
	"aws.neptune.instance.port": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPort()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.neptune.instance.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEndpoint()).ToDataRes(types.Dict)
	},
	"aws.neptune.instance.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEngine()).ToDataRes(types.String)
	},
	"aws.neptune.instance.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.neptune.instance.enhancedMonitoringResourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetEnhancedMonitoringResourceArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.iamDatabaseAuthenticationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetIamDatabaseAuthenticationEnabled()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.neptune.instance.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.neptune.instance.latestRestorableTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetLatestRestorableTime()).ToDataRes(types.Time)
	},
	"aws.neptune.instance.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.neptune.instance.monitoringInterval": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMonitoringInterval()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.monitoringRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMonitoringRoleArn()).ToDataRes(types.String)
	},
	"aws.neptune.instance.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.preferredBackupWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPreferredBackupWindow()).ToDataRes(types.String)
	},
	"aws.neptune.instance.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.neptune.instance.promotionTier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetPromotionTier()).ToDataRes(types.Int)
	},
	"aws.neptune.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.neptune.instance.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.neptune.instance.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetStorageType()).ToDataRes(types.String)
	},
	"aws.neptune.instance.tdeCredentialArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsNeptuneInstance).GetTdeCredentialArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.databases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalytics).GetDatabases()).ToDataRes(types.Array(types.Resource("aws.timestream.liveanalytics.database")))
	},
	"aws.timestream.liveanalytics.tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalytics).GetTables()).ToDataRes(types.Array(types.Resource("aws.timestream.liveanalytics.table")))
	},
	"aws.timestream.liveanalytics.database.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.kmsKeyId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetKmsKeyId()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetRegion()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.database.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.database.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.database.tableCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsDatabase).GetTableCount()).ToDataRes(types.Int)
	},
	"aws.timestream.liveanalytics.table.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetArn()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.databaseName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetDatabaseName()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetRegion()).ToDataRes(types.String)
	},
	"aws.timestream.liveanalytics.table.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.table.updatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetUpdatedAt()).ToDataRes(types.Time)
	},
	"aws.timestream.liveanalytics.table.magneticStoreWriteProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetMagneticStoreWriteProperties()).ToDataRes(types.Dict)
	},
	"aws.timestream.liveanalytics.table.retentionProperties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsTimestreamLiveanalyticsTable).GetRetentionProperties()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.applications": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeploy).GetApplications()).ToDataRes(types.Array(types.Resource("aws.codedeploy.application")))
	},
	"aws.codedeploy.application.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetArn()).ToDataRes(types.String)
	},
	"aws.codedeploy.application.applicationId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetApplicationId()).ToDataRes(types.String)
	},
	"aws.codedeploy.application.applicationName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetApplicationName()).ToDataRes(types.String)
	},
	"aws.codedeploy.application.computePlatform": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetComputePlatform()).ToDataRes(types.String)
	},
	"aws.codedeploy.application.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.codedeploy.application.linkedToGitHub": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetLinkedToGitHub()).ToDataRes(types.Bool)
	},
	"aws.codedeploy.application.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.codedeploy.application.deploymentGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetDeploymentGroups()).ToDataRes(types.Array(types.Resource("aws.codedeploy.deploymentGroup")))
	},
	"aws.codedeploy.application.deployments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetDeployments()).ToDataRes(types.Array(types.Resource("aws.codedeploy.deployment")))
	},
	"aws.codedeploy.application.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployApplication).GetRegion()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.applicationName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetApplicationName()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.deploymentGroupId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetDeploymentGroupId()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.deploymentGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetDeploymentGroupName()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.computePlatform": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetComputePlatform()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.serviceRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetServiceRoleArn()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.targetRevision": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetTargetRevision()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deploymentGroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.codedeploy.deploymentGroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.codedeploy.deploymentGroup.deployments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetDeployments()).ToDataRes(types.Array(types.Resource("aws.codedeploy.deployment")))
	},
	"aws.codedeploy.deploymentGroup.autoScalingGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetAutoScalingGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.codedeploy.deploymentGroup.ec2TagFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetEc2TagFilters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.codedeploy.deploymentGroup.onPremisesInstanceTagFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetOnPremisesInstanceTagFilters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.codedeploy.deploymentGroup.lastSuccessfulDeployment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetLastSuccessfulDeployment()).ToDataRes(types.Resource("aws.codedeploy.deployment"))
	},
	"aws.codedeploy.deploymentGroup.lastAttemptedDeployment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetLastAttemptedDeployment()).ToDataRes(types.Resource("aws.codedeploy.deployment"))
	},
	"aws.codedeploy.deploymentGroup.deploymentStyle": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetDeploymentStyle()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deploymentGroup.blueGreenDeploymentConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetBlueGreenDeploymentConfiguration()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deploymentGroup.loadBalancerInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeploymentGroup).GetLoadBalancerInfo()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deployment.applicationName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetApplicationName()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.deploymentId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetDeploymentId()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetArn()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetStatus()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.deploymentGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetDeploymentGroupName()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.deploymentConfigName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetDeploymentConfigName()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.codedeploy.deployment.compleatedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetCompleatedAt()).ToDataRes(types.Time)
	},
	"aws.codedeploy.deployment.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetDescription()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.creator": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetCreator()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.ignoreApplicationStopFailures": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetIgnoreApplicationStopFailures()).ToDataRes(types.Bool)
	},
	"aws.codedeploy.deployment.targetInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetTargetInstances()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deployment.revision": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetRevision()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deployment.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetRegion()).ToDataRes(types.String)
	},
	"aws.codedeploy.deployment.errorInformation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetErrorInformation()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deployment.deploymentOverview": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetDeploymentOverview()).ToDataRes(types.Dict)
	},
	"aws.codedeploy.deployment.isRollback": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetIsRollback()).ToDataRes(types.Bool)
	},
	"aws.codedeploy.deployment.rollbackInfo": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodedeployDeployment).GetRollbackInfo()).ToDataRes(types.Dict)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool{
	"aws.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).__id, ok = v.Value.(string)
		return
	},
	"aws.vpcs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Vpcs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.regions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Regions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.account.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).__id, ok = v.Value.(string)
		return
	},
	"aws.account.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.aliases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Aliases, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.account.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Organization, ok = plugin.RawToTValue[*mqlAwsOrganization](v.Value, v.Error)
		return
	},
	"aws.account.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.account.contactInformation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).ContactInformation, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.account.alternateContacts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).AlternateContacts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.account.securityContact": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).SecurityContact, ok = plugin.RawToTValue[*mqlAwsAccountAlternateContact](v.Value, v.Error)
		return
	},
	"aws.account.billingContact": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).BillingContact, ok = plugin.RawToTValue[*mqlAwsAccountAlternateContact](v.Value, v.Error)
		return
	},
	"aws.account.operationsContact": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).OperationsContact, ok = plugin.RawToTValue[*mqlAwsAccountAlternateContact](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).__id, ok = v.Value.(string)
		return
	},
	"aws.account.alternateContact.accountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).AccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.contactType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).ContactType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.emailAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).EmailAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.phoneNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).PhoneNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.alternateContact.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccountAlternateContact).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.organization.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).__id, ok = v.Value.(string)
		return
	},
	"aws.organization.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.featureSet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).FeatureSet, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountEmail, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.accounts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Accounts, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.organization.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).InstanceTenancy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Endpoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.flowLogs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).FlowLogs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.routeTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).RouteTables, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.natGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).NatGateways, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).ServiceEndpoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).PeeringConnections, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.internetGatewayBlockMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).InternetGatewayBlockMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.dhcpOptionsId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).DhcpOptionsId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.internetGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).InternetGateways, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.networkAcls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).NetworkAcls, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).VpnGateways, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.routetable.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.associations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Associations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Routes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.routetable.association.routeTableAssociationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).RouteTableAssociationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.associationsState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).AssociationsState, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.gatewayId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).GatewayId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.main": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).Main, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.routeTableId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).RouteTableId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.association.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetableAssociation).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.subnet.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Cidrs, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).MapPublicIpOnLaunch, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).DefaultForAvailabilityZone, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.assignIpv6AddressOnCreation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AssignIpv6AddressOnCreation, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.availableIpAddressCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AvailableIpAddressCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.internetGatewayBlockMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).InternetGatewayBlockMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.routeTable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).RouteTable, ok = plugin.RawToTValue[*mqlAwsVpcRoutetable](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.endpoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).ServiceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).PolicyDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.privateDnsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).PrivateDnsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.flowlog.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.destination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Destination, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.destinationType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).DestinationType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.deliverLogsStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).DeliverLogsStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.logFormat": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).LogFormat, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.maxAggregationInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).MaxAggregationInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.trafficType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).TrafficType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.vpnGateway.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.amazonSideAsn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).AmazonSideAsn, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Attachments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.vpnGateway.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcVpnGateway).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.waf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.acls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).Acls, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.ruleGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).RuleGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.ipSets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).IpSets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWaf).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.acl.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.acl.managedByFirewallManager": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).ManagedByFirewallManager, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.acl.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Rules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.acl.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafAcl).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rulegroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Rules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rulegroup.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRulegroup).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.priority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Priority, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Statement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).Action, ok = plugin.RawToTValue[*mqlAwsWafRuleAction](v.Value, v.Error)
		return
	},
	"aws.waf.rule.belongsTo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRule).BelongsTo, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.action.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).Action, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.action.responseCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleAction).ResponseCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.kind": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Kind, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.json": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).Json, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqliMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).SqliMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementSqlimatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).XssMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementXssmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.byteMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).ByteMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementBytematchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RegexMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRegexmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geoMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).GeoMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementGeomatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipSetReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).IpSetReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementIpsetreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelMatchStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).LabelMatchStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementLabelmatchstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedRuleGroupStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).ManagedRuleGroupStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementManagedrulegroupstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).NotStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementNotstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).OrStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementOrstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).AndStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementAndstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rateBasedStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RateBasedStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRatebasedstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexPatternSetReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RegexPatternSetReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ruleGroupReferenceStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).RuleGroupReferenceStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementRulegroupreferencestatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeConstraintStatement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatement).SizeConstraintStatement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementSizeconstraintstatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.geomatchstatement.countryCodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementGeomatchstatement).CountryCodes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipSetForwardedIPConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatement).IpSetForwardedIPConfig, ok = plugin.RawToTValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.headerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).HeaderName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.position": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).Position, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig.fallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig).FallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.labelmatchstatement.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementLabelmatchstatement).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.managedrulegroupstatement.vendorName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementManagedrulegroupstatement).VendorName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.andstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.andstatement.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementAndstatement).Statements, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.notstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.notstatement.statement": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementNotstatement).Statement, ok = plugin.RawToTValue[*mqlAwsWafRuleStatement](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.orstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.orstatement.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementOrstatement).Statements, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.ratebasedstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRatebasedstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexpatternsetreferencestatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexpatternsetreferencestatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.rulegroupreferencestatement.excludeRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRulegroupreferencestatement).ExcludeRules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.comparisonOperator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).ComparisonOperator, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sizeconstraintstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSizeconstraintstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.regexmatchstatement.regexString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementRegexmatchstatement).RegexString, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.bytematchstatement.searchString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementBytematchstatement).SearchString, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.method": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Method, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.uriPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).UriPath, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.queryString": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).QueryString, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.allQueryArguments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).AllQueryArguments, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Body, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchBody](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Cookie, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchCookie](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleHeader": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).SingleHeader, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchSingleheader](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerOrder": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).HeaderOrder, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeaderorder](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Headers, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeaders](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3Fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).Ja3Fingerprint, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonBody": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).JsonBody, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJsonbody](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleQueryArgument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatch).SingleQueryArgument, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.body.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.body.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchBody).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.cookie.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchCookie).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headerorder.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaderorder).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singleheader.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSingleheader).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.singlequeryargument.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchSinglequeryargument).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.ja3fingerprint.fallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJa3fingerprint).FallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchScope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).MatchScope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.invalidFallbackBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).InvalidFallbackBehavior, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbody).MatchPattern, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.all": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).All, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.jsonbody.matchpattern.includePaths": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern).IncludePaths, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchScope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).MatchScope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.overSizeHandling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).OverSizeHandling, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeaders).MatchPattern, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.all": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).All, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.includeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).IncludeHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.fieldtomatch.headers.matchpattern.excludeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleFieldtomatchHeadersMatchpattern).ExcludeHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.xssmatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementXssmatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.ruleName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).RuleName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.statementID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).StatementID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.fieldToMatch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).FieldToMatch, ok = plugin.RawToTValue[*mqlAwsWafRuleFieldtomatch](v.Value, v.Error)
		return
	},
	"aws.waf.rule.statement.sqlimatchstatement.sensitivityLevel": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafRuleStatementSqlimatchstatement).SensitivityLevel, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).__id, ok = v.Value.(string)
		return
	},
	"aws.waf.ipset.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.addressType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).AddressType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.waf.ipset.addresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsWafIpset).Addresses, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.efs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfs).__id, ok = v.Value.(string)
		return
	},
	"aws.efs.filesystems": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfs).Filesystems, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).__id, ok = v.Value.(string)
		return
	},
	"aws.efs.filesystem.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).BackupPolicy, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.mountTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).MountTargets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.accessPoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).AccessPoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.fileSystemPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).FileSystemPolicy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).__id, ok = v.Value.(string)
		return
	},
	"aws.efs.mountTarget.mountTargetId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).MountTargetId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.fileSystemId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).FileSystemId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.subnetId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).SubnetId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.ipAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).IpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.lifecycleState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).LifecycleState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.networkInterfaceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).NetworkInterfaceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.mountTarget.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsMountTarget).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).__id, ok = v.Value.(string)
		return
	},
	"aws.efs.accessPoint.accessPointId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).AccessPointId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.fileSystemId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).FileSystemId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.posixUser": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).PosixUser, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.rootDirectory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).RootDirectory, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.lifecycleState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).LifecycleState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.efs.accessPoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsAccessPoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsx).__id, ok = v.Value.(string)
		return
	},
	"aws.fsx.fileSystems": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsx).FileSystems, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.caches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsx).Caches, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsx).Backups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).__id, ok = v.Value.(string)
		return
	},
	"aws.fsx.filesystem.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.lifecycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Lifecycle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.storageCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).StorageCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.subnetIds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).SubnetIds, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.fsx.filesystem.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxFilesystem).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).__id, ok = v.Value.(string)
		return
	},
	"aws.fsx.cache.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.lifecycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).Lifecycle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.storageCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).StorageCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.subnetIds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).SubnetIds, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.lustreConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).LustreConfiguration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.dataRepositoryAssociations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).DataRepositoryAssociations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.fsx.cache.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxCache).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).__id, ok = v.Value.(string)
		return
	},
	"aws.fsx.backup.backupId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).BackupId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.lifecycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).Lifecycle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.fileSystemId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).FileSystemId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.fileSystemType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).FileSystemType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.fsx.backup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsFsxBackup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.kms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKms).__id, ok = v.Value.(string)
		return
	},
	"aws.kms.keys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKms).Keys, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.kms.key.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).__id, ok = v.Value.(string)
		return
	},
	"aws.kms.key.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).KeyRotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.kms.key.metadata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Metadata, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.kms.key.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.kms.key.aliases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Aliases, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.kms.key.keyState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).KeyState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.kms.key.deletedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).DeletedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.kms.key.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.kms.key.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.grants": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Grants, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.kms.grant.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).__id, ok = v.Value.(string)
		return
	},
	"aws.kms.grant.grantId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).GrantId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.grant.keyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).KeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.grant.granteePrincipal": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).GranteePrincipal, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.grant.retiringPrincipal": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).RetiringPrincipal, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.grant.issuingAccount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).IssuingAccount, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.grant.operations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).Operations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.kms.grant.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsGrant).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.users": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Users, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.roles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Roles, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Groups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Policies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AttachedPolicies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.credentialReport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).CredentialReport, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountPasswordPolicy, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.iam.accountSummary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountSummary, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).VirtualMfaDevices, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.serverCertificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).ServerCertificates, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfiles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).InstanceProfiles, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.samlProviders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).SamlProviders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProviders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).OidcProviders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Properties, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).MfaActive, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastChanged, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordNextRotation, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.user.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.user.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Policies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AttachedPolicies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.user.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Groups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AccessKeys, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.user.loginProfile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).LoginProfile, ok = plugin.RawToTValue[*mqlAwsIamLoginProfile](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.instanceProfile.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.instanceProfileId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).InstanceProfileId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.instanceProfileName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).InstanceProfileName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.instanceProfile.iamRoles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamInstanceProfile).IamRoles, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.loginProfile.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamLoginProfile).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.loginProfile.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamLoginProfile).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.policy.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.policyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).PolicyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).IsAttachable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachmentCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.iam.policy.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.versions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Versions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).DefaultVersion, ok = plugin.RawToTValue[*mqlAwsIamPolicyversion](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedUsers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedRoles, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.policyversion.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).VersionId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).IsDefaultVersion, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Document, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.role.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.role.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.assumeRolePolicyDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).AssumeRolePolicyDocument, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.iam.role.lastUsedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).LastUsedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.lastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.maxSessionDuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).MaxSessionDuration, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.iam.role.permissionsBoundaryArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).PermissionsBoundaryArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.usernames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Usernames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.group.inlinePolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).InlinePolicies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).SerialNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).EnableDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.samlProvider.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.validUntil": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).ValidUntil, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.metadataDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).MetadataDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.samlProvider.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamSamlProvider).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.oidcProvider.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.clientIds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).ClientIds, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.thumbprints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).Thumbprints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.oidcProvider.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamOidcProvider).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.accessAnalyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessAnalyzer).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.accessAnalyzer.analyzers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessAnalyzer).Analyzers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.accessAnalyzer.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessAnalyzer).Findings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.accessanalyzer.analyzer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).LastResourceAnalyzed, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).LastResourceAnalyzedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.analyzer.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerAnalyzer).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).__id, ok = v.Value.(string)
		return
	},
	"aws.iam.accessanalyzer.finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.error": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Error, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceOwnerAccount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceOwnerAccount, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.analyzedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).AnalyzedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.accessanalyzer.finding.analyzerArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamAccessanalyzerFinding).AnalyzerArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).__id, ok = v.Value.(string)
		return
	},
	"aws.sagemaker.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).Endpoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).NotebookInstances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).__id, ok = v.Value.(string)
		return
	},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Details, ok = plugin.RawToTValue[*mqlAwsSagemakerNotebookinstancedetails](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstancedetails.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstancedetails).__id, ok = v.Value.(string)
		return
	},
	"aws.sagemaker.notebookinstancedetails.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstancedetails).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstancedetails.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstancedetails).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstancedetails.directInternetAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstancedetails).DirectInternetAccess, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).__id, ok = v.Value.(string)
		return
	},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Config, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.sns.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSns).__id, ok = v.Value.(string)
		return
	},
	"aws.sns.topics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSns).Topics, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.sns.topic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).__id, ok = v.Value.(string)
		return
	},
	"aws.sns.topic.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Subscriptions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.sns.topic.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Attributes, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.sns.topic.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.sns.topic.signatureVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).SignatureVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).__id, ok = v.Value.(string)
		return
	},
	"aws.sns.subscription.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEs).__id, ok = v.Value.(string)
		return
	},
	"aws.es.domains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEs).Domains, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.es.domain.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).__id, ok = v.Value.(string)
		return
	},
	"aws.es.domain.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).EncryptionAtRestEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).NodeToNodeEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).ElasticsearchVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearch).__id, ok = v.Value.(string)
		return
	},
	"aws.opensearch.domains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearch).Domains, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).__id, ok = v.Value.(string)
		return
	},
	"aws.opensearch.domain.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.domainId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).DomainId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.encryptionAtRestEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EncryptionAtRestEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.encryptionAtRestKmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EncryptionAtRestKmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).NodeToNodeEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.dedicatedMasterEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).DedicatedMasterEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.dedicatedMasterType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).DedicatedMasterType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.dedicatedMasterCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).DedicatedMasterCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.instanceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).InstanceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.instanceCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).InstanceCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.zoneAwarenessEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).ZoneAwarenessEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.availabilityZoneCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).AvailabilityZoneCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.warmEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).WarmEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.warmType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).WarmType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.warmCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).WarmCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.coldStorageEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).ColdStorageEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ebsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EbsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ebsVolumeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EbsVolumeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ebsVolumeSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EbsVolumeSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ebsIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EbsIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ebsThroughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EbsThroughput, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.enforceHTTPS": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).EnforceHTTPS, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.tlsSecurityPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).TlsSecurityPolicy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.samlEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).SamlEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.anonymousAuthEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).AnonymousAuthEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.internalUserDatabaseEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).InternalUserDatabaseEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.advancedSecurityEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).AdvancedSecurityEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.processing": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Processing, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.upgradeProcessing": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).UpgradeProcessing, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.autoTuneState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).AutoTuneState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.auditLogEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).AuditLogEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.ipAddressType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).IpAddressType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.serviceSoftwareNewVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).ServiceSoftwareNewVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.opensearch.domain.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOpensearchDomain).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.acm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcm).__id, ok = v.Value.(string)
		return
	},
	"aws.acm.certificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcm).Certificates, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).__id, ok = v.Value.(string)
		return
	},
	"aws.acm.certificate.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotBefore, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotAfter, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.subject": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Subject, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Certificate, ok = plugin.RawToTValue[plugin.Resource](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.keyAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).KeyAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.serial": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Serial, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Source, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.issuer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Issuer, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.issuedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).IssuedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.importedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).ImportedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.autoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscaling).__id, ok = v.Value.(string)
		return
	},
	"aws.autoscaling.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscaling).Groups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).__id, ok = v.Value.(string)
		return
	},
	"aws.autoscaling.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LoadBalancerNames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tagSpecifications": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).TagSpecifications, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.minSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MinSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.maxSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MaxSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.defaultCooldown": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DefaultCooldown, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.launchConfigurationName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LaunchConfigurationName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckGracePeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckGracePeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.maxInstanceLifetime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).MaxInstanceLifetime, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.desiredCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DesiredCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).AvailabilityZones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.capacityRebalance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).CapacityRebalance, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.defaultInstanceWarmup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DefaultInstanceWarmup, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Instances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.desiredCapacityType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).DesiredCapacityType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.warmPoolSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).WarmPoolSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.predictedCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).PredictedCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.placementGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).PlacementGroup, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.newInstancesProtectedFromScaleIn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).NewInstancesProtectedFromScaleIn, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.targetGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).TargetGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tag.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).__id, ok = v.Value.(string)
		return
	},
	"aws.autoscaling.group.tag.key": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).Key, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tag.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tag.propagateAtLaunch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).PropagateAtLaunch, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tag.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tag.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroupTag).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).__id, ok = v.Value.(string)
		return
	},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).ClassicLoadBalancers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).LoadBalancers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).__id, ok = v.Value.(string)
		return
	},
	"aws.elb.targetgroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.protocolVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).ProtocolVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.ipAddressType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).IpAddressType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckIntervalSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckIntervalSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckPort, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckProtocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckProtocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.healthCheckTimeoutSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).HealthCheckTimeoutSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.targetType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).TargetType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.unhealthyThresholdCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).UnhealthyThresholdCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.ec2Targets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).Ec2Targets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.targetgroup.lambdaTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbTargetgroup).LambdaTargets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).__id, ok = v.Value.(string)
		return
	},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).DnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ListenerDescriptions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Attributes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).AvailabilityZones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.hostedZoneId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).HostedZoneId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.elbType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ElbType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.targetGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).TargetGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codebuild.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuild).__id, ok = v.Value.(string)
		return
	},
	"aws.codebuild.projects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuild).Projects, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).__id, ok = v.Value.(string)
		return
	},
	"aws.codebuild.project.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Environment, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Source, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).__id, ok = v.Value.(string)
		return
	},
	"aws.guardduty.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Findings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.detectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Detectors, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).__id, ok = v.Value.(string)
		return
	},
	"aws.guardduty.detector.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.features": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Features, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).FindingPublishingFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Findings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).__id, ok = v.Value.(string)
		return
	},
	"aws.guardduty.finding.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Severity, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.confidence": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Confidence, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.guardduty.finding.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyFinding).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacie).__id, ok = v.Value.(string)
		return
	},
	"aws.macie.sessions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacie).Sessions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJobs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacie).ClassificationJobs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.findings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacie).Findings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifiers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacie).CustomDataIdentifiers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.session.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).__id, ok = v.Value.(string)
		return
	},
	"aws.macie.session.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.session.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.session.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.session.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.session.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.session.findingPublishingFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).FindingPublishingFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.session.serviceRole": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).ServiceRole, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.session.s3BucketCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieSession).S3BucketCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).__id, ok = v.Value.(string)
		return
	},
	"aws.macie.classificationJob.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.jobId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).JobId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.jobType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).JobType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.lastRunTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).LastRunTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.samplingPercentage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).SamplingPercentage, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.bucketDefinitions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).BucketDefinitions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.scheduleFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).ScheduleFrequency, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.statistics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Statistics, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.macie.classificationJob.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieClassificationJob).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.macie.finding.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).__id, ok = v.Value.(string)
		return
	},
	"aws.macie.finding.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.accountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).AccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.severity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Severity, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.macie.finding.category": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Category, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.archived": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Archived, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.macie.finding.count": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Count, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.macie.finding.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.finding.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.finding.title": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Title, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.finding.classificationDetails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).ClassificationDetails, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.macie.finding.resourcesAffected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieFinding).ResourcesAffected, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).__id, ok = v.Value.(string)
		return
	},
	"aws.macie.customDataIdentifier.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.regex": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Regex, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.keywords": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Keywords, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.macie.customDataIdentifier.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsMacieCustomDataIdentifier).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.securityhub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhub).__id, ok = v.Value.(string)
		return
	},
	"aws.securityhub.hubs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhub).Hubs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).__id, ok = v.Value.(string)
		return
	},
	"aws.securityhub.hub.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).SubscribedAt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanager).__id, ok = v.Value.(string)
		return
	},
	"aws.secretsmanager.secrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanager).Secrets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).__id, ok = v.Value.(string)
		return
	},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastAccessedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastAccessedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastChangedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastRotatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).NextRotationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.owningService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).OwningService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).PrimaryRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationLambda": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationLambda, ok = plugin.RawToTValue[*mqlAwsLambdaFunction](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationRules, ok = plugin.RawToTValue[*mqlAwsSecretsmanagerSecretRotationRules](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationRules.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecretRotationRules).__id, ok = v.Value.(string)
		return
	},
	"aws.secretsmanager.secret.rotationRules.automaticallyAfterDays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecretRotationRules).AutomaticallyAfterDays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationRules.duration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecretRotationRules).Duration, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationRules.scheduleExpression": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecretRotationRules).ScheduleExpression, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Containers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).ContainerInstances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinitions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).TaskDefinitions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RunningTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).PendingTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RegisteredContainerInstancesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Configuration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tasks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).ContainerInstances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.services": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Services, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.activeServicesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).ActiveServicesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.fargateEphemeralStorageKmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).FargateEphemeralStorageKmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).AgentConnected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).CapacityProvider, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Ec2Instance, ok = plugin.RawToTValue[*mqlAwsEc2Instance](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.task.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Connectivity, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.task.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Containers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.container.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskDefinitionArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).LogDriver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Command, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).RuntimeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.containerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ContainerName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.cpuUnits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).CpuUnits, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.memorySoftLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).MemorySoftLimit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.memoryHardLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).MemoryHardLimit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.reason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Reason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.family": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Family, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.revision": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Revision, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.networkMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).NetworkMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.pidMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).PidMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.ipcMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).IpcMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.taskRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).TaskRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.executionRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).ExecutionRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinitions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).ContainerDefinitions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volumes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Volumes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.ephemeralStorage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).EphemeralStorage, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionEphemeralStorage](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinition).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.service.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.clusterArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).ClusterArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.desiredCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).DesiredCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.service.runningCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).RunningCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.service.taskDefinition": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).TaskDefinition, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.launchType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).LaunchType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).DeploymentConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsServiceDeploymentConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.service.networkConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).NetworkConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsServiceNetworkConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.service.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ecs.service.createdBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).CreatedBy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.taskSets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsService).TaskSets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskSet.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.clusterArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).ClusterArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.serviceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).ServiceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.taskDefinition": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).TaskDefinition, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.launchType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).LaunchType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.networkConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).NetworkConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsTaskSetNetworkConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.runningCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).RunningCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.pendingCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).PendingCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.computedDesiredCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).ComputedDesiredCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.stabilityStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).StabilityStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.externalId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).ExternalId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.startedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSet).StartedBy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.networkConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSetNetworkConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskSet.networkConfiguration.assignPublicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSetNetworkConfiguration).AssignPublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.networkConfiguration.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSetNetworkConfiguration).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskSet.networkConfiguration.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskSetNetworkConfiguration).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.service.deploymentConfiguration.maximumPercent": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).MaximumPercent, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.minimumHealthyPercent": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).MinimumHealthyPercent, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).DeploymentCircuitBreaker, ok = plugin.RawToTValue[*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).Alarms, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.bakeTimeInMinutes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).BakeTimeInMinutes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.canaryConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).CanaryConfiguration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.lifecycleHooks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).LifecycleHooks, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.linearConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).LinearConfiguration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.strategy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfiguration).Strategy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker.enable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker).Enable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker.rollback": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker).Rollback, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.service.networkConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfiguration).AwsVpcConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.service.networkConfiguration.awsVpcConfiguration.assignPublicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration).AssignPublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.privileged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Privileged, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.readonlyRootFilesystem": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).ReadonlyRootFilesystem, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).User, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Environment, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.secrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Secrets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).LogConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.memory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Memory, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.cpu": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).Cpu, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.portMappings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinition).PortMappings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.environmentVariable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.environmentVariable.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.environmentVariable.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.secret.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionSecret).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.secret.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionSecret).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.secret.valueFrom": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionSecret).ValueFrom, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration.logDriver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration).LogDriver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.logConfiguration.options": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration).Options, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.containerPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).ContainerPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.hostPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).HostPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.containerDefinition.portMapping.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolume).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.volume.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolume).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolume).EfsVolumeConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.host": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolume).Host, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionVolumeHost](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolume).DockerVolumeConfiguration, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.fileSystemId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).FileSystemId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.rootDirectory": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).RootDirectory, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.transitEncryption": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).TransitEncryption, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.transitEncryptionPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).TransitEncryptionPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration).AuthorizationConfig, ok = plugin.RawToTValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig.accessPointId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig).AccessPointId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig.iam": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig).Iam, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.host.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeHost).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.volume.host.sourcePath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeHost).SourcePath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.autoprovision": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).Autoprovision, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.driver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).Driver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.driverOpts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).DriverOpts, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.volume.dockerVolumeConfiguration.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration).Labels, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ecs.taskDefinition.ephemeralStorage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionEphemeralStorage).__id, ok = v.Value.(string)
		return
	},
	"aws.ecs.taskDefinition.ephemeralStorage.sizeInGiB": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTaskDefinitionEphemeralStorage).SizeInGiB, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.emr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmr).__id, ok = v.Value.(string)
		return
	},
	"aws.emr.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmr).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.emr.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).NormalizedInstanceHours, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).OutpostArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Status, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).MasterInstances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.logGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).LogGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Alarms, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Metrics, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricNamespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Actions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).StateReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).InsufficientDataActions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).OkActions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.metric.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Alarms, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Dimensions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Statistics, ok = plugin.RawToTValue[*mqlAwsCloudwatchMetricstatistics](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Datapoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Timestamp, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Maximum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Minimum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Average, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Sum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Unit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).MetricsFilters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.retentionInDays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).RetentionInDays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Metrics, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudfront.distributions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Distributions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Functions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Origins, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DefaultCacheBehavior, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).CacheBehaviors, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).HttpVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).IsIPV6Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).PriceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.cnames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Cnames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.viewerProtocolPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).ViewerProtocolPolicy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.minimumProtocolVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).MinimumProtocolVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.webAclId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).WebAclId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.geoRestrictionType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).GeoRestrictionType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.lastModifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).LastModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionAttempts, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionTimeout, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).OriginPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Account, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudfront.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).LastModifiedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Stage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrail).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudtrail.trails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrail).Trails, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).__id, ok = v.Value.(string)
		return
	},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsMultiRegionTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsOrganizationTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogFileValidationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IncludeGlobalServiceEvents, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).S3bucket, ok = plugin.RawToTValue[*mqlAwsS3Bucket](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).SnsTopicARN, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Status, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogGroup, ok = plugin.RawToTValue[*mqlAwsCloudwatchLoggroup](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).CloudWatchLogsRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.cloudWatchLogsLogGroupArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).CloudWatchLogsLogGroupArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).EventSelectors, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.hasInsightSelectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).HasInsightSelectors, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.hasCustomEventSelectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).HasCustomEventSelectors, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3control.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3control).__id, ok = v.Value.(string)
		return
	},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3control).AccountPublicAccessBlock, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.s3.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.buckets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3).Buckets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Policy, ok = plugin.RawToTValue[*mqlAwsS3BucketPolicy](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.acl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Acl, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Owner, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.cors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Cors, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Versioning, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Logging, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).StaticWebsiteHosting, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.website": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Website, ok = plugin.RawToTValue[*mqlAwsS3BucketWebsiteConfiguration](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).DefaultLock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.replication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Replication, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Encryption, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).PublicAccessBlock, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.objectLockEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).ObjectLockEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.grant.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Permission, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Grantee, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedMethods, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedOrigins, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).ExposeHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).MaxAgeSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.bucketName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).BucketName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Document, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Statements, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.websiteConfiguration.indexDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfiguration).IndexDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.errorDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfiguration).ErrorDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsTo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfiguration).RedirectAllRequestsTo, ok = plugin.RawToTValue[*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfiguration).RoutingRules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf.hostname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf).Hostname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRule).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirect": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRule).Redirect, ok = plugin.RawToTValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.condition": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRule).Condition, ok = plugin.RawToTValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.hostname": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).Hostname, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.httpRedirectCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).HttpRedirectCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.replaceKeyPrefixWith": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).ReplaceKeyPrefixWith, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.redirectConf.replaceKeyWith": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf).ReplaceKeyWith, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf).__id, ok = v.Value.(string)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf.httpErrorCodeReturnedEquals": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf).HttpErrorCodeReturnedEquals, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.websiteConfiguration.routingRule.conditionConf.keyPrefixEquals": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf).KeyPrefixEquals, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).__id, ok = v.Value.(string)
		return
	},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).ScalableTargets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).__id, ok = v.Value.(string)
		return
	},
	"aws.applicationAutoscaling.target.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.scalableDimension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).ScalableDimension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.minCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).MinCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.maxCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).MaxCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.suspendedState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).SuspendedState, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).Policies, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.target.scheduledActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingTarget).ScheduledActions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).__id, ok = v.Value.(string)
		return
	},
	"aws.applicationAutoscaling.policy.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.policyType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).PolicyType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.scalableDimension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).ScalableDimension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).Alarms, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.targetTrackingConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).TargetTrackingConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.stepScalingConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).StepScalingConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.policy.predictiveScalingConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingPolicy).PredictiveScalingConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).__id, ok = v.Value.(string)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.schedule": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).Schedule, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.timezone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).Timezone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.scalableDimension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).ScalableDimension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.startAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).StartAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.endAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).EndAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scheduledAction.scalableTargetAction": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscalingScheduledAction).ScalableTargetAction, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrs).__id, ok = v.Value.(string)
		return
	},
	"aws.drs.sourceServers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrs).SourceServers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.drs.jobs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrs).Jobs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).__id, ok = v.Value.(string)
		return
	},
	"aws.drs.sourceServer.sourceServerID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).SourceServerID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.dataReplicationInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).DataReplicationInfo, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.lastLaunchResult": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).LastLaunchResult, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.lifeCycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).LifeCycle, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.sourceProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).SourceProperties, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.stagingArea": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).StagingArea, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.replicationDirection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).ReplicationDirection, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.recoveryInstanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).RecoveryInstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.replicationConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).ReplicationConfiguration, ok = plugin.RawToTValue[*mqlAwsDrsReplicationConfiguration](v.Value, v.Error)
		return
	},
	"aws.drs.sourceServer.launchConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsSourceServer).LaunchConfiguration, ok = plugin.RawToTValue[*mqlAwsDrsLaunchConfiguration](v.Value, v.Error)
		return
	},
	"aws.drs.job.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).__id, ok = v.Value.(string)
		return
	},
	"aws.drs.job.jobID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).JobID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.job.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.job.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.job.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.job.initiatedBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).InitiatedBy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.job.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.drs.job.endedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).EndedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.drs.job.participatingServers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsJob).ParticipatingServers, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.drs.replicationConfiguration.sourceServerID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).SourceServerID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.stagingAreaSubnetId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).StagingAreaSubnetId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.stagingAreaTags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).StagingAreaTags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.useDedicatedReplicationServer": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).UseDedicatedReplicationServer, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.replicationServerInstanceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).ReplicationServerInstanceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.ebsEncryption": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).EbsEncryption, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.ebsEncryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).EbsEncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.replicatedDisks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).ReplicatedDisks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.drs.replicationConfiguration.bandwidthThrottling": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsReplicationConfiguration).BandwidthThrottling, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).__id, ok = v.Value.(string)
		return
	},
	"aws.drs.launchConfiguration.sourceServerID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).SourceServerID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.targetInstanceTypeRightSizingMethod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).TargetInstanceTypeRightSizingMethod, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.launchDisposition": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).LaunchDisposition, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.copyPrivateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).CopyPrivateIp, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.copyTags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).CopyTags, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.ec2LaunchTemplateID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).Ec2LaunchTemplateID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.licensing": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).Licensing, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.postLaunchEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).PostLaunchEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.drs.launchConfiguration.launchIntoInstanceProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDrsLaunchConfiguration).LaunchIntoInstanceProperties, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.backup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackup).__id, ok = v.Value.(string)
		return
	},
	"aws.backup.vaults": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackup).Vaults, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.backup.vault.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).__id, ok = v.Value.(string)
		return
	},
	"aws.backup.vault.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).RecoveryPoints, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.backup.vault.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vault.locked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Locked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.backup.vault.lockedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).LockedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.maxRetentionDays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).MaxRetentionDays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.backup.vault.minRetentionDays": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).MinRetentionDays, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).__id, ok = v.Value.(string)
		return
	},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreatedBy, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IamRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CompletionDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IsEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.dynamodb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).__id, ok = v.Value.(string)
		return
	},
	"aws.dynamodb.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Backups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).GlobalTables, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Tables, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Limits, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.exports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Exports, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).__id, ok = v.Value.(string)
		return
	},
	"aws.dynamodb.export.table": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Table, ok = plugin.RawToTValue[*mqlAwsDynamodbTable](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3Bucket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3Bucket, ok = plugin.RawToTValue[*mqlAwsS3Bucket](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3Prefix": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3Prefix, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.itemCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).ItemCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.format": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Format, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.endTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).EndTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.s3SseAlgorithm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).S3SseAlgorithm, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.dynamodb.export.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbExport).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).__id, ok = v.Value.(string)
		return
	},
	"aws.dynamodb.limit.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).__id, ok = v.Value.(string)
		return
	},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).ReplicaSettings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).__id, ok = v.Value.(string)
		return
	},
	"aws.dynamodb.table.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Backups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).SseDescription, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ProvisionedThroughput, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ContinuousBackups, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.deletionProtectionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).DeletionProtectionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.globalTableVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).GlobalTableVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.items": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Items, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.sizeBytes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).SizeBytes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.latestStreamArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).LatestStreamArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqs).__id, ok = v.Value.(string)
		return
	},
	"aws.sqs.queues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqs).Queues, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).__id, ok = v.Value.(string)
		return
	},
	"aws.sqs.queue.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.deadLetterQueue": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).DeadLetterQueue, ok = plugin.RawToTValue[*mqlAwsSqsQueue](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.deliveryDelaySeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).DeliveryDelaySeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.lastModified": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).LastModified, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.maxReceiveCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MaxReceiveCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.maximumMessageSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MaximumMessageSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.messageRetentionPeriodSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).MessageRetentionPeriodSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.receiveMessageWaitTimeSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).ReceiveMessageWaitTimeSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.sqsManagedSseEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).SqsManagedSseEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.queueType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).QueueType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.url": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).Url, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sqs.queue.visibilityTimeoutSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSqsQueue).VisibilityTimeoutSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).Instances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.allPendingMaintenanceActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).AllPendingMaintenanceActions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).ParameterGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).ClusterParameterGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.backupsetting.target": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Target, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.retentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).RetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.dedicatedLogVolume": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).DedicatedLogVolume, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.timezone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).Timezone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.earliestRestoreAvailable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).EarliestRestoreAvailable, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.backupsetting.latestRestoreAvailable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsBackupsetting).LatestRestoreAvailable, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.dbcluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Members, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Snapshots, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageAllocated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageAllocated, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.clusterDbInstanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ClusterDbInstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).AvailabilityZones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.hostedZoneId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).HostedZoneId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.backupSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).BackupSettings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.engineLifecycleSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).EngineLifecycleSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.certificateExpiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CertificateExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.certificateAuthority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).CertificateAuthority, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.iamDatabaseAuthentication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).IamDatabaseAuthentication, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.activityStreamMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ActivityStreamMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.activityStreamStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ActivityStreamStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.httpEndpointEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).HttpEndpointEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.parameterGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).ParameterGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.globalClusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).GlobalClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.databaseInsightsMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).DatabaseInsightsMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.performanceInsightsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).PerformanceInsightsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Attributes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).IsClusterSnapshot, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.allocatedStorage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).AllocatedStorage, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.dbinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Snapshots, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageAllocated, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnhancedMonitoringResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.backupSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).BackupSettings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Subnets, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engineLifecycleSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EngineLifecycleSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.certificateExpiresAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CertificateExpiresAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.certificateAuthority": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CertificateAuthority, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.iamDatabaseAuthentication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).IamDatabaseAuthentication, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.customIamInstanceProfile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CustomIamInstanceProfile, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.activityStreamMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).ActivityStreamMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.activityStreamStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).ActivityStreamStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.pendingMaintenanceActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PendingMaintenanceActions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.performanceInsightsEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PerformanceInsightsEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.copyTagsToSnapshot": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CopyTagsToSnapshot, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.performanceInsightsKmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PerformanceInsightsKmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.pendingMaintenanceAction.resourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).ResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.action": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).Action, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.autoAppliedAfterDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).AutoAppliedAfterDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.currentApplyDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).CurrentApplyDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.forcedApplyDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).ForcedApplyDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.rds.pendingMaintenanceAction.optInStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsPendingMaintenanceAction).OptInStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.clusterParameterGroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.family": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Family, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.clusterParameterGroup.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsClusterParameterGroup).Parameters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.parameterGroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.family": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Family, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroup).Parameters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).__id, ok = v.Value.(string)
		return
	},
	"aws.rds.parameterGroup.parameter.allowedValues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).AllowedValues, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.applyMethod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).ApplyMethod, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.applyType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).ApplyType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.dataType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).DataType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.isModifiable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).IsModifiable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.minimumEngineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).MinimumEngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).Source, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.parameterGroup.parameter.supportedEngineModes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsParameterGroupParameter).SupportedEngineModes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).__id, ok = v.Value.(string)
		return
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).CacheClusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCaches": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).ServerlessCaches, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.elasticache.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AtRestEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenLastModifiedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterCreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).ClientDownloadLandingPage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).IpDiscovery, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).LogDeliveryConfigurations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NotificationConfiguration, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NumCacheNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).PreferredAvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SnapshotRetentionLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.snapshotWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SnapshotWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).__id, ok = v.Value.(string)
		return
	},
	"aws.elasticache.serverlessCache.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.majorEngineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).MajorEngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.snapshotRetentionLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).SnapshotRetentionLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.dailySnapshotTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).DailySnapshotTime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.serverlessCache.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheServerlessCache).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshift).__id, ok = v.Value.(string)
		return
	},
	"aws.redshift.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshift).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AllowVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AutomatedSnapshotRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterParameterGroupNames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterRevisionNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).DbName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).EnhancedVpcRouting, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Logging, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NextMaintenanceWindowStartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NumberOfNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Parameters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).__id, ok = v.Value.(string)
		return
	},
	"aws.ecr.privateRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PrivateRepositories, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PublicRepositories, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecr.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).Images, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).__id, ok = v.Value.(string)
		return
	},
	"aws.ecr.repository.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Images, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).ImageScanOnPush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.imageTagMutability": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).ImageTagMutability, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.encryptionType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).EncryptionType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.scanningFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).ScanningFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).__id, ok = v.Value.(string)
		return
	},
	"aws.ecr.image.digest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Digest, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).MediaType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Tags, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ecr.image.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.pushedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).PushedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ecr.image.sizeInBytes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).SizeInBytes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecr.image.lastRecordedPullTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).LastRecordedPullTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.dms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDms).__id, ok = v.Value.(string)
		return
	},
	"aws.dms.replicationInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDms).ReplicationInstances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigateway).__id, ok = v.Value.(string)
		return
	},
	"aws.apigateway.restApis": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigateway).RestApis, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).__id, ok = v.Value.(string)
		return
	},
	"aws.apigateway.restapi.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).CreatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Stages, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.apiKeySource": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).ApiKeySource, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.disableExecuteApiEndpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).DisableExecuteApiEndpoint, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.minimumCompressionSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).MinimumCompressionSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.binaryMediaTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).BinaryMediaTypes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.securityPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).SecurityPolicy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Policy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).__id, ok = v.Value.(string)
		return
	},
	"aws.apigateway.stage.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).TracingEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).DeploymentId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).MethodSettings, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.cacheClusterEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).CacheClusterEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.cacheClusterSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).CacheClusterSize, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.cacheClusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).CacheClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.clientCertificateId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).ClientCertificateId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.webAclArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).WebAclArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.lastUpdatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).LastUpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.documentationVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).DocumentationVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.variables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Variables, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.lambda.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambda).__id, ok = v.Value.(string)
		return
	},
	"aws.lambda.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambda).Functions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).__id, ok = v.Value.(string)
		return
	},
	"aws.lambda.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Concurrency, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).DlqTargetArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Policy, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).VpcConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.architectures": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Architectures, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.ephemeralStorageSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).EphemeralStorageSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.memorySize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).MemorySize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.role": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Role, ok = plugin.RawToTValue[*mqlAwsIamRole](v.Value, v.Error)
		return
	},
	"aws.lambda.function.timeout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Timeout, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.handler": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Handler, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.tracingMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).TracingMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.packageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).PackageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.codeSha256": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).CodeSha256, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.lastModifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).LastModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).UrlConfig, ok = plugin.RawToTValue[*mqlAwsLambdaFunctionUrlConfig](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).__id, ok = v.Value.(string)
		return
	},
	"aws.lambda.function.urlConfig.functionUrl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).FunctionUrl, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.authType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).AuthType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsAllowOrigins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsAllowOrigins, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsAllowMethods": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsAllowMethods, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsAllowHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsAllowHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsAllowCredentials": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsAllowCredentials, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsExposeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsExposeHeaders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.corsMaxAge": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CorsMaxAge, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.lambda.function.urlConfig.lastModifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunctionUrlConfig).LastModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ssm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).__id, ok = v.Value.(string)
		return
	},
	"aws.ssm.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).Instances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ssm.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).Parameters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).__id, ok = v.Value.(string)
		return
	},
	"aws.ssm.parameter.allowedPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).AllowedPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.dataType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).DataType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.lastModifiedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).LastModifiedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.tier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Tier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.parameter.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmParameter).Version, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).__id, ok = v.Value.(string)
		return
	},
	"aws.ssm.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PingStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).IpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Instances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).EbsEncryptionByDefault, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.volumes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Volumes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Snapshots, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.internetGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).InternetGateways, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).VpnConnections, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkAcls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).NetworkAcls, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.keypairs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Keypairs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.eips": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Eips, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Images, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.eip.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.attached": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Attached, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Instance, ok = plugin.RawToTValue[*mqlAwsEc2Instance](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.networkInterfaceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).NetworkInterfaceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.networkInterfaceOwnerId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).NetworkInterfaceOwnerId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.privateIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PrivateIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.publicIpv4Pool": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).PublicIpv4Pool, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.eip.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Eip).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.natgateway.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.natGatewayId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).NatGatewayId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.addresses": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Addresses, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgateway).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.natgateway.address.allocationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).AllocationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.networkInterfaceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).NetworkInterfaceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.privateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).PrivateIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).PublicIp, ok = plugin.RawToTValue[*mqlAwsEc2Eip](v.Value, v.Error)
		return
	},
	"aws.vpc.natgateway.address.isPrimary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcNatgatewayAddress).IsPrimary, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.serviceEndpoint.acceptanceRequired": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).AcceptanceRequired, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).AvailabilityZones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.dnsNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).DnsNames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.managesVpcEndpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).ManagesVpcEndpoints, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Owner, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.payerResponsibility": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PayerResponsibility, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.privateDnsNameVerificationState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PrivateDnsNameVerificationState, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.privateDnsNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).PrivateDnsNames, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.serviceEndpoint.vpcEndpointPolicySupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcServiceEndpoint).VpcEndpointPolicySupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.peeringConnection.acceptorVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).AcceptorVpc, ok = plugin.RawToTValue[*mqlAwsVpcPeeringConnectionPeeringVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.expirationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).ExpirationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.requestorVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).RequestorVpc, ok = plugin.RawToTValue[*mqlAwsVpcPeeringConnectionPeeringVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnection).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).__id, ok = v.Value.(string)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.allowDnsResolutionFromRemoteVpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).AllowDnsResolutionFromRemoteVpc, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv4CiderBlocks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Ipv4CiderBlocks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ipv6CiderBlocks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Ipv6CiderBlocks, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.ownerID": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).OwnerID, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.vpc.peeringConnection.peeringVpc.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcPeeringConnectionPeeringVpc).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.networkacl.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Entries, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.associations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Associations, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.networkacl.association.associationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).AssociationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.networkAclId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).NetworkAclId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.association.subnetId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclAssociation).SubnetId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Egress, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).RuleAction, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ruleNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).RuleNumber, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).PortRange, ok = plugin.RawToTValue[*mqlAwsEc2NetworkaclEntryPortrange](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.cidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ipv6CidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Ipv6CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).From, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).To, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).VgwTelemetry, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).OutsideIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).StatusMessage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Attachments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).CreateVolumePermission, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.completionTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).CompletionTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.volumeSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).VolumeSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.storageTier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).StorageTier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.volume.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Attachments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).VolumeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).CreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.multiAttachEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).MultiAttachEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.throughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Throughput, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.size": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Size, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.iops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Iops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.inspector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspector).__id, ok = v.Value.(string)
		return
	},
	"aws.inspector.coverages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspector).Coverages, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).__id, ok = v.Value.(string)
		return
	},
	"aws.inspector.coverage.accountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).AccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.resourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.lastScannedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).LastScannedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.statusReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).StatusReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.statusCode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).StatusCode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.scanType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).ScanType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ec2Instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Ec2Instance, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageInstance](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ecrImage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).EcrImage, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageImage](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.ecrRepo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).EcrRepo, ok = plugin.RawToTValue[*mqlAwsInspectorCoverageRepository](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.lambda": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverage).Lambda, ok = plugin.RawToTValue[*mqlAwsLambdaFunction](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).__id, ok = v.Value.(string)
		return
	},
	"aws.inspector.coverage.instance.platform": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Platform, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Image, ok = plugin.RawToTValue[*mqlAwsEc2Image](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).__id, ok = v.Value.(string)
		return
	},
	"aws.inspector.coverage.image.imagePulledAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).ImagePulledAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageImage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).__id, ok = v.Value.(string)
		return
	},
	"aws.inspector.coverage.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.scanFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).ScanFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.inspector.coverage.repository.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsInspectorCoverageRepository).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DetailedMonitoring, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Ssm, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpTokens, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpEndpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpPutResponseHopLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpPutResponseHopLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.enclaveEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EnclaveEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PatchState, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DeviceMappings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PlatformDetails, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceStatus, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateReason, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EbsOptimized, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.enaSupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EnaSupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.iamInstanceProfile": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).IamInstanceProfile, ok = plugin.RawToTValue[*mqlAwsIamInstanceProfile](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Image, ok = plugin.RawToTValue[*mqlAwsEc2Image](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).LaunchTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Keypair, ok = plugin.RawToTValue[*mqlAwsEc2Keypair](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).VpcArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.hypervisor": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Hypervisor, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceLifecycle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceLifecycle, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.rootDeviceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).RootDeviceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.rootDeviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).RootDeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.architecture": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Architecture, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.tpmSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).TpmSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.networkInterfaces": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).NetworkInterfaces, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.disableApiTermination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DisableApiTermination, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.networkinterface.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.subnet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Subnet, ok = plugin.RawToTValue[*mqlAwsVpcSubnet](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.sourceDestCheck": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).SourceDestCheck, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.requesterManaged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).RequesterManaged, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).SecurityGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.ipv6Native": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).Ipv6Native, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.macAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).MacAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.privateDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).PrivateDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkinterface.privateIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkinterface).PrivateIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.keypair.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.architecture": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Architecture, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerAlias, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.image.deprecatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).DeprecatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.image.enaSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).EnaSupport, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.image.tpmSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).TpmSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.imdsSupport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).ImdsSupport, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.image.rootDeviceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).RootDeviceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.virtualizationType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).VirtualizationType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.blockDeviceMappings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).BlockDeviceMappings, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.launchPermissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).LaunchPermissions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.image.launchPermission.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageLaunchPermission).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.image.launchPermission.userId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageLaunchPermission).UserId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.launchPermission.group": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageLaunchPermission).Group, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.launchPermission.organizationArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageLaunchPermission).OrganizationArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.launchPermission.organizationalUnitArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageLaunchPermission).OrganizationalUnitArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.blockDeviceMapping.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageBlockDeviceMapping).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.image.blockDeviceMapping.deviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageBlockDeviceMapping).DeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.blockDeviceMapping.virtualName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageBlockDeviceMapping).VirtualName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.blockDeviceMapping.noDevice": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageBlockDeviceMapping).NoDevice, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.image.blockDeviceMapping.ebs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageBlockDeviceMapping).Ebs, ok = plugin.RawToTValue[*mqlAwsEc2ImageEbsBlockDevice](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.image.ebsBlockDevice.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.snapshotId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).SnapshotId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.volumeSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).VolumeSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.volumeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).VolumeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.iops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).Iops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.throughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).Throughput, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ebsBlockDevice.deleteOnTermination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2ImageEbsBlockDevice).DeleteOnTermination, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeleteOnTermination, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissions, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissionsEgress, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IsAttachedToNetworkInterface, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).__id, ok = v.Value.(string)
		return
	},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).FromPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).ToPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpProtocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpRanges, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Ipv6Ranges, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.prefixListIds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).PrefixListIds, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.userIdGroupPairs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).UserIdGroupPairs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.config.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).__id, ok = v.Value.(string)
		return
	},
	"aws.config.recorders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Recorders, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.config.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Rules, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.config.deliveryChannels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).DeliveryChannels, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.config.rule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).__id, ok = v.Value.(string)
		return
	},
	"aws.config.rule.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Source, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.config.rule.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).__id, ok = v.Value.(string)
		return
	},
	"aws.config.recorder.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).RoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).AllSupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).IncludeGlobalResourceTypes, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.recording": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Recording, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.resourceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).ResourceTypes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).__id, ok = v.Value.(string)
		return
	},
	"aws.config.deliverychannel.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.s3BucketName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).S3BucketName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.s3KeyPrefix": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).S3KeyPrefix, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.snsTopicARN": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).SnsTopicARN, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.deliverychannel.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigDeliverychannel).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEks).__id, ok = v.Value.(string)
		return
	},
	"aws.eks.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEks).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).__id, ok = v.Value.(string)
		return
	},
	"aws.eks.nodegroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.modifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).ModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.capacityType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).CapacityType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.scalingConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).ScalingConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.instanceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).InstanceTypes, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.amiType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).AmiType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.nodeRole": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).NodeRole, ok = plugin.RawToTValue[*mqlAwsIamRole](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.diskSize": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).DiskSize, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.labels": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Labels, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.eks.nodegroup.autoscalingGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksNodegroup).AutoscalingGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.addon.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).__id, ok = v.Value.(string)
		return
	},
	"aws.eks.addon.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.addonVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).AddonVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.addon.modifiedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).ModifiedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.addon.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.eks.addon.publisher": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Publisher, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).Owner, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.addon.configurationValues": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksAddon).ConfigurationValues, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.eks.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).EncryptionConfig, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Logging, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).NetworkConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).ResourcesVpcConfig, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.nodeGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).NodeGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.addons": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Addons, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.iamRole": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).IamRole, ok = plugin.RawToTValue[*mqlAwsIamRole](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.supportType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).SupportType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.authenticationMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).AuthenticationMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.endpointPublicAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).EndpointPublicAccess, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.endpointPrivateAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).EndpointPrivateAccess, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.publicAccessCidrs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).PublicAccessCidrs, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptune).__id, ok = v.Value.(string)
		return
	},
	"aws.neptune.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptune).Clusters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptune).Instances, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).__id, ok = v.Value.(string)
		return
	},
	"aws.neptune.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.globalClusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).GlobalClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.automaticRestartTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).AutomaticRestartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.availabilityZones": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).AvailabilityZones, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.crossAccountClone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).CrossAccountClone, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterParameterGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterParameterGroup, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.subnetGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).SubnetGroup, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.clusterResourceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).ClusterResourceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.earliestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EarliestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.iamDatabaseAuthenticationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).IamDatabaseAuthenticationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.cluster.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneCluster).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).__id, ok = v.Value.(string)
		return
	},
	"aws.neptune.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.clusterIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).ClusterIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.instanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).InstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.port": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Port, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Endpoint, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.enhancedMonitoringResourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).EnhancedMonitoringResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.iamDatabaseAuthenticationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).IamDatabaseAuthenticationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.latestRestorableTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).LatestRestorableTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.monitoringInterval": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MonitoringInterval, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.monitoringRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MonitoringRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.preferredBackupWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PreferredBackupWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.promotionTier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).PromotionTier, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.neptune.instance.tdeCredentialArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsNeptuneInstance).TdeCredentialArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalytics).__id, ok = v.Value.(string)
		return
	},
	"aws.timestream.liveanalytics.databases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalytics).Databases, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalytics).Tables, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).__id, ok = v.Value.(string)
		return
	},
	"aws.timestream.liveanalytics.database.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.kmsKeyId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).KmsKeyId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.database.tableCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsDatabase).TableCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).__id, ok = v.Value.(string)
		return
	},
	"aws.timestream.liveanalytics.table.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.databaseName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).DatabaseName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.updatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).UpdatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.magneticStoreWriteProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).MagneticStoreWriteProperties, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.timestream.liveanalytics.table.retentionProperties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsTimestreamLiveanalyticsTable).RetentionProperties, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeploy).__id, ok = v.Value.(string)
		return
	},
	"aws.codedeploy.applications": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeploy).Applications, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).__id, ok = v.Value.(string)
		return
	},
	"aws.codedeploy.application.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.applicationId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).ApplicationId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.applicationName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).ApplicationName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.computePlatform": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).ComputePlatform, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.linkedToGitHub": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).LinkedToGitHub, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.deploymentGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).DeploymentGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.deployments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).Deployments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.application.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployApplication).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).__id, ok = v.Value.(string)
		return
	},
	"aws.codedeploy.deploymentGroup.applicationName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).ApplicationName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.deploymentGroupId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).DeploymentGroupId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.deploymentGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).DeploymentGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.computePlatform": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).ComputePlatform, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.serviceRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).ServiceRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.targetRevision": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).TargetRevision, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).Tags, ok = plugin.RawToTValue[map[string]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.deployments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).Deployments, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.autoScalingGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).AutoScalingGroups, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.ec2TagFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).Ec2TagFilters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.onPremisesInstanceTagFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).OnPremisesInstanceTagFilters, ok = plugin.RawToTValue[[]any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.lastSuccessfulDeployment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).LastSuccessfulDeployment, ok = plugin.RawToTValue[*mqlAwsCodedeployDeployment](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.lastAttemptedDeployment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).LastAttemptedDeployment, ok = plugin.RawToTValue[*mqlAwsCodedeployDeployment](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.deploymentStyle": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).DeploymentStyle, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.blueGreenDeploymentConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).BlueGreenDeploymentConfiguration, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deploymentGroup.loadBalancerInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeploymentGroup).LoadBalancerInfo, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).__id, ok = v.Value.(string)
		return
	},
	"aws.codedeploy.deployment.applicationName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).ApplicationName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.deploymentId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).DeploymentId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.deploymentGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).DeploymentGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.deploymentConfigName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).DeploymentConfigName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.compleatedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).CompleatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.creator": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Creator, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.ignoreApplicationStopFailures": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).IgnoreApplicationStopFailures, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.targetInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).TargetInstances, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.revision": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Revision, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.errorInformation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).ErrorInformation, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.deploymentOverview": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).DeploymentOverview, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.isRollback": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).IsRollback, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.codedeploy.deployment.rollbackInfo": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodedeployDeployment).RollbackInfo, ok = plugin.RawToTValue[any](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName()+"."+field]
	if !ok {
		return errors.New("[aws] cannot set '" + field + "' in resource '" + resource.MqlName() + "', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[aws] cannot set '" + field + "' in resource '" + resource.MqlName() + "', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAws for the aws resource
type mqlAws struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsInternal it will be used here
	Vpcs    plugin.TValue[[]any]
	Regions plugin.TValue[[]any]
}

// createAws creates a new instance of this resource
func createAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAws{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAws) MqlName() string {
	return "aws"
}

func (c *mqlAws) MqlID() string {
	return c.__id
}

func (c *mqlAws) GetVpcs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Vpcs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws", c.__id, "vpcs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.vpcs()
	})
}

func (c *mqlAws) GetRegions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Regions, func() ([]any, error) {
		return c.regions()
	})
}

// mqlAwsAccount for the aws.account resource
type mqlAwsAccount struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAccountInternal it will be used here
	Id                 plugin.TValue[string]
	Aliases            plugin.TValue[[]any]
	Organization       plugin.TValue[*mqlAwsOrganization]
	Tags               plugin.TValue[map[string]any]
	ContactInformation plugin.TValue[any]
	AlternateContacts  plugin.TValue[[]any]
	SecurityContact    plugin.TValue[*mqlAwsAccountAlternateContact]
	BillingContact     plugin.TValue[*mqlAwsAccountAlternateContact]
	OperationsContact  plugin.TValue[*mqlAwsAccountAlternateContact]
}

// createAwsAccount creates a new instance of this resource
func createAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccount{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.account", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccount) MqlName() string {
	return "aws.account"
}

func (c *mqlAwsAccount) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccount) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsAccount) GetAliases() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Aliases, func() ([]any, error) {
		return c.aliases()
	})
}

func (c *mqlAwsAccount) GetOrganization() *plugin.TValue[*mqlAwsOrganization] {
	return plugin.GetOrCompute[*mqlAwsOrganization](&c.Organization, func() (*mqlAwsOrganization, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "organization")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsOrganization), nil
			}
		}

		return c.organization()
	})
}

func (c *mqlAwsAccount) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsAccount) GetContactInformation() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ContactInformation, func() (any, error) {
		return c.contactInformation()
	})
}

func (c *mqlAwsAccount) GetAlternateContacts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AlternateContacts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "alternateContacts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.alternateContacts()
	})
}

func (c *mqlAwsAccount) GetSecurityContact() *plugin.TValue[*mqlAwsAccountAlternateContact] {
	return plugin.GetOrCompute[*mqlAwsAccountAlternateContact](&c.SecurityContact, func() (*mqlAwsAccountAlternateContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "securityContact")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsAccountAlternateContact), nil
			}
		}

		return c.securityContact()
	})
}

func (c *mqlAwsAccount) GetBillingContact() *plugin.TValue[*mqlAwsAccountAlternateContact] {
	return plugin.GetOrCompute[*mqlAwsAccountAlternateContact](&c.BillingContact, func() (*mqlAwsAccountAlternateContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "billingContact")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsAccountAlternateContact), nil
			}
		}

		return c.billingContact()
	})
}

func (c *mqlAwsAccount) GetOperationsContact() *plugin.TValue[*mqlAwsAccountAlternateContact] {
	return plugin.GetOrCompute[*mqlAwsAccountAlternateContact](&c.OperationsContact, func() (*mqlAwsAccountAlternateContact, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "operationsContact")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsAccountAlternateContact), nil
			}
		}

		return c.operationsContact()
	})
}

// mqlAwsAccountAlternateContact for the aws.account.alternateContact resource
type mqlAwsAccountAlternateContact struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAccountAlternateContactInternal it will be used here
	AccountId    plugin.TValue[string]
	ContactType  plugin.TValue[string]
	EmailAddress plugin.TValue[string]
	Name         plugin.TValue[string]
	PhoneNumber  plugin.TValue[string]
	Title        plugin.TValue[string]
	Exists       plugin.TValue[bool]
}

// createAwsAccountAlternateContact creates a new instance of this resource
func createAwsAccountAlternateContact(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccountAlternateContact{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.account.alternateContact", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccountAlternateContact) MqlName() string {
	return "aws.account.alternateContact"
}

func (c *mqlAwsAccountAlternateContact) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccountAlternateContact) GetAccountId() *plugin.TValue[string] {
	return &c.AccountId
}

func (c *mqlAwsAccountAlternateContact) GetContactType() *plugin.TValue[string] {
	return &c.ContactType
}

func (c *mqlAwsAccountAlternateContact) GetEmailAddress() *plugin.TValue[string] {
	return &c.EmailAddress
}

func (c *mqlAwsAccountAlternateContact) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAccountAlternateContact) GetPhoneNumber() *plugin.TValue[string] {
	return &c.PhoneNumber
}

func (c *mqlAwsAccountAlternateContact) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlAwsAccountAlternateContact) GetExists() *plugin.TValue[bool] {
	return &c.Exists
}

// mqlAwsOrganization for the aws.organization resource
type mqlAwsOrganization struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsOrganizationInternal it will be used here
	Arn                plugin.TValue[string]
	FeatureSet         plugin.TValue[string]
	MasterAccountId    plugin.TValue[string]
	MasterAccountEmail plugin.TValue[string]
	Accounts           plugin.TValue[[]any]
	Id                 plugin.TValue[string]
}

// createAwsOrganization creates a new instance of this resource
func createAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOrganization{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.organization", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOrganization) MqlName() string {
	return "aws.organization"
}

func (c *mqlAwsOrganization) MqlID() string {
	return c.__id
}

func (c *mqlAwsOrganization) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsOrganization) GetFeatureSet() *plugin.TValue[string] {
	return &c.FeatureSet
}

func (c *mqlAwsOrganization) GetMasterAccountId() *plugin.TValue[string] {
	return &c.MasterAccountId
}

func (c *mqlAwsOrganization) GetMasterAccountEmail() *plugin.TValue[string] {
	return &c.MasterAccountEmail
}

func (c *mqlAwsOrganization) GetAccounts() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Accounts, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.organization", c.__id, "accounts")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.accounts()
	})
}

func (c *mqlAwsOrganization) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsVpc for the aws.vpc resource
type mqlAwsVpc struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsVpcInternal it will be used here
	Arn                      plugin.TValue[string]
	Id                       plugin.TValue[string]
	Name                     plugin.TValue[string]
	CidrBlock                plugin.TValue[string]
	State                    plugin.TValue[string]
	IsDefault                plugin.TValue[bool]
	InstanceTenancy          plugin.TValue[string]
	Region                   plugin.TValue[string]
	Endpoints                plugin.TValue[[]any]
	FlowLogs                 plugin.TValue[[]any]
	RouteTables              plugin.TValue[[]any]
	Subnets                  plugin.TValue[[]any]
	Tags                     plugin.TValue[map[string]any]
	NatGateways              plugin.TValue[[]any]
	ServiceEndpoints         plugin.TValue[[]any]
	PeeringConnections       plugin.TValue[[]any]
	InternetGatewayBlockMode plugin.TValue[string]
	DhcpOptionsId            plugin.TValue[string]
	InternetGateways         plugin.TValue[[]any]
	SecurityGroups           plugin.TValue[[]any]
	NetworkAcls              plugin.TValue[[]any]
	VpnGateways              plugin.TValue[[]any]
}

// createAwsVpc creates a new instance of this resource
func createAwsVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpc) MqlName() string {
	return "aws.vpc"
}

func (c *mqlAwsVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpc) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpc) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpc) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsVpc) GetCidrBlock() *plugin.TValue[string] {
	return &c.CidrBlock
}

func (c *mqlAwsVpc) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpc) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsVpc) GetInstanceTenancy() *plugin.TValue[string] {
	return &c.InstanceTenancy
}

func (c *mqlAwsVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpc) GetEndpoints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Endpoints, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsVpc) GetFlowLogs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.FlowLogs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "flowLogs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.flowLogs()
	})
}

func (c *mqlAwsVpc) GetRouteTables() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.RouteTables, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "routeTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.routeTables()
	})
}

func (c *mqlAwsVpc) GetSubnets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Subnets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.subnets()
	})
}

func (c *mqlAwsVpc) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsVpc) GetNatGateways() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NatGateways, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "natGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.natGateways()
	})
}

func (c *mqlAwsVpc) GetServiceEndpoints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ServiceEndpoints, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "serviceEndpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.serviceEndpoints()
	})
}

func (c *mqlAwsVpc) GetPeeringConnections() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PeeringConnections, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "peeringConnections")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.peeringConnections()
	})
}

func (c *mqlAwsVpc) GetInternetGatewayBlockMode() *plugin.TValue[string] {
	return &c.InternetGatewayBlockMode
}

func (c *mqlAwsVpc) GetDhcpOptionsId() *plugin.TValue[string] {
	return &c.DhcpOptionsId
}

func (c *mqlAwsVpc) GetInternetGateways() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.InternetGateways, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "internetGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.internetGateways()
	})
}

func (c *mqlAwsVpc) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsVpc) GetNetworkAcls() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NetworkAcls, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "networkAcls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.networkAcls()
	})
}

func (c *mqlAwsVpc) GetVpnGateways() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.VpnGateways, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "vpnGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.vpnGateways()
	})
}

// mqlAwsVpcRoutetable for the aws.vpc.routetable resource
type mqlAwsVpcRoutetable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcRoutetableInternal
	Arn          plugin.TValue[string]
	Associations plugin.TValue[[]any]
	Id           plugin.TValue[string]
	Region       plugin.TValue[string]
	Routes       plugin.TValue[[]any]
	Tags         plugin.TValue[map[string]any]
}

// createAwsVpcRoutetable creates a new instance of this resource
func createAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetable) MqlName() string {
	return "aws.vpc.routetable"
}

func (c *mqlAwsVpcRoutetable) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpcRoutetable) GetAssociations() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Associations, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.routetable", c.__id, "associations")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.associations()
	})
}

func (c *mqlAwsVpcRoutetable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcRoutetable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcRoutetable) GetRoutes() *plugin.TValue[[]any] {
	return &c.Routes
}

func (c *mqlAwsVpcRoutetable) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsVpcRoutetableAssociation for the aws.vpc.routetable.association resource
type mqlAwsVpcRoutetableAssociation struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcRoutetableAssociationInternal
	RouteTableAssociationId plugin.TValue[string]
	AssociationsState       plugin.TValue[any]
	GatewayId               plugin.TValue[string]
	Main                    plugin.TValue[bool]
	RouteTableId            plugin.TValue[string]
	Subnet                  plugin.TValue[*mqlAwsVpcSubnet]
}

// createAwsVpcRoutetableAssociation creates a new instance of this resource
func createAwsVpcRoutetableAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetableAssociation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable.association", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetableAssociation) MqlName() string {
	return "aws.vpc.routetable.association"
}

func (c *mqlAwsVpcRoutetableAssociation) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetableAssociation) GetRouteTableAssociationId() *plugin.TValue[string] {
	return &c.RouteTableAssociationId
}

func (c *mqlAwsVpcRoutetableAssociation) GetAssociationsState() *plugin.TValue[any] {
	return &c.AssociationsState
}

func (c *mqlAwsVpcRoutetableAssociation) GetGatewayId() *plugin.TValue[string] {
	return &c.GatewayId
}

func (c *mqlAwsVpcRoutetableAssociation) GetMain() *plugin.TValue[bool] {
	return &c.Main
}

func (c *mqlAwsVpcRoutetableAssociation) GetRouteTableId() *plugin.TValue[string] {
	return &c.RouteTableId
}

func (c *mqlAwsVpcRoutetableAssociation) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.routetable.association", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

// mqlAwsVpcSubnet for the aws.vpc.subnet resource
type mqlAwsVpcSubnet struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcSubnetInternal
	Arn                         plugin.TValue[string]
	Id                          plugin.TValue[string]
	Name                        plugin.TValue[string]
	Cidrs                       plugin.TValue[string]
	MapPublicIpOnLaunch         plugin.TValue[bool]
	AvailabilityZone            plugin.TValue[string]
	DefaultForAvailabilityZone  plugin.TValue[bool]
	AssignIpv6AddressOnCreation plugin.TValue[bool]
	State                       plugin.TValue[string]
	Region                      plugin.TValue[string]
	AvailableIpAddressCount     plugin.TValue[int64]
	InternetGatewayBlockMode    plugin.TValue[string]
	Tags                        plugin.TValue[map[string]any]
	RouteTable                  plugin.TValue[*mqlAwsVpcRoutetable]
}

// createAwsVpcSubnet creates a new instance of this resource
func createAwsVpcSubnet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcSubnet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.subnet", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcSubnet) MqlName() string {
	return "aws.vpc.subnet"
}

func (c *mqlAwsVpcSubnet) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcSubnet) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpcSubnet) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcSubnet) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsVpcSubnet) GetCidrs() *plugin.TValue[string] {
	return &c.Cidrs
}

func (c *mqlAwsVpcSubnet) GetMapPublicIpOnLaunch() *plugin.TValue[bool] {
	return &c.MapPublicIpOnLaunch
}

func (c *mqlAwsVpcSubnet) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsVpcSubnet) GetDefaultForAvailabilityZone() *plugin.TValue[bool] {
	return &c.DefaultForAvailabilityZone
}

func (c *mqlAwsVpcSubnet) GetAssignIpv6AddressOnCreation() *plugin.TValue[bool] {
	return &c.AssignIpv6AddressOnCreation
}

func (c *mqlAwsVpcSubnet) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcSubnet) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcSubnet) GetAvailableIpAddressCount() *plugin.TValue[int64] {
	return &c.AvailableIpAddressCount
}

func (c *mqlAwsVpcSubnet) GetInternetGatewayBlockMode() *plugin.TValue[string] {
	return &c.InternetGatewayBlockMode
}

func (c *mqlAwsVpcSubnet) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsVpcSubnet) GetRouteTable() *plugin.TValue[*mqlAwsVpcRoutetable] {
	return plugin.GetOrCompute[*mqlAwsVpcRoutetable](&c.RouteTable, func() (*mqlAwsVpcRoutetable, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.subnet", c.__id, "routeTable")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcRoutetable), nil
			}
		}

		return c.routeTable()
	})
}

// mqlAwsVpcEndpoint for the aws.vpc.endpoint resource
type mqlAwsVpcEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsVpcEndpointInternal it will be used here
	Id                plugin.TValue[string]
	Type              plugin.TValue[string]
	Vpc               plugin.TValue[string]
	Region            plugin.TValue[string]
	ServiceName       plugin.TValue[string]
	PolicyDocument    plugin.TValue[string]
	Subnets           plugin.TValue[[]any]
	PrivateDnsEnabled plugin.TValue[bool]
	State             plugin.TValue[string]
	CreatedAt         plugin.TValue[*time.Time]
}

// createAwsVpcEndpoint creates a new instance of this resource
func createAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcEndpoint) MqlName() string {
	return "aws.vpc.endpoint"
}

func (c *mqlAwsVpcEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcEndpoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcEndpoint) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcEndpoint) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcEndpoint) GetServiceName() *plugin.TValue[string] {
	return &c.ServiceName
}

func (c *mqlAwsVpcEndpoint) GetPolicyDocument() *plugin.TValue[string] {
	return &c.PolicyDocument
}

func (c *mqlAwsVpcEndpoint) GetSubnets() *plugin.TValue[[]any] {
	return &c.Subnets
}

func (c *mqlAwsVpcEndpoint) GetPrivateDnsEnabled() *plugin.TValue[bool] {
	return &c.PrivateDnsEnabled
}

func (c *mqlAwsVpcEndpoint) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcEndpoint) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsVpcFlowlog for the aws.vpc.flowlog resource
type mqlAwsVpcFlowlog struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsVpcFlowlogInternal it will be used here
	Id                     plugin.TValue[string]
	Vpc                    plugin.TValue[string]
	Region                 plugin.TValue[string]
	Status                 plugin.TValue[string]
	Tags                   plugin.TValue[map[string]any]
	CreatedAt              plugin.TValue[*time.Time]
	Destination            plugin.TValue[string]
	DestinationType        plugin.TValue[string]
	DeliverLogsStatus      plugin.TValue[string]
	LogFormat              plugin.TValue[string]
	MaxAggregationInterval plugin.TValue[int64]
	TrafficType            plugin.TValue[string]
}

// createAwsVpcFlowlog creates a new instance of this resource
func createAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcFlowlog{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.flowlog", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcFlowlog) MqlName() string {
	return "aws.vpc.flowlog"
}

func (c *mqlAwsVpcFlowlog) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcFlowlog) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcFlowlog) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcFlowlog) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcFlowlog) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcFlowlog) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsVpcFlowlog) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsVpcFlowlog) GetDestination() *plugin.TValue[string] {
	return &c.Destination
}

func (c *mqlAwsVpcFlowlog) GetDestinationType() *plugin.TValue[string] {
	return &c.DestinationType
}

func (c *mqlAwsVpcFlowlog) GetDeliverLogsStatus() *plugin.TValue[string] {
	return &c.DeliverLogsStatus
}

func (c *mqlAwsVpcFlowlog) GetLogFormat() *plugin.TValue[string] {
	return &c.LogFormat
}

func (c *mqlAwsVpcFlowlog) GetMaxAggregationInterval() *plugin.TValue[int64] {
	return &c.MaxAggregationInterval
}

func (c *mqlAwsVpcFlowlog) GetTrafficType() *plugin.TValue[string] {
	return &c.TrafficType
}

// mqlAwsVpcVpnGateway for the aws.vpc.vpnGateway resource
type mqlAwsVpcVpnGateway struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsVpcVpnGatewayInternal it will be used here
	Id               plugin.TValue[string]
	Arn              plugin.TValue[string]
	Region           plugin.TValue[string]
	State            plugin.TValue[string]
	Type             plugin.TValue[string]
	AmazonSideAsn    plugin.TValue[int64]
	AvailabilityZone plugin.TValue[string]
	Attachments      plugin.TValue[[]any]
	Tags             plugin.TValue[map[string]any]
}

// createAwsVpcVpnGateway creates a new instance of this resource
func createAwsVpcVpnGateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcVpnGateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.vpnGateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcVpnGateway) MqlName() string {
	return "aws.vpc.vpnGateway"
}

func (c *mqlAwsVpcVpnGateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcVpnGateway) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcVpnGateway) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpcVpnGateway) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcVpnGateway) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcVpnGateway) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcVpnGateway) GetAmazonSideAsn() *plugin.TValue[int64] {
	return &c.AmazonSideAsn
}

func (c *mqlAwsVpcVpnGateway) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsVpcVpnGateway) GetAttachments() *plugin.TValue[[]any] {
	return &c.Attachments
}

func (c *mqlAwsVpcVpnGateway) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsWaf for the aws.waf resource
type mqlAwsWaf struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafInternal it will be used here
	Acls       plugin.TValue[[]any]
	RuleGroups plugin.TValue[[]any]
	IpSets     plugin.TValue[[]any]
	Scope      plugin.TValue[string]
}

// createAwsWaf creates a new instance of this resource
func createAwsWaf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWaf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWaf) MqlName() string {
	return "aws.waf"
}

func (c *mqlAwsWaf) MqlID() string {
	return c.__id
}

func (c *mqlAwsWaf) GetAcls() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Acls, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "acls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.acls()
	})
}

func (c *mqlAwsWaf) GetRuleGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.RuleGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "ruleGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ruleGroups()
	})
}

func (c *mqlAwsWaf) GetIpSets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.IpSets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf", c.__id, "ipSets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ipSets()
	})
}

func (c *mqlAwsWaf) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafAcl for the aws.waf.acl resource
type mqlAwsWafAcl struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafAclInternal it will be used here
	Arn                      plugin.TValue[string]
	Id                       plugin.TValue[string]
	Name                     plugin.TValue[string]
	Description              plugin.TValue[string]
	ManagedByFirewallManager plugin.TValue[bool]
	Rules                    plugin.TValue[[]any]
	Scope                    plugin.TValue[string]
}

// createAwsWafAcl creates a new instance of this resource
func createAwsWafAcl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafAcl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.acl", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafAcl) MqlName() string {
	return "aws.waf.acl"
}

func (c *mqlAwsWafAcl) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafAcl) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafAcl) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafAcl) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafAcl) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafAcl) GetManagedByFirewallManager() *plugin.TValue[bool] {
	return &c.ManagedByFirewallManager
}

func (c *mqlAwsWafAcl) GetRules() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Rules, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf.acl", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsWafAcl) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRulegroup for the aws.waf.rulegroup resource
type mqlAwsWafRulegroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRulegroupInternal it will be used here
	Arn         plugin.TValue[string]
	Id          plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	Rules       plugin.TValue[[]any]
	Scope       plugin.TValue[string]
}

// createAwsWafRulegroup creates a new instance of this resource
func createAwsWafRulegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRulegroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rulegroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRulegroup) MqlName() string {
	return "aws.waf.rulegroup"
}

func (c *mqlAwsWafRulegroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRulegroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRulegroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRulegroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRulegroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafRulegroup) GetRules() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Rules, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.waf.rulegroup", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsWafRulegroup) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRule for the aws.waf.rule resource
type mqlAwsWafRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleInternal it will be used here
	Id        plugin.TValue[string]
	Name      plugin.TValue[string]
	Priority  plugin.TValue[int64]
	Statement plugin.TValue[*mqlAwsWafRuleStatement]
	Action    plugin.TValue[*mqlAwsWafRuleAction]
	BelongsTo plugin.TValue[string]
}

// createAwsWafRule creates a new instance of this resource
func createAwsWafRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRule) MqlName() string {
	return "aws.waf.rule"
}

func (c *mqlAwsWafRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRule) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRule) GetPriority() *plugin.TValue[int64] {
	return &c.Priority
}

func (c *mqlAwsWafRule) GetStatement() *plugin.TValue[*mqlAwsWafRuleStatement] {
	return &c.Statement
}

func (c *mqlAwsWafRule) GetAction() *plugin.TValue[*mqlAwsWafRuleAction] {
	return &c.Action
}

func (c *mqlAwsWafRule) GetBelongsTo() *plugin.TValue[string] {
	return &c.BelongsTo
}

// mqlAwsWafRuleAction for the aws.waf.rule.action resource
type mqlAwsWafRuleAction struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleActionInternal it will be used here
	RuleName     plugin.TValue[string]
	Action       plugin.TValue[string]
	ResponseCode plugin.TValue[string]
}

// createAwsWafRuleAction creates a new instance of this resource
func createAwsWafRuleAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleAction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.action", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleAction) MqlName() string {
	return "aws.waf.rule.action"
}

func (c *mqlAwsWafRuleAction) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleAction) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleAction) GetAction() *plugin.TValue[string] {
	return &c.Action
}

func (c *mqlAwsWafRuleAction) GetResponseCode() *plugin.TValue[string] {
	return &c.ResponseCode
}

// mqlAwsWafRuleStatement for the aws.waf.rule.statement resource
type mqlAwsWafRuleStatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementInternal it will be used here
	Id                                plugin.TValue[string]
	Kind                              plugin.TValue[string]
	Json                              plugin.TValue[any]
	SqliMatchStatement                plugin.TValue[*mqlAwsWafRuleStatementSqlimatchstatement]
	XssMatchStatement                 plugin.TValue[*mqlAwsWafRuleStatementXssmatchstatement]
	ByteMatchStatement                plugin.TValue[*mqlAwsWafRuleStatementBytematchstatement]
	RegexMatchStatement               plugin.TValue[*mqlAwsWafRuleStatementRegexmatchstatement]
	GeoMatchStatement                 plugin.TValue[*mqlAwsWafRuleStatementGeomatchstatement]
	IpSetReferenceStatement           plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatement]
	LabelMatchStatement               plugin.TValue[*mqlAwsWafRuleStatementLabelmatchstatement]
	ManagedRuleGroupStatement         plugin.TValue[*mqlAwsWafRuleStatementManagedrulegroupstatement]
	NotStatement                      plugin.TValue[*mqlAwsWafRuleStatementNotstatement]
	OrStatement                       plugin.TValue[*mqlAwsWafRuleStatementOrstatement]
	AndStatement                      plugin.TValue[*mqlAwsWafRuleStatementAndstatement]
	RateBasedStatement                plugin.TValue[*mqlAwsWafRuleStatementRatebasedstatement]
	RegexPatternSetReferenceStatement plugin.TValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement]
	RuleGroupReferenceStatement       plugin.TValue[*mqlAwsWafRuleStatementRulegroupreferencestatement]
	SizeConstraintStatement           plugin.TValue[*mqlAwsWafRuleStatementSizeconstraintstatement]
}

// createAwsWafRuleStatement creates a new instance of this resource
func createAwsWafRuleStatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatement) MqlName() string {
	return "aws.waf.rule.statement"
}

func (c *mqlAwsWafRuleStatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatement) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafRuleStatement) GetKind() *plugin.TValue[string] {
	return &c.Kind
}

func (c *mqlAwsWafRuleStatement) GetJson() *plugin.TValue[any] {
	return &c.Json
}

func (c *mqlAwsWafRuleStatement) GetSqliMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementSqlimatchstatement] {
	return &c.SqliMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetXssMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementXssmatchstatement] {
	return &c.XssMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetByteMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementBytematchstatement] {
	return &c.ByteMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetRegexMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementRegexmatchstatement] {
	return &c.RegexMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetGeoMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementGeomatchstatement] {
	return &c.GeoMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetIpSetReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatement] {
	return &c.IpSetReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetLabelMatchStatement() *plugin.TValue[*mqlAwsWafRuleStatementLabelmatchstatement] {
	return &c.LabelMatchStatement
}

func (c *mqlAwsWafRuleStatement) GetManagedRuleGroupStatement() *plugin.TValue[*mqlAwsWafRuleStatementManagedrulegroupstatement] {
	return &c.ManagedRuleGroupStatement
}

func (c *mqlAwsWafRuleStatement) GetNotStatement() *plugin.TValue[*mqlAwsWafRuleStatementNotstatement] {
	return &c.NotStatement
}

func (c *mqlAwsWafRuleStatement) GetOrStatement() *plugin.TValue[*mqlAwsWafRuleStatementOrstatement] {
	return &c.OrStatement
}

func (c *mqlAwsWafRuleStatement) GetAndStatement() *plugin.TValue[*mqlAwsWafRuleStatementAndstatement] {
	return &c.AndStatement
}

func (c *mqlAwsWafRuleStatement) GetRateBasedStatement() *plugin.TValue[*mqlAwsWafRuleStatementRatebasedstatement] {
	return &c.RateBasedStatement
}

func (c *mqlAwsWafRuleStatement) GetRegexPatternSetReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementRegexpatternsetreferencestatement] {
	return &c.RegexPatternSetReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetRuleGroupReferenceStatement() *plugin.TValue[*mqlAwsWafRuleStatementRulegroupreferencestatement] {
	return &c.RuleGroupReferenceStatement
}

func (c *mqlAwsWafRuleStatement) GetSizeConstraintStatement() *plugin.TValue[*mqlAwsWafRuleStatementSizeconstraintstatement] {
	return &c.SizeConstraintStatement
}

// mqlAwsWafRuleStatementGeomatchstatement for the aws.waf.rule.statement.geomatchstatement resource
type mqlAwsWafRuleStatementGeomatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementGeomatchstatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	CountryCodes plugin.TValue[[]any]
}

// createAwsWafRuleStatementGeomatchstatement creates a new instance of this resource
func createAwsWafRuleStatementGeomatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementGeomatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.geomatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) MqlName() string {
	return "aws.waf.rule.statement.geomatchstatement"
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementGeomatchstatement) GetCountryCodes() *plugin.TValue[[]any] {
	return &c.CountryCodes
}

// mqlAwsWafRuleStatementIpsetreferencestatement for the aws.waf.rule.statement.ipsetreferencestatement resource
type mqlAwsWafRuleStatementIpsetreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementIpsetreferencestatementInternal it will be used here
	RuleName               plugin.TValue[string]
	StatementID            plugin.TValue[string]
	Arn                    plugin.TValue[string]
	IpSetForwardedIPConfig plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig]
}

// createAwsWafRuleStatementIpsetreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementIpsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementIpsetreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ipsetreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.ipsetreferencestatement"
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatement) GetIpSetForwardedIPConfig() *plugin.TValue[*mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig] {
	return &c.IpSetForwardedIPConfig
}

// mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig for the aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig resource
type mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfigInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	HeaderName       plugin.TValue[string]
	Position         plugin.TValue[string]
	FallbackBehavior plugin.TValue[string]
}

// createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig creates a new instance of this resource
func createAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) MqlName() string {
	return "aws.waf.rule.statement.ipsetreferencestatement.ipsetforwardedipconfig"
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetHeaderName() *plugin.TValue[string] {
	return &c.HeaderName
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetPosition() *plugin.TValue[string] {
	return &c.Position
}

func (c *mqlAwsWafRuleStatementIpsetreferencestatementIpsetforwardedipconfig) GetFallbackBehavior() *plugin.TValue[string] {
	return &c.FallbackBehavior
}

// mqlAwsWafRuleStatementLabelmatchstatement for the aws.waf.rule.statement.labelmatchstatement resource
type mqlAwsWafRuleStatementLabelmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementLabelmatchstatementInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Key         plugin.TValue[string]
	Scope       plugin.TValue[string]
}

// createAwsWafRuleStatementLabelmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementLabelmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementLabelmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.labelmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.labelmatchstatement"
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlAwsWafRuleStatementLabelmatchstatement) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

// mqlAwsWafRuleStatementManagedrulegroupstatement for the aws.waf.rule.statement.managedrulegroupstatement resource
type mqlAwsWafRuleStatementManagedrulegroupstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementManagedrulegroupstatementInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name        plugin.TValue[string]
	VendorName  plugin.TValue[string]
}

// createAwsWafRuleStatementManagedrulegroupstatement creates a new instance of this resource
func createAwsWafRuleStatementManagedrulegroupstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementManagedrulegroupstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.managedrulegroupstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) MqlName() string {
	return "aws.waf.rule.statement.managedrulegroupstatement"
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafRuleStatementManagedrulegroupstatement) GetVendorName() *plugin.TValue[string] {
	return &c.VendorName
}

// mqlAwsWafRuleStatementAndstatement for the aws.waf.rule.statement.andstatement resource
type mqlAwsWafRuleStatementAndstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementAndstatementInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statements  plugin.TValue[[]any]
}

// createAwsWafRuleStatementAndstatement creates a new instance of this resource
func createAwsWafRuleStatementAndstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementAndstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.andstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementAndstatement) MqlName() string {
	return "aws.waf.rule.statement.andstatement"
}

func (c *mqlAwsWafRuleStatementAndstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementAndstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementAndstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementAndstatement) GetStatements() *plugin.TValue[[]any] {
	return &c.Statements
}

// mqlAwsWafRuleStatementNotstatement for the aws.waf.rule.statement.notstatement resource
type mqlAwsWafRuleStatementNotstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementNotstatementInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statement   plugin.TValue[*mqlAwsWafRuleStatement]
}

// createAwsWafRuleStatementNotstatement creates a new instance of this resource
func createAwsWafRuleStatementNotstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementNotstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.notstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementNotstatement) MqlName() string {
	return "aws.waf.rule.statement.notstatement"
}

func (c *mqlAwsWafRuleStatementNotstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementNotstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementNotstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementNotstatement) GetStatement() *plugin.TValue[*mqlAwsWafRuleStatement] {
	return &c.Statement
}

// mqlAwsWafRuleStatementOrstatement for the aws.waf.rule.statement.orstatement resource
type mqlAwsWafRuleStatementOrstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementOrstatementInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Statements  plugin.TValue[[]any]
}

// createAwsWafRuleStatementOrstatement creates a new instance of this resource
func createAwsWafRuleStatementOrstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementOrstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.orstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementOrstatement) MqlName() string {
	return "aws.waf.rule.statement.orstatement"
}

func (c *mqlAwsWafRuleStatementOrstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementOrstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementOrstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementOrstatement) GetStatements() *plugin.TValue[[]any] {
	return &c.Statements
}

// mqlAwsWafRuleStatementRatebasedstatement for the aws.waf.rule.statement.ratebasedstatement resource
type mqlAwsWafRuleStatementRatebasedstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementRatebasedstatementInternal it will be used here
}

// createAwsWafRuleStatementRatebasedstatement creates a new instance of this resource
func createAwsWafRuleStatementRatebasedstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRatebasedstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.ratebasedstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRatebasedstatement) MqlName() string {
	return "aws.waf.rule.statement.ratebasedstatement"
}

func (c *mqlAwsWafRuleStatementRatebasedstatement) MqlID() string {
	return c.__id
}

// mqlAwsWafRuleStatementRegexpatternsetreferencestatement for the aws.waf.rule.statement.regexpatternsetreferencestatement resource
type mqlAwsWafRuleStatementRegexpatternsetreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementRegexpatternsetreferencestatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	Arn          plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementRegexpatternsetreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementRegexpatternsetreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRegexpatternsetreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.regexpatternsetreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.regexpatternsetreferencestatement"
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementRegexpatternsetreferencestatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementRulegroupreferencestatement for the aws.waf.rule.statement.rulegroupreferencestatement resource
type mqlAwsWafRuleStatementRulegroupreferencestatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementRulegroupreferencestatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	Arn          plugin.TValue[string]
	ExcludeRules plugin.TValue[[]any]
}

// createAwsWafRuleStatementRulegroupreferencestatement creates a new instance of this resource
func createAwsWafRuleStatementRulegroupreferencestatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRulegroupreferencestatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.rulegroupreferencestatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) MqlName() string {
	return "aws.waf.rule.statement.rulegroupreferencestatement"
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafRuleStatementRulegroupreferencestatement) GetExcludeRules() *plugin.TValue[[]any] {
	return &c.ExcludeRules
}

// mqlAwsWafRuleStatementSizeconstraintstatement for the aws.waf.rule.statement.sizeconstraintstatement resource
type mqlAwsWafRuleStatementSizeconstraintstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementSizeconstraintstatementInternal it will be used here
	RuleName           plugin.TValue[string]
	StatementID        plugin.TValue[string]
	Size               plugin.TValue[int64]
	ComparisonOperator plugin.TValue[string]
	FieldToMatch       plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementSizeconstraintstatement creates a new instance of this resource
func createAwsWafRuleStatementSizeconstraintstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementSizeconstraintstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.sizeconstraintstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) MqlName() string {
	return "aws.waf.rule.statement.sizeconstraintstatement"
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetComparisonOperator() *plugin.TValue[string] {
	return &c.ComparisonOperator
}

func (c *mqlAwsWafRuleStatementSizeconstraintstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementRegexmatchstatement for the aws.waf.rule.statement.regexmatchstatement resource
type mqlAwsWafRuleStatementRegexmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementRegexmatchstatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	RegexString  plugin.TValue[string]
}

// createAwsWafRuleStatementRegexmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementRegexmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementRegexmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.regexmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.regexmatchstatement"
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementRegexmatchstatement) GetRegexString() *plugin.TValue[string] {
	return &c.RegexString
}

// mqlAwsWafRuleStatementBytematchstatement for the aws.waf.rule.statement.bytematchstatement resource
type mqlAwsWafRuleStatementBytematchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementBytematchstatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	SearchString plugin.TValue[string]
}

// createAwsWafRuleStatementBytematchstatement creates a new instance of this resource
func createAwsWafRuleStatementBytematchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementBytematchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.bytematchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementBytematchstatement) MqlName() string {
	return "aws.waf.rule.statement.bytematchstatement"
}

func (c *mqlAwsWafRuleStatementBytematchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementBytematchstatement) GetSearchString() *plugin.TValue[string] {
	return &c.SearchString
}

// mqlAwsWafRuleFieldtomatch for the aws.waf.rule.fieldtomatch resource
type mqlAwsWafRuleFieldtomatch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchInternal it will be used here
	Target              plugin.TValue[string]
	RuleName            plugin.TValue[string]
	StatementID         plugin.TValue[string]
	Method              plugin.TValue[bool]
	UriPath             plugin.TValue[bool]
	QueryString         plugin.TValue[bool]
	AllQueryArguments   plugin.TValue[bool]
	Body                plugin.TValue[*mqlAwsWafRuleFieldtomatchBody]
	Cookie              plugin.TValue[*mqlAwsWafRuleFieldtomatchCookie]
	SingleHeader        plugin.TValue[*mqlAwsWafRuleFieldtomatchSingleheader]
	HeaderOrder         plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaderorder]
	Headers             plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaders]
	Ja3Fingerprint      plugin.TValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint]
	JsonBody            plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbody]
	SingleQueryArgument plugin.TValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument]
}

// createAwsWafRuleFieldtomatch creates a new instance of this resource
func createAwsWafRuleFieldtomatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatch) MqlName() string {
	return "aws.waf.rule.fieldtomatch"
}

func (c *mqlAwsWafRuleFieldtomatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatch) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlAwsWafRuleFieldtomatch) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatch) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatch) GetMethod() *plugin.TValue[bool] {
	return &c.Method
}

func (c *mqlAwsWafRuleFieldtomatch) GetUriPath() *plugin.TValue[bool] {
	return &c.UriPath
}

func (c *mqlAwsWafRuleFieldtomatch) GetQueryString() *plugin.TValue[bool] {
	return &c.QueryString
}

func (c *mqlAwsWafRuleFieldtomatch) GetAllQueryArguments() *plugin.TValue[bool] {
	return &c.AllQueryArguments
}

func (c *mqlAwsWafRuleFieldtomatch) GetBody() *plugin.TValue[*mqlAwsWafRuleFieldtomatchBody] {
	return &c.Body
}

func (c *mqlAwsWafRuleFieldtomatch) GetCookie() *plugin.TValue[*mqlAwsWafRuleFieldtomatchCookie] {
	return &c.Cookie
}

func (c *mqlAwsWafRuleFieldtomatch) GetSingleHeader() *plugin.TValue[*mqlAwsWafRuleFieldtomatchSingleheader] {
	return &c.SingleHeader
}

func (c *mqlAwsWafRuleFieldtomatch) GetHeaderOrder() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaderorder] {
	return &c.HeaderOrder
}

func (c *mqlAwsWafRuleFieldtomatch) GetHeaders() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeaders] {
	return &c.Headers
}

func (c *mqlAwsWafRuleFieldtomatch) GetJa3Fingerprint() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJa3fingerprint] {
	return &c.Ja3Fingerprint
}

func (c *mqlAwsWafRuleFieldtomatch) GetJsonBody() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbody] {
	return &c.JsonBody
}

func (c *mqlAwsWafRuleFieldtomatch) GetSingleQueryArgument() *plugin.TValue[*mqlAwsWafRuleFieldtomatchSinglequeryargument] {
	return &c.SingleQueryArgument
}

// mqlAwsWafRuleFieldtomatchBody for the aws.waf.rule.fieldtomatch.body resource
type mqlAwsWafRuleFieldtomatchBody struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchBodyInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchBody creates a new instance of this resource
func createAwsWafRuleFieldtomatchBody(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchBody{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.body", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchBody) MqlName() string {
	return "aws.waf.rule.fieldtomatch.body"
}

func (c *mqlAwsWafRuleFieldtomatchBody) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchBody) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchCookie for the aws.waf.rule.fieldtomatch.cookie resource
type mqlAwsWafRuleFieldtomatchCookie struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchCookieInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchCookie creates a new instance of this resource
func createAwsWafRuleFieldtomatchCookie(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchCookie{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.cookie", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchCookie) MqlName() string {
	return "aws.waf.rule.fieldtomatch.cookie"
}

func (c *mqlAwsWafRuleFieldtomatchCookie) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchCookie) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchHeaderorder for the aws.waf.rule.fieldtomatch.headerorder resource
type mqlAwsWafRuleFieldtomatchHeaderorder struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeaderorderInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchHeaderorder creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeaderorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeaderorder{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headerorder", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headerorder"
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeaderorder) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

// mqlAwsWafRuleFieldtomatchSingleheader for the aws.waf.rule.fieldtomatch.singleheader resource
type mqlAwsWafRuleFieldtomatchSingleheader struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchSingleheaderInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name        plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchSingleheader creates a new instance of this resource
func createAwsWafRuleFieldtomatchSingleheader(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchSingleheader{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.singleheader", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) MqlName() string {
	return "aws.waf.rule.fieldtomatch.singleheader"
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchSingleheader) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsWafRuleFieldtomatchSinglequeryargument for the aws.waf.rule.fieldtomatch.singlequeryargument resource
type mqlAwsWafRuleFieldtomatchSinglequeryargument struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchSinglequeryargumentInternal it will be used here
	RuleName    plugin.TValue[string]
	StatementID plugin.TValue[string]
	Name        plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchSinglequeryargument creates a new instance of this resource
func createAwsWafRuleFieldtomatchSinglequeryargument(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchSinglequeryargument{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.singlequeryargument", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) MqlName() string {
	return "aws.waf.rule.fieldtomatch.singlequeryargument"
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchSinglequeryargument) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsWafRuleFieldtomatchJa3fingerprint for the aws.waf.rule.fieldtomatch.ja3fingerprint resource
type mqlAwsWafRuleFieldtomatchJa3fingerprint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchJa3fingerprintInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	FallbackBehavior plugin.TValue[string]
}

// createAwsWafRuleFieldtomatchJa3fingerprint creates a new instance of this resource
func createAwsWafRuleFieldtomatchJa3fingerprint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJa3fingerprint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.ja3fingerprint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) MqlName() string {
	return "aws.waf.rule.fieldtomatch.ja3fingerprint"
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJa3fingerprint) GetFallbackBehavior() *plugin.TValue[string] {
	return &c.FallbackBehavior
}

// mqlAwsWafRuleFieldtomatchJsonbody for the aws.waf.rule.fieldtomatch.jsonbody resource
type mqlAwsWafRuleFieldtomatchJsonbody struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchJsonbodyInternal it will be used here
	RuleName                plugin.TValue[string]
	StatementID             plugin.TValue[string]
	OverSizeHandling        plugin.TValue[string]
	MatchScope              plugin.TValue[string]
	InvalidFallbackBehavior plugin.TValue[string]
	MatchPattern            plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern]
}

// createAwsWafRuleFieldtomatchJsonbody creates a new instance of this resource
func createAwsWafRuleFieldtomatchJsonbody(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJsonbody{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.jsonbody", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) MqlName() string {
	return "aws.waf.rule.fieldtomatch.jsonbody"
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetMatchScope() *plugin.TValue[string] {
	return &c.MatchScope
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetInvalidFallbackBehavior() *plugin.TValue[string] {
	return &c.InvalidFallbackBehavior
}

func (c *mqlAwsWafRuleFieldtomatchJsonbody) GetMatchPattern() *plugin.TValue[*mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern] {
	return &c.MatchPattern
}

// mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern for the aws.waf.rule.fieldtomatch.jsonbody.matchpattern resource
type mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchJsonbodyMatchpatternInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	All          plugin.TValue[bool]
	IncludePaths plugin.TValue[[]any]
}

// createAwsWafRuleFieldtomatchJsonbodyMatchpattern creates a new instance of this resource
func createAwsWafRuleFieldtomatchJsonbodyMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.jsonbody.matchpattern", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) MqlName() string {
	return "aws.waf.rule.fieldtomatch.jsonbody.matchpattern"
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetAll() *plugin.TValue[bool] {
	return &c.All
}

func (c *mqlAwsWafRuleFieldtomatchJsonbodyMatchpattern) GetIncludePaths() *plugin.TValue[[]any] {
	return &c.IncludePaths
}

// mqlAwsWafRuleFieldtomatchHeaders for the aws.waf.rule.fieldtomatch.headers resource
type mqlAwsWafRuleFieldtomatchHeaders struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeadersInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	MatchScope       plugin.TValue[string]
	OverSizeHandling plugin.TValue[string]
	MatchPattern     plugin.TValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern]
}

// createAwsWafRuleFieldtomatchHeaders creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeaders(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeaders{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headers", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headers"
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetMatchScope() *plugin.TValue[string] {
	return &c.MatchScope
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetOverSizeHandling() *plugin.TValue[string] {
	return &c.OverSizeHandling
}

func (c *mqlAwsWafRuleFieldtomatchHeaders) GetMatchPattern() *plugin.TValue[*mqlAwsWafRuleFieldtomatchHeadersMatchpattern] {
	return &c.MatchPattern
}

// mqlAwsWafRuleFieldtomatchHeadersMatchpattern for the aws.waf.rule.fieldtomatch.headers.matchpattern resource
type mqlAwsWafRuleFieldtomatchHeadersMatchpattern struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleFieldtomatchHeadersMatchpatternInternal it will be used here
	RuleName       plugin.TValue[string]
	StatementID    plugin.TValue[string]
	All            plugin.TValue[bool]
	IncludeHeaders plugin.TValue[[]any]
	ExcludeHeaders plugin.TValue[[]any]
}

// createAwsWafRuleFieldtomatchHeadersMatchpattern creates a new instance of this resource
func createAwsWafRuleFieldtomatchHeadersMatchpattern(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleFieldtomatchHeadersMatchpattern{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.fieldtomatch.headers.matchpattern", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) MqlName() string {
	return "aws.waf.rule.fieldtomatch.headers.matchpattern"
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetAll() *plugin.TValue[bool] {
	return &c.All
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetIncludeHeaders() *plugin.TValue[[]any] {
	return &c.IncludeHeaders
}

func (c *mqlAwsWafRuleFieldtomatchHeadersMatchpattern) GetExcludeHeaders() *plugin.TValue[[]any] {
	return &c.ExcludeHeaders
}

// mqlAwsWafRuleStatementXssmatchstatement for the aws.waf.rule.statement.xssmatchstatement resource
type mqlAwsWafRuleStatementXssmatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementXssmatchstatementInternal it will be used here
	RuleName     plugin.TValue[string]
	StatementID  plugin.TValue[string]
	FieldToMatch plugin.TValue[*mqlAwsWafRuleFieldtomatch]
}

// createAwsWafRuleStatementXssmatchstatement creates a new instance of this resource
func createAwsWafRuleStatementXssmatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementXssmatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.xssmatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) MqlName() string {
	return "aws.waf.rule.statement.xssmatchstatement"
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementXssmatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

// mqlAwsWafRuleStatementSqlimatchstatement for the aws.waf.rule.statement.sqlimatchstatement resource
type mqlAwsWafRuleStatementSqlimatchstatement struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafRuleStatementSqlimatchstatementInternal it will be used here
	RuleName         plugin.TValue[string]
	StatementID      plugin.TValue[string]
	FieldToMatch     plugin.TValue[*mqlAwsWafRuleFieldtomatch]
	SensitivityLevel plugin.TValue[string]
}

// createAwsWafRuleStatementSqlimatchstatement creates a new instance of this resource
func createAwsWafRuleStatementSqlimatchstatement(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafRuleStatementSqlimatchstatement{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.rule.statement.sqlimatchstatement", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) MqlName() string {
	return "aws.waf.rule.statement.sqlimatchstatement"
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetRuleName() *plugin.TValue[string] {
	return &c.RuleName
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetStatementID() *plugin.TValue[string] {
	return &c.StatementID
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetFieldToMatch() *plugin.TValue[*mqlAwsWafRuleFieldtomatch] {
	return &c.FieldToMatch
}

func (c *mqlAwsWafRuleStatementSqlimatchstatement) GetSensitivityLevel() *plugin.TValue[string] {
	return &c.SensitivityLevel
}

// mqlAwsWafIpset for the aws.waf.ipset resource
type mqlAwsWafIpset struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsWafIpsetInternal it will be used here
	Arn         plugin.TValue[string]
	Id          plugin.TValue[string]
	Scope       plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	AddressType plugin.TValue[string]
	Addresses   plugin.TValue[any]
}

// createAwsWafIpset creates a new instance of this resource
func createAwsWafIpset(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsWafIpset{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.waf.ipset", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsWafIpset) MqlName() string {
	return "aws.waf.ipset"
}

func (c *mqlAwsWafIpset) MqlID() string {
	return c.__id
}

func (c *mqlAwsWafIpset) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsWafIpset) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsWafIpset) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

func (c *mqlAwsWafIpset) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsWafIpset) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsWafIpset) GetAddressType() *plugin.TValue[string] {
	return &c.AddressType
}

func (c *mqlAwsWafIpset) GetAddresses() *plugin.TValue[any] {
	return &c.Addresses
}

// mqlAwsEfs for the aws.efs resource
type mqlAwsEfs struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEfsInternal it will be used here
	Filesystems plugin.TValue[[]any]
}

// createAwsEfs creates a new instance of this resource
func createAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfs) MqlName() string {
	return "aws.efs"
}

func (c *mqlAwsEfs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfs) GetFilesystems() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Filesystems, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs", c.__id, "filesystems")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.filesystems()
	})
}

// mqlAwsEfsFilesystem for the aws.efs.filesystem resource
type mqlAwsEfsFilesystem struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEfsFilesystemInternal
	Name             plugin.TValue[string]
	Id               plugin.TValue[string]
	Arn              plugin.TValue[string]
	Encrypted        plugin.TValue[bool]
	KmsKey           plugin.TValue[*mqlAwsKmsKey]
	BackupPolicy     plugin.TValue[any]
	Region           plugin.TValue[string]
	AvailabilityZone plugin.TValue[string]
	Tags             plugin.TValue[map[string]any]
	CreatedAt        plugin.TValue[*time.Time]
	MountTargets     plugin.TValue[[]any]
	AccessPoints     plugin.TValue[[]any]
	FileSystemPolicy plugin.TValue[string]
}

// createAwsEfsFilesystem creates a new instance of this resource
func createAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsFilesystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.filesystem", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsFilesystem) MqlName() string {
	return "aws.efs.filesystem"
}

func (c *mqlAwsEfsFilesystem) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsFilesystem) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEfsFilesystem) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEfsFilesystem) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEfsFilesystem) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEfsFilesystem) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsEfsFilesystem) GetBackupPolicy() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.BackupPolicy, func() (any, error) {
		return c.backupPolicy()
	})
}

func (c *mqlAwsEfsFilesystem) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEfsFilesystem) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEfsFilesystem) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEfsFilesystem) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEfsFilesystem) GetMountTargets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.MountTargets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "mountTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.mountTargets()
	})
}

func (c *mqlAwsEfsFilesystem) GetAccessPoints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AccessPoints, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "accessPoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.accessPoints()
	})
}

func (c *mqlAwsEfsFilesystem) GetFileSystemPolicy() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.FileSystemPolicy, func() (string, error) {
		return c.fileSystemPolicy()
	})
}

// mqlAwsEfsMountTarget for the aws.efs.mountTarget resource
type mqlAwsEfsMountTarget struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEfsMountTargetInternal
	MountTargetId      plugin.TValue[string]
	FileSystemId       plugin.TValue[string]
	SubnetId           plugin.TValue[string]
	AvailabilityZone   plugin.TValue[string]
	IpAddress          plugin.TValue[string]
	SecurityGroups     plugin.TValue[[]any]
	LifecycleState     plugin.TValue[string]
	NetworkInterfaceId plugin.TValue[string]
	Region             plugin.TValue[string]
}

// createAwsEfsMountTarget creates a new instance of this resource
func createAwsEfsMountTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsMountTarget{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.mountTarget", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsMountTarget) MqlName() string {
	return "aws.efs.mountTarget"
}

func (c *mqlAwsEfsMountTarget) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsMountTarget) GetMountTargetId() *plugin.TValue[string] {
	return &c.MountTargetId
}

func (c *mqlAwsEfsMountTarget) GetFileSystemId() *plugin.TValue[string] {
	return &c.FileSystemId
}

func (c *mqlAwsEfsMountTarget) GetSubnetId() *plugin.TValue[string] {
	return &c.SubnetId
}

func (c *mqlAwsEfsMountTarget) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEfsMountTarget) GetIpAddress() *plugin.TValue[string] {
	return &c.IpAddress
}

func (c *mqlAwsEfsMountTarget) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.mountTarget", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEfsMountTarget) GetLifecycleState() *plugin.TValue[string] {
	return &c.LifecycleState
}

func (c *mqlAwsEfsMountTarget) GetNetworkInterfaceId() *plugin.TValue[string] {
	return &c.NetworkInterfaceId
}

func (c *mqlAwsEfsMountTarget) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEfsAccessPoint for the aws.efs.accessPoint resource
type mqlAwsEfsAccessPoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEfsAccessPointInternal it will be used here
	AccessPointId  plugin.TValue[string]
	Arn            plugin.TValue[string]
	FileSystemId   plugin.TValue[string]
	Name           plugin.TValue[string]
	PosixUser      plugin.TValue[any]
	RootDirectory  plugin.TValue[any]
	LifecycleState plugin.TValue[string]
	Tags           plugin.TValue[map[string]any]
	Region         plugin.TValue[string]
}

// createAwsEfsAccessPoint creates a new instance of this resource
func createAwsEfsAccessPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsAccessPoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.accessPoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsAccessPoint) MqlName() string {
	return "aws.efs.accessPoint"
}

func (c *mqlAwsEfsAccessPoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsAccessPoint) GetAccessPointId() *plugin.TValue[string] {
	return &c.AccessPointId
}

func (c *mqlAwsEfsAccessPoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEfsAccessPoint) GetFileSystemId() *plugin.TValue[string] {
	return &c.FileSystemId
}

func (c *mqlAwsEfsAccessPoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEfsAccessPoint) GetPosixUser() *plugin.TValue[any] {
	return &c.PosixUser
}

func (c *mqlAwsEfsAccessPoint) GetRootDirectory() *plugin.TValue[any] {
	return &c.RootDirectory
}

func (c *mqlAwsEfsAccessPoint) GetLifecycleState() *plugin.TValue[string] {
	return &c.LifecycleState
}

func (c *mqlAwsEfsAccessPoint) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEfsAccessPoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsFsx for the aws.fsx resource
type mqlAwsFsx struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsFsxInternal it will be used here
	FileSystems plugin.TValue[[]any]
	Caches      plugin.TValue[[]any]
	Backups     plugin.TValue[[]any]
}

// createAwsFsx creates a new instance of this resource
func createAwsFsx(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsFsx{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.fsx", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsFsx) MqlName() string {
	return "aws.fsx"
}

func (c *mqlAwsFsx) MqlID() string {
	return c.__id
}

func (c *mqlAwsFsx) GetFileSystems() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.FileSystems, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.fsx", c.__id, "fileSystems")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.fileSystems()
	})
}

func (c *mqlAwsFsx) GetCaches() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Caches, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.fsx", c.__id, "caches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.caches()
	})
}

func (c *mqlAwsFsx) GetBackups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Backups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.fsx", c.__id, "backups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.backups()
	})
}

// mqlAwsFsxFilesystem for the aws.fsx.filesystem resource
type mqlAwsFsxFilesystem struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsFsxFilesystemInternal it will be used here
	Id              plugin.TValue[string]
	Arn             plugin.TValue[string]
	Type            plugin.TValue[string]
	Lifecycle       plugin.TValue[string]
	StorageCapacity plugin.TValue[int64]
	StorageType     plugin.TValue[string]
	Encrypted       plugin.TValue[bool]
	KmsKeyId        plugin.TValue[string]
	VpcId           plugin.TValue[string]
	SubnetIds       plugin.TValue[[]any]
	Tags            plugin.TValue[map[string]any]
	CreatedAt       plugin.TValue[*time.Time]
	Region          plugin.TValue[string]
}

// createAwsFsxFilesystem creates a new instance of this resource
func createAwsFsxFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsFsxFilesystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.fsx.filesystem", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsFsxFilesystem) MqlName() string {
	return "aws.fsx.filesystem"
}

func (c *mqlAwsFsxFilesystem) MqlID() string {
	return c.__id
}

func (c *mqlAwsFsxFilesystem) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsFsxFilesystem) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsFsxFilesystem) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsFsxFilesystem) GetLifecycle() *plugin.TValue[string] {
	return &c.Lifecycle
}

func (c *mqlAwsFsxFilesystem) GetStorageCapacity() *plugin.TValue[int64] {
	return &c.StorageCapacity
}

func (c *mqlAwsFsxFilesystem) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsFsxFilesystem) GetEncrypted() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Encrypted, func() (bool, error) {
		return c.encrypted()
	})
}

func (c *mqlAwsFsxFilesystem) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsFsxFilesystem) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsFsxFilesystem) GetSubnetIds() *plugin.TValue[[]any] {
	return &c.SubnetIds
}

func (c *mqlAwsFsxFilesystem) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsFsxFilesystem) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsFsxFilesystem) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsFsxCache for the aws.fsx.cache resource
type mqlAwsFsxCache struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsFsxCacheInternal it will be used here
	Id                         plugin.TValue[string]
	Arn                        plugin.TValue[string]
	Lifecycle                  plugin.TValue[string]
	StorageCapacity            plugin.TValue[int64]
	VpcId                      plugin.TValue[string]
	SubnetIds                  plugin.TValue[[]any]
	LustreConfiguration        plugin.TValue[any]
	DataRepositoryAssociations plugin.TValue[[]any]
	Tags                       plugin.TValue[map[string]any]
}

// createAwsFsxCache creates a new instance of this resource
func createAwsFsxCache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsFsxCache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.fsx.cache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsFsxCache) MqlName() string {
	return "aws.fsx.cache"
}

func (c *mqlAwsFsxCache) MqlID() string {
	return c.__id
}

func (c *mqlAwsFsxCache) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsFsxCache) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsFsxCache) GetLifecycle() *plugin.TValue[string] {
	return &c.Lifecycle
}

func (c *mqlAwsFsxCache) GetStorageCapacity() *plugin.TValue[int64] {
	return &c.StorageCapacity
}

func (c *mqlAwsFsxCache) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsFsxCache) GetSubnetIds() *plugin.TValue[[]any] {
	return &c.SubnetIds
}

func (c *mqlAwsFsxCache) GetLustreConfiguration() *plugin.TValue[any] {
	return &c.LustreConfiguration
}

func (c *mqlAwsFsxCache) GetDataRepositoryAssociations() *plugin.TValue[[]any] {
	return &c.DataRepositoryAssociations
}

func (c *mqlAwsFsxCache) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsFsxBackup for the aws.fsx.backup resource
type mqlAwsFsxBackup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsFsxBackupInternal it will be used here
	BackupId       plugin.TValue[string]
	Arn            plugin.TValue[string]
	Type           plugin.TValue[string]
	Lifecycle      plugin.TValue[string]
	FileSystemId   plugin.TValue[string]
	FileSystemType plugin.TValue[string]
	KmsKeyId       plugin.TValue[string]
	CreatedAt      plugin.TValue[*time.Time]
	Tags           plugin.TValue[map[string]any]
}

// createAwsFsxBackup creates a new instance of this resource
func createAwsFsxBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsFsxBackup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.fsx.backup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsFsxBackup) MqlName() string {
	return "aws.fsx.backup"
}

func (c *mqlAwsFsxBackup) MqlID() string {
	return c.__id
}

func (c *mqlAwsFsxBackup) GetBackupId() *plugin.TValue[string] {
	return &c.BackupId
}

func (c *mqlAwsFsxBackup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsFsxBackup) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsFsxBackup) GetLifecycle() *plugin.TValue[string] {
	return &c.Lifecycle
}

func (c *mqlAwsFsxBackup) GetFileSystemId() *plugin.TValue[string] {
	return &c.FileSystemId
}

func (c *mqlAwsFsxBackup) GetFileSystemType() *plugin.TValue[string] {
	return &c.FileSystemType
}

func (c *mqlAwsFsxBackup) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsFsxBackup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsFsxBackup) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsKms for the aws.kms resource
type mqlAwsKms struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsKmsInternal it will be used here
	Keys plugin.TValue[[]any]
}

// createAwsKms creates a new instance of this resource
func createAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKms) MqlName() string {
	return "aws.kms"
}

func (c *mqlAwsKms) MqlID() string {
	return c.__id
}

func (c *mqlAwsKms) GetKeys() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Keys, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.kms", c.__id, "keys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.keys()
	})
}

// mqlAwsKmsKey for the aws.kms.key resource
type mqlAwsKmsKey struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsKmsKeyInternal
	Id                 plugin.TValue[string]
	Arn                plugin.TValue[string]
	Region             plugin.TValue[string]
	KeyRotationEnabled plugin.TValue[bool]
	Metadata           plugin.TValue[any]
	Tags               plugin.TValue[map[string]any]
	Aliases            plugin.TValue[[]any]
	KeyState           plugin.TValue[string]
	CreatedAt          plugin.TValue[*time.Time]
	DeletedAt          plugin.TValue[*time.Time]
	Enabled            plugin.TValue[bool]
	Description        plugin.TValue[string]
	Grants             plugin.TValue[[]any]
}

// createAwsKmsKey creates a new instance of this resource
func createAwsKmsKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKmsKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms.key", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKmsKey) MqlName() string {
	return "aws.kms.key"
}

func (c *mqlAwsKmsKey) MqlID() string {
	return c.__id
}

func (c *mqlAwsKmsKey) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsKmsKey) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsKmsKey) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsKmsKey) GetKeyRotationEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.KeyRotationEnabled, func() (bool, error) {
		return c.keyRotationEnabled()
	})
}

func (c *mqlAwsKmsKey) GetMetadata() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Metadata, func() (any, error) {
		return c.metadata()
	})
}

func (c *mqlAwsKmsKey) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsKmsKey) GetAliases() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Aliases, func() ([]any, error) {
		return c.aliases()
	})
}

func (c *mqlAwsKmsKey) GetKeyState() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.KeyState, func() (string, error) {
		return c.keyState()
	})
}

func (c *mqlAwsKmsKey) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsKmsKey) GetDeletedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.DeletedAt, func() (*time.Time, error) {
		return c.deletedAt()
	})
}

func (c *mqlAwsKmsKey) GetEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Enabled, func() (bool, error) {
		return c.enabled()
	})
}

func (c *mqlAwsKmsKey) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsKmsKey) GetGrants() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Grants, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.kms.key", c.__id, "grants")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.grants()
	})
}

// mqlAwsKmsGrant for the aws.kms.grant resource
type mqlAwsKmsGrant struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsKmsGrantInternal it will be used here
	GrantId           plugin.TValue[string]
	KeyArn            plugin.TValue[string]
	GranteePrincipal  plugin.TValue[string]
	RetiringPrincipal plugin.TValue[string]
	IssuingAccount    plugin.TValue[string]
	Operations        plugin.TValue[[]any]
	CreatedAt         plugin.TValue[*time.Time]
}

// createAwsKmsGrant creates a new instance of this resource
func createAwsKmsGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKmsGrant{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms.grant", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKmsGrant) MqlName() string {
	return "aws.kms.grant"
}

func (c *mqlAwsKmsGrant) MqlID() string {
	return c.__id
}

func (c *mqlAwsKmsGrant) GetGrantId() *plugin.TValue[string] {
	return &c.GrantId
}

func (c *mqlAwsKmsGrant) GetKeyArn() *plugin.TValue[string] {
	return &c.KeyArn
}

func (c *mqlAwsKmsGrant) GetGranteePrincipal() *plugin.TValue[string] {
	return &c.GranteePrincipal
}

func (c *mqlAwsKmsGrant) GetRetiringPrincipal() *plugin.TValue[string] {
	return &c.RetiringPrincipal
}

func (c *mqlAwsKmsGrant) GetIssuingAccount() *plugin.TValue[string] {
	return &c.IssuingAccount
}

func (c *mqlAwsKmsGrant) GetOperations() *plugin.TValue[[]any] {
	return &c.Operations
}

func (c *mqlAwsKmsGrant) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIam for the aws.iam resource
type mqlAwsIam struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamInternal it will be used here
	Users                 plugin.TValue[[]any]
	Roles                 plugin.TValue[[]any]
	Groups                plugin.TValue[[]any]
	Policies              plugin.TValue[[]any]
	AttachedPolicies      plugin.TValue[[]any]
	CredentialReport      plugin.TValue[[]any]
	AccountPasswordPolicy plugin.TValue[any]
	AccountSummary        plugin.TValue[map[string]any]
	VirtualMfaDevices     plugin.TValue[[]any]
	ServerCertificates    plugin.TValue[[]any]
	InstanceProfiles      plugin.TValue[[]any]
	SamlProviders         plugin.TValue[[]any]
	OidcProviders         plugin.TValue[[]any]
}

// createAwsIam creates a new instance of this resource
func createAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIam{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIam) MqlName() string {
	return "aws.iam"
}

func (c *mqlAwsIam) MqlID() string {
	return c.__id
}

func (c *mqlAwsIam) GetUsers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Users, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "users")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.users()
	})
}

func (c *mqlAwsIam) GetRoles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Roles, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "roles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.roles()
	})
}

func (c *mqlAwsIam) GetGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Groups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.groups()
	})
}

func (c *mqlAwsIam) GetPolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Policies, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "policies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.policies()
	})
}

func (c *mqlAwsIam) GetAttachedPolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AttachedPolicies, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIam) GetCredentialReport() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CredentialReport, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "credentialReport")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.credentialReport()
	})
}

func (c *mqlAwsIam) GetAccountPasswordPolicy() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.AccountPasswordPolicy, func() (any, error) {
		return c.accountPasswordPolicy()
	})
}

func (c *mqlAwsIam) GetAccountSummary() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.AccountSummary, func() (map[string]any, error) {
		return c.accountSummary()
	})
}

func (c *mqlAwsIam) GetVirtualMfaDevices() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.VirtualMfaDevices, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "virtualMfaDevices")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.virtualMfaDevices()
	})
}

func (c *mqlAwsIam) GetServerCertificates() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ServerCertificates, func() ([]any, error) {
		return c.serverCertificates()
	})
}

func (c *mqlAwsIam) GetInstanceProfiles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.InstanceProfiles, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "instanceProfiles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instanceProfiles()
	})
}

func (c *mqlAwsIam) GetSamlProviders() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SamlProviders, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "samlProviders")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.samlProviders()
	})
}

func (c *mqlAwsIam) GetOidcProviders() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.OidcProviders, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "oidcProviders")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.oidcProviders()
	})
}

// mqlAwsIamUsercredentialreportentry for the aws.iam.usercredentialreportentry resource
type mqlAwsIamUsercredentialreportentry struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamUsercredentialreportentryInternal it will be used here
	Properties                plugin.TValue[map[string]any]
	Arn                       plugin.TValue[string]
	AccessKey1Active          plugin.TValue[bool]
	AccessKey1LastRotated     plugin.TValue[*time.Time]
	AccessKey1LastUsedDate    plugin.TValue[*time.Time]
	AccessKey1LastUsedRegion  plugin.TValue[string]
	AccessKey1LastUsedService plugin.TValue[string]
	AccessKey2Active          plugin.TValue[bool]
	AccessKey2LastRotated     plugin.TValue[*time.Time]
	AccessKey2LastUsedDate    plugin.TValue[*time.Time]
	AccessKey2LastUsedRegion  plugin.TValue[string]
	AccessKey2LastUsedService plugin.TValue[string]
	Cert1Active               plugin.TValue[bool]
	Cert1LastRotated          plugin.TValue[*time.Time]
	Cert2Active               plugin.TValue[bool]
	Cert2LastRotated          plugin.TValue[*time.Time]
	MfaActive                 plugin.TValue[bool]
	PasswordEnabled           plugin.TValue[bool]
	PasswordLastChanged       plugin.TValue[*time.Time]
	PasswordLastUsed          plugin.TValue[*time.Time]
	PasswordNextRotation      plugin.TValue[*time.Time]
	User                      plugin.TValue[*mqlAwsIamUser]
	CreatedAt                 plugin.TValue[*time.Time]
}

// createAwsIamUsercredentialreportentry creates a new instance of this resource
func createAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUsercredentialreportentry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.usercredentialreportentry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUsercredentialreportentry) MqlName() string {
	return "aws.iam.usercredentialreportentry"
}

func (c *mqlAwsIamUsercredentialreportentry) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUsercredentialreportentry) GetProperties() *plugin.TValue[map[string]any] {
	return &c.Properties
}

func (c *mqlAwsIamUsercredentialreportentry) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey1Active, func() (bool, error) {
		return c.accessKey1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastRotated, func() (*time.Time, error) {
		return c.accessKey1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastUsedDate, func() (*time.Time, error) {
		return c.accessKey1LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedRegion, func() (string, error) {
		return c.accessKey1LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedService, func() (string, error) {
		return c.accessKey1LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey2Active, func() (bool, error) {
		return c.accessKey2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastRotated, func() (*time.Time, error) {
		return c.accessKey2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastUsedDate, func() (*time.Time, error) {
		return c.accessKey2LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedRegion, func() (string, error) {
		return c.accessKey2LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedService, func() (string, error) {
		return c.accessKey2LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert1Active, func() (bool, error) {
		return c.cert1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert1LastRotated, func() (*time.Time, error) {
		return c.cert1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert2Active, func() (bool, error) {
		return c.cert2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert2LastRotated, func() (*time.Time, error) {
		return c.cert2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetMfaActive() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.MfaActive, func() (bool, error) {
		return c.mfaActive()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.PasswordEnabled, func() (bool, error) {
		return c.passwordEnabled()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastChanged() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastChanged, func() (*time.Time, error) {
		return c.passwordLastChanged()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastUsed, func() (*time.Time, error) {
		return c.passwordLastUsed()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordNextRotation() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordNextRotation, func() (*time.Time, error) {
		return c.passwordNextRotation()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.usercredentialreportentry", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

// mqlAwsIamUser for the aws.iam.user resource
type mqlAwsIamUser struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamUserInternal it will be used here
	Arn              plugin.TValue[string]
	Id               plugin.TValue[string]
	Name             plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	Tags             plugin.TValue[map[string]any]
	Policies         plugin.TValue[[]any]
	AttachedPolicies plugin.TValue[[]any]
	Groups           plugin.TValue[[]any]
	AccessKeys       plugin.TValue[[]any]
	LoginProfile     plugin.TValue[*mqlAwsIamLoginProfile]
}

// createAwsIamUser creates a new instance of this resource
func createAwsIamUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUser) MqlName() string {
	return "aws.iam.user"
}

func (c *mqlAwsIamUser) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUser) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamUser) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamUser) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamUser) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return &c.PasswordLastUsed
}

func (c *mqlAwsIamUser) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsIamUser) GetPolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Policies, func() ([]any, error) {
		return c.policies()
	})
}

func (c *mqlAwsIamUser) GetAttachedPolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AttachedPolicies, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIamUser) GetGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Groups, func() ([]any, error) {
		return c.groups()
	})
}

func (c *mqlAwsIamUser) GetAccessKeys() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AccessKeys, func() ([]any, error) {
		return c.accessKeys()
	})
}

func (c *mqlAwsIamUser) GetLoginProfile() *plugin.TValue[*mqlAwsIamLoginProfile] {
	return plugin.GetOrCompute[*mqlAwsIamLoginProfile](&c.LoginProfile, func() (*mqlAwsIamLoginProfile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "loginProfile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamLoginProfile), nil
			}
		}

		return c.loginProfile()
	})
}

// mqlAwsIamInstanceProfile for the aws.iam.instanceProfile resource
type mqlAwsIamInstanceProfile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsIamInstanceProfileInternal
	Arn                 plugin.TValue[string]
	CreatedAt           plugin.TValue[*time.Time]
	InstanceProfileId   plugin.TValue[string]
	InstanceProfileName plugin.TValue[string]
	Tags                plugin.TValue[map[string]any]
	IamRoles            plugin.TValue[[]any]
}

// createAwsIamInstanceProfile creates a new instance of this resource
func createAwsIamInstanceProfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamInstanceProfile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.instanceProfile", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamInstanceProfile) MqlName() string {
	return "aws.iam.instanceProfile"
}

func (c *mqlAwsIamInstanceProfile) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamInstanceProfile) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamInstanceProfile) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamInstanceProfile) GetInstanceProfileId() *plugin.TValue[string] {
	return &c.InstanceProfileId
}

func (c *mqlAwsIamInstanceProfile) GetInstanceProfileName() *plugin.TValue[string] {
	return &c.InstanceProfileName
}

func (c *mqlAwsIamInstanceProfile) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsIamInstanceProfile) GetIamRoles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.IamRoles, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.instanceProfile", c.__id, "iamRoles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.iamRoles()
	})
}

// mqlAwsIamLoginProfile for the aws.iam.loginProfile resource
type mqlAwsIamLoginProfile struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamLoginProfileInternal it will be used here
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsIamLoginProfile creates a new instance of this resource
func createAwsIamLoginProfile(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamLoginProfile{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.loginProfile", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamLoginProfile) MqlName() string {
	return "aws.iam.loginProfile"
}

func (c *mqlAwsIamLoginProfile) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamLoginProfile) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIamPolicy for the aws.iam.policy resource
type mqlAwsIamPolicy struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsIamPolicyInternal
	Arn             plugin.TValue[string]
	PolicyId        plugin.TValue[string]
	Name            plugin.TValue[string]
	Description     plugin.TValue[string]
	IsAttachable    plugin.TValue[bool]
	AttachmentCount plugin.TValue[int64]
	CreatedAt       plugin.TValue[*time.Time]
	UpdatedAt       plugin.TValue[*time.Time]
	Scope           plugin.TValue[string]
	Versions        plugin.TValue[[]any]
	DefaultVersion  plugin.TValue[*mqlAwsIamPolicyversion]
	AttachedUsers   plugin.TValue[[]any]
	AttachedRoles   plugin.TValue[[]any]
	AttachedGroups  plugin.TValue[[]any]
}

// createAwsIamPolicy creates a new instance of this resource
func createAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicy) MqlName() string {
	return "aws.iam.policy"
}

func (c *mqlAwsIamPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicy) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicy) GetPolicyId() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.PolicyId, func() (string, error) {
		return c.policyId()
	})
}

func (c *mqlAwsIamPolicy) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlAwsIamPolicy) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsIamPolicy) GetIsAttachable() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachable, func() (bool, error) {
		return c.isAttachable()
	})
}

func (c *mqlAwsIamPolicy) GetAttachmentCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.AttachmentCount, func() (int64, error) {
		return c.attachmentCount()
	})
}

func (c *mqlAwsIamPolicy) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsIamPolicy) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UpdatedAt, func() (*time.Time, error) {
		return c.updatedAt()
	})
}

func (c *mqlAwsIamPolicy) GetScope() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Scope, func() (string, error) {
		return c.scope()
	})
}

func (c *mqlAwsIamPolicy) GetVersions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Versions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "versions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.versions()
	})
}

func (c *mqlAwsIamPolicy) GetDefaultVersion() *plugin.TValue[*mqlAwsIamPolicyversion] {
	return plugin.GetOrCompute[*mqlAwsIamPolicyversion](&c.DefaultVersion, func() (*mqlAwsIamPolicyversion, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "defaultVersion")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamPolicyversion), nil
			}
		}

		return c.defaultVersion()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedUsers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AttachedUsers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedUsers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.attachedUsers()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedRoles() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AttachedRoles, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedRoles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.attachedRoles()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AttachedGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.attachedGroups()
	})
}

// mqlAwsIamPolicyversion for the aws.iam.policyversion resource
type mqlAwsIamPolicyversion struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamPolicyversionInternal it will be used here
	Arn              plugin.TValue[string]
	VersionId        plugin.TValue[string]
	IsDefaultVersion plugin.TValue[bool]
	Document         plugin.TValue[any]
	CreatedAt        plugin.TValue[*time.Time]
}

// createAwsIamPolicyversion creates a new instance of this resource
func createAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicyversion{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policyversion", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicyversion) MqlName() string {
	return "aws.iam.policyversion"
}

func (c *mqlAwsIamPolicyversion) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicyversion) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicyversion) GetVersionId() *plugin.TValue[string] {
	return &c.VersionId
}

func (c *mqlAwsIamPolicyversion) GetIsDefaultVersion() *plugin.TValue[bool] {
	return &c.IsDefaultVersion
}

func (c *mqlAwsIamPolicyversion) GetDocument() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Document, func() (any, error) {
		return c.document()
	})
}

func (c *mqlAwsIamPolicyversion) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIamRole for the aws.iam.role resource
type mqlAwsIamRole struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamRoleInternal it will be used here
	Arn                      plugin.TValue[string]
	Id                       plugin.TValue[string]
	Name                     plugin.TValue[string]
	Description              plugin.TValue[string]
	Tags                     plugin.TValue[map[string]any]
	CreatedAt                plugin.TValue[*time.Time]
	AssumeRolePolicyDocument plugin.TValue[any]
	LastUsedAt               plugin.TValue[*time.Time]
	LastUsedRegion           plugin.TValue[string]
	MaxSessionDuration       plugin.TValue[int64]
	PermissionsBoundaryArn   plugin.TValue[string]
}

// createAwsIamRole creates a new instance of this resource
func createAwsIamRole(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamRole{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.role", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamRole) MqlName() string {
	return "aws.iam.role"
}

func (c *mqlAwsIamRole) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamRole) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamRole) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamRole) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamRole) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsIamRole) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsIamRole) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamRole) GetAssumeRolePolicyDocument() *plugin.TValue[any] {
	return &c.AssumeRolePolicyDocument
}

func (c *mqlAwsIamRole) GetLastUsedAt() *plugin.TValue[*time.Time] {
	return &c.LastUsedAt
}

func (c *mqlAwsIamRole) GetLastUsedRegion() *plugin.TValue[string] {
	return &c.LastUsedRegion
}

func (c *mqlAwsIamRole) GetMaxSessionDuration() *plugin.TValue[int64] {
	return &c.MaxSessionDuration
}

func (c *mqlAwsIamRole) GetPermissionsBoundaryArn() *plugin.TValue[string] {
	return &c.PermissionsBoundaryArn
}

// mqlAwsIamGroup for the aws.iam.group resource
type mqlAwsIamGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamGroupInternal it will be used here
	Arn            plugin.TValue[string]
	Id             plugin.TValue[string]
	Name           plugin.TValue[string]
	CreatedAt      plugin.TValue[*time.Time]
	Usernames      plugin.TValue[[]any]
	InlinePolicies plugin.TValue[[]any]
}

// createAwsIamGroup creates a new instance of this resource
func createAwsIamGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamGroup) MqlName() string {
	return "aws.iam.group"
}

func (c *mqlAwsIamGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamGroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamGroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamGroup) GetUsernames() *plugin.TValue[[]any] {
	return &c.Usernames
}

func (c *mqlAwsIamGroup) GetInlinePolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.InlinePolicies, func() ([]any, error) {
		return c.inlinePolicies()
	})
}

// mqlAwsIamVirtualmfadevice for the aws.iam.virtualmfadevice resource
type mqlAwsIamVirtualmfadevice struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsIamVirtualmfadeviceInternal
	SerialNumber plugin.TValue[string]
	EnableDate   plugin.TValue[*time.Time]
	User         plugin.TValue[*mqlAwsIamUser]
}

// createAwsIamVirtualmfadevice creates a new instance of this resource
func createAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamVirtualmfadevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.virtualmfadevice", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamVirtualmfadevice) MqlName() string {
	return "aws.iam.virtualmfadevice"
}

func (c *mqlAwsIamVirtualmfadevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamVirtualmfadevice) GetSerialNumber() *plugin.TValue[string] {
	return &c.SerialNumber
}

func (c *mqlAwsIamVirtualmfadevice) GetEnableDate() *plugin.TValue[*time.Time] {
	return &c.EnableDate
}

func (c *mqlAwsIamVirtualmfadevice) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.virtualmfadevice", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

// mqlAwsIamSamlProvider for the aws.iam.samlProvider resource
type mqlAwsIamSamlProvider struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsIamSamlProviderInternal
	Arn              plugin.TValue[string]
	Name             plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	ValidUntil       plugin.TValue[*time.Time]
	MetadataDocument plugin.TValue[string]
	Tags             plugin.TValue[map[string]any]
}

// createAwsIamSamlProvider creates a new instance of this resource
func createAwsIamSamlProvider(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamSamlProvider{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.samlProvider", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamSamlProvider) MqlName() string {
	return "aws.iam.samlProvider"
}

func (c *mqlAwsIamSamlProvider) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamSamlProvider) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamSamlProvider) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlAwsIamSamlProvider) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsIamSamlProvider) GetValidUntil() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ValidUntil, func() (*time.Time, error) {
		return c.validUntil()
	})
}

func (c *mqlAwsIamSamlProvider) GetMetadataDocument() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.MetadataDocument, func() (string, error) {
		return c.metadataDocument()
	})
}

func (c *mqlAwsIamSamlProvider) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

// mqlAwsIamOidcProvider for the aws.iam.oidcProvider resource
type mqlAwsIamOidcProvider struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsIamOidcProviderInternal
	Arn         plugin.TValue[string]
	Url         plugin.TValue[string]
	ClientIds   plugin.TValue[[]any]
	Thumbprints plugin.TValue[[]any]
	CreatedAt   plugin.TValue[*time.Time]
	Tags        plugin.TValue[map[string]any]
}

// createAwsIamOidcProvider creates a new instance of this resource
func createAwsIamOidcProvider(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamOidcProvider{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.oidcProvider", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamOidcProvider) MqlName() string {
	return "aws.iam.oidcProvider"
}

func (c *mqlAwsIamOidcProvider) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamOidcProvider) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamOidcProvider) GetUrl() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Url, func() (string, error) {
		return c.url()
	})
}

func (c *mqlAwsIamOidcProvider) GetClientIds() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClientIds, func() ([]any, error) {
		return c.clientIds()
	})
}

func (c *mqlAwsIamOidcProvider) GetThumbprints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Thumbprints, func() ([]any, error) {
		return c.thumbprints()
	})
}

func (c *mqlAwsIamOidcProvider) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsIamOidcProvider) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

// mqlAwsIamAccessAnalyzer for the aws.iam.accessAnalyzer resource
type mqlAwsIamAccessAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamAccessAnalyzerInternal it will be used here
	Analyzers plugin.TValue[[]any]
	Findings  plugin.TValue[[]any]
}

// createAwsIamAccessAnalyzer creates a new instance of this resource
func createAwsIamAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessAnalyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessAnalyzer) MqlName() string {
	return "aws.iam.accessAnalyzer"
}

func (c *mqlAwsIamAccessAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessAnalyzer) GetAnalyzers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Analyzers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.accessAnalyzer", c.__id, "analyzers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.analyzers()
	})
}

func (c *mqlAwsIamAccessAnalyzer) GetFindings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Findings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.accessAnalyzer", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.findings()
	})
}

// mqlAwsIamAccessanalyzerAnalyzer for the aws.iam.accessanalyzer.analyzer resource
type mqlAwsIamAccessanalyzerAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamAccessanalyzerAnalyzerInternal it will be used here
	Arn                    plugin.TValue[string]
	Name                   plugin.TValue[string]
	Status                 plugin.TValue[string]
	Type                   plugin.TValue[string]
	Region                 plugin.TValue[string]
	Tags                   plugin.TValue[map[string]any]
	LastResourceAnalyzed   plugin.TValue[string]
	LastResourceAnalyzedAt plugin.TValue[*time.Time]
	CreatedAt              plugin.TValue[*time.Time]
}

// createAwsIamAccessanalyzerAnalyzer creates a new instance of this resource
func createAwsIamAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessanalyzerAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessanalyzer.analyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) MqlName() string {
	return "aws.iam.accessanalyzer.analyzer"
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetLastResourceAnalyzed() *plugin.TValue[string] {
	return &c.LastResourceAnalyzed
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetLastResourceAnalyzedAt() *plugin.TValue[*time.Time] {
	return &c.LastResourceAnalyzedAt
}

func (c *mqlAwsIamAccessanalyzerAnalyzer) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsIamAccessanalyzerFinding for the aws.iam.accessanalyzer.finding resource
type mqlAwsIamAccessanalyzerFinding struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsIamAccessanalyzerFindingInternal it will be used here
	Id                   plugin.TValue[string]
	Error                plugin.TValue[string]
	ResourceArn          plugin.TValue[string]
	ResourceOwnerAccount plugin.TValue[string]
	ResourceType         plugin.TValue[string]
	Type                 plugin.TValue[string]
	Status               plugin.TValue[string]
	AnalyzedAt           plugin.TValue[*time.Time]
	CreatedAt            plugin.TValue[*time.Time]
	UpdatedAt            plugin.TValue[*time.Time]
	Region               plugin.TValue[string]
	AnalyzerArn          plugin.TValue[string]
}

// createAwsIamAccessanalyzerFinding creates a new instance of this resource
func createAwsIamAccessanalyzerFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamAccessanalyzerFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.accessanalyzer.finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamAccessanalyzerFinding) MqlName() string {
	return "aws.iam.accessanalyzer.finding"
}

func (c *mqlAwsIamAccessanalyzerFinding) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamAccessanalyzerFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamAccessanalyzerFinding) GetError() *plugin.TValue[string] {
	return &c.Error
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceArn() *plugin.TValue[string] {
	return &c.ResourceArn
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceOwnerAccount() *plugin.TValue[string] {
	return &c.ResourceOwnerAccount
}

func (c *mqlAwsIamAccessanalyzerFinding) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsIamAccessanalyzerFinding) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsIamAccessanalyzerFinding) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsIamAccessanalyzerFinding) GetAnalyzedAt() *plugin.TValue[*time.Time] {
	return &c.AnalyzedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsIamAccessanalyzerFinding) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsIamAccessanalyzerFinding) GetAnalyzerArn() *plugin.TValue[string] {
	return &c.AnalyzerArn
}

// mqlAwsSagemaker for the aws.sagemaker resource
type mqlAwsSagemaker struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSagemakerInternal it will be used here
	Endpoints         plugin.TValue[[]any]
	NotebookInstances plugin.TValue[[]any]
}

// createAwsSagemaker creates a new instance of this resource
func createAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemaker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemaker) MqlName() string {
	return "aws.sagemaker"
}

func (c *mqlAwsSagemaker) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemaker) GetEndpoints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Endpoints, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsSagemaker) GetNotebookInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NotebookInstances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "notebookInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.notebookInstances()
	})
}

// mqlAwsSagemakerNotebookinstance for the aws.sagemaker.notebookinstance resource
type mqlAwsSagemakerNotebookinstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSagemakerNotebookinstanceInternal it will be used here
	Arn     plugin.TValue[string]
	Name    plugin.TValue[string]
	Details plugin.TValue[*mqlAwsSagemakerNotebookinstancedetails]
	Region  plugin.TValue[string]
	Tags    plugin.TValue[map[string]any]
}

// createAwsSagemakerNotebookinstance creates a new instance of this resource
func createAwsSagemakerNotebookinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstance) MqlName() string {
	return "aws.sagemaker.notebookinstance"
}

func (c *mqlAwsSagemakerNotebookinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerNotebookinstance) GetDetails() *plugin.TValue[*mqlAwsSagemakerNotebookinstancedetails] {
	return plugin.GetOrCompute[*mqlAwsSagemakerNotebookinstancedetails](&c.Details, func() (*mqlAwsSagemakerNotebookinstancedetails, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance", c.__id, "details")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSagemakerNotebookinstancedetails), nil
			}
		}

		return c.details()
	})
}

func (c *mqlAwsSagemakerNotebookinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerNotebookinstance) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsSagemakerNotebookinstancedetails for the aws.sagemaker.notebookinstancedetails resource
type mqlAwsSagemakerNotebookinstancedetails struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsSagemakerNotebookinstancedetailsInternal
	Arn                  plugin.TValue[string]
	KmsKey               plugin.TValue[*mqlAwsKmsKey]
	DirectInternetAccess plugin.TValue[string]
}

// createAwsSagemakerNotebookinstancedetails creates a new instance of this resource
func createAwsSagemakerNotebookinstancedetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstancedetails{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstancedetails", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstancedetails) MqlName() string {
	return "aws.sagemaker.notebookinstancedetails"
}

func (c *mqlAwsSagemakerNotebookinstancedetails) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstancedetails) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstancedetails) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstancedetails", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSagemakerNotebookinstancedetails) GetDirectInternetAccess() *plugin.TValue[string] {
	return &c.DirectInternetAccess
}

// mqlAwsSagemakerEndpoint for the aws.sagemaker.endpoint resource
type mqlAwsSagemakerEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSagemakerEndpointInternal it will be used here
	Arn    plugin.TValue[string]
	Name   plugin.TValue[string]
	Config plugin.TValue[any]
	Region plugin.TValue[string]
	Tags   plugin.TValue[map[string]any]
}

// createAwsSagemakerEndpoint creates a new instance of this resource
func createAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerEndpoint) MqlName() string {
	return "aws.sagemaker.endpoint"
}

func (c *mqlAwsSagemakerEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerEndpoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerEndpoint) GetConfig() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Config, func() (any, error) {
		return c.config()
	})
}

func (c *mqlAwsSagemakerEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerEndpoint) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsSns for the aws.sns resource
type mqlAwsSns struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSnsInternal it will be used here
	Topics plugin.TValue[[]any]
}

// createAwsSns creates a new instance of this resource
func createAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSns{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSns) MqlName() string {
	return "aws.sns"
}

func (c *mqlAwsSns) MqlID() string {
	return c.__id
}

func (c *mqlAwsSns) GetTopics() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Topics, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns", c.__id, "topics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.topics()
	})
}

// mqlAwsSnsTopic for the aws.sns.topic resource
type mqlAwsSnsTopic struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSnsTopicInternal it will be used here
	Arn              plugin.TValue[string]
	Region           plugin.TValue[string]
	Subscriptions    plugin.TValue[[]any]
	Attributes       plugin.TValue[any]
	Tags             plugin.TValue[map[string]any]
	SignatureVersion plugin.TValue[string]
}

// createAwsSnsTopic creates a new instance of this resource
func createAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsTopic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.topic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsTopic) MqlName() string {
	return "aws.sns.topic"
}

func (c *mqlAwsSnsTopic) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsTopic) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsTopic) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSnsTopic) GetSubscriptions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Subscriptions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns.topic", c.__id, "subscriptions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.subscriptions()
	})
}

func (c *mqlAwsSnsTopic) GetAttributes() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Attributes, func() (any, error) {
		return c.attributes()
	})
}

func (c *mqlAwsSnsTopic) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsSnsTopic) GetSignatureVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.SignatureVersion, func() (string, error) {
		return c.signatureVersion()
	})
}

// mqlAwsSnsSubscription for the aws.sns.subscription resource
type mqlAwsSnsSubscription struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSnsSubscriptionInternal it will be used here
	Arn      plugin.TValue[string]
	Protocol plugin.TValue[string]
}

// createAwsSnsSubscription creates a new instance of this resource
func createAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsSubscription{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.subscription", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsSubscription) MqlName() string {
	return "aws.sns.subscription"
}

func (c *mqlAwsSnsSubscription) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsSubscription) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsSubscription) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsEs for the aws.es resource
type mqlAwsEs struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEsInternal it will be used here
	Domains plugin.TValue[[]any]
}

// createAwsEs creates a new instance of this resource
func createAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEs) MqlName() string {
	return "aws.es"
}

func (c *mqlAwsEs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEs) GetDomains() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Domains, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.es", c.__id, "domains")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.domains()
	})
}

// mqlAwsEsDomain for the aws.es.domain resource
type mqlAwsEsDomain struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEsDomainInternal it will be used here
	Arn                         plugin.TValue[string]
	EncryptionAtRestEnabled     plugin.TValue[bool]
	NodeToNodeEncryptionEnabled plugin.TValue[bool]
	Name                        plugin.TValue[string]
	Endpoint                    plugin.TValue[string]
	Region                      plugin.TValue[string]
	Tags                        plugin.TValue[map[string]any]
	ElasticsearchVersion        plugin.TValue[string]
	DomainId                    plugin.TValue[string]
	DomainName                  plugin.TValue[string]
}

// createAwsEsDomain creates a new instance of this resource
func createAwsEsDomain(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEsDomain{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es.domain", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEsDomain) MqlName() string {
	return "aws.es.domain"
}

func (c *mqlAwsEsDomain) MqlID() string {
	return c.__id
}

func (c *mqlAwsEsDomain) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEsDomain) GetEncryptionAtRestEnabled() *plugin.TValue[bool] {
	return &c.EncryptionAtRestEnabled
}

func (c *mqlAwsEsDomain) GetNodeToNodeEncryptionEnabled() *plugin.TValue[bool] {
	return &c.NodeToNodeEncryptionEnabled
}

func (c *mqlAwsEsDomain) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEsDomain) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEsDomain) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEsDomain) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEsDomain) GetElasticsearchVersion() *plugin.TValue[string] {
	return &c.ElasticsearchVersion
}

func (c *mqlAwsEsDomain) GetDomainId() *plugin.TValue[string] {
	return &c.DomainId
}

func (c *mqlAwsEsDomain) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

// mqlAwsOpensearch for the aws.opensearch resource
type mqlAwsOpensearch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsOpensearchInternal it will be used here
	Domains plugin.TValue[[]any]
}

// createAwsOpensearch creates a new instance of this resource
func createAwsOpensearch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOpensearch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.opensearch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOpensearch) MqlName() string {
	return "aws.opensearch"
}

func (c *mqlAwsOpensearch) MqlID() string {
	return c.__id
}

func (c *mqlAwsOpensearch) GetDomains() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Domains, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.opensearch", c.__id, "domains")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.domains()
	})
}

// mqlAwsOpensearchDomain for the aws.opensearch.domain resource
type mqlAwsOpensearchDomain struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsOpensearchDomainInternal
	Arn                         plugin.TValue[string]
	Name                        plugin.TValue[string]
	DomainId                    plugin.TValue[string]
	Region                      plugin.TValue[string]
	EngineVersion               plugin.TValue[string]
	Endpoint                    plugin.TValue[string]
	EncryptionAtRestEnabled     plugin.TValue[bool]
	EncryptionAtRestKmsKeyId    plugin.TValue[string]
	NodeToNodeEncryptionEnabled plugin.TValue[bool]
	DedicatedMasterEnabled      plugin.TValue[bool]
	DedicatedMasterType         plugin.TValue[string]
	DedicatedMasterCount        plugin.TValue[int64]
	InstanceType                plugin.TValue[string]
	InstanceCount               plugin.TValue[int64]
	ZoneAwarenessEnabled        plugin.TValue[bool]
	AvailabilityZoneCount       plugin.TValue[int64]
	WarmEnabled                 plugin.TValue[bool]
	WarmType                    plugin.TValue[string]
	WarmCount                   plugin.TValue[int64]
	ColdStorageEnabled          plugin.TValue[bool]
	EbsEnabled                  plugin.TValue[bool]
	EbsVolumeType               plugin.TValue[string]
	EbsVolumeSize               plugin.TValue[int64]
	EbsIops                     plugin.TValue[int64]
	EbsThroughput               plugin.TValue[int64]
	VpcId                       plugin.TValue[string]
	EnforceHTTPS                plugin.TValue[bool]
	TlsSecurityPolicy           plugin.TValue[string]
	SamlEnabled                 plugin.TValue[bool]
	AnonymousAuthEnabled        plugin.TValue[bool]
	InternalUserDatabaseEnabled plugin.TValue[bool]
	AdvancedSecurityEnabled     plugin.TValue[bool]
	Processing                  plugin.TValue[bool]
	UpgradeProcessing           plugin.TValue[bool]
	CreatedAt                   plugin.TValue[*time.Time]
	AutoTuneState               plugin.TValue[string]
	AuditLogEnabled             plugin.TValue[bool]
	IpAddressType               plugin.TValue[string]
	ServiceSoftwareNewVersion   plugin.TValue[string]
	Tags                        plugin.TValue[map[string]any]
	SecurityGroups              plugin.TValue[[]any]
	Subnets                     plugin.TValue[[]any]
}

// createAwsOpensearchDomain creates a new instance of this resource
func createAwsOpensearchDomain(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOpensearchDomain{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.opensearch.domain", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOpensearchDomain) MqlName() string {
	return "aws.opensearch.domain"
}

func (c *mqlAwsOpensearchDomain) MqlID() string {
	return c.__id
}

func (c *mqlAwsOpensearchDomain) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsOpensearchDomain) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsOpensearchDomain) GetDomainId() *plugin.TValue[string] {
	return &c.DomainId
}

func (c *mqlAwsOpensearchDomain) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsOpensearchDomain) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsOpensearchDomain) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsOpensearchDomain) GetEncryptionAtRestEnabled() *plugin.TValue[bool] {
	return &c.EncryptionAtRestEnabled
}

func (c *mqlAwsOpensearchDomain) GetEncryptionAtRestKmsKeyId() *plugin.TValue[string] {
	return &c.EncryptionAtRestKmsKeyId
}

func (c *mqlAwsOpensearchDomain) GetNodeToNodeEncryptionEnabled() *plugin.TValue[bool] {
	return &c.NodeToNodeEncryptionEnabled
}

func (c *mqlAwsOpensearchDomain) GetDedicatedMasterEnabled() *plugin.TValue[bool] {
	return &c.DedicatedMasterEnabled
}

func (c *mqlAwsOpensearchDomain) GetDedicatedMasterType() *plugin.TValue[string] {
	return &c.DedicatedMasterType
}

func (c *mqlAwsOpensearchDomain) GetDedicatedMasterCount() *plugin.TValue[int64] {
	return &c.DedicatedMasterCount
}

func (c *mqlAwsOpensearchDomain) GetInstanceType() *plugin.TValue[string] {
	return &c.InstanceType
}

func (c *mqlAwsOpensearchDomain) GetInstanceCount() *plugin.TValue[int64] {
	return &c.InstanceCount
}

func (c *mqlAwsOpensearchDomain) GetZoneAwarenessEnabled() *plugin.TValue[bool] {
	return &c.ZoneAwarenessEnabled
}

func (c *mqlAwsOpensearchDomain) GetAvailabilityZoneCount() *plugin.TValue[int64] {
	return &c.AvailabilityZoneCount
}

func (c *mqlAwsOpensearchDomain) GetWarmEnabled() *plugin.TValue[bool] {
	return &c.WarmEnabled
}

func (c *mqlAwsOpensearchDomain) GetWarmType() *plugin.TValue[string] {
	return &c.WarmType
}

func (c *mqlAwsOpensearchDomain) GetWarmCount() *plugin.TValue[int64] {
	return &c.WarmCount
}

func (c *mqlAwsOpensearchDomain) GetColdStorageEnabled() *plugin.TValue[bool] {
	return &c.ColdStorageEnabled
}

func (c *mqlAwsOpensearchDomain) GetEbsEnabled() *plugin.TValue[bool] {
	return &c.EbsEnabled
}

func (c *mqlAwsOpensearchDomain) GetEbsVolumeType() *plugin.TValue[string] {
	return &c.EbsVolumeType
}

func (c *mqlAwsOpensearchDomain) GetEbsVolumeSize() *plugin.TValue[int64] {
	return &c.EbsVolumeSize
}

func (c *mqlAwsOpensearchDomain) GetEbsIops() *plugin.TValue[int64] {
	return &c.EbsIops
}

func (c *mqlAwsOpensearchDomain) GetEbsThroughput() *plugin.TValue[int64] {
	return &c.EbsThroughput
}

func (c *mqlAwsOpensearchDomain) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsOpensearchDomain) GetEnforceHTTPS() *plugin.TValue[bool] {
	return &c.EnforceHTTPS
}

func (c *mqlAwsOpensearchDomain) GetTlsSecurityPolicy() *plugin.TValue[string] {
	return &c.TlsSecurityPolicy
}

func (c *mqlAwsOpensearchDomain) GetSamlEnabled() *plugin.TValue[bool] {
	return &c.SamlEnabled
}

func (c *mqlAwsOpensearchDomain) GetAnonymousAuthEnabled() *plugin.TValue[bool] {
	return &c.AnonymousAuthEnabled
}

func (c *mqlAwsOpensearchDomain) GetInternalUserDatabaseEnabled() *plugin.TValue[bool] {
	return &c.InternalUserDatabaseEnabled
}

func (c *mqlAwsOpensearchDomain) GetAdvancedSecurityEnabled() *plugin.TValue[bool] {
	return &c.AdvancedSecurityEnabled
}

func (c *mqlAwsOpensearchDomain) GetProcessing() *plugin.TValue[bool] {
	return &c.Processing
}

func (c *mqlAwsOpensearchDomain) GetUpgradeProcessing() *plugin.TValue[bool] {
	return &c.UpgradeProcessing
}

func (c *mqlAwsOpensearchDomain) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsOpensearchDomain) GetAutoTuneState() *plugin.TValue[string] {
	return &c.AutoTuneState
}

func (c *mqlAwsOpensearchDomain) GetAuditLogEnabled() *plugin.TValue[bool] {
	return &c.AuditLogEnabled
}

func (c *mqlAwsOpensearchDomain) GetIpAddressType() *plugin.TValue[string] {
	return &c.IpAddressType
}

func (c *mqlAwsOpensearchDomain) GetServiceSoftwareNewVersion() *plugin.TValue[string] {
	return &c.ServiceSoftwareNewVersion
}

func (c *mqlAwsOpensearchDomain) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsOpensearchDomain) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.opensearch.domain", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsOpensearchDomain) GetSubnets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Subnets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.opensearch.domain", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.subnets()
	})
}

// mqlAwsAcm for the aws.acm resource
type mqlAwsAcm struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAcmInternal it will be used here
	Certificates plugin.TValue[[]any]
}

// createAwsAcm creates a new instance of this resource
func createAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcm) MqlName() string {
	return "aws.acm"
}

func (c *mqlAwsAcm) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcm) GetCertificates() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Certificates, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm", c.__id, "certificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.certificates()
	})
}

// mqlAwsAcmCertificate for the aws.acm.certificate resource
type mqlAwsAcmCertificate struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAcmCertificateInternal it will be used here
	Arn          plugin.TValue[string]
	NotBefore    plugin.TValue[*time.Time]
	NotAfter     plugin.TValue[*time.Time]
	CreatedAt    plugin.TValue[*time.Time]
	DomainName   plugin.TValue[string]
	Status       plugin.TValue[string]
	Subject      plugin.TValue[string]
	Certificate  plugin.TValue[plugin.Resource]
	Tags         plugin.TValue[map[string]any]
	KeyAlgorithm plugin.TValue[string]
	Serial       plugin.TValue[string]
	Source       plugin.TValue[string]
	Issuer       plugin.TValue[string]
	IssuedAt     plugin.TValue[*time.Time]
	ImportedAt   plugin.TValue[*time.Time]
}

// createAwsAcmCertificate creates a new instance of this resource
func createAwsAcmCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcmCertificate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm.certificate", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcmCertificate) MqlName() string {
	return "aws.acm.certificate"
}

func (c *mqlAwsAcmCertificate) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcmCertificate) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAcmCertificate) GetNotBefore() *plugin.TValue[*time.Time] {
	return &c.NotBefore
}

func (c *mqlAwsAcmCertificate) GetNotAfter() *plugin.TValue[*time.Time] {
	return &c.NotAfter
}

func (c *mqlAwsAcmCertificate) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAcmCertificate) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsAcmCertificate) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAcmCertificate) GetSubject() *plugin.TValue[string] {
	return &c.Subject
}

func (c *mqlAwsAcmCertificate) GetCertificate() *plugin.TValue[plugin.Resource] {
	return plugin.GetOrCompute[plugin.Resource](&c.Certificate, func() (plugin.Resource, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm.certificate", c.__id, "certificate")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(plugin.Resource), nil
			}
		}

		return c.certificate()
	})
}

func (c *mqlAwsAcmCertificate) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsAcmCertificate) GetKeyAlgorithm() *plugin.TValue[string] {
	return &c.KeyAlgorithm
}

func (c *mqlAwsAcmCertificate) GetSerial() *plugin.TValue[string] {
	return &c.Serial
}

func (c *mqlAwsAcmCertificate) GetSource() *plugin.TValue[string] {
	return &c.Source
}

func (c *mqlAwsAcmCertificate) GetIssuer() *plugin.TValue[string] {
	return &c.Issuer
}

func (c *mqlAwsAcmCertificate) GetIssuedAt() *plugin.TValue[*time.Time] {
	return &c.IssuedAt
}

func (c *mqlAwsAcmCertificate) GetImportedAt() *plugin.TValue[*time.Time] {
	return &c.ImportedAt
}

// mqlAwsAutoscaling for the aws.autoscaling resource
type mqlAwsAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAutoscalingInternal it will be used here
	Groups plugin.TValue[[]any]
}

// createAwsAutoscaling creates a new instance of this resource
func createAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscaling) MqlName() string {
	return "aws.autoscaling"
}

func (c *mqlAwsAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscaling) GetGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Groups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.groups()
	})
}

// mqlAwsAutoscalingGroup for the aws.autoscaling.group resource
type mqlAwsAutoscalingGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsAutoscalingGroupInternal
	Arn                              plugin.TValue[string]
	Name                             plugin.TValue[string]
	LoadBalancerNames                plugin.TValue[[]any]
	HealthCheckType                  plugin.TValue[string]
	Tags                             plugin.TValue[map[string]any]
	TagSpecifications                plugin.TValue[[]any]
	Region                           plugin.TValue[string]
	MinSize                          plugin.TValue[int64]
	MaxSize                          plugin.TValue[int64]
	DefaultCooldown                  plugin.TValue[int64]
	LaunchConfigurationName          plugin.TValue[string]
	HealthCheckGracePeriod           plugin.TValue[int64]
	CreatedAt                        plugin.TValue[*time.Time]
	MaxInstanceLifetime              plugin.TValue[int64]
	DesiredCapacity                  plugin.TValue[int64]
	AvailabilityZones                plugin.TValue[[]any]
	CapacityRebalance                plugin.TValue[bool]
	DefaultInstanceWarmup            plugin.TValue[int64]
	Instances                        plugin.TValue[[]any]
	DesiredCapacityType              plugin.TValue[string]
	WarmPoolSize                     plugin.TValue[int64]
	PredictedCapacity                plugin.TValue[int64]
	PlacementGroup                   plugin.TValue[string]
	NewInstancesProtectedFromScaleIn plugin.TValue[bool]
	TargetGroups                     plugin.TValue[[]any]
}

// createAwsAutoscalingGroup creates a new instance of this resource
func createAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscalingGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscalingGroup) MqlName() string {
	return "aws.autoscaling.group"
}

func (c *mqlAwsAutoscalingGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscalingGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAutoscalingGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAutoscalingGroup) GetLoadBalancerNames() *plugin.TValue[[]any] {
	return &c.LoadBalancerNames
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckType() *plugin.TValue[string] {
	return &c.HealthCheckType
}

func (c *mqlAwsAutoscalingGroup) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsAutoscalingGroup) GetTagSpecifications() *plugin.TValue[[]any] {
	return &c.TagSpecifications
}

func (c *mqlAwsAutoscalingGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsAutoscalingGroup) GetMinSize() *plugin.TValue[int64] {
	return &c.MinSize
}

func (c *mqlAwsAutoscalingGroup) GetMaxSize() *plugin.TValue[int64] {
	return &c.MaxSize
}

func (c *mqlAwsAutoscalingGroup) GetDefaultCooldown() *plugin.TValue[int64] {
	return &c.DefaultCooldown
}

func (c *mqlAwsAutoscalingGroup) GetLaunchConfigurationName() *plugin.TValue[string] {
	return &c.LaunchConfigurationName
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckGracePeriod() *plugin.TValue[int64] {
	return &c.HealthCheckGracePeriod
}

func (c *mqlAwsAutoscalingGroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAutoscalingGroup) GetMaxInstanceLifetime() *plugin.TValue[int64] {
	return &c.MaxInstanceLifetime
}

func (c *mqlAwsAutoscalingGroup) GetDesiredCapacity() *plugin.TValue[int64] {
	return &c.DesiredCapacity
}

func (c *mqlAwsAutoscalingGroup) GetAvailabilityZones() *plugin.TValue[[]any] {
	return &c.AvailabilityZones
}

func (c *mqlAwsAutoscalingGroup) GetCapacityRebalance() *plugin.TValue[bool] {
	return &c.CapacityRebalance
}

func (c *mqlAwsAutoscalingGroup) GetDefaultInstanceWarmup() *plugin.TValue[int64] {
	return &c.DefaultInstanceWarmup
}

func (c *mqlAwsAutoscalingGroup) GetInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Instances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling.group", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsAutoscalingGroup) GetDesiredCapacityType() *plugin.TValue[string] {
	return &c.DesiredCapacityType
}

func (c *mqlAwsAutoscalingGroup) GetWarmPoolSize() *plugin.TValue[int64] {
	return &c.WarmPoolSize
}

func (c *mqlAwsAutoscalingGroup) GetPredictedCapacity() *plugin.TValue[int64] {
	return &c.PredictedCapacity
}

func (c *mqlAwsAutoscalingGroup) GetPlacementGroup() *plugin.TValue[string] {
	return &c.PlacementGroup
}

func (c *mqlAwsAutoscalingGroup) GetNewInstancesProtectedFromScaleIn() *plugin.TValue[bool] {
	return &c.NewInstancesProtectedFromScaleIn
}

func (c *mqlAwsAutoscalingGroup) GetTargetGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.TargetGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling.group", c.__id, "targetGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.targetGroups()
	})
}

// mqlAwsAutoscalingGroupTag for the aws.autoscaling.group.tag resource
type mqlAwsAutoscalingGroupTag struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsAutoscalingGroupTagInternal it will be used here
	Key               plugin.TValue[string]
	Value             plugin.TValue[string]
	PropagateAtLaunch plugin.TValue[bool]
	ResourceId        plugin.TValue[string]
	ResourceType      plugin.TValue[string]
}

// createAwsAutoscalingGroupTag creates a new instance of this resource
func createAwsAutoscalingGroupTag(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscalingGroupTag{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling.group.tag", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscalingGroupTag) MqlName() string {
	return "aws.autoscaling.group.tag"
}

func (c *mqlAwsAutoscalingGroupTag) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscalingGroupTag) GetKey() *plugin.TValue[string] {
	return &c.Key
}

func (c *mqlAwsAutoscalingGroupTag) GetValue() *plugin.TValue[string] {
	return &c.Value
}

func (c *mqlAwsAutoscalingGroupTag) GetPropagateAtLaunch() *plugin.TValue[bool] {
	return &c.PropagateAtLaunch
}

func (c *mqlAwsAutoscalingGroupTag) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsAutoscalingGroupTag) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

// mqlAwsElb for the aws.elb resource
type mqlAwsElb struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsElbInternal it will be used here
	ClassicLoadBalancers plugin.TValue[[]any]
	LoadBalancers        plugin.TValue[[]any]
}

// createAwsElb creates a new instance of this resource
func createAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElb) MqlName() string {
	return "aws.elb"
}

func (c *mqlAwsElb) MqlID() string {
	return c.__id
}

func (c *mqlAwsElb) GetClassicLoadBalancers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClassicLoadBalancers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "classicLoadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.classicLoadBalancers()
	})
}

func (c *mqlAwsElb) GetLoadBalancers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.LoadBalancers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "loadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.loadBalancers()
	})
}

// mqlAwsElbTargetgroup for the aws.elb.targetgroup resource
type mqlAwsElbTargetgroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsElbTargetgroupInternal
	Name                       plugin.TValue[string]
	Arn                        plugin.TValue[string]
	Port                       plugin.TValue[int64]
	Protocol                   plugin.TValue[string]
	ProtocolVersion            plugin.TValue[string]
	IpAddressType              plugin.TValue[string]
	HealthCheckEnabled         plugin.TValue[bool]
	HealthCheckIntervalSeconds plugin.TValue[int64]
	HealthCheckPath            plugin.TValue[string]
	HealthCheckPort            plugin.TValue[string]
	HealthCheckProtocol        plugin.TValue[string]
	HealthCheckTimeoutSeconds  plugin.TValue[int64]
	TargetType                 plugin.TValue[string]
	UnhealthyThresholdCount    plugin.TValue[int64]
	Vpc                        plugin.TValue[*mqlAwsVpc]
	Ec2Targets                 plugin.TValue[[]any]
	LambdaTargets              plugin.TValue[[]any]
}

// createAwsElbTargetgroup creates a new instance of this resource
func createAwsElbTargetgroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbTargetgroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.targetgroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbTargetgroup) MqlName() string {
	return "aws.elb.targetgroup"
}

func (c *mqlAwsElbTargetgroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbTargetgroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbTargetgroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbTargetgroup) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsElbTargetgroup) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlAwsElbTargetgroup) GetProtocolVersion() *plugin.TValue[string] {
	return &c.ProtocolVersion
}

func (c *mqlAwsElbTargetgroup) GetIpAddressType() *plugin.TValue[string] {
	return &c.IpAddressType
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckEnabled() *plugin.TValue[bool] {
	return &c.HealthCheckEnabled
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckIntervalSeconds() *plugin.TValue[int64] {
	return &c.HealthCheckIntervalSeconds
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckPath() *plugin.TValue[string] {
	return &c.HealthCheckPath
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckPort() *plugin.TValue[string] {
	return &c.HealthCheckPort
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckProtocol() *plugin.TValue[string] {
	return &c.HealthCheckProtocol
}

func (c *mqlAwsElbTargetgroup) GetHealthCheckTimeoutSeconds() *plugin.TValue[int64] {
	return &c.HealthCheckTimeoutSeconds
}

func (c *mqlAwsElbTargetgroup) GetTargetType() *plugin.TValue[string] {
	return &c.TargetType
}

func (c *mqlAwsElbTargetgroup) GetUnhealthyThresholdCount() *plugin.TValue[int64] {
	return &c.UnhealthyThresholdCount
}

func (c *mqlAwsElbTargetgroup) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsElbTargetgroup) GetEc2Targets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Ec2Targets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "ec2Targets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ec2Targets()
	})
}

func (c *mqlAwsElbTargetgroup) GetLambdaTargets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.LambdaTargets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.targetgroup", c.__id, "lambdaTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.lambdaTargets()
	})
}

// mqlAwsElbLoadbalancer for the aws.elb.loadbalancer resource
type mqlAwsElbLoadbalancer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsElbLoadbalancerInternal it will be used here
	Arn                  plugin.TValue[string]
	DnsName              plugin.TValue[string]
	ListenerDescriptions plugin.TValue[[]any]
	Name                 plugin.TValue[string]
	Scheme               plugin.TValue[string]
	Attributes           plugin.TValue[[]any]
	VpcId                plugin.TValue[string]
	CreatedTime          plugin.TValue[*time.Time]
	CreatedAt            plugin.TValue[*time.Time]
	AvailabilityZones    plugin.TValue[[]any]
	SecurityGroups       plugin.TValue[[]any]
	HostedZoneId         plugin.TValue[string]
	Region               plugin.TValue[string]
	ElbType              plugin.TValue[string]
	Vpc                  plugin.TValue[*mqlAwsVpc]
	TargetGroups         plugin.TValue[[]any]
}

// createAwsElbLoadbalancer creates a new instance of this resource
func createAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbLoadbalancer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.loadbalancer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbLoadbalancer) MqlName() string {
	return "aws.elb.loadbalancer"
}

func (c *mqlAwsElbLoadbalancer) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbLoadbalancer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbLoadbalancer) GetDnsName() *plugin.TValue[string] {
	return &c.DnsName
}

func (c *mqlAwsElbLoadbalancer) GetListenerDescriptions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ListenerDescriptions, func() ([]any, error) {
		return c.listenerDescriptions()
	})
}

func (c *mqlAwsElbLoadbalancer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbLoadbalancer) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlAwsElbLoadbalancer) GetAttributes() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Attributes, func() ([]any, error) {
		return c.attributes()
	})
}

func (c *mqlAwsElbLoadbalancer) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsElbLoadbalancer) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsElbLoadbalancer) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsElbLoadbalancer) GetAvailabilityZones() *plugin.TValue[[]any] {
	return &c.AvailabilityZones
}

func (c *mqlAwsElbLoadbalancer) GetSecurityGroups() *plugin.TValue[[]any] {
	return &c.SecurityGroups
}

func (c *mqlAwsElbLoadbalancer) GetHostedZoneId() *plugin.TValue[string] {
	return &c.HostedZoneId
}

func (c *mqlAwsElbLoadbalancer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElbLoadbalancer) GetElbType() *plugin.TValue[string] {
	return &c.ElbType
}

func (c *mqlAwsElbLoadbalancer) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return &c.Vpc
}

func (c *mqlAwsElbLoadbalancer) GetTargetGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.TargetGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb.loadbalancer", c.__id, "targetGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.targetGroups()
	})
}

// mqlAwsCodebuild for the aws.codebuild resource
type mqlAwsCodebuild struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCodebuildInternal it will be used here
	Projects plugin.TValue[[]any]
}

// createAwsCodebuild creates a new instance of this resource
func createAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuild{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuild) MqlName() string {
	return "aws.codebuild"
}

func (c *mqlAwsCodebuild) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuild) GetProjects() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Projects, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codebuild", c.__id, "projects")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.projects()
	})
}

// mqlAwsCodebuildProject for the aws.codebuild.project resource
type mqlAwsCodebuildProject struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCodebuildProjectInternal it will be used here
	Arn         plugin.TValue[string]
	Description plugin.TValue[string]
	Name        plugin.TValue[string]
	Environment plugin.TValue[any]
	Region      plugin.TValue[string]
	Source      plugin.TValue[any]
	Tags        plugin.TValue[map[string]any]
}

// createAwsCodebuildProject creates a new instance of this resource
func createAwsCodebuildProject(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuildProject{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild.project", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuildProject) MqlName() string {
	return "aws.codebuild.project"
}

func (c *mqlAwsCodebuildProject) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuildProject) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodebuildProject) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsCodebuildProject) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCodebuildProject) GetEnvironment() *plugin.TValue[any] {
	return &c.Environment
}

func (c *mqlAwsCodebuildProject) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodebuildProject) GetSource() *plugin.TValue[any] {
	return &c.Source
}

func (c *mqlAwsCodebuildProject) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsGuardduty for the aws.guardduty resource
type mqlAwsGuardduty struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsGuarddutyInternal it will be used here
	Findings  plugin.TValue[[]any]
	Detectors plugin.TValue[[]any]
}

// createAwsGuardduty creates a new instance of this resource
func createAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuardduty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuardduty) MqlName() string {
	return "aws.guardduty"
}

func (c *mqlAwsGuardduty) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuardduty) GetFindings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Findings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlAwsGuardduty) GetDetectors() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Detectors, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "detectors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.detectors()
	})
}

// mqlAwsGuarddutyDetector for the aws.guardduty.detector resource
type mqlAwsGuarddutyDetector struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsGuarddutyDetectorInternal it will be used here
	Id                         plugin.TValue[string]
	Region                     plugin.TValue[string]
	Status                     plugin.TValue[string]
	Features                   plugin.TValue[[]any]
	Tags                       plugin.TValue[map[string]any]
	FindingPublishingFrequency plugin.TValue[string]
	Findings                   plugin.TValue[[]any]
	CreatedAt                  plugin.TValue[*time.Time]
	UpdatedAt                  plugin.TValue[*time.Time]
}

// createAwsGuarddutyDetector creates a new instance of this resource
func createAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyDetector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.detector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyDetector) MqlName() string {
	return "aws.guardduty.detector"
}

func (c *mqlAwsGuarddutyDetector) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyDetector) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyDetector) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyDetector) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFeatures() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Features, func() ([]any, error) {
		return c.features()
	})
}

func (c *mqlAwsGuarddutyDetector) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFindingPublishingFrequency() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.FindingPublishingFrequency, func() (string, error) {
		return c.findingPublishingFrequency()
	})
}

func (c *mqlAwsGuarddutyDetector) GetFindings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Findings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty.detector", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlAwsGuarddutyDetector) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsGuarddutyDetector) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UpdatedAt, func() (*time.Time, error) {
		return c.updatedAt()
	})
}

// mqlAwsGuarddutyFinding for the aws.guardduty.finding resource
type mqlAwsGuarddutyFinding struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsGuarddutyFindingInternal it will be used here
	Arn         plugin.TValue[string]
	Id          plugin.TValue[string]
	Region      plugin.TValue[string]
	Title       plugin.TValue[string]
	Description plugin.TValue[string]
	Severity    plugin.TValue[float64]
	Confidence  plugin.TValue[float64]
	Type        plugin.TValue[string]
	CreatedAt   plugin.TValue[*time.Time]
	UpdatedAt   plugin.TValue[*time.Time]
}

// createAwsGuarddutyFinding creates a new instance of this resource
func createAwsGuarddutyFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyFinding) MqlName() string {
	return "aws.guardduty.finding"
}

func (c *mqlAwsGuarddutyFinding) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyFinding) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsGuarddutyFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyFinding) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyFinding) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlAwsGuarddutyFinding) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsGuarddutyFinding) GetSeverity() *plugin.TValue[float64] {
	return &c.Severity
}

func (c *mqlAwsGuarddutyFinding) GetConfidence() *plugin.TValue[float64] {
	return &c.Confidence
}

func (c *mqlAwsGuarddutyFinding) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsGuarddutyFinding) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsGuarddutyFinding) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

// mqlAwsMacie for the aws.macie resource
type mqlAwsMacie struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsMacieInternal it will be used here
	Sessions              plugin.TValue[[]any]
	ClassificationJobs    plugin.TValue[[]any]
	Findings              plugin.TValue[[]any]
	CustomDataIdentifiers plugin.TValue[[]any]
}

// createAwsMacie creates a new instance of this resource
func createAwsMacie(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsMacie{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.macie", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsMacie) MqlName() string {
	return "aws.macie"
}

func (c *mqlAwsMacie) MqlID() string {
	return c.__id
}

func (c *mqlAwsMacie) GetSessions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Sessions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.macie", c.__id, "sessions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.sessions()
	})
}

func (c *mqlAwsMacie) GetClassificationJobs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClassificationJobs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.macie", c.__id, "classificationJobs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.classificationJobs()
	})
}

func (c *mqlAwsMacie) GetFindings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Findings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.macie", c.__id, "findings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.findings()
	})
}

func (c *mqlAwsMacie) GetCustomDataIdentifiers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CustomDataIdentifiers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.macie", c.__id, "customDataIdentifiers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.customDataIdentifiers()
	})
}

// mqlAwsMacieSession for the aws.macie.session resource
type mqlAwsMacieSession struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsMacieSessionInternal it will be used here
	Arn                        plugin.TValue[string]
	Region                     plugin.TValue[string]
	Status                     plugin.TValue[string]
	CreatedAt                  plugin.TValue[*time.Time]
	UpdatedAt                  plugin.TValue[*time.Time]
	FindingPublishingFrequency plugin.TValue[string]
	ServiceRole                plugin.TValue[string]
	S3BucketCount              plugin.TValue[int64]
}

// createAwsMacieSession creates a new instance of this resource
func createAwsMacieSession(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsMacieSession{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.macie.session", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsMacieSession) MqlName() string {
	return "aws.macie.session"
}

func (c *mqlAwsMacieSession) MqlID() string {
	return c.__id
}

func (c *mqlAwsMacieSession) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsMacieSession) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsMacieSession) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsMacieSession) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsMacieSession) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsMacieSession) GetFindingPublishingFrequency() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.FindingPublishingFrequency, func() (string, error) {
		return c.findingPublishingFrequency()
	})
}

func (c *mqlAwsMacieSession) GetServiceRole() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.ServiceRole, func() (string, error) {
		return c.serviceRole()
	})
}

func (c *mqlAwsMacieSession) GetS3BucketCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.S3BucketCount, func() (int64, error) {
		return c.s3BucketCount()
	})
}

// mqlAwsMacieClassificationJob for the aws.macie.classificationJob resource
type mqlAwsMacieClassificationJob struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsMacieClassificationJobInternal
	Arn                plugin.TValue[string]
	JobId              plugin.TValue[string]
	Name               plugin.TValue[string]
	Region             plugin.TValue[string]
	Status             plugin.TValue[string]
	JobType            plugin.TValue[string]
	CreatedAt          plugin.TValue[*time.Time]
	LastRunTime        plugin.TValue[*time.Time]
	SamplingPercentage plugin.TValue[int64]
	BucketDefinitions  plugin.TValue[[]any]
	ScheduleFrequency  plugin.TValue[any]
	Statistics         plugin.TValue[any]
	Tags               plugin.TValue[map[string]any]
}

// createAwsMacieClassificationJob creates a new instance of this resource
func createAwsMacieClassificationJob(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsMacieClassificationJob{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.macie.classificationJob", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsMacieClassificationJob) MqlName() string {
	return "aws.macie.classificationJob"
}

func (c *mqlAwsMacieClassificationJob) MqlID() string {
	return c.__id
}

func (c *mqlAwsMacieClassificationJob) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsMacieClassificationJob) GetJobId() *plugin.TValue[string] {
	return &c.JobId
}

func (c *mqlAwsMacieClassificationJob) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsMacieClassificationJob) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsMacieClassificationJob) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsMacieClassificationJob) GetJobType() *plugin.TValue[string] {
	return &c.JobType
}

func (c *mqlAwsMacieClassificationJob) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsMacieClassificationJob) GetLastRunTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.LastRunTime, func() (*time.Time, error) {
		return c.lastRunTime()
	})
}

func (c *mqlAwsMacieClassificationJob) GetSamplingPercentage() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.SamplingPercentage, func() (int64, error) {
		return c.samplingPercentage()
	})
}

func (c *mqlAwsMacieClassificationJob) GetBucketDefinitions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.BucketDefinitions, func() ([]any, error) {
		return c.bucketDefinitions()
	})
}

func (c *mqlAwsMacieClassificationJob) GetScheduleFrequency() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ScheduleFrequency, func() (any, error) {
		return c.scheduleFrequency()
	})
}

func (c *mqlAwsMacieClassificationJob) GetStatistics() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Statistics, func() (any, error) {
		return c.statistics()
	})
}

func (c *mqlAwsMacieClassificationJob) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

// mqlAwsMacieFinding for the aws.macie.finding resource
type mqlAwsMacieFinding struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsMacieFindingInternal it will be used here
	Id                    plugin.TValue[string]
	Arn                   plugin.TValue[string]
	Region                plugin.TValue[string]
	AccountId             plugin.TValue[string]
	Type                  plugin.TValue[string]
	Severity              plugin.TValue[any]
	Category              plugin.TValue[string]
	Archived              plugin.TValue[bool]
	Count                 plugin.TValue[int64]
	CreatedAt             plugin.TValue[*time.Time]
	UpdatedAt             plugin.TValue[*time.Time]
	Title                 plugin.TValue[string]
	Description           plugin.TValue[string]
	ClassificationDetails plugin.TValue[any]
	ResourcesAffected     plugin.TValue[any]
}

// createAwsMacieFinding creates a new instance of this resource
func createAwsMacieFinding(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsMacieFinding{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.macie.finding", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsMacieFinding) MqlName() string {
	return "aws.macie.finding"
}

func (c *mqlAwsMacieFinding) MqlID() string {
	return c.__id
}

func (c *mqlAwsMacieFinding) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsMacieFinding) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsMacieFinding) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsMacieFinding) GetAccountId() *plugin.TValue[string] {
	return &c.AccountId
}

func (c *mqlAwsMacieFinding) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsMacieFinding) GetSeverity() *plugin.TValue[any] {
	return &c.Severity
}

func (c *mqlAwsMacieFinding) GetCategory() *plugin.TValue[string] {
	return &c.Category
}

func (c *mqlAwsMacieFinding) GetArchived() *plugin.TValue[bool] {
	return &c.Archived
}

func (c *mqlAwsMacieFinding) GetCount() *plugin.TValue[int64] {
	return &c.Count
}

func (c *mqlAwsMacieFinding) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsMacieFinding) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsMacieFinding) GetTitle() *plugin.TValue[string] {
	return &c.Title
}

func (c *mqlAwsMacieFinding) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsMacieFinding) GetClassificationDetails() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ClassificationDetails, func() (any, error) {
		return c.classificationDetails()
	})
}

func (c *mqlAwsMacieFinding) GetResourcesAffected() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ResourcesAffected, func() (any, error) {
		return c.resourcesAffected()
	})
}

// mqlAwsMacieCustomDataIdentifier for the aws.macie.customDataIdentifier resource
type mqlAwsMacieCustomDataIdentifier struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsMacieCustomDataIdentifierInternal
	Id          plugin.TValue[string]
	Arn         plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	Regex       plugin.TValue[string]
	Keywords    plugin.TValue[[]any]
	CreatedAt   plugin.TValue[*time.Time]
	Tags        plugin.TValue[map[string]any]
}

// createAwsMacieCustomDataIdentifier creates a new instance of this resource
func createAwsMacieCustomDataIdentifier(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsMacieCustomDataIdentifier{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.macie.customDataIdentifier", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsMacieCustomDataIdentifier) MqlName() string {
	return "aws.macie.customDataIdentifier"
}

func (c *mqlAwsMacieCustomDataIdentifier) MqlID() string {
	return c.__id
}

func (c *mqlAwsMacieCustomDataIdentifier) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsMacieCustomDataIdentifier) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsMacieCustomDataIdentifier) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsMacieCustomDataIdentifier) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsMacieCustomDataIdentifier) GetRegex() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Regex, func() (string, error) {
		return c.regex()
	})
}

func (c *mqlAwsMacieCustomDataIdentifier) GetKeywords() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Keywords, func() ([]any, error) {
		return c.keywords()
	})
}

func (c *mqlAwsMacieCustomDataIdentifier) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsMacieCustomDataIdentifier) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

// mqlAwsSecurityhub for the aws.securityhub resource
type mqlAwsSecurityhub struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSecurityhubInternal it will be used here
	Hubs plugin.TValue[[]any]
}

// createAwsSecurityhub creates a new instance of this resource
func createAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhub) MqlName() string {
	return "aws.securityhub"
}

func (c *mqlAwsSecurityhub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhub) GetHubs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Hubs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.securityhub", c.__id, "hubs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.hubs()
	})
}

// mqlAwsSecurityhubHub for the aws.securityhub.hub resource
type mqlAwsSecurityhubHub struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSecurityhubHubInternal it will be used here
	Arn          plugin.TValue[string]
	SubscribedAt plugin.TValue[string]
	Region       plugin.TValue[string]
}

// createAwsSecurityhubHub creates a new instance of this resource
func createAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhubHub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub.hub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhubHub) MqlName() string {
	return "aws.securityhub.hub"
}

func (c *mqlAwsSecurityhubHub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhubHub) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecurityhubHub) GetSubscribedAt() *plugin.TValue[string] {
	return &c.SubscribedAt
}

func (c *mqlAwsSecurityhubHub) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsSecretsmanager for the aws.secretsmanager resource
type mqlAwsSecretsmanager struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSecretsmanagerInternal it will be used here
	Secrets plugin.TValue[[]any]
}

// createAwsSecretsmanager creates a new instance of this resource
func createAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanager{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanager) MqlName() string {
	return "aws.secretsmanager"
}

func (c *mqlAwsSecretsmanager) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanager) GetSecrets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Secrets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.secretsmanager", c.__id, "secrets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.secrets()
	})
}

// mqlAwsSecretsmanagerSecret for the aws.secretsmanager.secret resource
type mqlAwsSecretsmanagerSecret struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSecretsmanagerSecretInternal it will be used here
	Arn              plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	Description      plugin.TValue[string]
	KmsKey           plugin.TValue[*mqlAwsKmsKey]
	LastAccessedDate plugin.TValue[*time.Time]
	LastChangedDate  plugin.TValue[*time.Time]
	LastRotatedDate  plugin.TValue[*time.Time]
	Name             plugin.TValue[string]
	NextRotationDate plugin.TValue[*time.Time]
	OwningService    plugin.TValue[string]
	PrimaryRegion    plugin.TValue[string]
	RotationEnabled  plugin.TValue[bool]
	RotationLambda   plugin.TValue[*mqlAwsLambdaFunction]
	RotationRules    plugin.TValue[*mqlAwsSecretsmanagerSecretRotationRules]
	Tags             plugin.TValue[map[string]any]
}

// createAwsSecretsmanagerSecret creates a new instance of this resource
func createAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanagerSecret{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager.secret", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanagerSecret) MqlName() string {
	return "aws.secretsmanager.secret"
}

func (c *mqlAwsSecretsmanagerSecret) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanagerSecret) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecretsmanagerSecret) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsSecretsmanagerSecret) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsSecretsmanagerSecret) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.secretsmanager.secret", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSecretsmanagerSecret) GetLastAccessedDate() *plugin.TValue[*time.Time] {
	return &c.LastAccessedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetLastChangedDate() *plugin.TValue[*time.Time] {
	return &c.LastChangedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetLastRotatedDate() *plugin.TValue[*time.Time] {
	return &c.LastRotatedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSecretsmanagerSecret) GetNextRotationDate() *plugin.TValue[*time.Time] {
	return &c.NextRotationDate
}

func (c *mqlAwsSecretsmanagerSecret) GetOwningService() *plugin.TValue[string] {
	return &c.OwningService
}

func (c *mqlAwsSecretsmanagerSecret) GetPrimaryRegion() *plugin.TValue[string] {
	return &c.PrimaryRegion
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationEnabled() *plugin.TValue[bool] {
	return &c.RotationEnabled
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationLambda() *plugin.TValue[*mqlAwsLambdaFunction] {
	return &c.RotationLambda
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationRules() *plugin.TValue[*mqlAwsSecretsmanagerSecretRotationRules] {
	return &c.RotationRules
}

func (c *mqlAwsSecretsmanagerSecret) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsSecretsmanagerSecretRotationRules for the aws.secretsmanager.secret.rotationRules resource
type mqlAwsSecretsmanagerSecretRotationRules struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSecretsmanagerSecretRotationRulesInternal it will be used here
	AutomaticallyAfterDays plugin.TValue[int64]
	Duration               plugin.TValue[string]
	ScheduleExpression     plugin.TValue[string]
}

// createAwsSecretsmanagerSecretRotationRules creates a new instance of this resource
func createAwsSecretsmanagerSecretRotationRules(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanagerSecretRotationRules{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager.secret.rotationRules", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanagerSecretRotationRules) MqlName() string {
	return "aws.secretsmanager.secret.rotationRules"
}

func (c *mqlAwsSecretsmanagerSecretRotationRules) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanagerSecretRotationRules) GetAutomaticallyAfterDays() *plugin.TValue[int64] {
	return &c.AutomaticallyAfterDays
}

func (c *mqlAwsSecretsmanagerSecretRotationRules) GetDuration() *plugin.TValue[string] {
	return &c.Duration
}

func (c *mqlAwsSecretsmanagerSecretRotationRules) GetScheduleExpression() *plugin.TValue[string] {
	return &c.ScheduleExpression
}

// mqlAwsEcs for the aws.ecs resource
type mqlAwsEcs struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsInternal it will be used here
	Clusters           plugin.TValue[[]any]
	Containers         plugin.TValue[[]any]
	ContainerInstances plugin.TValue[[]any]
	TaskDefinitions    plugin.TValue[[]any]
}

// createAwsEcs creates a new instance of this resource
func createAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcs) MqlName() string {
	return "aws.ecs"
}

func (c *mqlAwsEcs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcs) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsEcs) GetContainers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Containers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.containers()
	})
}

func (c *mqlAwsEcs) GetContainerInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ContainerInstances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.containerInstances()
	})
}

func (c *mqlAwsEcs) GetTaskDefinitions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.TaskDefinitions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "taskDefinitions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.taskDefinitions()
	})
}

// mqlAwsEcsCluster for the aws.ecs.cluster resource
type mqlAwsEcsCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsClusterInternal it will be used here
	Arn                               plugin.TValue[string]
	Name                              plugin.TValue[string]
	Tags                              plugin.TValue[map[string]any]
	RunningTasksCount                 plugin.TValue[int64]
	PendingTasksCount                 plugin.TValue[int64]
	RegisteredContainerInstancesCount plugin.TValue[int64]
	Configuration                     plugin.TValue[any]
	Status                            plugin.TValue[string]
	Tasks                             plugin.TValue[[]any]
	ContainerInstances                plugin.TValue[[]any]
	Services                          plugin.TValue[[]any]
	Region                            plugin.TValue[string]
	ActiveServicesCount               plugin.TValue[int64]
	FargateEphemeralStorageKmsKey     plugin.TValue[*mqlAwsKmsKey]
}

// createAwsEcsCluster creates a new instance of this resource
func createAwsEcsCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsCluster) MqlName() string {
	return "aws.ecs.cluster"
}

func (c *mqlAwsEcsCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsCluster) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEcsCluster) GetRunningTasksCount() *plugin.TValue[int64] {
	return &c.RunningTasksCount
}

func (c *mqlAwsEcsCluster) GetPendingTasksCount() *plugin.TValue[int64] {
	return &c.PendingTasksCount
}

func (c *mqlAwsEcsCluster) GetRegisteredContainerInstancesCount() *plugin.TValue[int64] {
	return &c.RegisteredContainerInstancesCount
}

func (c *mqlAwsEcsCluster) GetConfiguration() *plugin.TValue[any] {
	return &c.Configuration
}

func (c *mqlAwsEcsCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsCluster) GetTasks() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Tasks, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "tasks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.tasks()
	})
}

func (c *mqlAwsEcsCluster) GetContainerInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ContainerInstances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.containerInstances()
	})
}

func (c *mqlAwsEcsCluster) GetServices() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Services, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "services")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.services()
	})
}

func (c *mqlAwsEcsCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcsCluster) GetActiveServicesCount() *plugin.TValue[int64] {
	return &c.ActiveServicesCount
}

func (c *mqlAwsEcsCluster) GetFargateEphemeralStorageKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.FargateEphemeralStorageKmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "fargateEphemeralStorageKmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.fargateEphemeralStorageKmsKey()
	})
}

// mqlAwsEcsInstance for the aws.ecs.instance resource
type mqlAwsEcsInstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsInstanceInternal it will be used here
	AgentConnected   plugin.TValue[bool]
	Id               plugin.TValue[string]
	Arn              plugin.TValue[string]
	CapacityProvider plugin.TValue[string]
	Ec2Instance      plugin.TValue[*mqlAwsEc2Instance]
	Region           plugin.TValue[string]
}

// createAwsEcsInstance creates a new instance of this resource
func createAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsInstance) MqlName() string {
	return "aws.ecs.instance"
}

func (c *mqlAwsEcsInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsInstance) GetAgentConnected() *plugin.TValue[bool] {
	return &c.AgentConnected
}

func (c *mqlAwsEcsInstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEcsInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsInstance) GetCapacityProvider() *plugin.TValue[string] {
	return &c.CapacityProvider
}

func (c *mqlAwsEcsInstance) GetEc2Instance() *plugin.TValue[*mqlAwsEc2Instance] {
	return plugin.GetOrCompute[*mqlAwsEc2Instance](&c.Ec2Instance, func() (*mqlAwsEc2Instance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.instance", c.__id, "ec2Instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Instance), nil
			}
		}

		return c.ec2Instance()
	})
}

func (c *mqlAwsEcsInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsTask for the aws.ecs.task resource
type mqlAwsEcsTask struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEcsTaskInternal
	Arn             plugin.TValue[string]
	ClusterName     plugin.TValue[string]
	Connectivity    plugin.TValue[any]
	LastStatus      plugin.TValue[string]
	PlatformFamily  plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Tags            plugin.TValue[map[string]any]
	Containers      plugin.TValue[[]any]
}

// createAwsEcsTask creates a new instance of this resource
func createAwsEcsTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTask{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.task", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTask) MqlName() string {
	return "aws.ecs.task"
}

func (c *mqlAwsEcsTask) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTask) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTask) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsTask) GetConnectivity() *plugin.TValue[any] {
	return &c.Connectivity
}

func (c *mqlAwsEcsTask) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsEcsTask) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsTask) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsTask) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEcsTask) GetContainers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Containers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.task", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.containers()
	})
}

// mqlAwsEcsContainer for the aws.ecs.container resource
type mqlAwsEcsContainer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsContainerInternal it will be used here
	Name              plugin.TValue[string]
	Arn               plugin.TValue[string]
	PublicIp          plugin.TValue[string]
	Image             plugin.TValue[string]
	ClusterName       plugin.TValue[string]
	TaskDefinitionArn plugin.TValue[string]
	LogDriver         plugin.TValue[string]
	PlatformFamily    plugin.TValue[string]
	PlatformVersion   plugin.TValue[string]
	Status            plugin.TValue[string]
	Region            plugin.TValue[string]
	Command           plugin.TValue[[]any]
	TaskArn           plugin.TValue[string]
	RuntimeId         plugin.TValue[string]
	ContainerName     plugin.TValue[string]
	CpuUnits          plugin.TValue[string]
	MemorySoftLimit   plugin.TValue[string]
	MemoryHardLimit   plugin.TValue[string]
	Reason            plugin.TValue[string]
}

// createAwsEcsContainer creates a new instance of this resource
func createAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsContainer) MqlName() string {
	return "aws.ecs.container"
}

func (c *mqlAwsEcsContainer) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsContainer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsContainer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsContainer) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEcsContainer) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlAwsEcsContainer) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsContainer) GetTaskDefinitionArn() *plugin.TValue[string] {
	return &c.TaskDefinitionArn
}

func (c *mqlAwsEcsContainer) GetLogDriver() *plugin.TValue[string] {
	return &c.LogDriver
}

func (c *mqlAwsEcsContainer) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsContainer) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsContainer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsContainer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcsContainer) GetCommand() *plugin.TValue[[]any] {
	return &c.Command
}

func (c *mqlAwsEcsContainer) GetTaskArn() *plugin.TValue[string] {
	return &c.TaskArn
}

func (c *mqlAwsEcsContainer) GetRuntimeId() *plugin.TValue[string] {
	return &c.RuntimeId
}

func (c *mqlAwsEcsContainer) GetContainerName() *plugin.TValue[string] {
	return &c.ContainerName
}

func (c *mqlAwsEcsContainer) GetCpuUnits() *plugin.TValue[string] {
	return &c.CpuUnits
}

func (c *mqlAwsEcsContainer) GetMemorySoftLimit() *plugin.TValue[string] {
	return &c.MemorySoftLimit
}

func (c *mqlAwsEcsContainer) GetMemoryHardLimit() *plugin.TValue[string] {
	return &c.MemoryHardLimit
}

func (c *mqlAwsEcsContainer) GetReason() *plugin.TValue[string] {
	return &c.Reason
}

// mqlAwsEcsTaskDefinition for the aws.ecs.taskDefinition resource
type mqlAwsEcsTaskDefinition struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionInternal it will be used here
	Arn                  plugin.TValue[string]
	Family               plugin.TValue[string]
	Revision             plugin.TValue[int64]
	Status               plugin.TValue[string]
	NetworkMode          plugin.TValue[string]
	PidMode              plugin.TValue[string]
	IpcMode              plugin.TValue[string]
	TaskRoleArn          plugin.TValue[string]
	ExecutionRoleArn     plugin.TValue[string]
	ContainerDefinitions plugin.TValue[[]any]
	Volumes              plugin.TValue[[]any]
	EphemeralStorage     plugin.TValue[*mqlAwsEcsTaskDefinitionEphemeralStorage]
	Tags                 plugin.TValue[map[string]any]
	Region               plugin.TValue[string]
}

// createAwsEcsTaskDefinition creates a new instance of this resource
func createAwsEcsTaskDefinition(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinition{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinition) MqlName() string {
	return "aws.ecs.taskDefinition"
}

func (c *mqlAwsEcsTaskDefinition) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinition) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTaskDefinition) GetFamily() *plugin.TValue[string] {
	return &c.Family
}

func (c *mqlAwsEcsTaskDefinition) GetRevision() *plugin.TValue[int64] {
	return &c.Revision
}

func (c *mqlAwsEcsTaskDefinition) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsTaskDefinition) GetNetworkMode() *plugin.TValue[string] {
	return &c.NetworkMode
}

func (c *mqlAwsEcsTaskDefinition) GetPidMode() *plugin.TValue[string] {
	return &c.PidMode
}

func (c *mqlAwsEcsTaskDefinition) GetIpcMode() *plugin.TValue[string] {
	return &c.IpcMode
}

func (c *mqlAwsEcsTaskDefinition) GetTaskRoleArn() *plugin.TValue[string] {
	return &c.TaskRoleArn
}

func (c *mqlAwsEcsTaskDefinition) GetExecutionRoleArn() *plugin.TValue[string] {
	return &c.ExecutionRoleArn
}

func (c *mqlAwsEcsTaskDefinition) GetContainerDefinitions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ContainerDefinitions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition", c.__id, "containerDefinitions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.containerDefinitions()
	})
}

func (c *mqlAwsEcsTaskDefinition) GetVolumes() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Volumes, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition", c.__id, "volumes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.volumes()
	})
}

func (c *mqlAwsEcsTaskDefinition) GetEphemeralStorage() *plugin.TValue[*mqlAwsEcsTaskDefinitionEphemeralStorage] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionEphemeralStorage](&c.EphemeralStorage, func() (*mqlAwsEcsTaskDefinitionEphemeralStorage, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition", c.__id, "ephemeralStorage")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionEphemeralStorage), nil
			}
		}

		return c.ephemeralStorage()
	})
}

func (c *mqlAwsEcsTaskDefinition) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEcsTaskDefinition) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsService for the aws.ecs.service resource
type mqlAwsEcsService struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsServiceInternal it will be used here
	Arn                     plugin.TValue[string]
	Name                    plugin.TValue[string]
	ClusterArn              plugin.TValue[string]
	Status                  plugin.TValue[string]
	DesiredCount            plugin.TValue[int64]
	RunningCount            plugin.TValue[int64]
	TaskDefinition          plugin.TValue[string]
	LaunchType              plugin.TValue[string]
	DeploymentConfiguration plugin.TValue[*mqlAwsEcsServiceDeploymentConfiguration]
	NetworkConfiguration    plugin.TValue[*mqlAwsEcsServiceNetworkConfiguration]
	Tags                    plugin.TValue[map[string]any]
	CreatedAt               plugin.TValue[*time.Time]
	CreatedBy               plugin.TValue[string]
	TaskSets                plugin.TValue[[]any]
}

// createAwsEcsService creates a new instance of this resource
func createAwsEcsService(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsService{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.service", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsService) MqlName() string {
	return "aws.ecs.service"
}

func (c *mqlAwsEcsService) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsService) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsService) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsService) GetClusterArn() *plugin.TValue[string] {
	return &c.ClusterArn
}

func (c *mqlAwsEcsService) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsService) GetDesiredCount() *plugin.TValue[int64] {
	return &c.DesiredCount
}

func (c *mqlAwsEcsService) GetRunningCount() *plugin.TValue[int64] {
	return &c.RunningCount
}

func (c *mqlAwsEcsService) GetTaskDefinition() *plugin.TValue[string] {
	return &c.TaskDefinition
}

func (c *mqlAwsEcsService) GetLaunchType() *plugin.TValue[string] {
	return &c.LaunchType
}

func (c *mqlAwsEcsService) GetDeploymentConfiguration() *plugin.TValue[*mqlAwsEcsServiceDeploymentConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsServiceDeploymentConfiguration](&c.DeploymentConfiguration, func() (*mqlAwsEcsServiceDeploymentConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.service", c.__id, "deploymentConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsServiceDeploymentConfiguration), nil
			}
		}

		return c.deploymentConfiguration()
	})
}

func (c *mqlAwsEcsService) GetNetworkConfiguration() *plugin.TValue[*mqlAwsEcsServiceNetworkConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsServiceNetworkConfiguration](&c.NetworkConfiguration, func() (*mqlAwsEcsServiceNetworkConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.service", c.__id, "networkConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsServiceNetworkConfiguration), nil
			}
		}

		return c.networkConfiguration()
	})
}

func (c *mqlAwsEcsService) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEcsService) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEcsService) GetCreatedBy() *plugin.TValue[string] {
	return &c.CreatedBy
}

func (c *mqlAwsEcsService) GetTaskSets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.TaskSets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.service", c.__id, "taskSets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.taskSets()
	})
}

// mqlAwsEcsTaskSet for the aws.ecs.taskSet resource
type mqlAwsEcsTaskSet struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskSetInternal it will be used here
	Arn                  plugin.TValue[string]
	Id                   plugin.TValue[string]
	ClusterArn           plugin.TValue[string]
	ServiceArn           plugin.TValue[string]
	Status               plugin.TValue[string]
	TaskDefinition       plugin.TValue[string]
	LaunchType           plugin.TValue[string]
	PlatformVersion      plugin.TValue[string]
	PlatformFamily       plugin.TValue[string]
	NetworkConfiguration plugin.TValue[*mqlAwsEcsTaskSetNetworkConfiguration]
	Tags                 plugin.TValue[map[string]any]
	CreatedAt            plugin.TValue[*time.Time]
	UpdatedAt            plugin.TValue[*time.Time]
	RunningCount         plugin.TValue[int64]
	PendingCount         plugin.TValue[int64]
	ComputedDesiredCount plugin.TValue[int64]
	StabilityStatus      plugin.TValue[string]
	ExternalId           plugin.TValue[string]
	StartedBy            plugin.TValue[string]
}

// createAwsEcsTaskSet creates a new instance of this resource
func createAwsEcsTaskSet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskSet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskSet", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskSet) MqlName() string {
	return "aws.ecs.taskSet"
}

func (c *mqlAwsEcsTaskSet) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskSet) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTaskSet) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEcsTaskSet) GetClusterArn() *plugin.TValue[string] {
	return &c.ClusterArn
}

func (c *mqlAwsEcsTaskSet) GetServiceArn() *plugin.TValue[string] {
	return &c.ServiceArn
}

func (c *mqlAwsEcsTaskSet) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsTaskSet) GetTaskDefinition() *plugin.TValue[string] {
	return &c.TaskDefinition
}

func (c *mqlAwsEcsTaskSet) GetLaunchType() *plugin.TValue[string] {
	return &c.LaunchType
}

func (c *mqlAwsEcsTaskSet) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsTaskSet) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsTaskSet) GetNetworkConfiguration() *plugin.TValue[*mqlAwsEcsTaskSetNetworkConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskSetNetworkConfiguration](&c.NetworkConfiguration, func() (*mqlAwsEcsTaskSetNetworkConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskSet", c.__id, "networkConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskSetNetworkConfiguration), nil
			}
		}

		return c.networkConfiguration()
	})
}

func (c *mqlAwsEcsTaskSet) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEcsTaskSet) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEcsTaskSet) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsEcsTaskSet) GetRunningCount() *plugin.TValue[int64] {
	return &c.RunningCount
}

func (c *mqlAwsEcsTaskSet) GetPendingCount() *plugin.TValue[int64] {
	return &c.PendingCount
}

func (c *mqlAwsEcsTaskSet) GetComputedDesiredCount() *plugin.TValue[int64] {
	return &c.ComputedDesiredCount
}

func (c *mqlAwsEcsTaskSet) GetStabilityStatus() *plugin.TValue[string] {
	return &c.StabilityStatus
}

func (c *mqlAwsEcsTaskSet) GetExternalId() *plugin.TValue[string] {
	return &c.ExternalId
}

func (c *mqlAwsEcsTaskSet) GetStartedBy() *plugin.TValue[string] {
	return &c.StartedBy
}

// mqlAwsEcsTaskSetNetworkConfiguration for the aws.ecs.taskSet.networkConfiguration resource
type mqlAwsEcsTaskSetNetworkConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskSetNetworkConfigurationInternal it will be used here
	AssignPublicIp plugin.TValue[string]
	Subnets        plugin.TValue[[]any]
	SecurityGroups plugin.TValue[[]any]
}

// createAwsEcsTaskSetNetworkConfiguration creates a new instance of this resource
func createAwsEcsTaskSetNetworkConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskSetNetworkConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskSet.networkConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskSetNetworkConfiguration) MqlName() string {
	return "aws.ecs.taskSet.networkConfiguration"
}

func (c *mqlAwsEcsTaskSetNetworkConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskSetNetworkConfiguration) GetAssignPublicIp() *plugin.TValue[string] {
	return &c.AssignPublicIp
}

func (c *mqlAwsEcsTaskSetNetworkConfiguration) GetSubnets() *plugin.TValue[[]any] {
	return &c.Subnets
}

func (c *mqlAwsEcsTaskSetNetworkConfiguration) GetSecurityGroups() *plugin.TValue[[]any] {
	return &c.SecurityGroups
}

// mqlAwsEcsServiceDeploymentConfiguration for the aws.ecs.service.deploymentConfiguration resource
type mqlAwsEcsServiceDeploymentConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsServiceDeploymentConfigurationInternal it will be used here
	MaximumPercent           plugin.TValue[int64]
	MinimumHealthyPercent    plugin.TValue[int64]
	DeploymentCircuitBreaker plugin.TValue[*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker]
	Alarms                   plugin.TValue[any]
	BakeTimeInMinutes        plugin.TValue[int64]
	CanaryConfiguration      plugin.TValue[any]
	LifecycleHooks           plugin.TValue[any]
	LinearConfiguration      plugin.TValue[any]
	Strategy                 plugin.TValue[string]
}

// createAwsEcsServiceDeploymentConfiguration creates a new instance of this resource
func createAwsEcsServiceDeploymentConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsServiceDeploymentConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.service.deploymentConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) MqlName() string {
	return "aws.ecs.service.deploymentConfiguration"
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetMaximumPercent() *plugin.TValue[int64] {
	return &c.MaximumPercent
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetMinimumHealthyPercent() *plugin.TValue[int64] {
	return &c.MinimumHealthyPercent
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetDeploymentCircuitBreaker() *plugin.TValue[*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker] {
	return plugin.GetOrCompute[*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker](&c.DeploymentCircuitBreaker, func() (*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.service.deploymentConfiguration", c.__id, "deploymentCircuitBreaker")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker), nil
			}
		}

		return c.deploymentCircuitBreaker()
	})
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetAlarms() *plugin.TValue[any] {
	return &c.Alarms
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetBakeTimeInMinutes() *plugin.TValue[int64] {
	return &c.BakeTimeInMinutes
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetCanaryConfiguration() *plugin.TValue[any] {
	return &c.CanaryConfiguration
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetLifecycleHooks() *plugin.TValue[any] {
	return &c.LifecycleHooks
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetLinearConfiguration() *plugin.TValue[any] {
	return &c.LinearConfiguration
}

func (c *mqlAwsEcsServiceDeploymentConfiguration) GetStrategy() *plugin.TValue[string] {
	return &c.Strategy
}

// mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker for the aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker resource
type mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerInternal it will be used here
	Enable   plugin.TValue[bool]
	Rollback plugin.TValue[bool]
}

// createAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker creates a new instance of this resource
func createAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker) MqlName() string {
	return "aws.ecs.service.deploymentConfiguration.deploymentCircuitBreaker"
}

func (c *mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker) GetEnable() *plugin.TValue[bool] {
	return &c.Enable
}

func (c *mqlAwsEcsServiceDeploymentConfigurationDeploymentCircuitBreaker) GetRollback() *plugin.TValue[bool] {
	return &c.Rollback
}

// mqlAwsEcsServiceNetworkConfiguration for the aws.ecs.service.networkConfiguration resource
type mqlAwsEcsServiceNetworkConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsServiceNetworkConfigurationInternal it will be used here
	AwsVpcConfiguration plugin.TValue[*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration]
}

// createAwsEcsServiceNetworkConfiguration creates a new instance of this resource
func createAwsEcsServiceNetworkConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsServiceNetworkConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.service.networkConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsServiceNetworkConfiguration) MqlName() string {
	return "aws.ecs.service.networkConfiguration"
}

func (c *mqlAwsEcsServiceNetworkConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsServiceNetworkConfiguration) GetAwsVpcConfiguration() *plugin.TValue[*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration](&c.AwsVpcConfiguration, func() (*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.service.networkConfiguration", c.__id, "awsVpcConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration), nil
			}
		}

		return c.awsVpcConfiguration()
	})
}

// mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration for the aws.ecs.service.networkConfiguration.awsVpcConfiguration resource
type mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsServiceNetworkConfigurationAwsVpcConfigurationInternal it will be used here
	Subnets        plugin.TValue[[]any]
	SecurityGroups plugin.TValue[[]any]
	AssignPublicIp plugin.TValue[string]
}

// createAwsEcsServiceNetworkConfigurationAwsVpcConfiguration creates a new instance of this resource
func createAwsEcsServiceNetworkConfigurationAwsVpcConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.service.networkConfiguration.awsVpcConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration) MqlName() string {
	return "aws.ecs.service.networkConfiguration.awsVpcConfiguration"
}

func (c *mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration) GetSubnets() *plugin.TValue[[]any] {
	return &c.Subnets
}

func (c *mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration) GetSecurityGroups() *plugin.TValue[[]any] {
	return &c.SecurityGroups
}

func (c *mqlAwsEcsServiceNetworkConfigurationAwsVpcConfiguration) GetAssignPublicIp() *plugin.TValue[string] {
	return &c.AssignPublicIp
}

// mqlAwsEcsTaskDefinitionContainerDefinition for the aws.ecs.taskDefinition.containerDefinition resource
type mqlAwsEcsTaskDefinitionContainerDefinition struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionContainerDefinitionInternal it will be used here
	Name                   plugin.TValue[string]
	Image                  plugin.TValue[string]
	Privileged             plugin.TValue[bool]
	ReadonlyRootFilesystem plugin.TValue[bool]
	User                   plugin.TValue[string]
	Environment            plugin.TValue[[]any]
	Secrets                plugin.TValue[[]any]
	LogConfiguration       plugin.TValue[*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration]
	Memory                 plugin.TValue[int64]
	Cpu                    plugin.TValue[int64]
	PortMappings           plugin.TValue[[]any]
}

// createAwsEcsTaskDefinitionContainerDefinition creates a new instance of this resource
func createAwsEcsTaskDefinitionContainerDefinition(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionContainerDefinition{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.containerDefinition", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) MqlName() string {
	return "aws.ecs.taskDefinition.containerDefinition"
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetPrivileged() *plugin.TValue[bool] {
	return &c.Privileged
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetReadonlyRootFilesystem() *plugin.TValue[bool] {
	return &c.ReadonlyRootFilesystem
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetUser() *plugin.TValue[string] {
	return &c.User
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetEnvironment() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Environment, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.containerDefinition", c.__id, "environment")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.environment()
	})
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetSecrets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Secrets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.containerDefinition", c.__id, "secrets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.secrets()
	})
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetLogConfiguration() *plugin.TValue[*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration](&c.LogConfiguration, func() (*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.containerDefinition", c.__id, "logConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration), nil
			}
		}

		return c.logConfiguration()
	})
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetMemory() *plugin.TValue[int64] {
	return &c.Memory
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetCpu() *plugin.TValue[int64] {
	return &c.Cpu
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinition) GetPortMappings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PortMappings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.containerDefinition", c.__id, "portMappings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.portMappings()
	})
}

// mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable for the aws.ecs.taskDefinition.containerDefinition.environmentVariable resource
type mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariableInternal it will be used here
	Name  plugin.TValue[string]
	Value plugin.TValue[string]
}

// createAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable creates a new instance of this resource
func createAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.containerDefinition.environmentVariable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable) MqlName() string {
	return "aws.ecs.taskDefinition.containerDefinition.environmentVariable"
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionEnvironmentVariable) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlAwsEcsTaskDefinitionContainerDefinitionSecret for the aws.ecs.taskDefinition.containerDefinition.secret resource
type mqlAwsEcsTaskDefinitionContainerDefinitionSecret struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionContainerDefinitionSecretInternal it will be used here
	Name      plugin.TValue[string]
	ValueFrom plugin.TValue[string]
}

// createAwsEcsTaskDefinitionContainerDefinitionSecret creates a new instance of this resource
func createAwsEcsTaskDefinitionContainerDefinitionSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionContainerDefinitionSecret{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.containerDefinition.secret", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionSecret) MqlName() string {
	return "aws.ecs.taskDefinition.containerDefinition.secret"
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionSecret) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionSecret) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionSecret) GetValueFrom() *plugin.TValue[string] {
	return &c.ValueFrom
}

// mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration for the aws.ecs.taskDefinition.containerDefinition.logConfiguration resource
type mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionContainerDefinitionLogConfigurationInternal it will be used here
	LogDriver plugin.TValue[string]
	Options   plugin.TValue[map[string]any]
}

// createAwsEcsTaskDefinitionContainerDefinitionLogConfiguration creates a new instance of this resource
func createAwsEcsTaskDefinitionContainerDefinitionLogConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.containerDefinition.logConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration) MqlName() string {
	return "aws.ecs.taskDefinition.containerDefinition.logConfiguration"
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration) GetLogDriver() *plugin.TValue[string] {
	return &c.LogDriver
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionLogConfiguration) GetOptions() *plugin.TValue[map[string]any] {
	return &c.Options
}

// mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping for the aws.ecs.taskDefinition.containerDefinition.portMapping resource
type mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionContainerDefinitionPortMappingInternal it will be used here
	ContainerPort plugin.TValue[int64]
	HostPort      plugin.TValue[int64]
	Protocol      plugin.TValue[string]
}

// createAwsEcsTaskDefinitionContainerDefinitionPortMapping creates a new instance of this resource
func createAwsEcsTaskDefinitionContainerDefinitionPortMapping(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.containerDefinition.portMapping", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping) MqlName() string {
	return "aws.ecs.taskDefinition.containerDefinition.portMapping"
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping) GetContainerPort() *plugin.TValue[int64] {
	return &c.ContainerPort
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping) GetHostPort() *plugin.TValue[int64] {
	return &c.HostPort
}

func (c *mqlAwsEcsTaskDefinitionContainerDefinitionPortMapping) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsEcsTaskDefinitionVolume for the aws.ecs.taskDefinition.volume resource
type mqlAwsEcsTaskDefinitionVolume struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionVolumeInternal it will be used here
	Name                      plugin.TValue[string]
	EfsVolumeConfiguration    plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration]
	Host                      plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeHost]
	DockerVolumeConfiguration plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration]
}

// createAwsEcsTaskDefinitionVolume creates a new instance of this resource
func createAwsEcsTaskDefinitionVolume(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionVolume{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.volume", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionVolume) MqlName() string {
	return "aws.ecs.taskDefinition.volume"
}

func (c *mqlAwsEcsTaskDefinitionVolume) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionVolume) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsTaskDefinitionVolume) GetEfsVolumeConfiguration() *plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration](&c.EfsVolumeConfiguration, func() (*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.volume", c.__id, "efsVolumeConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration), nil
			}
		}

		return c.efsVolumeConfiguration()
	})
}

func (c *mqlAwsEcsTaskDefinitionVolume) GetHost() *plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeHost] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionVolumeHost](&c.Host, func() (*mqlAwsEcsTaskDefinitionVolumeHost, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.volume", c.__id, "host")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionVolumeHost), nil
			}
		}

		return c.host()
	})
}

func (c *mqlAwsEcsTaskDefinitionVolume) GetDockerVolumeConfiguration() *plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration](&c.DockerVolumeConfiguration, func() (*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.volume", c.__id, "dockerVolumeConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration), nil
			}
		}

		return c.dockerVolumeConfiguration()
	})
}

// mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration for the aws.ecs.taskDefinition.volume.efsVolumeConfiguration resource
type mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationInternal it will be used here
	FileSystemId          plugin.TValue[string]
	RootDirectory         plugin.TValue[string]
	TransitEncryption     plugin.TValue[string]
	TransitEncryptionPort plugin.TValue[int64]
	AuthorizationConfig   plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig]
}

// createAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration creates a new instance of this resource
func createAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.volume.efsVolumeConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) MqlName() string {
	return "aws.ecs.taskDefinition.volume.efsVolumeConfiguration"
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) GetFileSystemId() *plugin.TValue[string] {
	return &c.FileSystemId
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) GetRootDirectory() *plugin.TValue[string] {
	return &c.RootDirectory
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) GetTransitEncryption() *plugin.TValue[string] {
	return &c.TransitEncryption
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) GetTransitEncryptionPort() *plugin.TValue[int64] {
	return &c.TransitEncryptionPort
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfiguration) GetAuthorizationConfig() *plugin.TValue[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig] {
	return plugin.GetOrCompute[*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig](&c.AuthorizationConfig, func() (*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.taskDefinition.volume.efsVolumeConfiguration", c.__id, "authorizationConfig")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig), nil
			}
		}

		return c.authorizationConfig()
	})
}

// mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig for the aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig resource
type mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigInternal it will be used here
	AccessPointId plugin.TValue[string]
	Iam           plugin.TValue[string]
}

// createAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig creates a new instance of this resource
func createAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig) MqlName() string {
	return "aws.ecs.taskDefinition.volume.efsVolumeConfiguration.authorizationConfig"
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig) GetAccessPointId() *plugin.TValue[string] {
	return &c.AccessPointId
}

func (c *mqlAwsEcsTaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig) GetIam() *plugin.TValue[string] {
	return &c.Iam
}

// mqlAwsEcsTaskDefinitionVolumeHost for the aws.ecs.taskDefinition.volume.host resource
type mqlAwsEcsTaskDefinitionVolumeHost struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionVolumeHostInternal it will be used here
	SourcePath plugin.TValue[string]
}

// createAwsEcsTaskDefinitionVolumeHost creates a new instance of this resource
func createAwsEcsTaskDefinitionVolumeHost(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionVolumeHost{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.volume.host", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionVolumeHost) MqlName() string {
	return "aws.ecs.taskDefinition.volume.host"
}

func (c *mqlAwsEcsTaskDefinitionVolumeHost) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionVolumeHost) GetSourcePath() *plugin.TValue[string] {
	return &c.SourcePath
}

// mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration for the aws.ecs.taskDefinition.volume.dockerVolumeConfiguration resource
type mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfigurationInternal it will be used here
	Scope         plugin.TValue[string]
	Autoprovision plugin.TValue[bool]
	Driver        plugin.TValue[string]
	DriverOpts    plugin.TValue[map[string]any]
	Labels        plugin.TValue[map[string]any]
}

// createAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration creates a new instance of this resource
func createAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.volume.dockerVolumeConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) MqlName() string {
	return "aws.ecs.taskDefinition.volume.dockerVolumeConfiguration"
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) GetScope() *plugin.TValue[string] {
	return &c.Scope
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) GetAutoprovision() *plugin.TValue[bool] {
	return &c.Autoprovision
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) GetDriver() *plugin.TValue[string] {
	return &c.Driver
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) GetDriverOpts() *plugin.TValue[map[string]any] {
	return &c.DriverOpts
}

func (c *mqlAwsEcsTaskDefinitionVolumeDockerVolumeConfiguration) GetLabels() *plugin.TValue[map[string]any] {
	return &c.Labels
}

// mqlAwsEcsTaskDefinitionEphemeralStorage for the aws.ecs.taskDefinition.ephemeralStorage resource
type mqlAwsEcsTaskDefinitionEphemeralStorage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcsTaskDefinitionEphemeralStorageInternal it will be used here
	SizeInGiB plugin.TValue[int64]
}

// createAwsEcsTaskDefinitionEphemeralStorage creates a new instance of this resource
func createAwsEcsTaskDefinitionEphemeralStorage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTaskDefinitionEphemeralStorage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.taskDefinition.ephemeralStorage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTaskDefinitionEphemeralStorage) MqlName() string {
	return "aws.ecs.taskDefinition.ephemeralStorage"
}

func (c *mqlAwsEcsTaskDefinitionEphemeralStorage) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTaskDefinitionEphemeralStorage) GetSizeInGiB() *plugin.TValue[int64] {
	return &c.SizeInGiB
}

// mqlAwsEmr for the aws.emr resource
type mqlAwsEmr struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEmrInternal it will be used here
	Clusters plugin.TValue[[]any]
}

// createAwsEmr creates a new instance of this resource
func createAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmr) MqlName() string {
	return "aws.emr"
}

func (c *mqlAwsEmr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmr) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.emr", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEmrCluster for the aws.emr.cluster resource
type mqlAwsEmrCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEmrClusterInternal it will be used here
	Arn                     plugin.TValue[string]
	Name                    plugin.TValue[string]
	NormalizedInstanceHours plugin.TValue[int64]
	OutpostArn              plugin.TValue[string]
	Status                  plugin.TValue[any]
	MasterInstances         plugin.TValue[[]any]
	Id                      plugin.TValue[string]
	Tags                    plugin.TValue[map[string]any]
}

// createAwsEmrCluster creates a new instance of this resource
func createAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmrCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmrCluster) MqlName() string {
	return "aws.emr.cluster"
}

func (c *mqlAwsEmrCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmrCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEmrCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEmrCluster) GetNormalizedInstanceHours() *plugin.TValue[int64] {
	return &c.NormalizedInstanceHours
}

func (c *mqlAwsEmrCluster) GetOutpostArn() *plugin.TValue[string] {
	return &c.OutpostArn
}

func (c *mqlAwsEmrCluster) GetStatus() *plugin.TValue[any] {
	return &c.Status
}

func (c *mqlAwsEmrCluster) GetMasterInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.MasterInstances, func() ([]any, error) {
		return c.masterInstances()
	})
}

func (c *mqlAwsEmrCluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEmrCluster) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsCloudwatch for the aws.cloudwatch resource
type mqlAwsCloudwatch struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchInternal it will be used here
	LogGroups plugin.TValue[[]any]
	Alarms    plugin.TValue[[]any]
	Metrics   plugin.TValue[[]any]
}

// createAwsCloudwatch creates a new instance of this resource
func createAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatch) MqlName() string {
	return "aws.cloudwatch"
}

func (c *mqlAwsCloudwatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatch) GetLogGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.LogGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "logGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.logGroups()
	})
}

func (c *mqlAwsCloudwatch) GetAlarms() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Alarms, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatch) GetMetrics() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Metrics, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "metrics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.metrics()
	})
}

// mqlAwsCloudwatchMetricsalarm for the aws.cloudwatch.metricsalarm resource
type mqlAwsCloudwatchMetricsalarm struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchMetricsalarmInternal it will be used here
	Arn                     plugin.TValue[string]
	MetricName              plugin.TValue[string]
	MetricNamespace         plugin.TValue[string]
	Region                  plugin.TValue[string]
	Actions                 plugin.TValue[[]any]
	State                   plugin.TValue[string]
	StateReason             plugin.TValue[string]
	InsufficientDataActions plugin.TValue[[]any]
	OkActions               plugin.TValue[[]any]
	Name                    plugin.TValue[string]
}

// createAwsCloudwatchMetricsalarm creates a new instance of this resource
func createAwsCloudwatchMetricsalarm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricsalarm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricsalarm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlName() string {
	return "aws.cloudwatch.metricsalarm"
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricsalarm) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricName() *plugin.TValue[string] {
	return &c.MetricName
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricNamespace() *plugin.TValue[string] {
	return &c.MetricNamespace
}

func (c *mqlAwsCloudwatchMetricsalarm) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricsalarm) GetActions() *plugin.TValue[[]any] {
	return &c.Actions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsCloudwatchMetricsalarm) GetStateReason() *plugin.TValue[string] {
	return &c.StateReason
}

func (c *mqlAwsCloudwatchMetricsalarm) GetInsufficientDataActions() *plugin.TValue[[]any] {
	return &c.InsufficientDataActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetOkActions() *plugin.TValue[[]any] {
	return &c.OkActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsCloudwatchMetric for the aws.cloudwatch.metric resource
type mqlAwsCloudwatchMetric struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchMetricInternal it will be used here
	Name       plugin.TValue[string]
	Namespace  plugin.TValue[string]
	Region     plugin.TValue[string]
	Alarms     plugin.TValue[[]any]
	Dimensions plugin.TValue[[]any]
	Statistics plugin.TValue[*mqlAwsCloudwatchMetricstatistics]
}

// createAwsCloudwatchMetric creates a new instance of this resource
func createAwsCloudwatchMetric(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetric{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetric) MqlName() string {
	return "aws.cloudwatch.metric"
}

func (c *mqlAwsCloudwatchMetric) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetric) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetric) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetric) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetric) GetAlarms() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Alarms, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatchMetric) GetDimensions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Dimensions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "dimensions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.dimensions()
	})
}

func (c *mqlAwsCloudwatchMetric) GetStatistics() *plugin.TValue[*mqlAwsCloudwatchMetricstatistics] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchMetricstatistics](&c.Statistics, func() (*mqlAwsCloudwatchMetricstatistics, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "statistics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchMetricstatistics), nil
			}
		}

		return c.statistics()
	})
}

// mqlAwsCloudwatchMetricdimension for the aws.cloudwatch.metricdimension resource
type mqlAwsCloudwatchMetricdimension struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchMetricdimensionInternal it will be used here
	Name  plugin.TValue[string]
	Value plugin.TValue[string]
}

// createAwsCloudwatchMetricdimension creates a new instance of this resource
func createAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricdimension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricdimension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricdimension) MqlName() string {
	return "aws.cloudwatch.metricdimension"
}

func (c *mqlAwsCloudwatchMetricdimension) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricdimension) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricdimension) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlAwsCloudwatchMetricstatistics for the aws.cloudwatch.metricstatistics resource
type mqlAwsCloudwatchMetricstatistics struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchMetricstatisticsInternal it will be used here
	Namespace  plugin.TValue[string]
	Name       plugin.TValue[string]
	Region     plugin.TValue[string]
	Label      plugin.TValue[string]
	Datapoints plugin.TValue[[]any]
}

// createAwsCloudwatchMetricstatistics creates a new instance of this resource
func createAwsCloudwatchMetricstatistics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricstatistics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricstatistics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlName() string {
	return "aws.cloudwatch.metricstatistics"
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricstatistics) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetricstatistics) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricstatistics) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricstatistics) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAwsCloudwatchMetricstatistics) GetDatapoints() *plugin.TValue[[]any] {
	return &c.Datapoints
}

// mqlAwsCloudwatchMetricDatapoint for the aws.cloudwatch.metric.datapoint resource
type mqlAwsCloudwatchMetricDatapoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchMetricDatapointInternal it will be used here
	Id        plugin.TValue[string]
	Timestamp plugin.TValue[*time.Time]
	Maximum   plugin.TValue[float64]
	Minimum   plugin.TValue[float64]
	Average   plugin.TValue[float64]
	Sum       plugin.TValue[float64]
	Unit      plugin.TValue[string]
}

// createAwsCloudwatchMetricDatapoint creates a new instance of this resource
func createAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricDatapoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric.datapoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlName() string {
	return "aws.cloudwatch.metric.datapoint"
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetTimestamp() *plugin.TValue[*time.Time] {
	return &c.Timestamp
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMaximum() *plugin.TValue[float64] {
	return &c.Maximum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMinimum() *plugin.TValue[float64] {
	return &c.Minimum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetAverage() *plugin.TValue[float64] {
	return &c.Average
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetSum() *plugin.TValue[float64] {
	return &c.Sum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetUnit() *plugin.TValue[string] {
	return &c.Unit
}

// mqlAwsCloudwatchLoggroup for the aws.cloudwatch.loggroup resource
type mqlAwsCloudwatchLoggroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchLoggroupInternal it will be used here
	Arn             plugin.TValue[string]
	Name            plugin.TValue[string]
	MetricsFilters  plugin.TValue[[]any]
	KmsKey          plugin.TValue[*mqlAwsKmsKey]
	Region          plugin.TValue[string]
	RetentionInDays plugin.TValue[int64]
	Tags            plugin.TValue[map[string]any]
}

// createAwsCloudwatchLoggroup creates a new instance of this resource
func createAwsCloudwatchLoggroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroup) MqlName() string {
	return "aws.cloudwatch.loggroup"
}

func (c *mqlAwsCloudwatchLoggroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchLoggroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchLoggroup) GetMetricsFilters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.MetricsFilters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "metricsFilters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.metricsFilters()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchLoggroup) GetRetentionInDays() *plugin.TValue[int64] {
	return &c.RetentionInDays
}

func (c *mqlAwsCloudwatchLoggroup) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsCloudwatchLoggroupMetricsfilter for the aws.cloudwatch.loggroup.metricsfilter resource
type mqlAwsCloudwatchLoggroupMetricsfilter struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudwatchLoggroupMetricsfilterInternal it will be used here
	Id            plugin.TValue[string]
	FilterName    plugin.TValue[string]
	FilterPattern plugin.TValue[string]
	Metrics       plugin.TValue[[]any]
}

// createAwsCloudwatchLoggroupMetricsfilter creates a new instance of this resource
func createAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroupMetricsfilter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup.metricsfilter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlName() string {
	return "aws.cloudwatch.loggroup.metricsfilter"
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterName() *plugin.TValue[string] {
	return &c.FilterName
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterPattern() *plugin.TValue[string] {
	return &c.FilterPattern
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetMetrics() *plugin.TValue[[]any] {
	return &c.Metrics
}

// mqlAwsCloudfront for the aws.cloudfront resource
type mqlAwsCloudfront struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudfrontInternal it will be used here
	Distributions plugin.TValue[[]any]
	Functions     plugin.TValue[[]any]
}

// createAwsCloudfront creates a new instance of this resource
func createAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfront{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfront) MqlName() string {
	return "aws.cloudfront"
}

func (c *mqlAwsCloudfront) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfront) GetDistributions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Distributions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "distributions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.distributions()
	})
}

func (c *mqlAwsCloudfront) GetFunctions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Functions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsCloudfrontDistribution for the aws.cloudfront.distribution resource
type mqlAwsCloudfrontDistribution struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudfrontDistributionInternal it will be used here
	Arn                    plugin.TValue[string]
	Status                 plugin.TValue[string]
	DomainName             plugin.TValue[string]
	Origins                plugin.TValue[[]any]
	DefaultCacheBehavior   plugin.TValue[any]
	CacheBehaviors         plugin.TValue[[]any]
	HttpVersion            plugin.TValue[string]
	IsIPV6Enabled          plugin.TValue[bool]
	Enabled                plugin.TValue[bool]
	PriceClass             plugin.TValue[string]
	Cnames                 plugin.TValue[[]any]
	ViewerProtocolPolicy   plugin.TValue[string]
	MinimumProtocolVersion plugin.TValue[string]
	WebAclId               plugin.TValue[string]
	GeoRestrictionType     plugin.TValue[string]
	LastModifiedAt         plugin.TValue[*time.Time]
}

// createAwsCloudfrontDistribution creates a new instance of this resource
func createAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistribution{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistribution) MqlName() string {
	return "aws.cloudfront.distribution"
}

func (c *mqlAwsCloudfrontDistribution) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistribution) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontDistribution) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontDistribution) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistribution) GetOrigins() *plugin.TValue[[]any] {
	return &c.Origins
}

func (c *mqlAwsCloudfrontDistribution) GetDefaultCacheBehavior() *plugin.TValue[any] {
	return &c.DefaultCacheBehavior
}

func (c *mqlAwsCloudfrontDistribution) GetCacheBehaviors() *plugin.TValue[[]any] {
	return &c.CacheBehaviors
}

func (c *mqlAwsCloudfrontDistribution) GetHttpVersion() *plugin.TValue[string] {
	return &c.HttpVersion
}

func (c *mqlAwsCloudfrontDistribution) GetIsIPV6Enabled() *plugin.TValue[bool] {
	return &c.IsIPV6Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetPriceClass() *plugin.TValue[string] {
	return &c.PriceClass
}

func (c *mqlAwsCloudfrontDistribution) GetCnames() *plugin.TValue[[]any] {
	return &c.Cnames
}

func (c *mqlAwsCloudfrontDistribution) GetViewerProtocolPolicy() *plugin.TValue[string] {
	return &c.ViewerProtocolPolicy
}

func (c *mqlAwsCloudfrontDistribution) GetMinimumProtocolVersion() *plugin.TValue[string] {
	return &c.MinimumProtocolVersion
}

func (c *mqlAwsCloudfrontDistribution) GetWebAclId() *plugin.TValue[string] {
	return &c.WebAclId
}

func (c *mqlAwsCloudfrontDistribution) GetGeoRestrictionType() *plugin.TValue[string] {
	return &c.GeoRestrictionType
}

func (c *mqlAwsCloudfrontDistribution) GetLastModifiedAt() *plugin.TValue[*time.Time] {
	return &c.LastModifiedAt
}

// mqlAwsCloudfrontDistributionOrigin for the aws.cloudfront.distribution.origin resource
type mqlAwsCloudfrontDistributionOrigin struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudfrontDistributionOriginInternal it will be used here
	DomainName         plugin.TValue[string]
	Id                 plugin.TValue[string]
	ConnectionAttempts plugin.TValue[int64]
	ConnectionTimeout  plugin.TValue[int64]
	OriginPath         plugin.TValue[string]
	Account            plugin.TValue[string]
}

// createAwsCloudfrontDistributionOrigin creates a new instance of this resource
func createAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistributionOrigin{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution.origin", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlName() string {
	return "aws.cloudfront.distribution.origin"
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionAttempts() *plugin.TValue[int64] {
	return &c.ConnectionAttempts
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionTimeout() *plugin.TValue[int64] {
	return &c.ConnectionTimeout
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetOriginPath() *plugin.TValue[string] {
	return &c.OriginPath
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetAccount() *plugin.TValue[string] {
	return &c.Account
}

// mqlAwsCloudfrontFunction for the aws.cloudfront.function resource
type mqlAwsCloudfrontFunction struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudfrontFunctionInternal it will be used here
	Name             plugin.TValue[string]
	Status           plugin.TValue[string]
	Arn              plugin.TValue[string]
	LastModifiedTime plugin.TValue[*time.Time]
	CreatedTime      plugin.TValue[*time.Time]
	CreatedAt        plugin.TValue[*time.Time]
	Stage            plugin.TValue[string]
	Comment          plugin.TValue[string]
	Runtime          plugin.TValue[string]
}

// createAwsCloudfrontFunction creates a new instance of this resource
func createAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontFunction) MqlName() string {
	return "aws.cloudfront.function"
}

func (c *mqlAwsCloudfrontFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudfrontFunction) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontFunction) GetLastModifiedTime() *plugin.TValue[*time.Time] {
	return &c.LastModifiedTime
}

func (c *mqlAwsCloudfrontFunction) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsCloudfrontFunction) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsCloudfrontFunction) GetStage() *plugin.TValue[string] {
	return &c.Stage
}

func (c *mqlAwsCloudfrontFunction) GetComment() *plugin.TValue[string] {
	return &c.Comment
}

func (c *mqlAwsCloudfrontFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

// mqlAwsCloudtrail for the aws.cloudtrail resource
type mqlAwsCloudtrail struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCloudtrailInternal it will be used here
	Trails plugin.TValue[[]any]
}

// createAwsCloudtrail creates a new instance of this resource
func createAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrail) MqlName() string {
	return "aws.cloudtrail"
}

func (c *mqlAwsCloudtrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrail) GetTrails() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Trails, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail", c.__id, "trails")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.trails()
	})
}

// mqlAwsCloudtrailTrail for the aws.cloudtrail.trail resource
type mqlAwsCloudtrailTrail struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsCloudtrailTrailInternal
	Arn                        plugin.TValue[string]
	Name                       plugin.TValue[string]
	KmsKey                     plugin.TValue[*mqlAwsKmsKey]
	IsMultiRegionTrail         plugin.TValue[bool]
	IsOrganizationTrail        plugin.TValue[bool]
	LogFileValidationEnabled   plugin.TValue[bool]
	IncludeGlobalServiceEvents plugin.TValue[bool]
	S3bucket                   plugin.TValue[*mqlAwsS3Bucket]
	SnsTopicARN                plugin.TValue[string]
	Status                     plugin.TValue[any]
	LogGroup                   plugin.TValue[*mqlAwsCloudwatchLoggroup]
	CloudWatchLogsRoleArn      plugin.TValue[string]
	CloudWatchLogsLogGroupArn  plugin.TValue[string]
	EventSelectors             plugin.TValue[[]any]
	Region                     plugin.TValue[string]
	HasInsightSelectors        plugin.TValue[bool]
	HasCustomEventSelectors    plugin.TValue[bool]
}

// createAwsCloudtrailTrail creates a new instance of this resource
func createAwsCloudtrailTrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrailTrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail.trail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrailTrail) MqlName() string {
	return "aws.cloudtrail.trail"
}

func (c *mqlAwsCloudtrailTrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrailTrail) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudtrailTrail) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudtrailTrail) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudtrailTrail) GetIsMultiRegionTrail() *plugin.TValue[bool] {
	return &c.IsMultiRegionTrail
}

func (c *mqlAwsCloudtrailTrail) GetIsOrganizationTrail() *plugin.TValue[bool] {
	return &c.IsOrganizationTrail
}

func (c *mqlAwsCloudtrailTrail) GetLogFileValidationEnabled() *plugin.TValue[bool] {
	return &c.LogFileValidationEnabled
}

func (c *mqlAwsCloudtrailTrail) GetIncludeGlobalServiceEvents() *plugin.TValue[bool] {
	return &c.IncludeGlobalServiceEvents
}

func (c *mqlAwsCloudtrailTrail) GetS3bucket() *plugin.TValue[*mqlAwsS3Bucket] {
	return plugin.GetOrCompute[*mqlAwsS3Bucket](&c.S3bucket, func() (*mqlAwsS3Bucket, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "s3bucket")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3Bucket), nil
			}
		}

		return c.s3bucket()
	})
}

func (c *mqlAwsCloudtrailTrail) GetSnsTopicARN() *plugin.TValue[string] {
	return &c.SnsTopicARN
}

func (c *mqlAwsCloudtrailTrail) GetStatus() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Status, func() (any, error) {
		return c.status()
	})
}

func (c *mqlAwsCloudtrailTrail) GetLogGroup() *plugin.TValue[*mqlAwsCloudwatchLoggroup] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchLoggroup](&c.LogGroup, func() (*mqlAwsCloudwatchLoggroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "logGroup")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchLoggroup), nil
			}
		}

		return c.logGroup()
	})
}

func (c *mqlAwsCloudtrailTrail) GetCloudWatchLogsRoleArn() *plugin.TValue[string] {
	return &c.CloudWatchLogsRoleArn
}

func (c *mqlAwsCloudtrailTrail) GetCloudWatchLogsLogGroupArn() *plugin.TValue[string] {
	return &c.CloudWatchLogsLogGroupArn
}

func (c *mqlAwsCloudtrailTrail) GetEventSelectors() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.EventSelectors, func() ([]any, error) {
		return c.eventSelectors()
	})
}

func (c *mqlAwsCloudtrailTrail) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudtrailTrail) GetHasInsightSelectors() *plugin.TValue[bool] {
	return &c.HasInsightSelectors
}

func (c *mqlAwsCloudtrailTrail) GetHasCustomEventSelectors() *plugin.TValue[bool] {
	return &c.HasCustomEventSelectors
}

// mqlAwsS3control for the aws.s3control resource
type mqlAwsS3control struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3controlInternal it will be used here
	AccountPublicAccessBlock plugin.TValue[any]
}

// createAwsS3control creates a new instance of this resource
func createAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3control{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3control", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3control) MqlName() string {
	return "aws.s3control"
}

func (c *mqlAwsS3control) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3control) GetAccountPublicAccessBlock() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.AccountPublicAccessBlock, func() (any, error) {
		return c.accountPublicAccessBlock()
	})
}

// mqlAwsS3 for the aws.s3 resource
type mqlAwsS3 struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3Internal it will be used here
	Buckets plugin.TValue[[]any]
}

// createAwsS3 creates a new instance of this resource
func createAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3) MqlName() string {
	return "aws.s3"
}

func (c *mqlAwsS3) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3) GetBuckets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Buckets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3", c.__id, "buckets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.buckets()
	})
}

// mqlAwsS3Bucket for the aws.s3.bucket resource
type mqlAwsS3Bucket struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketInternal it will be used here
	Arn                  plugin.TValue[string]
	Name                 plugin.TValue[string]
	Policy               plugin.TValue[*mqlAwsS3BucketPolicy]
	Tags                 plugin.TValue[map[string]any]
	Acl                  plugin.TValue[[]any]
	Owner                plugin.TValue[map[string]any]
	Public               plugin.TValue[bool]
	Cors                 plugin.TValue[[]any]
	Location             plugin.TValue[string]
	Versioning           plugin.TValue[map[string]any]
	Logging              plugin.TValue[map[string]any]
	StaticWebsiteHosting plugin.TValue[map[string]any]
	Website              plugin.TValue[*mqlAwsS3BucketWebsiteConfiguration]
	DefaultLock          plugin.TValue[string]
	Replication          plugin.TValue[any]
	Encryption           plugin.TValue[any]
	PublicAccessBlock    plugin.TValue[any]
	ObjectLockEnabled    plugin.TValue[bool]
	Exists               plugin.TValue[bool]
	CreatedTime          plugin.TValue[*time.Time]
	CreatedAt            plugin.TValue[*time.Time]
}

// createAwsS3Bucket creates a new instance of this resource
func createAwsS3Bucket(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3Bucket{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3Bucket) MqlName() string {
	return "aws.s3.bucket"
}

func (c *mqlAwsS3Bucket) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3Bucket) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsS3Bucket) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3Bucket) GetPolicy() *plugin.TValue[*mqlAwsS3BucketPolicy] {
	return plugin.GetOrCompute[*mqlAwsS3BucketPolicy](&c.Policy, func() (*mqlAwsS3BucketPolicy, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "policy")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3BucketPolicy), nil
			}
		}

		return c.policy()
	})
}

func (c *mqlAwsS3Bucket) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsS3Bucket) GetAcl() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Acl, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "acl")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.acl()
	})
}

func (c *mqlAwsS3Bucket) GetOwner() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Owner, func() (map[string]any, error) {
		return c.owner()
	})
}

func (c *mqlAwsS3Bucket) GetPublic() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Public, func() (bool, error) {
		return c.public()
	})
}

func (c *mqlAwsS3Bucket) GetCors() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Cors, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "cors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.cors()
	})
}

func (c *mqlAwsS3Bucket) GetLocation() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Location, func() (string, error) {
		return c.location()
	})
}

func (c *mqlAwsS3Bucket) GetVersioning() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Versioning, func() (map[string]any, error) {
		return c.versioning()
	})
}

func (c *mqlAwsS3Bucket) GetLogging() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Logging, func() (map[string]any, error) {
		return c.logging()
	})
}

func (c *mqlAwsS3Bucket) GetStaticWebsiteHosting() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.StaticWebsiteHosting, func() (map[string]any, error) {
		return c.staticWebsiteHosting()
	})
}

func (c *mqlAwsS3Bucket) GetWebsite() *plugin.TValue[*mqlAwsS3BucketWebsiteConfiguration] {
	return plugin.GetOrCompute[*mqlAwsS3BucketWebsiteConfiguration](&c.Website, func() (*mqlAwsS3BucketWebsiteConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "website")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3BucketWebsiteConfiguration), nil
			}
		}

		return c.website()
	})
}

func (c *mqlAwsS3Bucket) GetDefaultLock() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.DefaultLock, func() (string, error) {
		return c.defaultLock()
	})
}

func (c *mqlAwsS3Bucket) GetReplication() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Replication, func() (any, error) {
		return c.replication()
	})
}

func (c *mqlAwsS3Bucket) GetEncryption() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Encryption, func() (any, error) {
		return c.encryption()
	})
}

func (c *mqlAwsS3Bucket) GetPublicAccessBlock() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.PublicAccessBlock, func() (any, error) {
		return c.publicAccessBlock()
	})
}

func (c *mqlAwsS3Bucket) GetObjectLockEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.ObjectLockEnabled, func() (bool, error) {
		return c.objectLockEnabled()
	})
}

func (c *mqlAwsS3Bucket) GetExists() *plugin.TValue[bool] {
	return &c.Exists
}

func (c *mqlAwsS3Bucket) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsS3Bucket) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsS3BucketGrant for the aws.s3.bucket.grant resource
type mqlAwsS3BucketGrant struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketGrantInternal it will be used here
	Id         plugin.TValue[string]
	Name       plugin.TValue[string]
	Permission plugin.TValue[string]
	Grantee    plugin.TValue[map[string]any]
}

// createAwsS3BucketGrant creates a new instance of this resource
func createAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketGrant{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.grant", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketGrant) MqlName() string {
	return "aws.s3.bucket.grant"
}

func (c *mqlAwsS3BucketGrant) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketGrant) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketGrant) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketGrant) GetPermission() *plugin.TValue[string] {
	return &c.Permission
}

func (c *mqlAwsS3BucketGrant) GetGrantee() *plugin.TValue[map[string]any] {
	return &c.Grantee
}

// mqlAwsS3BucketCorsrule for the aws.s3.bucket.corsrule resource
type mqlAwsS3BucketCorsrule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketCorsruleInternal it will be used here
	Name           plugin.TValue[string]
	AllowedHeaders plugin.TValue[[]any]
	AllowedMethods plugin.TValue[[]any]
	AllowedOrigins plugin.TValue[[]any]
	ExposeHeaders  plugin.TValue[[]any]
	MaxAgeSeconds  plugin.TValue[int64]
}

// createAwsS3BucketCorsrule creates a new instance of this resource
func createAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketCorsrule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.corsrule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketCorsrule) MqlName() string {
	return "aws.s3.bucket.corsrule"
}

func (c *mqlAwsS3BucketCorsrule) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketCorsrule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedHeaders() *plugin.TValue[[]any] {
	return &c.AllowedHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedMethods() *plugin.TValue[[]any] {
	return &c.AllowedMethods
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedOrigins() *plugin.TValue[[]any] {
	return &c.AllowedOrigins
}

func (c *mqlAwsS3BucketCorsrule) GetExposeHeaders() *plugin.TValue[[]any] {
	return &c.ExposeHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetMaxAgeSeconds() *plugin.TValue[int64] {
	return &c.MaxAgeSeconds
}

// mqlAwsS3BucketPolicy for the aws.s3.bucket.policy resource
type mqlAwsS3BucketPolicy struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketPolicyInternal it will be used here
	Id         plugin.TValue[string]
	Name       plugin.TValue[string]
	BucketName plugin.TValue[string]
	Document   plugin.TValue[string]
	Version    plugin.TValue[string]
	Statements plugin.TValue[[]any]
}

// createAwsS3BucketPolicy creates a new instance of this resource
func createAwsS3BucketPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketPolicy) MqlName() string {
	return "aws.s3.bucket.policy"
}

func (c *mqlAwsS3BucketPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketPolicy) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketPolicy) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketPolicy) GetBucketName() *plugin.TValue[string] {
	return &c.BucketName
}

func (c *mqlAwsS3BucketPolicy) GetDocument() *plugin.TValue[string] {
	return &c.Document
}

func (c *mqlAwsS3BucketPolicy) GetVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Version, func() (string, error) {
		return c.version()
	})
}

func (c *mqlAwsS3BucketPolicy) GetStatements() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Statements, func() ([]any, error) {
		return c.statements()
	})
}

// mqlAwsS3BucketWebsiteConfiguration for the aws.s3.bucket.websiteConfiguration resource
type mqlAwsS3BucketWebsiteConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketWebsiteConfigurationInternal it will be used here
	IndexDocument         plugin.TValue[string]
	ErrorDocument         plugin.TValue[string]
	RedirectAllRequestsTo plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf]
	RoutingRules          plugin.TValue[[]any]
}

// createAwsS3BucketWebsiteConfiguration creates a new instance of this resource
func createAwsS3BucketWebsiteConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketWebsiteConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.websiteConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketWebsiteConfiguration) MqlName() string {
	return "aws.s3.bucket.websiteConfiguration"
}

func (c *mqlAwsS3BucketWebsiteConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketWebsiteConfiguration) GetIndexDocument() *plugin.TValue[string] {
	return &c.IndexDocument
}

func (c *mqlAwsS3BucketWebsiteConfiguration) GetErrorDocument() *plugin.TValue[string] {
	return &c.ErrorDocument
}

func (c *mqlAwsS3BucketWebsiteConfiguration) GetRedirectAllRequestsTo() *plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf] {
	return &c.RedirectAllRequestsTo
}

func (c *mqlAwsS3BucketWebsiteConfiguration) GetRoutingRules() *plugin.TValue[[]any] {
	return &c.RoutingRules
}

// mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf for the aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf resource
type mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConfInternal it will be used here
	Hostname plugin.TValue[string]
	Protocol plugin.TValue[string]
}

// createAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf creates a new instance of this resource
func createAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf) MqlName() string {
	return "aws.s3.bucket.websiteConfiguration.redirectAllRequestsToConf"
}

func (c *mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf) GetHostname() *plugin.TValue[string] {
	return &c.Hostname
}

func (c *mqlAwsS3BucketWebsiteConfigurationRedirectAllRequestsToConf) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsS3BucketWebsiteConfigurationRoutingRule for the aws.s3.bucket.websiteConfiguration.routingRule resource
type mqlAwsS3BucketWebsiteConfigurationRoutingRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketWebsiteConfigurationRoutingRuleInternal it will be used here
	Redirect  plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf]
	Condition plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf]
}

// createAwsS3BucketWebsiteConfigurationRoutingRule creates a new instance of this resource
func createAwsS3BucketWebsiteConfigurationRoutingRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketWebsiteConfigurationRoutingRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.websiteConfiguration.routingRule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRule) MqlName() string {
	return "aws.s3.bucket.websiteConfiguration.routingRule"
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRule) GetRedirect() *plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf] {
	return &c.Redirect
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRule) GetCondition() *plugin.TValue[*mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf] {
	return &c.Condition
}

// mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf for the aws.s3.bucket.websiteConfiguration.routingRule.redirectConf resource
type mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConfInternal it will be used here
	Hostname             plugin.TValue[string]
	HttpRedirectCode     plugin.TValue[string]
	Protocol             plugin.TValue[string]
	ReplaceKeyPrefixWith plugin.TValue[string]
	ReplaceKeyWith       plugin.TValue[string]
}

// createAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf creates a new instance of this resource
func createAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.websiteConfiguration.routingRule.redirectConf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) MqlName() string {
	return "aws.s3.bucket.websiteConfiguration.routingRule.redirectConf"
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) GetHostname() *plugin.TValue[string] {
	return &c.Hostname
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) GetHttpRedirectCode() *plugin.TValue[string] {
	return &c.HttpRedirectCode
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) GetReplaceKeyPrefixWith() *plugin.TValue[string] {
	return &c.ReplaceKeyPrefixWith
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleRedirectConf) GetReplaceKeyWith() *plugin.TValue[string] {
	return &c.ReplaceKeyWith
}

// mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf for the aws.s3.bucket.websiteConfiguration.routingRule.conditionConf resource
type mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConfInternal it will be used here
	HttpErrorCodeReturnedEquals plugin.TValue[string]
	KeyPrefixEquals             plugin.TValue[string]
}

// createAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf creates a new instance of this resource
func createAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.websiteConfiguration.routingRule.conditionConf", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf) MqlName() string {
	return "aws.s3.bucket.websiteConfiguration.routingRule.conditionConf"
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf) GetHttpErrorCodeReturnedEquals() *plugin.TValue[string] {
	return &c.HttpErrorCodeReturnedEquals
}

func (c *mqlAwsS3BucketWebsiteConfigurationRoutingRuleConditionConf) GetKeyPrefixEquals() *plugin.TValue[string] {
	return &c.KeyPrefixEquals
}

// mqlAwsApplicationAutoscaling for the aws.applicationAutoscaling resource
type mqlAwsApplicationAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApplicationAutoscalingInternal it will be used here
	Namespace       plugin.TValue[string]
	ScalableTargets plugin.TValue[[]any]
}

// createAwsApplicationAutoscaling creates a new instance of this resource
func createAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscaling) MqlName() string {
	return "aws.applicationAutoscaling"
}

func (c *mqlAwsApplicationAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscaling) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscaling) GetScalableTargets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ScalableTargets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.applicationAutoscaling", c.__id, "scalableTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.scalableTargets()
	})
}

// mqlAwsApplicationAutoscalingTarget for the aws.applicationAutoscaling.target resource
type mqlAwsApplicationAutoscalingTarget struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApplicationAutoscalingTargetInternal it will be used here
	Namespace         plugin.TValue[string]
	Arn               plugin.TValue[string]
	ResourceId        plugin.TValue[string]
	Region            plugin.TValue[string]
	ScalableDimension plugin.TValue[string]
	MinCapacity       plugin.TValue[int64]
	MaxCapacity       plugin.TValue[int64]
	SuspendedState    plugin.TValue[any]
	CreatedAt         plugin.TValue[*time.Time]
	Policies          plugin.TValue[[]any]
	ScheduledActions  plugin.TValue[[]any]
}

// createAwsApplicationAutoscalingTarget creates a new instance of this resource
func createAwsApplicationAutoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscalingTarget{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling.target", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscalingTarget) MqlName() string {
	return "aws.applicationAutoscaling.target"
}

func (c *mqlAwsApplicationAutoscalingTarget) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscalingTarget) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscalingTarget) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApplicationAutoscalingTarget) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsApplicationAutoscalingTarget) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsApplicationAutoscalingTarget) GetScalableDimension() *plugin.TValue[string] {
	return &c.ScalableDimension
}

func (c *mqlAwsApplicationAutoscalingTarget) GetMinCapacity() *plugin.TValue[int64] {
	return &c.MinCapacity
}

func (c *mqlAwsApplicationAutoscalingTarget) GetMaxCapacity() *plugin.TValue[int64] {
	return &c.MaxCapacity
}

func (c *mqlAwsApplicationAutoscalingTarget) GetSuspendedState() *plugin.TValue[any] {
	return &c.SuspendedState
}

func (c *mqlAwsApplicationAutoscalingTarget) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsApplicationAutoscalingTarget) GetPolicies() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Policies, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.applicationAutoscaling.target", c.__id, "policies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.policies()
	})
}

func (c *mqlAwsApplicationAutoscalingTarget) GetScheduledActions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ScheduledActions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.applicationAutoscaling.target", c.__id, "scheduledActions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.scheduledActions()
	})
}

// mqlAwsApplicationAutoscalingPolicy for the aws.applicationAutoscaling.policy resource
type mqlAwsApplicationAutoscalingPolicy struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApplicationAutoscalingPolicyInternal it will be used here
	Arn                     plugin.TValue[string]
	Name                    plugin.TValue[string]
	PolicyType              plugin.TValue[string]
	ResourceId              plugin.TValue[string]
	ScalableDimension       plugin.TValue[string]
	Namespace               plugin.TValue[string]
	CreatedAt               plugin.TValue[*time.Time]
	Alarms                  plugin.TValue[[]any]
	TargetTrackingConfig    plugin.TValue[any]
	StepScalingConfig       plugin.TValue[any]
	PredictiveScalingConfig plugin.TValue[any]
}

// createAwsApplicationAutoscalingPolicy creates a new instance of this resource
func createAwsApplicationAutoscalingPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscalingPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscalingPolicy) MqlName() string {
	return "aws.applicationAutoscaling.policy"
}

func (c *mqlAwsApplicationAutoscalingPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetPolicyType() *plugin.TValue[string] {
	return &c.PolicyType
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetScalableDimension() *plugin.TValue[string] {
	return &c.ScalableDimension
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetAlarms() *plugin.TValue[[]any] {
	return &c.Alarms
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetTargetTrackingConfig() *plugin.TValue[any] {
	return &c.TargetTrackingConfig
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetStepScalingConfig() *plugin.TValue[any] {
	return &c.StepScalingConfig
}

func (c *mqlAwsApplicationAutoscalingPolicy) GetPredictiveScalingConfig() *plugin.TValue[any] {
	return &c.PredictiveScalingConfig
}

// mqlAwsApplicationAutoscalingScheduledAction for the aws.applicationAutoscaling.scheduledAction resource
type mqlAwsApplicationAutoscalingScheduledAction struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApplicationAutoscalingScheduledActionInternal it will be used here
	Arn                  plugin.TValue[string]
	Name                 plugin.TValue[string]
	Schedule             plugin.TValue[string]
	Timezone             plugin.TValue[string]
	ResourceId           plugin.TValue[string]
	ScalableDimension    plugin.TValue[string]
	Namespace            plugin.TValue[string]
	CreatedAt            plugin.TValue[*time.Time]
	StartAt              plugin.TValue[*time.Time]
	EndAt                plugin.TValue[*time.Time]
	ScalableTargetAction plugin.TValue[any]
}

// createAwsApplicationAutoscalingScheduledAction creates a new instance of this resource
func createAwsApplicationAutoscalingScheduledAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscalingScheduledAction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling.scheduledAction", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) MqlName() string {
	return "aws.applicationAutoscaling.scheduledAction"
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetSchedule() *plugin.TValue[string] {
	return &c.Schedule
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetTimezone() *plugin.TValue[string] {
	return &c.Timezone
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetScalableDimension() *plugin.TValue[string] {
	return &c.ScalableDimension
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetStartAt() *plugin.TValue[*time.Time] {
	return &c.StartAt
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetEndAt() *plugin.TValue[*time.Time] {
	return &c.EndAt
}

func (c *mqlAwsApplicationAutoscalingScheduledAction) GetScalableTargetAction() *plugin.TValue[any] {
	return &c.ScalableTargetAction
}

// mqlAwsDrs for the aws.drs resource
type mqlAwsDrs struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDrsInternal it will be used here
	SourceServers plugin.TValue[[]any]
	Jobs          plugin.TValue[[]any]
}

// createAwsDrs creates a new instance of this resource
func createAwsDrs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDrs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.drs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDrs) MqlName() string {
	return "aws.drs"
}

func (c *mqlAwsDrs) MqlID() string {
	return c.__id
}

func (c *mqlAwsDrs) GetSourceServers() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SourceServers, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.drs", c.__id, "sourceServers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.sourceServers()
	})
}

func (c *mqlAwsDrs) GetJobs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Jobs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.drs", c.__id, "jobs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.jobs()
	})
}

// mqlAwsDrsSourceServer for the aws.drs.sourceServer resource
type mqlAwsDrsSourceServer struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDrsSourceServerInternal it will be used here
	SourceServerID           plugin.TValue[string]
	Arn                      plugin.TValue[string]
	DataReplicationInfo      plugin.TValue[any]
	LastLaunchResult         plugin.TValue[string]
	LifeCycle                plugin.TValue[any]
	SourceProperties         plugin.TValue[any]
	StagingArea              plugin.TValue[any]
	ReplicationDirection     plugin.TValue[string]
	RecoveryInstanceId       plugin.TValue[string]
	Tags                     plugin.TValue[map[string]any]
	ReplicationConfiguration plugin.TValue[*mqlAwsDrsReplicationConfiguration]
	LaunchConfiguration      plugin.TValue[*mqlAwsDrsLaunchConfiguration]
}

// createAwsDrsSourceServer creates a new instance of this resource
func createAwsDrsSourceServer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDrsSourceServer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.drs.sourceServer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDrsSourceServer) MqlName() string {
	return "aws.drs.sourceServer"
}

func (c *mqlAwsDrsSourceServer) MqlID() string {
	return c.__id
}

func (c *mqlAwsDrsSourceServer) GetSourceServerID() *plugin.TValue[string] {
	return &c.SourceServerID
}

func (c *mqlAwsDrsSourceServer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDrsSourceServer) GetDataReplicationInfo() *plugin.TValue[any] {
	return &c.DataReplicationInfo
}

func (c *mqlAwsDrsSourceServer) GetLastLaunchResult() *plugin.TValue[string] {
	return &c.LastLaunchResult
}

func (c *mqlAwsDrsSourceServer) GetLifeCycle() *plugin.TValue[any] {
	return &c.LifeCycle
}

func (c *mqlAwsDrsSourceServer) GetSourceProperties() *plugin.TValue[any] {
	return &c.SourceProperties
}

func (c *mqlAwsDrsSourceServer) GetStagingArea() *plugin.TValue[any] {
	return &c.StagingArea
}

func (c *mqlAwsDrsSourceServer) GetReplicationDirection() *plugin.TValue[string] {
	return &c.ReplicationDirection
}

func (c *mqlAwsDrsSourceServer) GetRecoveryInstanceId() *plugin.TValue[string] {
	return &c.RecoveryInstanceId
}

func (c *mqlAwsDrsSourceServer) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsDrsSourceServer) GetReplicationConfiguration() *plugin.TValue[*mqlAwsDrsReplicationConfiguration] {
	return plugin.GetOrCompute[*mqlAwsDrsReplicationConfiguration](&c.ReplicationConfiguration, func() (*mqlAwsDrsReplicationConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.drs.sourceServer", c.__id, "replicationConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsDrsReplicationConfiguration), nil
			}
		}

		return c.replicationConfiguration()
	})
}

func (c *mqlAwsDrsSourceServer) GetLaunchConfiguration() *plugin.TValue[*mqlAwsDrsLaunchConfiguration] {
	return plugin.GetOrCompute[*mqlAwsDrsLaunchConfiguration](&c.LaunchConfiguration, func() (*mqlAwsDrsLaunchConfiguration, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.drs.sourceServer", c.__id, "launchConfiguration")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsDrsLaunchConfiguration), nil
			}
		}

		return c.launchConfiguration()
	})
}

// mqlAwsDrsJob for the aws.drs.job resource
type mqlAwsDrsJob struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDrsJobInternal it will be used here
	JobID                plugin.TValue[string]
	Arn                  plugin.TValue[string]
	Type                 plugin.TValue[string]
	Status               plugin.TValue[string]
	InitiatedBy          plugin.TValue[string]
	CreatedAt            plugin.TValue[*time.Time]
	EndedAt              plugin.TValue[*time.Time]
	ParticipatingServers plugin.TValue[[]any]
}

// createAwsDrsJob creates a new instance of this resource
func createAwsDrsJob(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDrsJob{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.drs.job", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDrsJob) MqlName() string {
	return "aws.drs.job"
}

func (c *mqlAwsDrsJob) MqlID() string {
	return c.__id
}

func (c *mqlAwsDrsJob) GetJobID() *plugin.TValue[string] {
	return &c.JobID
}

func (c *mqlAwsDrsJob) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDrsJob) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsDrsJob) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsDrsJob) GetInitiatedBy() *plugin.TValue[string] {
	return &c.InitiatedBy
}

func (c *mqlAwsDrsJob) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsDrsJob) GetEndedAt() *plugin.TValue[*time.Time] {
	return &c.EndedAt
}

func (c *mqlAwsDrsJob) GetParticipatingServers() *plugin.TValue[[]any] {
	return &c.ParticipatingServers
}

// mqlAwsDrsReplicationConfiguration for the aws.drs.replicationConfiguration resource
type mqlAwsDrsReplicationConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDrsReplicationConfigurationInternal it will be used here
	SourceServerID                plugin.TValue[string]
	StagingAreaSubnetId           plugin.TValue[string]
	StagingAreaTags               plugin.TValue[map[string]any]
	UseDedicatedReplicationServer plugin.TValue[bool]
	ReplicationServerInstanceType plugin.TValue[string]
	EbsEncryption                 plugin.TValue[string]
	EbsEncryptionKeyArn           plugin.TValue[string]
	ReplicatedDisks               plugin.TValue[[]any]
	BandwidthThrottling           plugin.TValue[int64]
}

// createAwsDrsReplicationConfiguration creates a new instance of this resource
func createAwsDrsReplicationConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDrsReplicationConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.drs.replicationConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDrsReplicationConfiguration) MqlName() string {
	return "aws.drs.replicationConfiguration"
}

func (c *mqlAwsDrsReplicationConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsDrsReplicationConfiguration) GetSourceServerID() *plugin.TValue[string] {
	return &c.SourceServerID
}

func (c *mqlAwsDrsReplicationConfiguration) GetStagingAreaSubnetId() *plugin.TValue[string] {
	return &c.StagingAreaSubnetId
}

func (c *mqlAwsDrsReplicationConfiguration) GetStagingAreaTags() *plugin.TValue[map[string]any] {
	return &c.StagingAreaTags
}

func (c *mqlAwsDrsReplicationConfiguration) GetUseDedicatedReplicationServer() *plugin.TValue[bool] {
	return &c.UseDedicatedReplicationServer
}

func (c *mqlAwsDrsReplicationConfiguration) GetReplicationServerInstanceType() *plugin.TValue[string] {
	return &c.ReplicationServerInstanceType
}

func (c *mqlAwsDrsReplicationConfiguration) GetEbsEncryption() *plugin.TValue[string] {
	return &c.EbsEncryption
}

func (c *mqlAwsDrsReplicationConfiguration) GetEbsEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EbsEncryptionKeyArn
}

func (c *mqlAwsDrsReplicationConfiguration) GetReplicatedDisks() *plugin.TValue[[]any] {
	return &c.ReplicatedDisks
}

func (c *mqlAwsDrsReplicationConfiguration) GetBandwidthThrottling() *plugin.TValue[int64] {
	return &c.BandwidthThrottling
}

// mqlAwsDrsLaunchConfiguration for the aws.drs.launchConfiguration resource
type mqlAwsDrsLaunchConfiguration struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDrsLaunchConfigurationInternal it will be used here
	SourceServerID                      plugin.TValue[string]
	TargetInstanceTypeRightSizingMethod plugin.TValue[string]
	LaunchDisposition                   plugin.TValue[string]
	CopyPrivateIp                       plugin.TValue[bool]
	CopyTags                            plugin.TValue[bool]
	Ec2LaunchTemplateID                 plugin.TValue[string]
	Licensing                           plugin.TValue[any]
	PostLaunchEnabled                   plugin.TValue[bool]
	LaunchIntoInstanceProperties        plugin.TValue[any]
}

// createAwsDrsLaunchConfiguration creates a new instance of this resource
func createAwsDrsLaunchConfiguration(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDrsLaunchConfiguration{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.drs.launchConfiguration", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDrsLaunchConfiguration) MqlName() string {
	return "aws.drs.launchConfiguration"
}

func (c *mqlAwsDrsLaunchConfiguration) MqlID() string {
	return c.__id
}

func (c *mqlAwsDrsLaunchConfiguration) GetSourceServerID() *plugin.TValue[string] {
	return &c.SourceServerID
}

func (c *mqlAwsDrsLaunchConfiguration) GetTargetInstanceTypeRightSizingMethod() *plugin.TValue[string] {
	return &c.TargetInstanceTypeRightSizingMethod
}

func (c *mqlAwsDrsLaunchConfiguration) GetLaunchDisposition() *plugin.TValue[string] {
	return &c.LaunchDisposition
}

func (c *mqlAwsDrsLaunchConfiguration) GetCopyPrivateIp() *plugin.TValue[bool] {
	return &c.CopyPrivateIp
}

func (c *mqlAwsDrsLaunchConfiguration) GetCopyTags() *plugin.TValue[bool] {
	return &c.CopyTags
}

func (c *mqlAwsDrsLaunchConfiguration) GetEc2LaunchTemplateID() *plugin.TValue[string] {
	return &c.Ec2LaunchTemplateID
}

func (c *mqlAwsDrsLaunchConfiguration) GetLicensing() *plugin.TValue[any] {
	return &c.Licensing
}

func (c *mqlAwsDrsLaunchConfiguration) GetPostLaunchEnabled() *plugin.TValue[bool] {
	return &c.PostLaunchEnabled
}

func (c *mqlAwsDrsLaunchConfiguration) GetLaunchIntoInstanceProperties() *plugin.TValue[any] {
	return &c.LaunchIntoInstanceProperties
}

// mqlAwsBackup for the aws.backup resource
type mqlAwsBackup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsBackupInternal it will be used here
	Vaults plugin.TValue[[]any]
}

// createAwsBackup creates a new instance of this resource
func createAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackup) MqlName() string {
	return "aws.backup"
}

func (c *mqlAwsBackup) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackup) GetVaults() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Vaults, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup", c.__id, "vaults")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.vaults()
	})
}

// mqlAwsBackupVault for the aws.backup.vault resource
type mqlAwsBackupVault struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsBackupVaultInternal it will be used here
	Arn              plugin.TValue[string]
	Name             plugin.TValue[string]
	RecoveryPoints   plugin.TValue[[]any]
	Region           plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	Locked           plugin.TValue[bool]
	LockedAt         plugin.TValue[*time.Time]
	EncryptionKeyArn plugin.TValue[string]
	MaxRetentionDays plugin.TValue[int64]
	MinRetentionDays plugin.TValue[int64]
}

// createAwsBackupVault creates a new instance of this resource
func createAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVault{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vault", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVault) MqlName() string {
	return "aws.backup.vault"
}

func (c *mqlAwsBackupVault) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVault) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVault) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsBackupVault) GetRecoveryPoints() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.RecoveryPoints, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup.vault", c.__id, "recoveryPoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.recoveryPoints()
	})
}

func (c *mqlAwsBackupVault) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsBackupVault) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsBackupVault) GetLocked() *plugin.TValue[bool] {
	return &c.Locked
}

func (c *mqlAwsBackupVault) GetLockedAt() *plugin.TValue[*time.Time] {
	return &c.LockedAt
}

func (c *mqlAwsBackupVault) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

func (c *mqlAwsBackupVault) GetMaxRetentionDays() *plugin.TValue[int64] {
	return &c.MaxRetentionDays
}

func (c *mqlAwsBackupVault) GetMinRetentionDays() *plugin.TValue[int64] {
	return &c.MinRetentionDays
}

// mqlAwsBackupVaultRecoveryPoint for the aws.backup.vaultRecoveryPoint resource
type mqlAwsBackupVaultRecoveryPoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsBackupVaultRecoveryPointInternal it will be used here
	Arn              plugin.TValue[string]
	ResourceType     plugin.TValue[string]
	CreatedBy        plugin.TValue[any]
	IamRoleArn       plugin.TValue[string]
	Status           plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	CreationDate     plugin.TValue[*time.Time]
	CompletionDate   plugin.TValue[*time.Time]
	EncryptionKeyArn plugin.TValue[string]
	IsEncrypted      plugin.TValue[bool]
}

// createAwsBackupVaultRecoveryPoint creates a new instance of this resource
func createAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVaultRecoveryPoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vaultRecoveryPoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlName() string {
	return "aws.backup.vaultRecoveryPoint"
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreatedBy() *plugin.TValue[any] {
	return &c.CreatedBy
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIamRoleArn() *plugin.TValue[string] {
	return &c.IamRoleArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreationDate() *plugin.TValue[*time.Time] {
	return &c.CreationDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCompletionDate() *plugin.TValue[*time.Time] {
	return &c.CompletionDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIsEncrypted() *plugin.TValue[bool] {
	return &c.IsEncrypted
}

// mqlAwsDynamodb for the aws.dynamodb resource
type mqlAwsDynamodb struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDynamodbInternal it will be used here
	Backups      plugin.TValue[[]any]
	GlobalTables plugin.TValue[[]any]
	Tables       plugin.TValue[[]any]
	Limits       plugin.TValue[[]any]
	Exports      plugin.TValue[[]any]
}

// createAwsDynamodb creates a new instance of this resource
func createAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodb) MqlName() string {
	return "aws.dynamodb"
}

func (c *mqlAwsDynamodb) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodb) GetBackups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Backups, func() ([]any, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodb) GetGlobalTables() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.GlobalTables, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "globalTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.globalTables()
	})
}

func (c *mqlAwsDynamodb) GetTables() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Tables, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.tables()
	})
}

func (c *mqlAwsDynamodb) GetLimits() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Limits, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "limits")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.limits()
	})
}

func (c *mqlAwsDynamodb) GetExports() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Exports, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "exports")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.exports()
	})
}

// mqlAwsDynamodbExport for the aws.dynamodb.export resource
type mqlAwsDynamodbExport struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsDynamodbExportInternal
	Table          plugin.TValue[*mqlAwsDynamodbTable]
	S3Bucket       plugin.TValue[*mqlAwsS3Bucket]
	S3Prefix       plugin.TValue[string]
	ItemCount      plugin.TValue[int64]
	Type           plugin.TValue[string]
	Status         plugin.TValue[string]
	Format         plugin.TValue[string]
	StartTime      plugin.TValue[*time.Time]
	EndTime        plugin.TValue[*time.Time]
	S3SseAlgorithm plugin.TValue[string]
	KmsKey         plugin.TValue[*mqlAwsKmsKey]
	Arn            plugin.TValue[string]
}

// createAwsDynamodbExport creates a new instance of this resource
func createAwsDynamodbExport(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbExport{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.export", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbExport) MqlName() string {
	return "aws.dynamodb.export"
}

func (c *mqlAwsDynamodbExport) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbExport) GetTable() *plugin.TValue[*mqlAwsDynamodbTable] {
	return plugin.GetOrCompute[*mqlAwsDynamodbTable](&c.Table, func() (*mqlAwsDynamodbTable, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "table")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsDynamodbTable), nil
			}
		}

		return c.table()
	})
}

func (c *mqlAwsDynamodbExport) GetS3Bucket() *plugin.TValue[*mqlAwsS3Bucket] {
	return plugin.GetOrCompute[*mqlAwsS3Bucket](&c.S3Bucket, func() (*mqlAwsS3Bucket, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "s3Bucket")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3Bucket), nil
			}
		}

		return c.s3Bucket()
	})
}

func (c *mqlAwsDynamodbExport) GetS3Prefix() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.S3Prefix, func() (string, error) {
		return c.s3Prefix()
	})
}

func (c *mqlAwsDynamodbExport) GetItemCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.ItemCount, func() (int64, error) {
		return c.itemCount()
	})
}

func (c *mqlAwsDynamodbExport) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsDynamodbExport) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsDynamodbExport) GetFormat() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Format, func() (string, error) {
		return c.format()
	})
}

func (c *mqlAwsDynamodbExport) GetStartTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.StartTime, func() (*time.Time, error) {
		return c.startTime()
	})
}

func (c *mqlAwsDynamodbExport) GetEndTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.EndTime, func() (*time.Time, error) {
		return c.endTime()
	})
}

func (c *mqlAwsDynamodbExport) GetS3SseAlgorithm() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.S3SseAlgorithm, func() (string, error) {
		return c.s3SseAlgorithm()
	})
}

func (c *mqlAwsDynamodbExport) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb.export", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsDynamodbExport) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

// mqlAwsDynamodbLimit for the aws.dynamodb.limit resource
type mqlAwsDynamodbLimit struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDynamodbLimitInternal it will be used here
	Arn             plugin.TValue[string]
	Region          plugin.TValue[string]
	AccountMaxRead  plugin.TValue[int64]
	AccountMaxWrite plugin.TValue[int64]
	TableMaxRead    plugin.TValue[int64]
	TableMaxWrite   plugin.TValue[int64]
}

// createAwsDynamodbLimit creates a new instance of this resource
func createAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbLimit{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.limit", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbLimit) MqlName() string {
	return "aws.dynamodb.limit"
}

func (c *mqlAwsDynamodbLimit) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbLimit) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbLimit) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxRead() *plugin.TValue[int64] {
	return &c.AccountMaxRead
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxWrite() *plugin.TValue[int64] {
	return &c.AccountMaxWrite
}

func (c *mqlAwsDynamodbLimit) GetTableMaxRead() *plugin.TValue[int64] {
	return &c.TableMaxRead
}

func (c *mqlAwsDynamodbLimit) GetTableMaxWrite() *plugin.TValue[int64] {
	return &c.TableMaxWrite
}

// mqlAwsDynamodbGlobaltable for the aws.dynamodb.globaltable resource
type mqlAwsDynamodbGlobaltable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDynamodbGlobaltableInternal it will be used here
	Arn             plugin.TValue[string]
	Name            plugin.TValue[string]
	ReplicaSettings plugin.TValue[[]any]
}

// createAwsDynamodbGlobaltable creates a new instance of this resource
func createAwsDynamodbGlobaltable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbGlobaltable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.globaltable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbGlobaltable) MqlName() string {
	return "aws.dynamodb.globaltable"
}

func (c *mqlAwsDynamodbGlobaltable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbGlobaltable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbGlobaltable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbGlobaltable) GetReplicaSettings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ReplicaSettings, func() ([]any, error) {
		return c.replicaSettings()
	})
}

// mqlAwsDynamodbTable for the aws.dynamodb.table resource
type mqlAwsDynamodbTable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDynamodbTableInternal it will be used here
	Arn                       plugin.TValue[string]
	Id                        plugin.TValue[string]
	Name                      plugin.TValue[string]
	Region                    plugin.TValue[string]
	Backups                   plugin.TValue[[]any]
	SseDescription            plugin.TValue[any]
	ProvisionedThroughput     plugin.TValue[any]
	ContinuousBackups         plugin.TValue[any]
	Tags                      plugin.TValue[map[string]any]
	CreatedTime               plugin.TValue[*time.Time]
	CreatedAt                 plugin.TValue[*time.Time]
	DeletionProtectionEnabled plugin.TValue[bool]
	GlobalTableVersion        plugin.TValue[string]
	Items                     plugin.TValue[int64]
	SizeBytes                 plugin.TValue[int64]
	LatestStreamArn           plugin.TValue[string]
	Status                    plugin.TValue[string]
}

// createAwsDynamodbTable creates a new instance of this resource
func createAwsDynamodbTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbTable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.table", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbTable) MqlName() string {
	return "aws.dynamodb.table"
}

func (c *mqlAwsDynamodbTable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbTable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbTable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsDynamodbTable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbTable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbTable) GetBackups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Backups, func() ([]any, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodbTable) GetSseDescription() *plugin.TValue[any] {
	return &c.SseDescription
}

func (c *mqlAwsDynamodbTable) GetProvisionedThroughput() *plugin.TValue[any] {
	return &c.ProvisionedThroughput
}

func (c *mqlAwsDynamodbTable) GetContinuousBackups() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ContinuousBackups, func() (any, error) {
		return c.continuousBackups()
	})
}

func (c *mqlAwsDynamodbTable) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsDynamodbTable) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsDynamodbTable) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsDynamodbTable) GetDeletionProtectionEnabled() *plugin.TValue[bool] {
	return &c.DeletionProtectionEnabled
}

func (c *mqlAwsDynamodbTable) GetGlobalTableVersion() *plugin.TValue[string] {
	return &c.GlobalTableVersion
}

func (c *mqlAwsDynamodbTable) GetItems() *plugin.TValue[int64] {
	return &c.Items
}

func (c *mqlAwsDynamodbTable) GetSizeBytes() *plugin.TValue[int64] {
	return &c.SizeBytes
}

func (c *mqlAwsDynamodbTable) GetLatestStreamArn() *plugin.TValue[string] {
	return &c.LatestStreamArn
}

func (c *mqlAwsDynamodbTable) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

// mqlAwsSqs for the aws.sqs resource
type mqlAwsSqs struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSqsInternal it will be used here
	Queues plugin.TValue[[]any]
}

// createAwsSqs creates a new instance of this resource
func createAwsSqs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSqs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sqs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSqs) MqlName() string {
	return "aws.sqs"
}

func (c *mqlAwsSqs) MqlID() string {
	return c.__id
}

func (c *mqlAwsSqs) GetQueues() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Queues, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs", c.__id, "queues")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.queues()
	})
}

// mqlAwsSqsQueue for the aws.sqs.queue resource
type mqlAwsSqsQueue struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsSqsQueueInternal
	Arn                           plugin.TValue[string]
	CreatedAt                     plugin.TValue[*time.Time]
	DeadLetterQueue               plugin.TValue[*mqlAwsSqsQueue]
	DeliveryDelaySeconds          plugin.TValue[int64]
	KmsKey                        plugin.TValue[*mqlAwsKmsKey]
	LastModified                  plugin.TValue[*time.Time]
	MaxReceiveCount               plugin.TValue[int64]
	MaximumMessageSize            plugin.TValue[int64]
	MessageRetentionPeriodSeconds plugin.TValue[int64]
	ReceiveMessageWaitTimeSeconds plugin.TValue[int64]
	Region                        plugin.TValue[string]
	SqsManagedSseEnabled          plugin.TValue[bool]
	QueueType                     plugin.TValue[string]
	Url                           plugin.TValue[string]
	VisibilityTimeoutSeconds      plugin.TValue[int64]
}

// createAwsSqsQueue creates a new instance of this resource
func createAwsSqsQueue(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSqsQueue{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sqs.queue", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSqsQueue) MqlName() string {
	return "aws.sqs.queue"
}

func (c *mqlAwsSqsQueue) MqlID() string {
	return c.__id
}

func (c *mqlAwsSqsQueue) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsSqsQueue) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsSqsQueue) GetDeadLetterQueue() *plugin.TValue[*mqlAwsSqsQueue] {
	return plugin.GetOrCompute[*mqlAwsSqsQueue](&c.DeadLetterQueue, func() (*mqlAwsSqsQueue, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs.queue", c.__id, "deadLetterQueue")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSqsQueue), nil
			}
		}

		return c.deadLetterQueue()
	})
}

func (c *mqlAwsSqsQueue) GetDeliveryDelaySeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.DeliveryDelaySeconds, func() (int64, error) {
		return c.deliveryDelaySeconds()
	})
}

func (c *mqlAwsSqsQueue) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sqs.queue", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSqsQueue) GetLastModified() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.LastModified, func() (*time.Time, error) {
		return c.lastModified()
	})
}

func (c *mqlAwsSqsQueue) GetMaxReceiveCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MaxReceiveCount, func() (int64, error) {
		return c.maxReceiveCount()
	})
}

func (c *mqlAwsSqsQueue) GetMaximumMessageSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MaximumMessageSize, func() (int64, error) {
		return c.maximumMessageSize()
	})
}

func (c *mqlAwsSqsQueue) GetMessageRetentionPeriodSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.MessageRetentionPeriodSeconds, func() (int64, error) {
		return c.messageRetentionPeriodSeconds()
	})
}

func (c *mqlAwsSqsQueue) GetReceiveMessageWaitTimeSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.ReceiveMessageWaitTimeSeconds, func() (int64, error) {
		return c.receiveMessageWaitTimeSeconds()
	})
}

func (c *mqlAwsSqsQueue) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSqsQueue) GetSqsManagedSseEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.SqsManagedSseEnabled, func() (bool, error) {
		return c.sqsManagedSseEnabled()
	})
}

func (c *mqlAwsSqsQueue) GetQueueType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.QueueType, func() (string, error) {
		return c.queueType()
	})
}

func (c *mqlAwsSqsQueue) GetUrl() *plugin.TValue[string] {
	return &c.Url
}

func (c *mqlAwsSqsQueue) GetVisibilityTimeoutSeconds() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.VisibilityTimeoutSeconds, func() (int64, error) {
		return c.visibilityTimeoutSeconds()
	})
}

// mqlAwsRds for the aws.rds resource
type mqlAwsRds struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRdsInternal it will be used here
	Instances                    plugin.TValue[[]any]
	Clusters                     plugin.TValue[[]any]
	AllPendingMaintenanceActions plugin.TValue[[]any]
	ParameterGroups              plugin.TValue[[]any]
	ClusterParameterGroups       plugin.TValue[[]any]
}

// createAwsRds creates a new instance of this resource
func createAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRds{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRds) MqlName() string {
	return "aws.rds"
}

func (c *mqlAwsRds) MqlID() string {
	return c.__id
}

func (c *mqlAwsRds) GetInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Instances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsRds) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsRds) GetAllPendingMaintenanceActions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AllPendingMaintenanceActions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "allPendingMaintenanceActions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.allPendingMaintenanceActions()
	})
}

func (c *mqlAwsRds) GetParameterGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ParameterGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "parameterGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.parameterGroups()
	})
}

func (c *mqlAwsRds) GetClusterParameterGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ClusterParameterGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "clusterParameterGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusterParameterGroups()
	})
}

// mqlAwsRdsBackupsetting for the aws.rds.backupsetting resource
type mqlAwsRdsBackupsetting struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsRdsBackupsettingInternal
	Target                   plugin.TValue[string]
	RetentionPeriod          plugin.TValue[int64]
	DedicatedLogVolume       plugin.TValue[bool]
	Encrypted                plugin.TValue[bool]
	KmsKey                   plugin.TValue[*mqlAwsKmsKey]
	Region                   plugin.TValue[string]
	Status                   plugin.TValue[string]
	Timezone                 plugin.TValue[string]
	EarliestRestoreAvailable plugin.TValue[*time.Time]
	LatestRestoreAvailable   plugin.TValue[*time.Time]
}

// createAwsRdsBackupsetting creates a new instance of this resource
func createAwsRdsBackupsetting(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsBackupsetting{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.backupsetting", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsBackupsetting) MqlName() string {
	return "aws.rds.backupsetting"
}

func (c *mqlAwsRdsBackupsetting) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsBackupsetting) GetTarget() *plugin.TValue[string] {
	return &c.Target
}

func (c *mqlAwsRdsBackupsetting) GetRetentionPeriod() *plugin.TValue[int64] {
	return &c.RetentionPeriod
}

func (c *mqlAwsRdsBackupsetting) GetDedicatedLogVolume() *plugin.TValue[bool] {
	return &c.DedicatedLogVolume
}

func (c *mqlAwsRdsBackupsetting) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRdsBackupsetting) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.backupsetting", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsRdsBackupsetting) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsBackupsetting) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsBackupsetting) GetTimezone() *plugin.TValue[string] {
	return &c.Timezone
}

func (c *mqlAwsRdsBackupsetting) GetEarliestRestoreAvailable() *plugin.TValue[*time.Time] {
	return &c.EarliestRestoreAvailable
}

func (c *mqlAwsRdsBackupsetting) GetLatestRestoreAvailable() *plugin.TValue[*time.Time] {
	return &c.LatestRestoreAvailable
}

// mqlAwsRdsDbcluster for the aws.rds.dbcluster resource
type mqlAwsRdsDbcluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsRdsDbclusterInternal
	Arn                        plugin.TValue[string]
	Region                     plugin.TValue[string]
	Id                         plugin.TValue[string]
	Members                    plugin.TValue[[]any]
	Snapshots                  plugin.TValue[[]any]
	Tags                       plugin.TValue[map[string]any]
	StorageEncrypted           plugin.TValue[bool]
	StorageAllocated           plugin.TValue[int64]
	StorageIops                plugin.TValue[int64]
	StorageType                plugin.TValue[string]
	Status                     plugin.TValue[string]
	CreatedTime                plugin.TValue[*time.Time]
	CreatedAt                  plugin.TValue[*time.Time]
	BackupRetentionPeriod      plugin.TValue[int64]
	AutoMinorVersionUpgrade    plugin.TValue[bool]
	ClusterDbInstanceClass     plugin.TValue[string]
	Engine                     plugin.TValue[string]
	EngineVersion              plugin.TValue[string]
	PubliclyAccessible         plugin.TValue[bool]
	MultiAZ                    plugin.TValue[bool]
	DeletionProtection         plugin.TValue[bool]
	SecurityGroups             plugin.TValue[[]any]
	AvailabilityZones          plugin.TValue[[]any]
	Port                       plugin.TValue[int64]
	Endpoint                   plugin.TValue[string]
	HostedZoneId               plugin.TValue[string]
	MasterUsername             plugin.TValue[string]
	LatestRestorableTime       plugin.TValue[*time.Time]
	BackupSettings             plugin.TValue[[]any]
	EngineLifecycleSupport     plugin.TValue[string]
	CertificateExpiresAt       plugin.TValue[*time.Time]
	CertificateAuthority       plugin.TValue[string]
	IamDatabaseAuthentication  plugin.TValue[bool]
	ActivityStreamMode         plugin.TValue[string]
	ActivityStreamStatus       plugin.TValue[string]
	MonitoringInterval         plugin.TValue[int64]
	NetworkType                plugin.TValue[string]
	PreferredMaintenanceWindow plugin.TValue[string]
	PreferredBackupWindow      plugin.TValue[string]
	HttpEndpointEnabled        plugin.TValue[bool]
	ParameterGroupName         plugin.TValue[string]
	GlobalClusterIdentifier    plugin.TValue[string]
	DatabaseInsightsMode       plugin.TValue[string]
	KmsKey                     plugin.TValue[*mqlAwsKmsKey]
	PerformanceInsightsEnabled plugin.TValue[bool]
}

// createAwsRdsDbcluster creates a new instance of this resource
func createAwsRdsDbcluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbcluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbcluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbcluster) MqlName() string {
	return "aws.rds.dbcluster"
}

func (c *mqlAwsRdsDbcluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbcluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbcluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbcluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbcluster) GetMembers() *plugin.TValue[[]any] {
	return &c.Members
}

func (c *mqlAwsRdsDbcluster) GetSnapshots() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Snapshots, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbcluster) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsRdsDbcluster) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsRdsDbcluster) GetStorageAllocated() *plugin.TValue[int64] {
	return &c.StorageAllocated
}

func (c *mqlAwsRdsDbcluster) GetStorageIops() *plugin.TValue[int64] {
	return &c.StorageIops
}

func (c *mqlAwsRdsDbcluster) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsRdsDbcluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsDbcluster) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsRdsDbcluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsRdsDbcluster) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsRdsDbcluster) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsRdsDbcluster) GetClusterDbInstanceClass() *plugin.TValue[string] {
	return &c.ClusterDbInstanceClass
}

func (c *mqlAwsRdsDbcluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsDbcluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsDbcluster) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRdsDbcluster) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsRdsDbcluster) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsRdsDbcluster) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsRdsDbcluster) GetAvailabilityZones() *plugin.TValue[[]any] {
	return &c.AvailabilityZones
}

func (c *mqlAwsRdsDbcluster) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsDbcluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsRdsDbcluster) GetHostedZoneId() *plugin.TValue[string] {
	return &c.HostedZoneId
}

func (c *mqlAwsRdsDbcluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRdsDbcluster) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsRdsDbcluster) GetBackupSettings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.BackupSettings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "backupSettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.backupSettings()
	})
}

func (c *mqlAwsRdsDbcluster) GetEngineLifecycleSupport() *plugin.TValue[string] {
	return &c.EngineLifecycleSupport
}

func (c *mqlAwsRdsDbcluster) GetCertificateExpiresAt() *plugin.TValue[*time.Time] {
	return &c.CertificateExpiresAt
}

func (c *mqlAwsRdsDbcluster) GetCertificateAuthority() *plugin.TValue[string] {
	return &c.CertificateAuthority
}

func (c *mqlAwsRdsDbcluster) GetIamDatabaseAuthentication() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthentication
}

func (c *mqlAwsRdsDbcluster) GetActivityStreamMode() *plugin.TValue[string] {
	return &c.ActivityStreamMode
}

func (c *mqlAwsRdsDbcluster) GetActivityStreamStatus() *plugin.TValue[string] {
	return &c.ActivityStreamStatus
}

func (c *mqlAwsRdsDbcluster) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsRdsDbcluster) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsRdsDbcluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRdsDbcluster) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsRdsDbcluster) GetHttpEndpointEnabled() *plugin.TValue[bool] {
	return &c.HttpEndpointEnabled
}

func (c *mqlAwsRdsDbcluster) GetParameterGroupName() *plugin.TValue[string] {
	return &c.ParameterGroupName
}

func (c *mqlAwsRdsDbcluster) GetGlobalClusterIdentifier() *plugin.TValue[string] {
	return &c.GlobalClusterIdentifier
}

func (c *mqlAwsRdsDbcluster) GetDatabaseInsightsMode() *plugin.TValue[string] {
	return &c.DatabaseInsightsMode
}

func (c *mqlAwsRdsDbcluster) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsRdsDbcluster) GetPerformanceInsightsEnabled() *plugin.TValue[bool] {
	return &c.PerformanceInsightsEnabled
}

// mqlAwsRdsSnapshot for the aws.rds.snapshot resource
type mqlAwsRdsSnapshot struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsRdsSnapshotInternal
	Arn               plugin.TValue[string]
	Id                plugin.TValue[string]
	Attributes        plugin.TValue[[]any]
	Type              plugin.TValue[string]
	Encrypted         plugin.TValue[bool]
	Region            plugin.TValue[string]
	IsClusterSnapshot plugin.TValue[bool]
	Tags              plugin.TValue[map[string]any]
	Engine            plugin.TValue[string]
	EngineVersion     plugin.TValue[string]
	Status            plugin.TValue[string]
	Port              plugin.TValue[int64]
	AllocatedStorage  plugin.TValue[int64]
	CreatedAt         plugin.TValue[*time.Time]
	KmsKey            plugin.TValue[*mqlAwsKmsKey]
}

// createAwsRdsSnapshot creates a new instance of this resource
func createAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsSnapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsSnapshot) MqlName() string {
	return "aws.rds.snapshot"
}

func (c *mqlAwsRdsSnapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsSnapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsSnapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsSnapshot) GetAttributes() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Attributes, func() ([]any, error) {
		return c.attributes()
	})
}

func (c *mqlAwsRdsSnapshot) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsRdsSnapshot) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRdsSnapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsSnapshot) GetIsClusterSnapshot() *plugin.TValue[bool] {
	return &c.IsClusterSnapshot
}

func (c *mqlAwsRdsSnapshot) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsRdsSnapshot) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsSnapshot) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsSnapshot) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsSnapshot) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsSnapshot) GetAllocatedStorage() *plugin.TValue[int64] {
	return &c.AllocatedStorage
}

func (c *mqlAwsRdsSnapshot) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsRdsSnapshot) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.snapshot", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

// mqlAwsRdsDbinstance for the aws.rds.dbinstance resource
type mqlAwsRdsDbinstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsRdsDbinstanceInternal
	Arn                           plugin.TValue[string]
	Id                            plugin.TValue[string]
	Name                          plugin.TValue[string]
	BackupRetentionPeriod         plugin.TValue[int64]
	Snapshots                     plugin.TValue[[]any]
	StorageEncrypted              plugin.TValue[bool]
	StorageAllocated              plugin.TValue[int64]
	StorageIops                   plugin.TValue[int64]
	StorageType                   plugin.TValue[string]
	Region                        plugin.TValue[string]
	AvailabilityZone              plugin.TValue[string]
	PubliclyAccessible            plugin.TValue[bool]
	EnabledCloudwatchLogsExports  plugin.TValue[[]any]
	DeletionProtection            plugin.TValue[bool]
	MultiAZ                       plugin.TValue[bool]
	MonitoringInterval            plugin.TValue[int64]
	EnhancedMonitoringResourceArn plugin.TValue[string]
	Tags                          plugin.TValue[map[string]any]
	DbInstanceClass               plugin.TValue[string]
	DbInstanceIdentifier          plugin.TValue[string]
	Engine                        plugin.TValue[string]
	EngineVersion                 plugin.TValue[string]
	SecurityGroups                plugin.TValue[[]any]
	Status                        plugin.TValue[string]
	AutoMinorVersionUpgrade       plugin.TValue[bool]
	CreatedTime                   plugin.TValue[*time.Time]
	CreatedAt                     plugin.TValue[*time.Time]
	Port                          plugin.TValue[int64]
	Endpoint                      plugin.TValue[string]
	MasterUsername                plugin.TValue[string]
	LatestRestorableTime          plugin.TValue[*time.Time]
	BackupSettings                plugin.TValue[[]any]
	Subnets                       plugin.TValue[[]any]
	EngineLifecycleSupport        plugin.TValue[string]
	CertificateExpiresAt          plugin.TValue[*time.Time]
	CertificateAuthority          plugin.TValue[string]
	IamDatabaseAuthentication     plugin.TValue[bool]
	CustomIamInstanceProfile      plugin.TValue[string]
	ActivityStreamMode            plugin.TValue[string]
	ActivityStreamStatus          plugin.TValue[string]
	PendingMaintenanceActions     plugin.TValue[[]any]
	NetworkType                   plugin.TValue[string]
	PreferredMaintenanceWindow    plugin.TValue[string]
	PreferredBackupWindow         plugin.TValue[string]
	KmsKey                        plugin.TValue[*mqlAwsKmsKey]
	PerformanceInsightsEnabled    plugin.TValue[bool]
	CopyTagsToSnapshot            plugin.TValue[bool]
	PerformanceInsightsKmsKey     plugin.TValue[*mqlAwsKmsKey]
}

// createAwsRdsDbinstance creates a new instance of this resource
func createAwsRdsDbinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbinstance) MqlName() string {
	return "aws.rds.dbinstance"
}

func (c *mqlAwsRdsDbinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbinstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsDbinstance) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsRdsDbinstance) GetSnapshots() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Snapshots, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbinstance) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsRdsDbinstance) GetStorageAllocated() *plugin.TValue[int64] {
	return &c.StorageAllocated
}

func (c *mqlAwsRdsDbinstance) GetStorageIops() *plugin.TValue[int64] {
	return &c.StorageIops
}

func (c *mqlAwsRdsDbinstance) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsRdsDbinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbinstance) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRdsDbinstance) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRdsDbinstance) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]any] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsRdsDbinstance) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsRdsDbinstance) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsRdsDbinstance) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsRdsDbinstance) GetEnhancedMonitoringResourceArn() *plugin.TValue[string] {
	return &c.EnhancedMonitoringResourceArn
}

func (c *mqlAwsRdsDbinstance) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceClass() *plugin.TValue[string] {
	return &c.DbInstanceClass
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceIdentifier() *plugin.TValue[string] {
	return &c.DbInstanceIdentifier
}

func (c *mqlAwsRdsDbinstance) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsDbinstance) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsDbinstance) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsRdsDbinstance) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsDbinstance) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsRdsDbinstance) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsRdsDbinstance) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsRdsDbinstance) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsRdsDbinstance) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsRdsDbinstance) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRdsDbinstance) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsRdsDbinstance) GetBackupSettings() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.BackupSettings, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "backupSettings")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.backupSettings()
	})
}

func (c *mqlAwsRdsDbinstance) GetSubnets() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Subnets, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.subnets()
	})
}

func (c *mqlAwsRdsDbinstance) GetEngineLifecycleSupport() *plugin.TValue[string] {
	return &c.EngineLifecycleSupport
}

func (c *mqlAwsRdsDbinstance) GetCertificateExpiresAt() *plugin.TValue[*time.Time] {
	return &c.CertificateExpiresAt
}

func (c *mqlAwsRdsDbinstance) GetCertificateAuthority() *plugin.TValue[string] {
	return &c.CertificateAuthority
}

func (c *mqlAwsRdsDbinstance) GetIamDatabaseAuthentication() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthentication
}

func (c *mqlAwsRdsDbinstance) GetCustomIamInstanceProfile() *plugin.TValue[string] {
	return &c.CustomIamInstanceProfile
}

func (c *mqlAwsRdsDbinstance) GetActivityStreamMode() *plugin.TValue[string] {
	return &c.ActivityStreamMode
}

func (c *mqlAwsRdsDbinstance) GetActivityStreamStatus() *plugin.TValue[string] {
	return &c.ActivityStreamStatus
}

func (c *mqlAwsRdsDbinstance) GetPendingMaintenanceActions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PendingMaintenanceActions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "pendingMaintenanceActions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.pendingMaintenanceActions()
	})
}

func (c *mqlAwsRdsDbinstance) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsRdsDbinstance) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRdsDbinstance) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsRdsDbinstance) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsRdsDbinstance) GetPerformanceInsightsEnabled() *plugin.TValue[bool] {
	return &c.PerformanceInsightsEnabled
}

func (c *mqlAwsRdsDbinstance) GetCopyTagsToSnapshot() *plugin.TValue[bool] {
	return &c.CopyTagsToSnapshot
}

func (c *mqlAwsRdsDbinstance) GetPerformanceInsightsKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.PerformanceInsightsKmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "performanceInsightsKmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.performanceInsightsKmsKey()
	})
}

// mqlAwsRdsPendingMaintenanceAction for the aws.rds.pendingMaintenanceAction resource
type mqlAwsRdsPendingMaintenanceAction struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRdsPendingMaintenanceActionInternal it will be used here
	ResourceArn          plugin.TValue[string]
	Action               plugin.TValue[string]
	Description          plugin.TValue[string]
	AutoAppliedAfterDate plugin.TValue[*time.Time]
	CurrentApplyDate     plugin.TValue[*time.Time]
	ForcedApplyDate      plugin.TValue[*time.Time]
	OptInStatus          plugin.TValue[string]
}

// createAwsRdsPendingMaintenanceAction creates a new instance of this resource
func createAwsRdsPendingMaintenanceAction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsPendingMaintenanceAction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.pendingMaintenanceAction", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsPendingMaintenanceAction) MqlName() string {
	return "aws.rds.pendingMaintenanceAction"
}

func (c *mqlAwsRdsPendingMaintenanceAction) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetResourceArn() *plugin.TValue[string] {
	return &c.ResourceArn
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetAction() *plugin.TValue[string] {
	return &c.Action
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetAutoAppliedAfterDate() *plugin.TValue[*time.Time] {
	return &c.AutoAppliedAfterDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetCurrentApplyDate() *plugin.TValue[*time.Time] {
	return &c.CurrentApplyDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetForcedApplyDate() *plugin.TValue[*time.Time] {
	return &c.ForcedApplyDate
}

func (c *mqlAwsRdsPendingMaintenanceAction) GetOptInStatus() *plugin.TValue[string] {
	return &c.OptInStatus
}

// mqlAwsRdsClusterParameterGroup for the aws.rds.clusterParameterGroup resource
type mqlAwsRdsClusterParameterGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRdsClusterParameterGroupInternal it will be used here
	Arn         plugin.TValue[string]
	Family      plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	Region      plugin.TValue[string]
	Parameters  plugin.TValue[[]any]
}

// createAwsRdsClusterParameterGroup creates a new instance of this resource
func createAwsRdsClusterParameterGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsClusterParameterGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.clusterParameterGroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsClusterParameterGroup) MqlName() string {
	return "aws.rds.clusterParameterGroup"
}

func (c *mqlAwsRdsClusterParameterGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsClusterParameterGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsClusterParameterGroup) GetFamily() *plugin.TValue[string] {
	return &c.Family
}

func (c *mqlAwsRdsClusterParameterGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsClusterParameterGroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsRdsClusterParameterGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsClusterParameterGroup) GetParameters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Parameters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.clusterParameterGroup", c.__id, "parameters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.parameters()
	})
}

// mqlAwsRdsParameterGroup for the aws.rds.parameterGroup resource
type mqlAwsRdsParameterGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRdsParameterGroupInternal it will be used here
	Arn         plugin.TValue[string]
	Family      plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	Region      plugin.TValue[string]
	Parameters  plugin.TValue[[]any]
}

// createAwsRdsParameterGroup creates a new instance of this resource
func createAwsRdsParameterGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsParameterGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.parameterGroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsParameterGroup) MqlName() string {
	return "aws.rds.parameterGroup"
}

func (c *mqlAwsRdsParameterGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsParameterGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsParameterGroup) GetFamily() *plugin.TValue[string] {
	return &c.Family
}

func (c *mqlAwsRdsParameterGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsParameterGroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsRdsParameterGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsParameterGroup) GetParameters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Parameters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.parameterGroup", c.__id, "parameters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.parameters()
	})
}

// mqlAwsRdsParameterGroupParameter for the aws.rds.parameterGroup.parameter resource
type mqlAwsRdsParameterGroupParameter struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRdsParameterGroupParameterInternal it will be used here
	AllowedValues        plugin.TValue[string]
	ApplyMethod          plugin.TValue[string]
	ApplyType            plugin.TValue[string]
	DataType             plugin.TValue[string]
	Description          plugin.TValue[string]
	IsModifiable         plugin.TValue[bool]
	MinimumEngineVersion plugin.TValue[string]
	Name                 plugin.TValue[string]
	Value                plugin.TValue[string]
	Source               plugin.TValue[string]
	SupportedEngineModes plugin.TValue[[]any]
}

// createAwsRdsParameterGroupParameter creates a new instance of this resource
func createAwsRdsParameterGroupParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsParameterGroupParameter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.parameterGroup.parameter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsParameterGroupParameter) MqlName() string {
	return "aws.rds.parameterGroup.parameter"
}

func (c *mqlAwsRdsParameterGroupParameter) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsParameterGroupParameter) GetAllowedValues() *plugin.TValue[string] {
	return &c.AllowedValues
}

func (c *mqlAwsRdsParameterGroupParameter) GetApplyMethod() *plugin.TValue[string] {
	return &c.ApplyMethod
}

func (c *mqlAwsRdsParameterGroupParameter) GetApplyType() *plugin.TValue[string] {
	return &c.ApplyType
}

func (c *mqlAwsRdsParameterGroupParameter) GetDataType() *plugin.TValue[string] {
	return &c.DataType
}

func (c *mqlAwsRdsParameterGroupParameter) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsRdsParameterGroupParameter) GetIsModifiable() *plugin.TValue[bool] {
	return &c.IsModifiable
}

func (c *mqlAwsRdsParameterGroupParameter) GetMinimumEngineVersion() *plugin.TValue[string] {
	return &c.MinimumEngineVersion
}

func (c *mqlAwsRdsParameterGroupParameter) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsParameterGroupParameter) GetValue() *plugin.TValue[string] {
	return &c.Value
}

func (c *mqlAwsRdsParameterGroupParameter) GetSource() *plugin.TValue[string] {
	return &c.Source
}

func (c *mqlAwsRdsParameterGroupParameter) GetSupportedEngineModes() *plugin.TValue[[]any] {
	return &c.SupportedEngineModes
}

// mqlAwsElasticache for the aws.elasticache resource
type mqlAwsElasticache struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsElasticacheInternal it will be used here
	CacheClusters    plugin.TValue[[]any]
	ServerlessCaches plugin.TValue[[]any]
}

// createAwsElasticache creates a new instance of this resource
func createAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticache) MqlName() string {
	return "aws.elasticache"
}

func (c *mqlAwsElasticache) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticache) GetCacheClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CacheClusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache", c.__id, "cacheClusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.cacheClusters()
	})
}

func (c *mqlAwsElasticache) GetServerlessCaches() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ServerlessCaches, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache", c.__id, "serverlessCaches")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.serverlessCaches()
	})
}

// mqlAwsElasticacheCluster for the aws.elasticache.cluster resource
type mqlAwsElasticacheCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsElasticacheClusterInternal
	Arn                       plugin.TValue[string]
	AtRestEncryptionEnabled   plugin.TValue[bool]
	AuthTokenEnabled          plugin.TValue[bool]
	AuthTokenLastModifiedDate plugin.TValue[*time.Time]
	AutoMinorVersionUpgrade   plugin.TValue[bool]
	CacheClusterCreateTime    plugin.TValue[*time.Time]
	CacheClusterId            plugin.TValue[string]
	CacheClusterStatus        plugin.TValue[string]
	CacheNodeType             plugin.TValue[string]
	CacheNodes                plugin.TValue[[]any]
	CacheSecurityGroups       plugin.TValue[[]any]
	CacheSubnetGroupName      plugin.TValue[string]
	ClientDownloadLandingPage plugin.TValue[string]
	NodeType                  plugin.TValue[string]
	Engine                    plugin.TValue[string]
	EngineVersion             plugin.TValue[string]
	IpDiscovery               plugin.TValue[string]
	LogDeliveryConfigurations plugin.TValue[[]any]
	NetworkType               plugin.TValue[string]
	NotificationConfiguration plugin.TValue[string]
	NumCacheNodes             plugin.TValue[int64]
	PreferredAvailabilityZone plugin.TValue[string]
	Region                    plugin.TValue[string]
	SecurityGroups            plugin.TValue[[]any]
	SnapshotRetentionLimit    plugin.TValue[int64]
	SnapshotWindow            plugin.TValue[string]
	TransitEncryptionEnabled  plugin.TValue[bool]
	TransitEncryptionMode     plugin.TValue[string]
}

// createAwsElasticacheCluster creates a new instance of this resource
func createAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticacheCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticacheCluster) MqlName() string {
	return "aws.elasticache.cluster"
}

func (c *mqlAwsElasticacheCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticacheCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElasticacheCluster) GetAtRestEncryptionEnabled() *plugin.TValue[bool] {
	return &c.AtRestEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenEnabled() *plugin.TValue[bool] {
	return &c.AuthTokenEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenLastModifiedDate() *plugin.TValue[*time.Time] {
	return &c.AuthTokenLastModifiedDate
}

func (c *mqlAwsElasticacheCluster) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterCreateTime() *plugin.TValue[*time.Time] {
	return &c.CacheClusterCreateTime
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterId() *plugin.TValue[string] {
	return &c.CacheClusterId
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterStatus() *plugin.TValue[string] {
	return &c.CacheClusterStatus
}

func (c *mqlAwsElasticacheCluster) GetCacheNodeType() *plugin.TValue[string] {
	return &c.CacheNodeType
}

func (c *mqlAwsElasticacheCluster) GetCacheNodes() *plugin.TValue[[]any] {
	return &c.CacheNodes
}

func (c *mqlAwsElasticacheCluster) GetCacheSecurityGroups() *plugin.TValue[[]any] {
	return &c.CacheSecurityGroups
}

func (c *mqlAwsElasticacheCluster) GetCacheSubnetGroupName() *plugin.TValue[string] {
	return &c.CacheSubnetGroupName
}

func (c *mqlAwsElasticacheCluster) GetClientDownloadLandingPage() *plugin.TValue[string] {
	return &c.ClientDownloadLandingPage
}

func (c *mqlAwsElasticacheCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsElasticacheCluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsElasticacheCluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsElasticacheCluster) GetIpDiscovery() *plugin.TValue[string] {
	return &c.IpDiscovery
}

func (c *mqlAwsElasticacheCluster) GetLogDeliveryConfigurations() *plugin.TValue[[]any] {
	return &c.LogDeliveryConfigurations
}

func (c *mqlAwsElasticacheCluster) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsElasticacheCluster) GetNotificationConfiguration() *plugin.TValue[string] {
	return &c.NotificationConfiguration
}

func (c *mqlAwsElasticacheCluster) GetNumCacheNodes() *plugin.TValue[int64] {
	return &c.NumCacheNodes
}

func (c *mqlAwsElasticacheCluster) GetPreferredAvailabilityZone() *plugin.TValue[string] {
	return &c.PreferredAvailabilityZone
}

func (c *mqlAwsElasticacheCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElasticacheCluster) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache.cluster", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsElasticacheCluster) GetSnapshotRetentionLimit() *plugin.TValue[int64] {
	return &c.SnapshotRetentionLimit
}

func (c *mqlAwsElasticacheCluster) GetSnapshotWindow() *plugin.TValue[string] {
	return &c.SnapshotWindow
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionEnabled() *plugin.TValue[bool] {
	return &c.TransitEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionMode() *plugin.TValue[string] {
	return &c.TransitEncryptionMode
}

// mqlAwsElasticacheServerlessCache for the aws.elasticache.serverlessCache resource
type mqlAwsElasticacheServerlessCache struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsElasticacheServerlessCacheInternal
	Arn                    plugin.TValue[string]
	Name                   plugin.TValue[string]
	Description            plugin.TValue[string]
	Engine                 plugin.TValue[string]
	EngineVersion          plugin.TValue[string]
	MajorEngineVersion     plugin.TValue[string]
	KmsKeyId               plugin.TValue[string]
	SecurityGroups         plugin.TValue[[]any]
	SnapshotRetentionLimit plugin.TValue[int64]
	DailySnapshotTime      plugin.TValue[string]
	Status                 plugin.TValue[string]
	Region                 plugin.TValue[string]
	CreatedAt              plugin.TValue[*time.Time]
}

// createAwsElasticacheServerlessCache creates a new instance of this resource
func createAwsElasticacheServerlessCache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticacheServerlessCache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache.serverlessCache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticacheServerlessCache) MqlName() string {
	return "aws.elasticache.serverlessCache"
}

func (c *mqlAwsElasticacheServerlessCache) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticacheServerlessCache) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElasticacheServerlessCache) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElasticacheServerlessCache) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsElasticacheServerlessCache) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsElasticacheServerlessCache) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsElasticacheServerlessCache) GetMajorEngineVersion() *plugin.TValue[string] {
	return &c.MajorEngineVersion
}

func (c *mqlAwsElasticacheServerlessCache) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsElasticacheServerlessCache) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache.serverlessCache", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsElasticacheServerlessCache) GetSnapshotRetentionLimit() *plugin.TValue[int64] {
	return &c.SnapshotRetentionLimit
}

func (c *mqlAwsElasticacheServerlessCache) GetDailySnapshotTime() *plugin.TValue[string] {
	return &c.DailySnapshotTime
}

func (c *mqlAwsElasticacheServerlessCache) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsElasticacheServerlessCache) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElasticacheServerlessCache) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsRedshift for the aws.redshift resource
type mqlAwsRedshift struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRedshiftInternal it will be used here
	Clusters plugin.TValue[[]any]
}

// createAwsRedshift creates a new instance of this resource
func createAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshift{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshift) MqlName() string {
	return "aws.redshift"
}

func (c *mqlAwsRedshift) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshift) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.redshift", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsRedshiftCluster for the aws.redshift.cluster resource
type mqlAwsRedshiftCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsRedshiftClusterInternal it will be used here
	AllowVersionUpgrade              plugin.TValue[bool]
	Arn                              plugin.TValue[string]
	AutomatedSnapshotRetentionPeriod plugin.TValue[int64]
	AvailabilityZone                 plugin.TValue[string]
	ClusterParameterGroupNames       plugin.TValue[[]any]
	ClusterRevisionNumber            plugin.TValue[string]
	ClusterStatus                    plugin.TValue[string]
	ClusterSubnetGroupName           plugin.TValue[string]
	ClusterVersion                   plugin.TValue[string]
	CreatedAt                        plugin.TValue[*time.Time]
	DbName                           plugin.TValue[string]
	Encrypted                        plugin.TValue[bool]
	EnhancedVpcRouting               plugin.TValue[bool]
	Logging                          plugin.TValue[any]
	MasterUsername                   plugin.TValue[string]
	Name                             plugin.TValue[string]
	NextMaintenanceWindowStartTime   plugin.TValue[*time.Time]
	NodeType                         plugin.TValue[string]
	NumberOfNodes                    plugin.TValue[int64]
	Parameters                       plugin.TValue[[]any]
	PreferredMaintenanceWindow       plugin.TValue[string]
	PubliclyAccessible               plugin.TValue[bool]
	Region                           plugin.TValue[string]
	Tags                             plugin.TValue[map[string]any]
	VpcId                            plugin.TValue[string]
}

// createAwsRedshiftCluster creates a new instance of this resource
func createAwsRedshiftCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshiftCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshiftCluster) MqlName() string {
	return "aws.redshift.cluster"
}

func (c *mqlAwsRedshiftCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshiftCluster) GetAllowVersionUpgrade() *plugin.TValue[bool] {
	return &c.AllowVersionUpgrade
}

func (c *mqlAwsRedshiftCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRedshiftCluster) GetAutomatedSnapshotRetentionPeriod() *plugin.TValue[int64] {
	return &c.AutomatedSnapshotRetentionPeriod
}

func (c *mqlAwsRedshiftCluster) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRedshiftCluster) GetClusterParameterGroupNames() *plugin.TValue[[]any] {
	return &c.ClusterParameterGroupNames
}

func (c *mqlAwsRedshiftCluster) GetClusterRevisionNumber() *plugin.TValue[string] {
	return &c.ClusterRevisionNumber
}

func (c *mqlAwsRedshiftCluster) GetClusterStatus() *plugin.TValue[string] {
	return &c.ClusterStatus
}

func (c *mqlAwsRedshiftCluster) GetClusterSubnetGroupName() *plugin.TValue[string] {
	return &c.ClusterSubnetGroupName
}

func (c *mqlAwsRedshiftCluster) GetClusterVersion() *plugin.TValue[string] {
	return &c.ClusterVersion
}

func (c *mqlAwsRedshiftCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsRedshiftCluster) GetDbName() *plugin.TValue[string] {
	return &c.DbName
}

func (c *mqlAwsRedshiftCluster) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRedshiftCluster) GetEnhancedVpcRouting() *plugin.TValue[bool] {
	return &c.EnhancedVpcRouting
}

func (c *mqlAwsRedshiftCluster) GetLogging() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Logging, func() (any, error) {
		return c.logging()
	})
}

func (c *mqlAwsRedshiftCluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRedshiftCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRedshiftCluster) GetNextMaintenanceWindowStartTime() *plugin.TValue[*time.Time] {
	return &c.NextMaintenanceWindowStartTime
}

func (c *mqlAwsRedshiftCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsRedshiftCluster) GetNumberOfNodes() *plugin.TValue[int64] {
	return &c.NumberOfNodes
}

func (c *mqlAwsRedshiftCluster) GetParameters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Parameters, func() ([]any, error) {
		return c.parameters()
	})
}

func (c *mqlAwsRedshiftCluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRedshiftCluster) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRedshiftCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRedshiftCluster) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsRedshiftCluster) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

// mqlAwsEcr for the aws.ecr resource
type mqlAwsEcr struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcrInternal it will be used here
	PrivateRepositories plugin.TValue[[]any]
	PublicRepositories  plugin.TValue[[]any]
	Images              plugin.TValue[[]any]
}

// createAwsEcr creates a new instance of this resource
func createAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcr) MqlName() string {
	return "aws.ecr"
}

func (c *mqlAwsEcr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcr) GetPrivateRepositories() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PrivateRepositories, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "privateRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.privateRepositories()
	})
}

func (c *mqlAwsEcr) GetPublicRepositories() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PublicRepositories, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "publicRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.publicRepositories()
	})
}

func (c *mqlAwsEcr) GetImages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Images, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.images()
	})
}

// mqlAwsEcrRepository for the aws.ecr.repository resource
type mqlAwsEcrRepository struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcrRepositoryInternal it will be used here
	Arn                plugin.TValue[string]
	Name               plugin.TValue[string]
	Uri                plugin.TValue[string]
	RegistryId         plugin.TValue[string]
	Public             plugin.TValue[bool]
	Images             plugin.TValue[[]any]
	Region             plugin.TValue[string]
	ImageScanOnPush    plugin.TValue[bool]
	ImageTagMutability plugin.TValue[string]
	EncryptionType     plugin.TValue[string]
	CreatedAt          plugin.TValue[*time.Time]
	ScanningFrequency  plugin.TValue[string]
}

// createAwsEcrRepository creates a new instance of this resource
func createAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrRepository) MqlName() string {
	return "aws.ecr.repository"
}

func (c *mqlAwsEcrRepository) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrRepository) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcrRepository) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

func (c *mqlAwsEcrRepository) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrRepository) GetPublic() *plugin.TValue[bool] {
	return &c.Public
}

func (c *mqlAwsEcrRepository) GetImages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Images, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr.repository", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.images()
	})
}

func (c *mqlAwsEcrRepository) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrRepository) GetImageScanOnPush() *plugin.TValue[bool] {
	return &c.ImageScanOnPush
}

func (c *mqlAwsEcrRepository) GetImageTagMutability() *plugin.TValue[string] {
	return &c.ImageTagMutability
}

func (c *mqlAwsEcrRepository) GetEncryptionType() *plugin.TValue[string] {
	return &c.EncryptionType
}

func (c *mqlAwsEcrRepository) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEcrRepository) GetScanningFrequency() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.ScanningFrequency, func() (string, error) {
		return c.scanningFrequency()
	})
}

// mqlAwsEcrImage for the aws.ecr.image resource
type mqlAwsEcrImage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEcrImageInternal it will be used here
	Digest               plugin.TValue[string]
	MediaType            plugin.TValue[string]
	Tags                 plugin.TValue[[]any]
	RegistryId           plugin.TValue[string]
	RepoName             plugin.TValue[string]
	Region               plugin.TValue[string]
	Arn                  plugin.TValue[string]
	Uri                  plugin.TValue[string]
	PushedAt             plugin.TValue[*time.Time]
	SizeInBytes          plugin.TValue[int64]
	LastRecordedPullTime plugin.TValue[*time.Time]
}

// createAwsEcrImage creates a new instance of this resource
func createAwsEcrImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrImage) MqlName() string {
	return "aws.ecr.image"
}

func (c *mqlAwsEcrImage) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrImage) GetDigest() *plugin.TValue[string] {
	return &c.Digest
}

func (c *mqlAwsEcrImage) GetMediaType() *plugin.TValue[string] {
	return &c.MediaType
}

func (c *mqlAwsEcrImage) GetTags() *plugin.TValue[[]any] {
	return &c.Tags
}

func (c *mqlAwsEcrImage) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrImage) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlAwsEcrImage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrImage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrImage) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

func (c *mqlAwsEcrImage) GetPushedAt() *plugin.TValue[*time.Time] {
	return &c.PushedAt
}

func (c *mqlAwsEcrImage) GetSizeInBytes() *plugin.TValue[int64] {
	return &c.SizeInBytes
}

func (c *mqlAwsEcrImage) GetLastRecordedPullTime() *plugin.TValue[*time.Time] {
	return &c.LastRecordedPullTime
}

// mqlAwsDms for the aws.dms resource
type mqlAwsDms struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsDmsInternal it will be used here
	ReplicationInstances plugin.TValue[[]any]
}

// createAwsDms creates a new instance of this resource
func createAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDms) MqlName() string {
	return "aws.dms"
}

func (c *mqlAwsDms) MqlID() string {
	return c.__id
}

func (c *mqlAwsDms) GetReplicationInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.ReplicationInstances, func() ([]any, error) {
		return c.replicationInstances()
	})
}

// mqlAwsApigateway for the aws.apigateway resource
type mqlAwsApigateway struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApigatewayInternal it will be used here
	RestApis plugin.TValue[[]any]
}

// createAwsApigateway creates a new instance of this resource
func createAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigateway) MqlName() string {
	return "aws.apigateway"
}

func (c *mqlAwsApigateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigateway) GetRestApis() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.RestApis, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway", c.__id, "restApis")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.restApis()
	})
}

// mqlAwsApigatewayRestapi for the aws.apigateway.restapi resource
type mqlAwsApigatewayRestapi struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApigatewayRestapiInternal it will be used here
	Arn                       plugin.TValue[string]
	Id                        plugin.TValue[string]
	Name                      plugin.TValue[string]
	CreatedDate               plugin.TValue[*time.Time]
	Description               plugin.TValue[string]
	Stages                    plugin.TValue[[]any]
	Region                    plugin.TValue[string]
	Tags                      plugin.TValue[map[string]any]
	ApiKeySource              plugin.TValue[string]
	DisableExecuteApiEndpoint plugin.TValue[bool]
	MinimumCompressionSize    plugin.TValue[int64]
	BinaryMediaTypes          plugin.TValue[[]any]
	Version                   plugin.TValue[string]
	SecurityPolicy            plugin.TValue[string]
	Policy                    plugin.TValue[string]
}

// createAwsApigatewayRestapi creates a new instance of this resource
func createAwsApigatewayRestapi(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayRestapi{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.restapi", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayRestapi) MqlName() string {
	return "aws.apigateway.restapi"
}

func (c *mqlAwsApigatewayRestapi) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayRestapi) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayRestapi) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsApigatewayRestapi) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayRestapi) GetCreatedDate() *plugin.TValue[*time.Time] {
	return &c.CreatedDate
}

func (c *mqlAwsApigatewayRestapi) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayRestapi) GetStages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Stages, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway.restapi", c.__id, "stages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.stages()
	})
}

func (c *mqlAwsApigatewayRestapi) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsApigatewayRestapi) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsApigatewayRestapi) GetApiKeySource() *plugin.TValue[string] {
	return &c.ApiKeySource
}

func (c *mqlAwsApigatewayRestapi) GetDisableExecuteApiEndpoint() *plugin.TValue[bool] {
	return &c.DisableExecuteApiEndpoint
}

func (c *mqlAwsApigatewayRestapi) GetMinimumCompressionSize() *plugin.TValue[int64] {
	return &c.MinimumCompressionSize
}

func (c *mqlAwsApigatewayRestapi) GetBinaryMediaTypes() *plugin.TValue[[]any] {
	return &c.BinaryMediaTypes
}

func (c *mqlAwsApigatewayRestapi) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlAwsApigatewayRestapi) GetSecurityPolicy() *plugin.TValue[string] {
	return &c.SecurityPolicy
}

func (c *mqlAwsApigatewayRestapi) GetPolicy() *plugin.TValue[string] {
	return &c.Policy
}

// mqlAwsApigatewayStage for the aws.apigateway.stage resource
type mqlAwsApigatewayStage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsApigatewayStageInternal it will be used here
	Arn                  plugin.TValue[string]
	Name                 plugin.TValue[string]
	TracingEnabled       plugin.TValue[bool]
	Description          plugin.TValue[string]
	DeploymentId         plugin.TValue[string]
	MethodSettings       plugin.TValue[any]
	CacheClusterEnabled  plugin.TValue[bool]
	CacheClusterSize     plugin.TValue[string]
	CacheClusterStatus   plugin.TValue[string]
	ClientCertificateId  plugin.TValue[string]
	WebAclArn            plugin.TValue[string]
	CreatedAt            plugin.TValue[*time.Time]
	LastUpdatedAt        plugin.TValue[*time.Time]
	DocumentationVersion plugin.TValue[string]
	Variables            plugin.TValue[map[string]any]
	Tags                 plugin.TValue[map[string]any]
}

// createAwsApigatewayStage creates a new instance of this resource
func createAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayStage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.stage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayStage) MqlName() string {
	return "aws.apigateway.stage"
}

func (c *mqlAwsApigatewayStage) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayStage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayStage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayStage) GetTracingEnabled() *plugin.TValue[bool] {
	return &c.TracingEnabled
}

func (c *mqlAwsApigatewayStage) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayStage) GetDeploymentId() *plugin.TValue[string] {
	return &c.DeploymentId
}

func (c *mqlAwsApigatewayStage) GetMethodSettings() *plugin.TValue[any] {
	return &c.MethodSettings
}

func (c *mqlAwsApigatewayStage) GetCacheClusterEnabled() *plugin.TValue[bool] {
	return &c.CacheClusterEnabled
}

func (c *mqlAwsApigatewayStage) GetCacheClusterSize() *plugin.TValue[string] {
	return &c.CacheClusterSize
}

func (c *mqlAwsApigatewayStage) GetCacheClusterStatus() *plugin.TValue[string] {
	return &c.CacheClusterStatus
}

func (c *mqlAwsApigatewayStage) GetClientCertificateId() *plugin.TValue[string] {
	return &c.ClientCertificateId
}

func (c *mqlAwsApigatewayStage) GetWebAclArn() *plugin.TValue[string] {
	return &c.WebAclArn
}

func (c *mqlAwsApigatewayStage) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsApigatewayStage) GetLastUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.LastUpdatedAt
}

func (c *mqlAwsApigatewayStage) GetDocumentationVersion() *plugin.TValue[string] {
	return &c.DocumentationVersion
}

func (c *mqlAwsApigatewayStage) GetVariables() *plugin.TValue[map[string]any] {
	return &c.Variables
}

func (c *mqlAwsApigatewayStage) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsLambda for the aws.lambda resource
type mqlAwsLambda struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsLambdaInternal it will be used here
	Functions plugin.TValue[[]any]
}

// createAwsLambda creates a new instance of this resource
func createAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambda{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambda) MqlName() string {
	return "aws.lambda"
}

func (c *mqlAwsLambda) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambda) GetFunctions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Functions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.lambda", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsLambdaFunction for the aws.lambda.function resource
type mqlAwsLambdaFunction struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsLambdaFunctionInternal
	Arn                  plugin.TValue[string]
	Name                 plugin.TValue[string]
	Runtime              plugin.TValue[string]
	Concurrency          plugin.TValue[int64]
	DlqTargetArn         plugin.TValue[string]
	Policy               plugin.TValue[any]
	VpcConfig            plugin.TValue[any]
	Region               plugin.TValue[string]
	Tags                 plugin.TValue[map[string]any]
	Architectures        plugin.TValue[[]any]
	EphemeralStorageSize plugin.TValue[int64]
	MemorySize           plugin.TValue[int64]
	Role                 plugin.TValue[*mqlAwsIamRole]
	Timeout              plugin.TValue[int64]
	Handler              plugin.TValue[string]
	TracingMode          plugin.TValue[string]
	PackageType          plugin.TValue[string]
	CodeSha256           plugin.TValue[string]
	Description          plugin.TValue[string]
	LastModifiedAt       plugin.TValue[*time.Time]
	UrlConfig            plugin.TValue[*mqlAwsLambdaFunctionUrlConfig]
}

// createAwsLambdaFunction creates a new instance of this resource
func createAwsLambdaFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambdaFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambdaFunction) MqlName() string {
	return "aws.lambda.function"
}

func (c *mqlAwsLambdaFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambdaFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsLambdaFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsLambdaFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

func (c *mqlAwsLambdaFunction) GetConcurrency() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Concurrency, func() (int64, error) {
		return c.concurrency()
	})
}

func (c *mqlAwsLambdaFunction) GetDlqTargetArn() *plugin.TValue[string] {
	return &c.DlqTargetArn
}

func (c *mqlAwsLambdaFunction) GetPolicy() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Policy, func() (any, error) {
		return c.policy()
	})
}

func (c *mqlAwsLambdaFunction) GetVpcConfig() *plugin.TValue[any] {
	return &c.VpcConfig
}

func (c *mqlAwsLambdaFunction) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsLambdaFunction) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsLambdaFunction) GetArchitectures() *plugin.TValue[[]any] {
	return &c.Architectures
}

func (c *mqlAwsLambdaFunction) GetEphemeralStorageSize() *plugin.TValue[int64] {
	return &c.EphemeralStorageSize
}

func (c *mqlAwsLambdaFunction) GetMemorySize() *plugin.TValue[int64] {
	return &c.MemorySize
}

func (c *mqlAwsLambdaFunction) GetRole() *plugin.TValue[*mqlAwsIamRole] {
	return plugin.GetOrCompute[*mqlAwsIamRole](&c.Role, func() (*mqlAwsIamRole, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.lambda.function", c.__id, "role")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamRole), nil
			}
		}

		return c.role()
	})
}

func (c *mqlAwsLambdaFunction) GetTimeout() *plugin.TValue[int64] {
	return &c.Timeout
}

func (c *mqlAwsLambdaFunction) GetHandler() *plugin.TValue[string] {
	return &c.Handler
}

func (c *mqlAwsLambdaFunction) GetTracingMode() *plugin.TValue[string] {
	return &c.TracingMode
}

func (c *mqlAwsLambdaFunction) GetPackageType() *plugin.TValue[string] {
	return &c.PackageType
}

func (c *mqlAwsLambdaFunction) GetCodeSha256() *plugin.TValue[string] {
	return &c.CodeSha256
}

func (c *mqlAwsLambdaFunction) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsLambdaFunction) GetLastModifiedAt() *plugin.TValue[*time.Time] {
	return &c.LastModifiedAt
}

func (c *mqlAwsLambdaFunction) GetUrlConfig() *plugin.TValue[*mqlAwsLambdaFunctionUrlConfig] {
	return plugin.GetOrCompute[*mqlAwsLambdaFunctionUrlConfig](&c.UrlConfig, func() (*mqlAwsLambdaFunctionUrlConfig, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.lambda.function", c.__id, "urlConfig")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsLambdaFunctionUrlConfig), nil
			}
		}

		return c.urlConfig()
	})
}

// mqlAwsLambdaFunctionUrlConfig for the aws.lambda.function.urlConfig resource
type mqlAwsLambdaFunctionUrlConfig struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsLambdaFunctionUrlConfigInternal it will be used here
	FunctionUrl          plugin.TValue[string]
	AuthType             plugin.TValue[string]
	CorsAllowOrigins     plugin.TValue[[]any]
	CorsAllowMethods     plugin.TValue[[]any]
	CorsAllowHeaders     plugin.TValue[[]any]
	CorsAllowCredentials plugin.TValue[bool]
	CorsExposeHeaders    plugin.TValue[[]any]
	CorsMaxAge           plugin.TValue[int64]
	CreatedAt            plugin.TValue[*time.Time]
	LastModifiedAt       plugin.TValue[*time.Time]
}

// createAwsLambdaFunctionUrlConfig creates a new instance of this resource
func createAwsLambdaFunctionUrlConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambdaFunctionUrlConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda.function.urlConfig", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambdaFunctionUrlConfig) MqlName() string {
	return "aws.lambda.function.urlConfig"
}

func (c *mqlAwsLambdaFunctionUrlConfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetFunctionUrl() *plugin.TValue[string] {
	return &c.FunctionUrl
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetAuthType() *plugin.TValue[string] {
	return &c.AuthType
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsAllowOrigins() *plugin.TValue[[]any] {
	return &c.CorsAllowOrigins
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsAllowMethods() *plugin.TValue[[]any] {
	return &c.CorsAllowMethods
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsAllowHeaders() *plugin.TValue[[]any] {
	return &c.CorsAllowHeaders
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsAllowCredentials() *plugin.TValue[bool] {
	return &c.CorsAllowCredentials
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsExposeHeaders() *plugin.TValue[[]any] {
	return &c.CorsExposeHeaders
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCorsMaxAge() *plugin.TValue[int64] {
	return &c.CorsMaxAge
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsLambdaFunctionUrlConfig) GetLastModifiedAt() *plugin.TValue[*time.Time] {
	return &c.LastModifiedAt
}

// mqlAwsSsm for the aws.ssm resource
type mqlAwsSsm struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSsmInternal it will be used here
	Instances  plugin.TValue[[]any]
	Parameters plugin.TValue[[]any]
}

// createAwsSsm creates a new instance of this resource
func createAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsm) MqlName() string {
	return "aws.ssm"
}

func (c *mqlAwsSsm) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsm) GetInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Instances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsSsm) GetParameters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Parameters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm", c.__id, "parameters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.parameters()
	})
}

// mqlAwsSsmParameter for the aws.ssm.parameter resource
type mqlAwsSsmParameter struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsSsmParameterInternal
	AllowedPattern   plugin.TValue[string]
	Arn              plugin.TValue[string]
	Region           plugin.TValue[string]
	DataType         plugin.TValue[string]
	Description      plugin.TValue[string]
	KmsKey           plugin.TValue[*mqlAwsKmsKey]
	LastModifiedDate plugin.TValue[*time.Time]
	Name             plugin.TValue[string]
	Tier             plugin.TValue[string]
	Type             plugin.TValue[string]
	Version          plugin.TValue[int64]
}

// createAwsSsmParameter creates a new instance of this resource
func createAwsSsmParameter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsmParameter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm.parameter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsmParameter) MqlName() string {
	return "aws.ssm.parameter"
}

func (c *mqlAwsSsmParameter) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsmParameter) GetAllowedPattern() *plugin.TValue[string] {
	return &c.AllowedPattern
}

func (c *mqlAwsSsmParameter) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSsmParameter) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSsmParameter) GetDataType() *plugin.TValue[string] {
	return &c.DataType
}

func (c *mqlAwsSsmParameter) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsSsmParameter) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm.parameter", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSsmParameter) GetLastModifiedDate() *plugin.TValue[*time.Time] {
	return &c.LastModifiedDate
}

func (c *mqlAwsSsmParameter) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSsmParameter) GetTier() *plugin.TValue[string] {
	return &c.Tier
}

func (c *mqlAwsSsmParameter) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsSsmParameter) GetVersion() *plugin.TValue[int64] {
	return &c.Version
}

// mqlAwsSsmInstance for the aws.ssm.instance resource
type mqlAwsSsmInstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsSsmInstanceInternal it will be used here
	InstanceId      plugin.TValue[string]
	PingStatus      plugin.TValue[string]
	IpAddress       plugin.TValue[string]
	PlatformName    plugin.TValue[string]
	PlatformType    plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Region          plugin.TValue[string]
	Arn             plugin.TValue[string]
	Tags            plugin.TValue[map[string]any]
}

// createAwsSsmInstance creates a new instance of this resource
func createAwsSsmInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsmInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsmInstance) MqlName() string {
	return "aws.ssm.instance"
}

func (c *mqlAwsSsmInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsmInstance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsSsmInstance) GetPingStatus() *plugin.TValue[string] {
	return &c.PingStatus
}

func (c *mqlAwsSsmInstance) GetIpAddress() *plugin.TValue[string] {
	return &c.IpAddress
}

func (c *mqlAwsSsmInstance) GetPlatformName() *plugin.TValue[string] {
	return &c.PlatformName
}

func (c *mqlAwsSsmInstance) GetPlatformType() *plugin.TValue[string] {
	return &c.PlatformType
}

func (c *mqlAwsSsmInstance) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsSsmInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSsmInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSsmInstance) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

// mqlAwsEc2 for the aws.ec2 resource
type mqlAwsEc2 struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2Internal it will be used here
	SecurityGroups         plugin.TValue[[]any]
	Instances              plugin.TValue[[]any]
	EbsEncryptionByDefault plugin.TValue[map[string]any]
	Volumes                plugin.TValue[[]any]
	Snapshots              plugin.TValue[[]any]
	InternetGateways       plugin.TValue[[]any]
	VpnConnections         plugin.TValue[[]any]
	NetworkAcls            plugin.TValue[[]any]
	Keypairs               plugin.TValue[[]any]
	Eips                   plugin.TValue[[]any]
	Images                 plugin.TValue[[]any]
}

// createAwsEc2 creates a new instance of this resource
func createAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2) MqlName() string {
	return "aws.ec2"
}

func (c *mqlAwsEc2) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2) GetInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Instances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsEc2) GetEbsEncryptionByDefault() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.EbsEncryptionByDefault, func() (map[string]any, error) {
		return c.ebsEncryptionByDefault()
	})
}

func (c *mqlAwsEc2) GetVolumes() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Volumes, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "volumes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.volumes()
	})
}

func (c *mqlAwsEc2) GetSnapshots() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Snapshots, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsEc2) GetInternetGateways() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.InternetGateways, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "internetGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.internetGateways()
	})
}

func (c *mqlAwsEc2) GetVpnConnections() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.VpnConnections, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "vpnConnections")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.vpnConnections()
	})
}

func (c *mqlAwsEc2) GetNetworkAcls() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NetworkAcls, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "networkAcls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.networkAcls()
	})
}

func (c *mqlAwsEc2) GetKeypairs() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Keypairs, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "keypairs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.keypairs()
	})
}

func (c *mqlAwsEc2) GetEips() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Eips, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "eips")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.eips()
	})
}

func (c *mqlAwsEc2) GetImages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Images, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.images()
	})
}

// mqlAwsEc2Eip for the aws.ec2.eip resource
type mqlAwsEc2Eip struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2EipInternal
	PublicIp                plugin.TValue[string]
	Attached                plugin.TValue[bool]
	Instance                plugin.TValue[*mqlAwsEc2Instance]
	NetworkInterfaceId      plugin.TValue[string]
	NetworkInterfaceOwnerId plugin.TValue[string]
	PrivateIpAddress        plugin.TValue[string]
	PublicIpv4Pool          plugin.TValue[string]
	Tags                    plugin.TValue[map[string]any]
	Region                  plugin.TValue[string]
}

// createAwsEc2Eip creates a new instance of this resource
func createAwsEc2Eip(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Eip{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.eip", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Eip) MqlName() string {
	return "aws.ec2.eip"
}

func (c *mqlAwsEc2Eip) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Eip) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEc2Eip) GetAttached() *plugin.TValue[bool] {
	return &c.Attached
}

func (c *mqlAwsEc2Eip) GetInstance() *plugin.TValue[*mqlAwsEc2Instance] {
	return plugin.GetOrCompute[*mqlAwsEc2Instance](&c.Instance, func() (*mqlAwsEc2Instance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.eip", c.__id, "instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Instance), nil
			}
		}

		return c.instance()
	})
}

func (c *mqlAwsEc2Eip) GetNetworkInterfaceId() *plugin.TValue[string] {
	return &c.NetworkInterfaceId
}

func (c *mqlAwsEc2Eip) GetNetworkInterfaceOwnerId() *plugin.TValue[string] {
	return &c.NetworkInterfaceOwnerId
}

func (c *mqlAwsEc2Eip) GetPrivateIpAddress() *plugin.TValue[string] {
	return &c.PrivateIpAddress
}

func (c *mqlAwsEc2Eip) GetPublicIpv4Pool() *plugin.TValue[string] {
	return &c.PublicIpv4Pool
}

func (c *mqlAwsEc2Eip) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Eip) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsVpcNatgateway for the aws.vpc.natgateway resource
type mqlAwsVpcNatgateway struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcNatgatewayInternal
	CreatedAt    plugin.TValue[*time.Time]
	NatGatewayId plugin.TValue[string]
	State        plugin.TValue[string]
	Tags         plugin.TValue[map[string]any]
	Vpc          plugin.TValue[*mqlAwsVpc]
	Addresses    plugin.TValue[[]any]
	Subnet       plugin.TValue[*mqlAwsVpcSubnet]
}

// createAwsVpcNatgateway creates a new instance of this resource
func createAwsVpcNatgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcNatgateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.natgateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcNatgateway) MqlName() string {
	return "aws.vpc.natgateway"
}

func (c *mqlAwsVpcNatgateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcNatgateway) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsVpcNatgateway) GetNatGatewayId() *plugin.TValue[string] {
	return &c.NatGatewayId
}

func (c *mqlAwsVpcNatgateway) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpcNatgateway) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsVpcNatgateway) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsVpcNatgateway) GetAddresses() *plugin.TValue[[]any] {
	return &c.Addresses
}

func (c *mqlAwsVpcNatgateway) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

// mqlAwsVpcNatgatewayAddress for the aws.vpc.natgateway.address resource
type mqlAwsVpcNatgatewayAddress struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcNatgatewayAddressInternal
	AllocationId       plugin.TValue[string]
	NetworkInterfaceId plugin.TValue[string]
	PrivateIp          plugin.TValue[string]
	PublicIp           plugin.TValue[*mqlAwsEc2Eip]
	IsPrimary          plugin.TValue[bool]
}

// createAwsVpcNatgatewayAddress creates a new instance of this resource
func createAwsVpcNatgatewayAddress(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcNatgatewayAddress{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.natgateway.address", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcNatgatewayAddress) MqlName() string {
	return "aws.vpc.natgateway.address"
}

func (c *mqlAwsVpcNatgatewayAddress) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcNatgatewayAddress) GetAllocationId() *plugin.TValue[string] {
	return &c.AllocationId
}

func (c *mqlAwsVpcNatgatewayAddress) GetNetworkInterfaceId() *plugin.TValue[string] {
	return &c.NetworkInterfaceId
}

func (c *mqlAwsVpcNatgatewayAddress) GetPrivateIp() *plugin.TValue[string] {
	return &c.PrivateIp
}

func (c *mqlAwsVpcNatgatewayAddress) GetPublicIp() *plugin.TValue[*mqlAwsEc2Eip] {
	return plugin.GetOrCompute[*mqlAwsEc2Eip](&c.PublicIp, func() (*mqlAwsEc2Eip, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.natgateway.address", c.__id, "publicIp")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Eip), nil
			}
		}

		return c.publicIp()
	})
}

func (c *mqlAwsVpcNatgatewayAddress) GetIsPrimary() *plugin.TValue[bool] {
	return &c.IsPrimary
}

// mqlAwsVpcServiceEndpoint for the aws.vpc.serviceEndpoint resource
type mqlAwsVpcServiceEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcServiceEndpointInternal
	AcceptanceRequired              plugin.TValue[bool]
	AvailabilityZones               plugin.TValue[[]any]
	DnsNames                        plugin.TValue[[]any]
	Id                              plugin.TValue[string]
	ManagesVpcEndpoints             plugin.TValue[bool]
	Name                            plugin.TValue[string]
	Owner                           plugin.TValue[string]
	PayerResponsibility             plugin.TValue[string]
	PrivateDnsNameVerificationState plugin.TValue[string]
	PrivateDnsNames                 plugin.TValue[[]any]
	Tags                            plugin.TValue[map[string]any]
	Type                            plugin.TValue[string]
	VpcEndpointPolicySupported      plugin.TValue[bool]
}

// createAwsVpcServiceEndpoint creates a new instance of this resource
func createAwsVpcServiceEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcServiceEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.serviceEndpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcServiceEndpoint) MqlName() string {
	return "aws.vpc.serviceEndpoint"
}

func (c *mqlAwsVpcServiceEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcServiceEndpoint) GetAcceptanceRequired() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AcceptanceRequired, func() (bool, error) {
		return c.acceptanceRequired()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetAvailabilityZones() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AvailabilityZones, func() ([]any, error) {
		return c.availabilityZones()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetDnsNames() *plugin.TValue[[]any] {
	return &c.DnsNames
}

func (c *mqlAwsVpcServiceEndpoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcServiceEndpoint) GetManagesVpcEndpoints() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.ManagesVpcEndpoints, func() (bool, error) {
		return c.managesVpcEndpoints()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsVpcServiceEndpoint) GetOwner() *plugin.TValue[string] {
	return &c.Owner
}

func (c *mqlAwsVpcServiceEndpoint) GetPayerResponsibility() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.PayerResponsibility, func() (string, error) {
		return c.payerResponsibility()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetPrivateDnsNameVerificationState() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.PrivateDnsNameVerificationState, func() (string, error) {
		return c.privateDnsNameVerificationState()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetPrivateDnsNames() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.PrivateDnsNames, func() ([]any, error) {
		return c.privateDnsNames()
	})
}

func (c *mqlAwsVpcServiceEndpoint) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsVpcServiceEndpoint) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcServiceEndpoint) GetVpcEndpointPolicySupported() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.VpcEndpointPolicySupported, func() (bool, error) {
		return c.vpcEndpointPolicySupported()
	})
}

// mqlAwsVpcPeeringConnection for the aws.vpc.peeringConnection resource
type mqlAwsVpcPeeringConnection struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsVpcPeeringConnectionInternal
	AcceptorVpc    plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc]
	ExpirationTime plugin.TValue[*time.Time]
	Id             plugin.TValue[string]
	RequestorVpc   plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc]
	Status         plugin.TValue[string]
	Tags           plugin.TValue[map[string]any]
}

// createAwsVpcPeeringConnection creates a new instance of this resource
func createAwsVpcPeeringConnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcPeeringConnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.peeringConnection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcPeeringConnection) MqlName() string {
	return "aws.vpc.peeringConnection"
}

func (c *mqlAwsVpcPeeringConnection) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcPeeringConnection) GetAcceptorVpc() *plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc] {
	return plugin.GetOrCompute[*mqlAwsVpcPeeringConnectionPeeringVpc](&c.AcceptorVpc, func() (*mqlAwsVpcPeeringConnectionPeeringVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection", c.__id, "acceptorVpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcPeeringConnectionPeeringVpc), nil
			}
		}

		return c.acceptorVpc()
	})
}

func (c *mqlAwsVpcPeeringConnection) GetExpirationTime() *plugin.TValue[*time.Time] {
	return &c.ExpirationTime
}

func (c *mqlAwsVpcPeeringConnection) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcPeeringConnection) GetRequestorVpc() *plugin.TValue[*mqlAwsVpcPeeringConnectionPeeringVpc] {
	return plugin.GetOrCompute[*mqlAwsVpcPeeringConnectionPeeringVpc](&c.RequestorVpc, func() (*mqlAwsVpcPeeringConnectionPeeringVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection", c.__id, "requestorVpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcPeeringConnectionPeeringVpc), nil
			}
		}

		return c.requestorVpc()
	})
}

func (c *mqlAwsVpcPeeringConnection) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcPeeringConnection) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsVpcPeeringConnectionPeeringVpc for the aws.vpc.peeringConnection.peeringVpc resource
type mqlAwsVpcPeeringConnectionPeeringVpc struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsVpcPeeringConnectionPeeringVpcInternal it will be used here
	AllowDnsResolutionFromRemoteVpc plugin.TValue[bool]
	Ipv4CiderBlocks                 plugin.TValue[[]any]
	Ipv6CiderBlocks                 plugin.TValue[[]any]
	OwnerID                         plugin.TValue[string]
	Region                          plugin.TValue[string]
	Vpc                             plugin.TValue[*mqlAwsVpc]
	VpcId                           plugin.TValue[string]
}

// createAwsVpcPeeringConnectionPeeringVpc creates a new instance of this resource
func createAwsVpcPeeringConnectionPeeringVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcPeeringConnectionPeeringVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.peeringConnection.peeringVpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) MqlName() string {
	return "aws.vpc.peeringConnection.peeringVpc"
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetAllowDnsResolutionFromRemoteVpc() *plugin.TValue[bool] {
	return &c.AllowDnsResolutionFromRemoteVpc
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetIpv4CiderBlocks() *plugin.TValue[[]any] {
	return &c.Ipv4CiderBlocks
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetIpv6CiderBlocks() *plugin.TValue[[]any] {
	return &c.Ipv6CiderBlocks
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetOwnerID() *plugin.TValue[string] {
	return &c.OwnerID
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc.peeringConnection.peeringVpc", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsVpcPeeringConnectionPeeringVpc) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

// mqlAwsEc2Networkacl for the aws.ec2.networkacl resource
type mqlAwsEc2Networkacl struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2NetworkaclInternal it will be used here
	Arn          plugin.TValue[string]
	Id           plugin.TValue[string]
	Region       plugin.TValue[string]
	Entries      plugin.TValue[[]any]
	IsDefault    plugin.TValue[bool]
	Tags         plugin.TValue[map[string]any]
	Associations plugin.TValue[[]any]
}

// createAwsEc2Networkacl creates a new instance of this resource
func createAwsEc2Networkacl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Networkacl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Networkacl) MqlName() string {
	return "aws.ec2.networkacl"
}

func (c *mqlAwsEc2Networkacl) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Networkacl) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Networkacl) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Networkacl) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Networkacl) GetEntries() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Entries, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl", c.__id, "entries")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.entries()
	})
}

func (c *mqlAwsEc2Networkacl) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsEc2Networkacl) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Networkacl) GetAssociations() *plugin.TValue[[]any] {
	return &c.Associations
}

// mqlAwsEc2NetworkaclAssociation for the aws.ec2.networkacl.association resource
type mqlAwsEc2NetworkaclAssociation struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2NetworkaclAssociationInternal it will be used here
	AssociationId plugin.TValue[string]
	NetworkAclId  plugin.TValue[string]
	SubnetId      plugin.TValue[string]
}

// createAwsEc2NetworkaclAssociation creates a new instance of this resource
func createAwsEc2NetworkaclAssociation(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclAssociation{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.association", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclAssociation) MqlName() string {
	return "aws.ec2.networkacl.association"
}

func (c *mqlAwsEc2NetworkaclAssociation) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclAssociation) GetAssociationId() *plugin.TValue[string] {
	return &c.AssociationId
}

func (c *mqlAwsEc2NetworkaclAssociation) GetNetworkAclId() *plugin.TValue[string] {
	return &c.NetworkAclId
}

func (c *mqlAwsEc2NetworkaclAssociation) GetSubnetId() *plugin.TValue[string] {
	return &c.SubnetId
}

// mqlAwsEc2NetworkaclEntry for the aws.ec2.networkacl.entry resource
type mqlAwsEc2NetworkaclEntry struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2NetworkaclEntryInternal it will be used here
	Egress        plugin.TValue[bool]
	RuleAction    plugin.TValue[string]
	RuleNumber    plugin.TValue[int64]
	PortRange     plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange]
	CidrBlock     plugin.TValue[string]
	Ipv6CidrBlock plugin.TValue[string]
	Id            plugin.TValue[string]
}

// createAwsEc2NetworkaclEntry creates a new instance of this resource
func createAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntry) MqlName() string {
	return "aws.ec2.networkacl.entry"
}

func (c *mqlAwsEc2NetworkaclEntry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntry) GetEgress() *plugin.TValue[bool] {
	return &c.Egress
}

func (c *mqlAwsEc2NetworkaclEntry) GetRuleAction() *plugin.TValue[string] {
	return &c.RuleAction
}

func (c *mqlAwsEc2NetworkaclEntry) GetRuleNumber() *plugin.TValue[int64] {
	return &c.RuleNumber
}

func (c *mqlAwsEc2NetworkaclEntry) GetPortRange() *plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange] {
	return plugin.GetOrCompute[*mqlAwsEc2NetworkaclEntryPortrange](&c.PortRange, func() (*mqlAwsEc2NetworkaclEntryPortrange, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl.entry", c.__id, "portRange")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2NetworkaclEntryPortrange), nil
			}
		}

		return c.portRange()
	})
}

func (c *mqlAwsEc2NetworkaclEntry) GetCidrBlock() *plugin.TValue[string] {
	return &c.CidrBlock
}

func (c *mqlAwsEc2NetworkaclEntry) GetIpv6CidrBlock() *plugin.TValue[string] {
	return &c.Ipv6CidrBlock
}

func (c *mqlAwsEc2NetworkaclEntry) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2NetworkaclEntryPortrange for the aws.ec2.networkacl.entry.portrange resource
type mqlAwsEc2NetworkaclEntryPortrange struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2NetworkaclEntryPortrangeInternal it will be used here
	From plugin.TValue[int64]
	To   plugin.TValue[int64]
	Id   plugin.TValue[string]
}

// createAwsEc2NetworkaclEntryPortrange creates a new instance of this resource
func createAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntryPortrange{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry.portrange", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlName() string {
	return "aws.ec2.networkacl.entry.portrange"
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetFrom() *plugin.TValue[int64] {
	return &c.From
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetTo() *plugin.TValue[int64] {
	return &c.To
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2Vpnconnection for the aws.ec2.vpnconnection resource
type mqlAwsEc2Vpnconnection struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2VpnconnectionInternal it will be used here
	Arn          plugin.TValue[string]
	VgwTelemetry plugin.TValue[[]any]
}

// createAwsEc2Vpnconnection creates a new instance of this resource
func createAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vpnconnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vpnconnection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vpnconnection) MqlName() string {
	return "aws.ec2.vpnconnection"
}

func (c *mqlAwsEc2Vpnconnection) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vpnconnection) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Vpnconnection) GetVgwTelemetry() *plugin.TValue[[]any] {
	return &c.VgwTelemetry
}

// mqlAwsEc2Vgwtelemetry for the aws.ec2.vgwtelemetry resource
type mqlAwsEc2Vgwtelemetry struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2VgwtelemetryInternal it will be used here
	OutsideIpAddress plugin.TValue[string]
	Status           plugin.TValue[string]
	StatusMessage    plugin.TValue[string]
}

// createAwsEc2Vgwtelemetry creates a new instance of this resource
func createAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vgwtelemetry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vgwtelemetry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vgwtelemetry) MqlName() string {
	return "aws.ec2.vgwtelemetry"
}

func (c *mqlAwsEc2Vgwtelemetry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vgwtelemetry) GetOutsideIpAddress() *plugin.TValue[string] {
	return &c.OutsideIpAddress
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatusMessage() *plugin.TValue[string] {
	return &c.StatusMessage
}

// mqlAwsEc2Internetgateway for the aws.ec2.internetgateway resource
type mqlAwsEc2Internetgateway struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2InternetgatewayInternal it will be used here
	Arn         plugin.TValue[string]
	Id          plugin.TValue[string]
	Region      plugin.TValue[string]
	Attachments plugin.TValue[[]any]
	Tags        plugin.TValue[map[string]any]
}

// createAwsEc2Internetgateway creates a new instance of this resource
func createAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Internetgateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.internetgateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Internetgateway) MqlName() string {
	return "aws.ec2.internetgateway"
}

func (c *mqlAwsEc2Internetgateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Internetgateway) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Internetgateway) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Internetgateway) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Internetgateway) GetAttachments() *plugin.TValue[[]any] {
	return &c.Attachments
}

func (c *mqlAwsEc2Internetgateway) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

// mqlAwsEc2Snapshot for the aws.ec2.snapshot resource
type mqlAwsEc2Snapshot struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2SnapshotInternal
	Arn                    plugin.TValue[string]
	Id                     plugin.TValue[string]
	Region                 plugin.TValue[string]
	CreateVolumePermission plugin.TValue[[]any]
	VolumeId               plugin.TValue[string]
	StartTime              plugin.TValue[*time.Time]
	CompletionTime         plugin.TValue[*time.Time]
	Tags                   plugin.TValue[map[string]any]
	State                  plugin.TValue[string]
	VolumeSize             plugin.TValue[int64]
	Description            plugin.TValue[string]
	Encrypted              plugin.TValue[bool]
	StorageTier            plugin.TValue[string]
	KmsKey                 plugin.TValue[*mqlAwsKmsKey]
}

// createAwsEc2Snapshot creates a new instance of this resource
func createAwsEc2Snapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Snapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Snapshot) MqlName() string {
	return "aws.ec2.snapshot"
}

func (c *mqlAwsEc2Snapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Snapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Snapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Snapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Snapshot) GetCreateVolumePermission() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.CreateVolumePermission, func() ([]any, error) {
		return c.createVolumePermission()
	})
}

func (c *mqlAwsEc2Snapshot) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2Snapshot) GetStartTime() *plugin.TValue[*time.Time] {
	return &c.StartTime
}

func (c *mqlAwsEc2Snapshot) GetCompletionTime() *plugin.TValue[*time.Time] {
	return &c.CompletionTime
}

func (c *mqlAwsEc2Snapshot) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Snapshot) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Snapshot) GetVolumeSize() *plugin.TValue[int64] {
	return &c.VolumeSize
}

func (c *mqlAwsEc2Snapshot) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Snapshot) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEc2Snapshot) GetStorageTier() *plugin.TValue[string] {
	return &c.StorageTier
}

func (c *mqlAwsEc2Snapshot) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.snapshot", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

// mqlAwsEc2Volume for the aws.ec2.volume resource
type mqlAwsEc2Volume struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2VolumeInternal
	Arn                plugin.TValue[string]
	Id                 plugin.TValue[string]
	Attachments        plugin.TValue[[]any]
	Encrypted          plugin.TValue[bool]
	State              plugin.TValue[string]
	Tags               plugin.TValue[map[string]any]
	AvailabilityZone   plugin.TValue[string]
	VolumeType         plugin.TValue[string]
	CreateTime         plugin.TValue[*time.Time]
	Region             plugin.TValue[string]
	MultiAttachEnabled plugin.TValue[bool]
	Throughput         plugin.TValue[int64]
	Size               plugin.TValue[int64]
	Iops               plugin.TValue[int64]
	KmsKey             plugin.TValue[*mqlAwsKmsKey]
}

// createAwsEc2Volume creates a new instance of this resource
func createAwsEc2Volume(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Volume{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.volume", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Volume) MqlName() string {
	return "aws.ec2.volume"
}

func (c *mqlAwsEc2Volume) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Volume) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Volume) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Volume) GetAttachments() *plugin.TValue[[]any] {
	return &c.Attachments
}

func (c *mqlAwsEc2Volume) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEc2Volume) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Volume) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Volume) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEc2Volume) GetVolumeType() *plugin.TValue[string] {
	return &c.VolumeType
}

func (c *mqlAwsEc2Volume) GetCreateTime() *plugin.TValue[*time.Time] {
	return &c.CreateTime
}

func (c *mqlAwsEc2Volume) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Volume) GetMultiAttachEnabled() *plugin.TValue[bool] {
	return &c.MultiAttachEnabled
}

func (c *mqlAwsEc2Volume) GetThroughput() *plugin.TValue[int64] {
	return &c.Throughput
}

func (c *mqlAwsEc2Volume) GetSize() *plugin.TValue[int64] {
	return &c.Size
}

func (c *mqlAwsEc2Volume) GetIops() *plugin.TValue[int64] {
	return &c.Iops
}

func (c *mqlAwsEc2Volume) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.volume", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

// mqlAwsInspector for the aws.inspector resource
type mqlAwsInspector struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsInspectorInternal it will be used here
	Coverages plugin.TValue[[]any]
}

// createAwsInspector creates a new instance of this resource
func createAwsInspector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspector) MqlName() string {
	return "aws.inspector"
}

func (c *mqlAwsInspector) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspector) GetCoverages() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Coverages, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector", c.__id, "coverages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.coverages()
	})
}

// mqlAwsInspectorCoverage for the aws.inspector.coverage resource
type mqlAwsInspectorCoverage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsInspectorCoverageInternal
	AccountId     plugin.TValue[string]
	ResourceId    plugin.TValue[string]
	ResourceType  plugin.TValue[string]
	LastScannedAt plugin.TValue[*time.Time]
	StatusReason  plugin.TValue[string]
	StatusCode    plugin.TValue[string]
	ScanType      plugin.TValue[string]
	Region        plugin.TValue[string]
	Ec2Instance   plugin.TValue[*mqlAwsInspectorCoverageInstance]
	EcrImage      plugin.TValue[*mqlAwsInspectorCoverageImage]
	EcrRepo       plugin.TValue[*mqlAwsInspectorCoverageRepository]
	Lambda        plugin.TValue[*mqlAwsLambdaFunction]
}

// createAwsInspectorCoverage creates a new instance of this resource
func createAwsInspectorCoverage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverage) MqlName() string {
	return "aws.inspector.coverage"
}

func (c *mqlAwsInspectorCoverage) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverage) GetAccountId() *plugin.TValue[string] {
	return &c.AccountId
}

func (c *mqlAwsInspectorCoverage) GetResourceId() *plugin.TValue[string] {
	return &c.ResourceId
}

func (c *mqlAwsInspectorCoverage) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsInspectorCoverage) GetLastScannedAt() *plugin.TValue[*time.Time] {
	return &c.LastScannedAt
}

func (c *mqlAwsInspectorCoverage) GetStatusReason() *plugin.TValue[string] {
	return &c.StatusReason
}

func (c *mqlAwsInspectorCoverage) GetStatusCode() *plugin.TValue[string] {
	return &c.StatusCode
}

func (c *mqlAwsInspectorCoverage) GetScanType() *plugin.TValue[string] {
	return &c.ScanType
}

func (c *mqlAwsInspectorCoverage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsInspectorCoverage) GetEc2Instance() *plugin.TValue[*mqlAwsInspectorCoverageInstance] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageInstance](&c.Ec2Instance, func() (*mqlAwsInspectorCoverageInstance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ec2Instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageInstance), nil
			}
		}

		return c.ec2Instance()
	})
}

func (c *mqlAwsInspectorCoverage) GetEcrImage() *plugin.TValue[*mqlAwsInspectorCoverageImage] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageImage](&c.EcrImage, func() (*mqlAwsInspectorCoverageImage, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ecrImage")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageImage), nil
			}
		}

		return c.ecrImage()
	})
}

func (c *mqlAwsInspectorCoverage) GetEcrRepo() *plugin.TValue[*mqlAwsInspectorCoverageRepository] {
	return plugin.GetOrCompute[*mqlAwsInspectorCoverageRepository](&c.EcrRepo, func() (*mqlAwsInspectorCoverageRepository, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "ecrRepo")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsInspectorCoverageRepository), nil
			}
		}

		return c.ecrRepo()
	})
}

func (c *mqlAwsInspectorCoverage) GetLambda() *plugin.TValue[*mqlAwsLambdaFunction] {
	return plugin.GetOrCompute[*mqlAwsLambdaFunction](&c.Lambda, func() (*mqlAwsLambdaFunction, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.inspector.coverage", c.__id, "lambda")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsLambdaFunction), nil
			}
		}

		return c.lambda()
	})
}

// mqlAwsInspectorCoverageInstance for the aws.inspector.coverage.instance resource
type mqlAwsInspectorCoverageInstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsInspectorCoverageInstanceInternal
	Platform plugin.TValue[string]
	Tags     plugin.TValue[map[string]any]
	Image    plugin.TValue[*mqlAwsEc2Image]
	Region   plugin.TValue[string]
}

// createAwsInspectorCoverageInstance creates a new instance of this resource
func createAwsInspectorCoverageInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageInstance) MqlName() string {
	return "aws.inspector.coverage.instance"
}

func (c *mqlAwsInspectorCoverageInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageInstance) GetPlatform() *plugin.TValue[string] {
	return &c.Platform
}

func (c *mqlAwsInspectorCoverageInstance) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsInspectorCoverageInstance) GetImage() *plugin.TValue[*mqlAwsEc2Image] {
	return &c.Image
}

func (c *mqlAwsInspectorCoverageInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsInspectorCoverageImage for the aws.inspector.coverage.image resource
type mqlAwsInspectorCoverageImage struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsInspectorCoverageImageInternal it will be used here
	ImagePulledAt plugin.TValue[*time.Time]
	Tags          plugin.TValue[map[string]any]
	Region        plugin.TValue[string]
}

// createAwsInspectorCoverageImage creates a new instance of this resource
func createAwsInspectorCoverageImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageImage) MqlName() string {
	return "aws.inspector.coverage.image"
}

func (c *mqlAwsInspectorCoverageImage) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageImage) GetImagePulledAt() *plugin.TValue[*time.Time] {
	return &c.ImagePulledAt
}

func (c *mqlAwsInspectorCoverageImage) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsInspectorCoverageImage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsInspectorCoverageRepository for the aws.inspector.coverage.repository resource
type mqlAwsInspectorCoverageRepository struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsInspectorCoverageRepositoryInternal it will be used here
	Name          plugin.TValue[string]
	ScanFrequency plugin.TValue[string]
	Region        plugin.TValue[string]
}

// createAwsInspectorCoverageRepository creates a new instance of this resource
func createAwsInspectorCoverageRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsInspectorCoverageRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.inspector.coverage.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsInspectorCoverageRepository) MqlName() string {
	return "aws.inspector.coverage.repository"
}

func (c *mqlAwsInspectorCoverageRepository) MqlID() string {
	return c.__id
}

func (c *mqlAwsInspectorCoverageRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsInspectorCoverageRepository) GetScanFrequency() *plugin.TValue[string] {
	return &c.ScanFrequency
}

func (c *mqlAwsInspectorCoverageRepository) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEc2Instance for the aws.ec2.instance resource
type mqlAwsEc2Instance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2InstanceInternal
	Arn                     plugin.TValue[string]
	InstanceId              plugin.TValue[string]
	DetailedMonitoring      plugin.TValue[string]
	Region                  plugin.TValue[string]
	PublicIp                plugin.TValue[string]
	Ssm                     plugin.TValue[any]
	Vpc                     plugin.TValue[*mqlAwsVpc]
	HttpTokens              plugin.TValue[string]
	HttpEndpoint            plugin.TValue[string]
	HttpPutResponseHopLimit plugin.TValue[int64]
	EnclaveEnabled          plugin.TValue[bool]
	PatchState              plugin.TValue[any]
	State                   plugin.TValue[string]
	DeviceMappings          plugin.TValue[[]any]
	SecurityGroups          plugin.TValue[[]any]
	PlatformDetails         plugin.TValue[string]
	PublicDnsName           plugin.TValue[string]
	InstanceStatus          plugin.TValue[any]
	StateReason             plugin.TValue[any]
	StateTransitionReason   plugin.TValue[string]
	EbsOptimized            plugin.TValue[bool]
	EnaSupported            plugin.TValue[bool]
	InstanceType            plugin.TValue[string]
	Tags                    plugin.TValue[map[string]any]
	IamInstanceProfile      plugin.TValue[*mqlAwsIamInstanceProfile]
	Image                   plugin.TValue[*mqlAwsEc2Image]
	LaunchTime              plugin.TValue[*time.Time]
	PrivateIp               plugin.TValue[string]
	PrivateDnsName          plugin.TValue[string]
	Keypair                 plugin.TValue[*mqlAwsEc2Keypair]
	StateTransitionTime     plugin.TValue[*time.Time]
	VpcArn                  plugin.TValue[string]
	Hypervisor              plugin.TValue[string]
	InstanceLifecycle       plugin.TValue[string]
	RootDeviceType          plugin.TValue[string]
	RootDeviceName          plugin.TValue[string]
	Architecture            plugin.TValue[string]
	TpmSupport              plugin.TValue[string]
	NetworkInterfaces       plugin.TValue[[]any]
	DisableApiTermination   plugin.TValue[bool]
}

// createAwsEc2Instance creates a new instance of this resource
func createAwsEc2Instance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Instance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Instance) MqlName() string {
	return "aws.ec2.instance"
}

func (c *mqlAwsEc2Instance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Instance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Instance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsEc2Instance) GetDetailedMonitoring() *plugin.TValue[string] {
	return &c.DetailedMonitoring
}

func (c *mqlAwsEc2Instance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Instance) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEc2Instance) GetSsm() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Ssm, func() (any, error) {
		return c.ssm()
	})
}

func (c *mqlAwsEc2Instance) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Instance) GetHttpTokens() *plugin.TValue[string] {
	return &c.HttpTokens
}

func (c *mqlAwsEc2Instance) GetHttpEndpoint() *plugin.TValue[string] {
	return &c.HttpEndpoint
}

func (c *mqlAwsEc2Instance) GetHttpPutResponseHopLimit() *plugin.TValue[int64] {
	return &c.HttpPutResponseHopLimit
}

func (c *mqlAwsEc2Instance) GetEnclaveEnabled() *plugin.TValue[bool] {
	return &c.EnclaveEnabled
}

func (c *mqlAwsEc2Instance) GetPatchState() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.PatchState, func() (any, error) {
		return c.patchState()
	})
}

func (c *mqlAwsEc2Instance) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Instance) GetDeviceMappings() *plugin.TValue[[]any] {
	return &c.DeviceMappings
}

func (c *mqlAwsEc2Instance) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2Instance) GetPlatformDetails() *plugin.TValue[string] {
	return &c.PlatformDetails
}

func (c *mqlAwsEc2Instance) GetPublicDnsName() *plugin.TValue[string] {
	return &c.PublicDnsName
}

func (c *mqlAwsEc2Instance) GetInstanceStatus() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.InstanceStatus, func() (any, error) {
		return c.instanceStatus()
	})
}

func (c *mqlAwsEc2Instance) GetStateReason() *plugin.TValue[any] {
	return &c.StateReason
}

func (c *mqlAwsEc2Instance) GetStateTransitionReason() *plugin.TValue[string] {
	return &c.StateTransitionReason
}

func (c *mqlAwsEc2Instance) GetEbsOptimized() *plugin.TValue[bool] {
	return &c.EbsOptimized
}

func (c *mqlAwsEc2Instance) GetEnaSupported() *plugin.TValue[bool] {
	return &c.EnaSupported
}

func (c *mqlAwsEc2Instance) GetInstanceType() *plugin.TValue[string] {
	return &c.InstanceType
}

func (c *mqlAwsEc2Instance) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Instance) GetIamInstanceProfile() *plugin.TValue[*mqlAwsIamInstanceProfile] {
	return plugin.GetOrCompute[*mqlAwsIamInstanceProfile](&c.IamInstanceProfile, func() (*mqlAwsIamInstanceProfile, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "iamInstanceProfile")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamInstanceProfile), nil
			}
		}

		return c.iamInstanceProfile()
	})
}

func (c *mqlAwsEc2Instance) GetImage() *plugin.TValue[*mqlAwsEc2Image] {
	return plugin.GetOrCompute[*mqlAwsEc2Image](&c.Image, func() (*mqlAwsEc2Image, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "image")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Image), nil
			}
		}

		return c.image()
	})
}

func (c *mqlAwsEc2Instance) GetLaunchTime() *plugin.TValue[*time.Time] {
	return &c.LaunchTime
}

func (c *mqlAwsEc2Instance) GetPrivateIp() *plugin.TValue[string] {
	return &c.PrivateIp
}

func (c *mqlAwsEc2Instance) GetPrivateDnsName() *plugin.TValue[string] {
	return &c.PrivateDnsName
}

func (c *mqlAwsEc2Instance) GetKeypair() *plugin.TValue[*mqlAwsEc2Keypair] {
	return plugin.GetOrCompute[*mqlAwsEc2Keypair](&c.Keypair, func() (*mqlAwsEc2Keypair, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "keypair")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Keypair), nil
			}
		}

		return c.keypair()
	})
}

func (c *mqlAwsEc2Instance) GetStateTransitionTime() *plugin.TValue[*time.Time] {
	return &c.StateTransitionTime
}

func (c *mqlAwsEc2Instance) GetVpcArn() *plugin.TValue[string] {
	return &c.VpcArn
}

func (c *mqlAwsEc2Instance) GetHypervisor() *plugin.TValue[string] {
	return &c.Hypervisor
}

func (c *mqlAwsEc2Instance) GetInstanceLifecycle() *plugin.TValue[string] {
	return &c.InstanceLifecycle
}

func (c *mqlAwsEc2Instance) GetRootDeviceType() *plugin.TValue[string] {
	return &c.RootDeviceType
}

func (c *mqlAwsEc2Instance) GetRootDeviceName() *plugin.TValue[string] {
	return &c.RootDeviceName
}

func (c *mqlAwsEc2Instance) GetArchitecture() *plugin.TValue[string] {
	return &c.Architecture
}

func (c *mqlAwsEc2Instance) GetTpmSupport() *plugin.TValue[string] {
	return &c.TpmSupport
}

func (c *mqlAwsEc2Instance) GetNetworkInterfaces() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NetworkInterfaces, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "networkInterfaces")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.networkInterfaces()
	})
}

func (c *mqlAwsEc2Instance) GetDisableApiTermination() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.DisableApiTermination, func() (bool, error) {
		return c.disableApiTermination()
	})
}

// mqlAwsEc2Networkinterface for the aws.ec2.networkinterface resource
type mqlAwsEc2Networkinterface struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2NetworkinterfaceInternal
	Id               plugin.TValue[string]
	Description      plugin.TValue[string]
	Subnet           plugin.TValue[*mqlAwsVpcSubnet]
	Vpc              plugin.TValue[*mqlAwsVpc]
	Status           plugin.TValue[string]
	SourceDestCheck  plugin.TValue[bool]
	RequesterManaged plugin.TValue[bool]
	Tags             plugin.TValue[map[string]any]
	AvailabilityZone plugin.TValue[string]
	SecurityGroups   plugin.TValue[[]any]
	Ipv6Native       plugin.TValue[bool]
	MacAddress       plugin.TValue[string]
	PrivateDnsName   plugin.TValue[string]
	PrivateIpAddress plugin.TValue[string]
}

// createAwsEc2Networkinterface creates a new instance of this resource
func createAwsEc2Networkinterface(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Networkinterface{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkinterface", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Networkinterface) MqlName() string {
	return "aws.ec2.networkinterface"
}

func (c *mqlAwsEc2Networkinterface) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Networkinterface) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Networkinterface) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Networkinterface) GetSubnet() *plugin.TValue[*mqlAwsVpcSubnet] {
	return plugin.GetOrCompute[*mqlAwsVpcSubnet](&c.Subnet, func() (*mqlAwsVpcSubnet, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "subnet")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpcSubnet), nil
			}
		}

		return c.subnet()
	})
}

func (c *mqlAwsEc2Networkinterface) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Networkinterface) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2Networkinterface) GetSourceDestCheck() *plugin.TValue[bool] {
	return &c.SourceDestCheck
}

func (c *mqlAwsEc2Networkinterface) GetRequesterManaged() *plugin.TValue[bool] {
	return &c.RequesterManaged
}

func (c *mqlAwsEc2Networkinterface) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Networkinterface) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEc2Networkinterface) GetSecurityGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.SecurityGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkinterface", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2Networkinterface) GetIpv6Native() *plugin.TValue[bool] {
	return &c.Ipv6Native
}

func (c *mqlAwsEc2Networkinterface) GetMacAddress() *plugin.TValue[string] {
	return &c.MacAddress
}

func (c *mqlAwsEc2Networkinterface) GetPrivateDnsName() *plugin.TValue[string] {
	return &c.PrivateDnsName
}

func (c *mqlAwsEc2Networkinterface) GetPrivateIpAddress() *plugin.TValue[string] {
	return &c.PrivateIpAddress
}

// mqlAwsEc2Keypair for the aws.ec2.keypair resource
type mqlAwsEc2Keypair struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2KeypairInternal it will be used here
	Arn         plugin.TValue[string]
	Fingerprint plugin.TValue[string]
	Name        plugin.TValue[string]
	Type        plugin.TValue[string]
	Tags        plugin.TValue[map[string]any]
	Region      plugin.TValue[string]
	CreatedAt   plugin.TValue[*time.Time]
}

// createAwsEc2Keypair creates a new instance of this resource
func createAwsEc2Keypair(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Keypair{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.keypair", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Keypair) MqlName() string {
	return "aws.ec2.keypair"
}

func (c *mqlAwsEc2Keypair) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Keypair) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Keypair) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlAwsEc2Keypair) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Keypair) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsEc2Keypair) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Keypair) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Keypair) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsEc2Image for the aws.ec2.image resource
type mqlAwsEc2Image struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2ImageInternal it will be used here
	Arn                 plugin.TValue[string]
	Id                  plugin.TValue[string]
	Name                plugin.TValue[string]
	Architecture        plugin.TValue[string]
	OwnerId             plugin.TValue[string]
	OwnerAlias          plugin.TValue[string]
	CreatedAt           plugin.TValue[*time.Time]
	DeprecatedAt        plugin.TValue[*time.Time]
	EnaSupport          plugin.TValue[bool]
	TpmSupport          plugin.TValue[string]
	ImdsSupport         plugin.TValue[string]
	State               plugin.TValue[string]
	Public              plugin.TValue[bool]
	RootDeviceType      plugin.TValue[string]
	VirtualizationType  plugin.TValue[string]
	BlockDeviceMappings plugin.TValue[[]any]
	Tags                plugin.TValue[map[string]any]
	Region              plugin.TValue[string]
	LaunchPermissions   plugin.TValue[[]any]
}

// createAwsEc2Image creates a new instance of this resource
func createAwsEc2Image(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Image{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Image) MqlName() string {
	return "aws.ec2.image"
}

func (c *mqlAwsEc2Image) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Image) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Image) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Image) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Image) GetArchitecture() *plugin.TValue[string] {
	return &c.Architecture
}

func (c *mqlAwsEc2Image) GetOwnerId() *plugin.TValue[string] {
	return &c.OwnerId
}

func (c *mqlAwsEc2Image) GetOwnerAlias() *plugin.TValue[string] {
	return &c.OwnerAlias
}

func (c *mqlAwsEc2Image) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEc2Image) GetDeprecatedAt() *plugin.TValue[*time.Time] {
	return &c.DeprecatedAt
}

func (c *mqlAwsEc2Image) GetEnaSupport() *plugin.TValue[bool] {
	return &c.EnaSupport
}

func (c *mqlAwsEc2Image) GetTpmSupport() *plugin.TValue[string] {
	return &c.TpmSupport
}

func (c *mqlAwsEc2Image) GetImdsSupport() *plugin.TValue[string] {
	return &c.ImdsSupport
}

func (c *mqlAwsEc2Image) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Image) GetPublic() *plugin.TValue[bool] {
	return &c.Public
}

func (c *mqlAwsEc2Image) GetRootDeviceType() *plugin.TValue[string] {
	return &c.RootDeviceType
}

func (c *mqlAwsEc2Image) GetVirtualizationType() *plugin.TValue[string] {
	return &c.VirtualizationType
}

func (c *mqlAwsEc2Image) GetBlockDeviceMappings() *plugin.TValue[[]any] {
	return &c.BlockDeviceMappings
}

func (c *mqlAwsEc2Image) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Image) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Image) GetLaunchPermissions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.LaunchPermissions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.image", c.__id, "launchPermissions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.launchPermissions()
	})
}

// mqlAwsEc2ImageLaunchPermission for the aws.ec2.image.launchPermission resource
type mqlAwsEc2ImageLaunchPermission struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2ImageLaunchPermissionInternal it will be used here
	UserId                plugin.TValue[string]
	Group                 plugin.TValue[string]
	OrganizationArn       plugin.TValue[string]
	OrganizationalUnitArn plugin.TValue[string]
}

// createAwsEc2ImageLaunchPermission creates a new instance of this resource
func createAwsEc2ImageLaunchPermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2ImageLaunchPermission{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image.launchPermission", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2ImageLaunchPermission) MqlName() string {
	return "aws.ec2.image.launchPermission"
}

func (c *mqlAwsEc2ImageLaunchPermission) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2ImageLaunchPermission) GetUserId() *plugin.TValue[string] {
	return &c.UserId
}

func (c *mqlAwsEc2ImageLaunchPermission) GetGroup() *plugin.TValue[string] {
	return &c.Group
}

func (c *mqlAwsEc2ImageLaunchPermission) GetOrganizationArn() *plugin.TValue[string] {
	return &c.OrganizationArn
}

func (c *mqlAwsEc2ImageLaunchPermission) GetOrganizationalUnitArn() *plugin.TValue[string] {
	return &c.OrganizationalUnitArn
}

// mqlAwsEc2ImageBlockDeviceMapping for the aws.ec2.image.blockDeviceMapping resource
type mqlAwsEc2ImageBlockDeviceMapping struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2ImageBlockDeviceMappingInternal it will be used here
	DeviceName  plugin.TValue[string]
	VirtualName plugin.TValue[string]
	NoDevice    plugin.TValue[bool]
	Ebs         plugin.TValue[*mqlAwsEc2ImageEbsBlockDevice]
}

// createAwsEc2ImageBlockDeviceMapping creates a new instance of this resource
func createAwsEc2ImageBlockDeviceMapping(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2ImageBlockDeviceMapping{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image.blockDeviceMapping", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) MqlName() string {
	return "aws.ec2.image.blockDeviceMapping"
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) GetDeviceName() *plugin.TValue[string] {
	return &c.DeviceName
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) GetVirtualName() *plugin.TValue[string] {
	return &c.VirtualName
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) GetNoDevice() *plugin.TValue[bool] {
	return &c.NoDevice
}

func (c *mqlAwsEc2ImageBlockDeviceMapping) GetEbs() *plugin.TValue[*mqlAwsEc2ImageEbsBlockDevice] {
	return &c.Ebs
}

// mqlAwsEc2ImageEbsBlockDevice for the aws.ec2.image.ebsBlockDevice resource
type mqlAwsEc2ImageEbsBlockDevice struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2ImageEbsBlockDeviceInternal it will be used here
	Encrypted           plugin.TValue[bool]
	SnapshotId          plugin.TValue[string]
	VolumeSize          plugin.TValue[int64]
	VolumeType          plugin.TValue[string]
	KmsKeyId            plugin.TValue[string]
	Iops                plugin.TValue[int64]
	Throughput          plugin.TValue[int64]
	DeleteOnTermination plugin.TValue[bool]
}

// createAwsEc2ImageEbsBlockDevice creates a new instance of this resource
func createAwsEc2ImageEbsBlockDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2ImageEbsBlockDevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image.ebsBlockDevice", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2ImageEbsBlockDevice) MqlName() string {
	return "aws.ec2.image.ebsBlockDevice"
}

func (c *mqlAwsEc2ImageEbsBlockDevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetSnapshotId() *plugin.TValue[string] {
	return &c.SnapshotId
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetVolumeSize() *plugin.TValue[int64] {
	return &c.VolumeSize
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetVolumeType() *plugin.TValue[string] {
	return &c.VolumeType
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetIops() *plugin.TValue[int64] {
	return &c.Iops
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetThroughput() *plugin.TValue[int64] {
	return &c.Throughput
}

func (c *mqlAwsEc2ImageEbsBlockDevice) GetDeleteOnTermination() *plugin.TValue[bool] {
	return &c.DeleteOnTermination
}

// mqlAwsEc2InstanceDevice for the aws.ec2.instance.device resource
type mqlAwsEc2InstanceDevice struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2InstanceDeviceInternal it will be used here
	DeleteOnTermination plugin.TValue[bool]
	Status              plugin.TValue[string]
	VolumeId            plugin.TValue[string]
	DeviceName          plugin.TValue[string]
}

// createAwsEc2InstanceDevice creates a new instance of this resource
func createAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2InstanceDevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance.device", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2InstanceDevice) MqlName() string {
	return "aws.ec2.instance.device"
}

func (c *mqlAwsEc2InstanceDevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2InstanceDevice) GetDeleteOnTermination() *plugin.TValue[bool] {
	return &c.DeleteOnTermination
}

func (c *mqlAwsEc2InstanceDevice) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2InstanceDevice) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2InstanceDevice) GetDeviceName() *plugin.TValue[string] {
	return &c.DeviceName
}

// mqlAwsEc2Securitygroup for the aws.ec2.securitygroup resource
type mqlAwsEc2Securitygroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEc2SecuritygroupInternal
	Arn                          plugin.TValue[string]
	Id                           plugin.TValue[string]
	Name                         plugin.TValue[string]
	Description                  plugin.TValue[string]
	Tags                         plugin.TValue[map[string]any]
	Vpc                          plugin.TValue[*mqlAwsVpc]
	IpPermissions                plugin.TValue[[]any]
	IpPermissionsEgress          plugin.TValue[[]any]
	Region                       plugin.TValue[string]
	IsAttachedToNetworkInterface plugin.TValue[bool]
}

// createAwsEc2Securitygroup creates a new instance of this resource
func createAwsEc2Securitygroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Securitygroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Securitygroup) MqlName() string {
	return "aws.ec2.securitygroup"
}

func (c *mqlAwsEc2Securitygroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Securitygroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Securitygroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Securitygroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Securitygroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Securitygroup) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEc2Securitygroup) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissions() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.IpPermissions, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "ipPermissions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ipPermissions()
	})
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissionsEgress() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.IpPermissionsEgress, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.securitygroup", c.__id, "ipPermissionsEgress")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.ipPermissionsEgress()
	})
}

func (c *mqlAwsEc2Securitygroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Securitygroup) GetIsAttachedToNetworkInterface() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachedToNetworkInterface, func() (bool, error) {
		return c.isAttachedToNetworkInterface()
	})
}

// mqlAwsEc2SecuritygroupIppermission for the aws.ec2.securitygroup.ippermission resource
type mqlAwsEc2SecuritygroupIppermission struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEc2SecuritygroupIppermissionInternal it will be used here
	Id               plugin.TValue[string]
	FromPort         plugin.TValue[int64]
	ToPort           plugin.TValue[int64]
	IpProtocol       plugin.TValue[string]
	IpRanges         plugin.TValue[[]any]
	Ipv6Ranges       plugin.TValue[[]any]
	PrefixListIds    plugin.TValue[[]any]
	UserIdGroupPairs plugin.TValue[[]any]
}

// createAwsEc2SecuritygroupIppermission creates a new instance of this resource
func createAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2SecuritygroupIppermission{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup.ippermission", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlName() string {
	return "aws.ec2.securitygroup.ippermission"
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetFromPort() *plugin.TValue[int64] {
	return &c.FromPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetToPort() *plugin.TValue[int64] {
	return &c.ToPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpProtocol() *plugin.TValue[string] {
	return &c.IpProtocol
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpRanges() *plugin.TValue[[]any] {
	return &c.IpRanges
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpv6Ranges() *plugin.TValue[[]any] {
	return &c.Ipv6Ranges
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetPrefixListIds() *plugin.TValue[[]any] {
	return &c.PrefixListIds
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetUserIdGroupPairs() *plugin.TValue[[]any] {
	return &c.UserIdGroupPairs
}

// mqlAwsConfig for the aws.config resource
type mqlAwsConfig struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsConfigInternal it will be used here
	Recorders        plugin.TValue[[]any]
	Rules            plugin.TValue[[]any]
	DeliveryChannels plugin.TValue[[]any]
}

// createAwsConfig creates a new instance of this resource
func createAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfig) MqlName() string {
	return "aws.config"
}

func (c *mqlAwsConfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfig) GetRecorders() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Recorders, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "recorders")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.recorders()
	})
}

func (c *mqlAwsConfig) GetRules() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Rules, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.rules()
	})
}

func (c *mqlAwsConfig) GetDeliveryChannels() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DeliveryChannels, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "deliveryChannels")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deliveryChannels()
	})
}

// mqlAwsConfigRule for the aws.config.rule resource
type mqlAwsConfigRule struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsConfigRuleInternal it will be used here
	Arn         plugin.TValue[string]
	State       plugin.TValue[string]
	Source      plugin.TValue[any]
	Id          plugin.TValue[string]
	Name        plugin.TValue[string]
	Description plugin.TValue[string]
	Region      plugin.TValue[string]
}

// createAwsConfigRule creates a new instance of this resource
func createAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.rule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRule) MqlName() string {
	return "aws.config.rule"
}

func (c *mqlAwsConfigRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRule) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsConfigRule) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsConfigRule) GetSource() *plugin.TValue[any] {
	return &c.Source
}

func (c *mqlAwsConfigRule) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsConfigRule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigRule) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsConfigRule) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsConfigRecorder for the aws.config.recorder resource
type mqlAwsConfigRecorder struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsConfigRecorderInternal it will be used here
	Name                       plugin.TValue[string]
	RoleArn                    plugin.TValue[string]
	AllSupported               plugin.TValue[bool]
	IncludeGlobalResourceTypes plugin.TValue[bool]
	Recording                  plugin.TValue[bool]
	LastStatus                 plugin.TValue[string]
	Region                     plugin.TValue[string]
	ResourceTypes              plugin.TValue[[]any]
}

// createAwsConfigRecorder creates a new instance of this resource
func createAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRecorder{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.recorder", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRecorder) MqlName() string {
	return "aws.config.recorder"
}

func (c *mqlAwsConfigRecorder) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRecorder) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigRecorder) GetRoleArn() *plugin.TValue[string] {
	return &c.RoleArn
}

func (c *mqlAwsConfigRecorder) GetAllSupported() *plugin.TValue[bool] {
	return &c.AllSupported
}

func (c *mqlAwsConfigRecorder) GetIncludeGlobalResourceTypes() *plugin.TValue[bool] {
	return &c.IncludeGlobalResourceTypes
}

func (c *mqlAwsConfigRecorder) GetRecording() *plugin.TValue[bool] {
	return &c.Recording
}

func (c *mqlAwsConfigRecorder) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsConfigRecorder) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsConfigRecorder) GetResourceTypes() *plugin.TValue[[]any] {
	return &c.ResourceTypes
}

// mqlAwsConfigDeliverychannel for the aws.config.deliverychannel resource
type mqlAwsConfigDeliverychannel struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsConfigDeliverychannelInternal it will be used here
	Name         plugin.TValue[string]
	S3BucketName plugin.TValue[string]
	S3KeyPrefix  plugin.TValue[string]
	SnsTopicARN  plugin.TValue[string]
	Region       plugin.TValue[string]
}

// createAwsConfigDeliverychannel creates a new instance of this resource
func createAwsConfigDeliverychannel(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigDeliverychannel{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.deliverychannel", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigDeliverychannel) MqlName() string {
	return "aws.config.deliverychannel"
}

func (c *mqlAwsConfigDeliverychannel) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigDeliverychannel) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigDeliverychannel) GetS3BucketName() *plugin.TValue[string] {
	return &c.S3BucketName
}

func (c *mqlAwsConfigDeliverychannel) GetS3KeyPrefix() *plugin.TValue[string] {
	return &c.S3KeyPrefix
}

func (c *mqlAwsConfigDeliverychannel) GetSnsTopicARN() *plugin.TValue[string] {
	return &c.SnsTopicARN
}

func (c *mqlAwsConfigDeliverychannel) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEks for the aws.eks resource
type mqlAwsEks struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEksInternal it will be used here
	Clusters plugin.TValue[[]any]
}

// createAwsEks creates a new instance of this resource
func createAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEks{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEks) MqlName() string {
	return "aws.eks"
}

func (c *mqlAwsEks) MqlID() string {
	return c.__id
}

func (c *mqlAwsEks) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEksNodegroup for the aws.eks.nodegroup resource
type mqlAwsEksNodegroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEksNodegroupInternal
	Name              plugin.TValue[string]
	Arn               plugin.TValue[string]
	Region            plugin.TValue[string]
	CreatedAt         plugin.TValue[*time.Time]
	ModifiedAt        plugin.TValue[*time.Time]
	Status            plugin.TValue[string]
	CapacityType      plugin.TValue[string]
	ScalingConfig     plugin.TValue[any]
	InstanceTypes     plugin.TValue[[]any]
	AmiType           plugin.TValue[string]
	NodeRole          plugin.TValue[*mqlAwsIamRole]
	DiskSize          plugin.TValue[int64]
	Labels            plugin.TValue[map[string]any]
	Tags              plugin.TValue[map[string]any]
	AutoscalingGroups plugin.TValue[[]any]
}

// createAwsEksNodegroup creates a new instance of this resource
func createAwsEksNodegroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksNodegroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.nodegroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksNodegroup) MqlName() string {
	return "aws.eks.nodegroup"
}

func (c *mqlAwsEksNodegroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksNodegroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksNodegroup) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsEksNodegroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEksNodegroup) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsEksNodegroup) GetModifiedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ModifiedAt, func() (*time.Time, error) {
		return c.modifiedAt()
	})
}

func (c *mqlAwsEksNodegroup) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsEksNodegroup) GetCapacityType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.CapacityType, func() (string, error) {
		return c.capacityType()
	})
}

func (c *mqlAwsEksNodegroup) GetScalingConfig() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ScalingConfig, func() (any, error) {
		return c.scalingConfig()
	})
}

func (c *mqlAwsEksNodegroup) GetInstanceTypes() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.InstanceTypes, func() ([]any, error) {
		return c.instanceTypes()
	})
}

func (c *mqlAwsEksNodegroup) GetAmiType() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AmiType, func() (string, error) {
		return c.amiType()
	})
}

func (c *mqlAwsEksNodegroup) GetNodeRole() *plugin.TValue[*mqlAwsIamRole] {
	return plugin.GetOrCompute[*mqlAwsIamRole](&c.NodeRole, func() (*mqlAwsIamRole, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.nodegroup", c.__id, "nodeRole")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamRole), nil
			}
		}

		return c.nodeRole()
	})
}

func (c *mqlAwsEksNodegroup) GetDiskSize() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.DiskSize, func() (int64, error) {
		return c.diskSize()
	})
}

func (c *mqlAwsEksNodegroup) GetLabels() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Labels, func() (map[string]any, error) {
		return c.labels()
	})
}

func (c *mqlAwsEksNodegroup) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsEksNodegroup) GetAutoscalingGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AutoscalingGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.nodegroup", c.__id, "autoscalingGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.autoscalingGroups()
	})
}

// mqlAwsEksAddon for the aws.eks.addon resource
type mqlAwsEksAddon struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsEksAddonInternal
	Name                plugin.TValue[string]
	Arn                 plugin.TValue[string]
	Status              plugin.TValue[string]
	AddonVersion        plugin.TValue[string]
	CreatedAt           plugin.TValue[*time.Time]
	ModifiedAt          plugin.TValue[*time.Time]
	Tags                plugin.TValue[map[string]any]
	Publisher           plugin.TValue[string]
	Owner               plugin.TValue[string]
	ConfigurationValues plugin.TValue[string]
}

// createAwsEksAddon creates a new instance of this resource
func createAwsEksAddon(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksAddon{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.addon", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksAddon) MqlName() string {
	return "aws.eks.addon"
}

func (c *mqlAwsEksAddon) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksAddon) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksAddon) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsEksAddon) GetStatus() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Status, func() (string, error) {
		return c.status()
	})
}

func (c *mqlAwsEksAddon) GetAddonVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AddonVersion, func() (string, error) {
		return c.addonVersion()
	})
}

func (c *mqlAwsEksAddon) GetCreatedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreatedAt, func() (*time.Time, error) {
		return c.createdAt()
	})
}

func (c *mqlAwsEksAddon) GetModifiedAt() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.ModifiedAt, func() (*time.Time, error) {
		return c.modifiedAt()
	})
}

func (c *mqlAwsEksAddon) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsEksAddon) GetPublisher() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Publisher, func() (string, error) {
		return c.publisher()
	})
}

func (c *mqlAwsEksAddon) GetOwner() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Owner, func() (string, error) {
		return c.owner()
	})
}

func (c *mqlAwsEksAddon) GetConfigurationValues() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.ConfigurationValues, func() (string, error) {
		return c.configurationValues()
	})
}

// mqlAwsEksCluster for the aws.eks.cluster resource
type mqlAwsEksCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsEksClusterInternal it will be used here
	Name                  plugin.TValue[string]
	Arn                   plugin.TValue[string]
	Region                plugin.TValue[string]
	Tags                  plugin.TValue[map[string]any]
	Endpoint              plugin.TValue[string]
	Version               plugin.TValue[string]
	PlatformVersion       plugin.TValue[string]
	Status                plugin.TValue[string]
	EncryptionConfig      plugin.TValue[[]any]
	Logging               plugin.TValue[any]
	NetworkConfig         plugin.TValue[any]
	ResourcesVpcConfig    plugin.TValue[any]
	CreatedAt             plugin.TValue[*time.Time]
	NodeGroups            plugin.TValue[[]any]
	Addons                plugin.TValue[[]any]
	IamRole               plugin.TValue[*mqlAwsIamRole]
	SupportType           plugin.TValue[string]
	AuthenticationMode    plugin.TValue[string]
	DeletionProtection    plugin.TValue[bool]
	EndpointPublicAccess  plugin.TValue[bool]
	EndpointPrivateAccess plugin.TValue[bool]
	PublicAccessCidrs     plugin.TValue[[]any]
}

// createAwsEksCluster creates a new instance of this resource
func createAwsEksCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksCluster) MqlName() string {
	return "aws.eks.cluster"
}

func (c *mqlAwsEksCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEksCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEksCluster) GetTags() *plugin.TValue[map[string]any] {
	return &c.Tags
}

func (c *mqlAwsEksCluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEksCluster) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlAwsEksCluster) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEksCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEksCluster) GetEncryptionConfig() *plugin.TValue[[]any] {
	return &c.EncryptionConfig
}

func (c *mqlAwsEksCluster) GetLogging() *plugin.TValue[any] {
	return &c.Logging
}

func (c *mqlAwsEksCluster) GetNetworkConfig() *plugin.TValue[any] {
	return &c.NetworkConfig
}

func (c *mqlAwsEksCluster) GetResourcesVpcConfig() *plugin.TValue[any] {
	return &c.ResourcesVpcConfig
}

func (c *mqlAwsEksCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsEksCluster) GetNodeGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.NodeGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.cluster", c.__id, "nodeGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.nodeGroups()
	})
}

func (c *mqlAwsEksCluster) GetAddons() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Addons, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks.cluster", c.__id, "addons")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.addons()
	})
}

func (c *mqlAwsEksCluster) GetIamRole() *plugin.TValue[*mqlAwsIamRole] {
	return &c.IamRole
}

func (c *mqlAwsEksCluster) GetSupportType() *plugin.TValue[string] {
	return &c.SupportType
}

func (c *mqlAwsEksCluster) GetAuthenticationMode() *plugin.TValue[string] {
	return &c.AuthenticationMode
}

func (c *mqlAwsEksCluster) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsEksCluster) GetEndpointPublicAccess() *plugin.TValue[bool] {
	return &c.EndpointPublicAccess
}

func (c *mqlAwsEksCluster) GetEndpointPrivateAccess() *plugin.TValue[bool] {
	return &c.EndpointPrivateAccess
}

func (c *mqlAwsEksCluster) GetPublicAccessCidrs() *plugin.TValue[[]any] {
	return &c.PublicAccessCidrs
}

// mqlAwsNeptune for the aws.neptune resource
type mqlAwsNeptune struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsNeptuneInternal it will be used here
	Clusters  plugin.TValue[[]any]
	Instances plugin.TValue[[]any]
}

// createAwsNeptune creates a new instance of this resource
func createAwsNeptune(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptune{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptune) MqlName() string {
	return "aws.neptune"
}

func (c *mqlAwsNeptune) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptune) GetClusters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Clusters, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.neptune", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsNeptune) GetInstances() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Instances, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.neptune", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.instances()
	})
}

// mqlAwsNeptuneCluster for the aws.neptune.cluster resource
type mqlAwsNeptuneCluster struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsNeptuneClusterInternal it will be used here
	Arn                              plugin.TValue[string]
	Name                             plugin.TValue[string]
	ClusterIdentifier                plugin.TValue[string]
	GlobalClusterIdentifier          plugin.TValue[string]
	Engine                           plugin.TValue[string]
	EngineVersion                    plugin.TValue[string]
	KmsKeyId                         plugin.TValue[string]
	Region                           plugin.TValue[string]
	AutomaticRestartTime             plugin.TValue[*time.Time]
	AvailabilityZones                plugin.TValue[[]any]
	BackupRetentionPeriod            plugin.TValue[int64]
	CreatedAt                        plugin.TValue[*time.Time]
	CrossAccountClone                plugin.TValue[bool]
	ClusterParameterGroup            plugin.TValue[string]
	SubnetGroup                      plugin.TValue[string]
	ClusterResourceId                plugin.TValue[string]
	DeletionProtection               plugin.TValue[bool]
	EarliestRestorableTime           plugin.TValue[*time.Time]
	EnabledCloudwatchLogsExports     plugin.TValue[[]any]
	Endpoint                         plugin.TValue[string]
	IamDatabaseAuthenticationEnabled plugin.TValue[bool]
	LatestRestorableTime             plugin.TValue[*time.Time]
	MasterUsername                   plugin.TValue[string]
	MultiAZ                          plugin.TValue[bool]
	Port                             plugin.TValue[int64]
	PreferredBackupWindow            plugin.TValue[string]
	PreferredMaintenanceWindow       plugin.TValue[string]
	Status                           plugin.TValue[string]
	StorageEncrypted                 plugin.TValue[bool]
	StorageType                      plugin.TValue[string]
}

// createAwsNeptuneCluster creates a new instance of this resource
func createAwsNeptuneCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptuneCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptuneCluster) MqlName() string {
	return "aws.neptune.cluster"
}

func (c *mqlAwsNeptuneCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptuneCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsNeptuneCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsNeptuneCluster) GetClusterIdentifier() *plugin.TValue[string] {
	return &c.ClusterIdentifier
}

func (c *mqlAwsNeptuneCluster) GetGlobalClusterIdentifier() *plugin.TValue[string] {
	return &c.GlobalClusterIdentifier
}

func (c *mqlAwsNeptuneCluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsNeptuneCluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsNeptuneCluster) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsNeptuneCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsNeptuneCluster) GetAutomaticRestartTime() *plugin.TValue[*time.Time] {
	return &c.AutomaticRestartTime
}

func (c *mqlAwsNeptuneCluster) GetAvailabilityZones() *plugin.TValue[[]any] {
	return &c.AvailabilityZones
}

func (c *mqlAwsNeptuneCluster) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsNeptuneCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsNeptuneCluster) GetCrossAccountClone() *plugin.TValue[bool] {
	return &c.CrossAccountClone
}

func (c *mqlAwsNeptuneCluster) GetClusterParameterGroup() *plugin.TValue[string] {
	return &c.ClusterParameterGroup
}

func (c *mqlAwsNeptuneCluster) GetSubnetGroup() *plugin.TValue[string] {
	return &c.SubnetGroup
}

func (c *mqlAwsNeptuneCluster) GetClusterResourceId() *plugin.TValue[string] {
	return &c.ClusterResourceId
}

func (c *mqlAwsNeptuneCluster) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsNeptuneCluster) GetEarliestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.EarliestRestorableTime
}

func (c *mqlAwsNeptuneCluster) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]any] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsNeptuneCluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsNeptuneCluster) GetIamDatabaseAuthenticationEnabled() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthenticationEnabled
}

func (c *mqlAwsNeptuneCluster) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsNeptuneCluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsNeptuneCluster) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsNeptuneCluster) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsNeptuneCluster) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsNeptuneCluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsNeptuneCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsNeptuneCluster) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsNeptuneCluster) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

// mqlAwsNeptuneInstance for the aws.neptune.instance resource
type mqlAwsNeptuneInstance struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsNeptuneInstanceInternal it will be used here
	Arn                              plugin.TValue[string]
	Name                             plugin.TValue[string]
	ClusterIdentifier                plugin.TValue[string]
	AutoMinorVersionUpgrade          plugin.TValue[bool]
	AvailabilityZone                 plugin.TValue[string]
	BackupRetentionPeriod            plugin.TValue[int64]
	InstanceClass                    plugin.TValue[string]
	Status                           plugin.TValue[string]
	Port                             plugin.TValue[int64]
	DeletionProtection               plugin.TValue[bool]
	EnabledCloudwatchLogsExports     plugin.TValue[[]any]
	Endpoint                         plugin.TValue[any]
	Engine                           plugin.TValue[string]
	EngineVersion                    plugin.TValue[string]
	EnhancedMonitoringResourceArn    plugin.TValue[string]
	IamDatabaseAuthenticationEnabled plugin.TValue[bool]
	CreatedAt                        plugin.TValue[*time.Time]
	KmsKeyId                         plugin.TValue[string]
	LatestRestorableTime             plugin.TValue[*time.Time]
	MasterUsername                   plugin.TValue[string]
	MonitoringInterval               plugin.TValue[int64]
	MonitoringRoleArn                plugin.TValue[string]
	MultiAZ                          plugin.TValue[bool]
	PreferredBackupWindow            plugin.TValue[string]
	PreferredMaintenanceWindow       plugin.TValue[string]
	PromotionTier                    plugin.TValue[int64]
	Region                           plugin.TValue[string]
	StorageEncrypted                 plugin.TValue[bool]
	StorageType                      plugin.TValue[string]
	TdeCredentialArn                 plugin.TValue[string]
}

// createAwsNeptuneInstance creates a new instance of this resource
func createAwsNeptuneInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsNeptuneInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.neptune.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsNeptuneInstance) MqlName() string {
	return "aws.neptune.instance"
}

func (c *mqlAwsNeptuneInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsNeptuneInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsNeptuneInstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsNeptuneInstance) GetClusterIdentifier() *plugin.TValue[string] {
	return &c.ClusterIdentifier
}

func (c *mqlAwsNeptuneInstance) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsNeptuneInstance) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsNeptuneInstance) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsNeptuneInstance) GetInstanceClass() *plugin.TValue[string] {
	return &c.InstanceClass
}

func (c *mqlAwsNeptuneInstance) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsNeptuneInstance) GetPort() *plugin.TValue[int64] {
	return &c.Port
}

func (c *mqlAwsNeptuneInstance) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsNeptuneInstance) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]any] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsNeptuneInstance) GetEndpoint() *plugin.TValue[any] {
	return &c.Endpoint
}

func (c *mqlAwsNeptuneInstance) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsNeptuneInstance) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsNeptuneInstance) GetEnhancedMonitoringResourceArn() *plugin.TValue[string] {
	return &c.EnhancedMonitoringResourceArn
}

func (c *mqlAwsNeptuneInstance) GetIamDatabaseAuthenticationEnabled() *plugin.TValue[bool] {
	return &c.IamDatabaseAuthenticationEnabled
}

func (c *mqlAwsNeptuneInstance) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsNeptuneInstance) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsNeptuneInstance) GetLatestRestorableTime() *plugin.TValue[*time.Time] {
	return &c.LatestRestorableTime
}

func (c *mqlAwsNeptuneInstance) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsNeptuneInstance) GetMonitoringInterval() *plugin.TValue[int64] {
	return &c.MonitoringInterval
}

func (c *mqlAwsNeptuneInstance) GetMonitoringRoleArn() *plugin.TValue[string] {
	return &c.MonitoringRoleArn
}

func (c *mqlAwsNeptuneInstance) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsNeptuneInstance) GetPreferredBackupWindow() *plugin.TValue[string] {
	return &c.PreferredBackupWindow
}

func (c *mqlAwsNeptuneInstance) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsNeptuneInstance) GetPromotionTier() *plugin.TValue[int64] {
	return &c.PromotionTier
}

func (c *mqlAwsNeptuneInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsNeptuneInstance) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsNeptuneInstance) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsNeptuneInstance) GetTdeCredentialArn() *plugin.TValue[string] {
	return &c.TdeCredentialArn
}

// mqlAwsTimestreamLiveanalytics for the aws.timestream.liveanalytics resource
type mqlAwsTimestreamLiveanalytics struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsTimestreamLiveanalyticsInternal it will be used here
	Databases plugin.TValue[[]any]
	Tables    plugin.TValue[[]any]
}

// createAwsTimestreamLiveanalytics creates a new instance of this resource
func createAwsTimestreamLiveanalytics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalytics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalytics) MqlName() string {
	return "aws.timestream.liveanalytics"
}

func (c *mqlAwsTimestreamLiveanalytics) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalytics) GetDatabases() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Databases, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.timestream.liveanalytics", c.__id, "databases")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.databases()
	})
}

func (c *mqlAwsTimestreamLiveanalytics) GetTables() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Tables, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.timestream.liveanalytics", c.__id, "tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.tables()
	})
}

// mqlAwsTimestreamLiveanalyticsDatabase for the aws.timestream.liveanalytics.database resource
type mqlAwsTimestreamLiveanalyticsDatabase struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsTimestreamLiveanalyticsDatabaseInternal it will be used here
	Arn        plugin.TValue[string]
	Name       plugin.TValue[string]
	KmsKeyId   plugin.TValue[string]
	Region     plugin.TValue[string]
	CreatedAt  plugin.TValue[*time.Time]
	UpdatedAt  plugin.TValue[*time.Time]
	TableCount plugin.TValue[int64]
}

// createAwsTimestreamLiveanalyticsDatabase creates a new instance of this resource
func createAwsTimestreamLiveanalyticsDatabase(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalyticsDatabase{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics.database", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) MqlName() string {
	return "aws.timestream.liveanalytics.database"
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetKmsKeyId() *plugin.TValue[string] {
	return &c.KmsKeyId
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsDatabase) GetTableCount() *plugin.TValue[int64] {
	return &c.TableCount
}

// mqlAwsTimestreamLiveanalyticsTable for the aws.timestream.liveanalytics.table resource
type mqlAwsTimestreamLiveanalyticsTable struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsTimestreamLiveanalyticsTableInternal it will be used here
	Arn                          plugin.TValue[string]
	Name                         plugin.TValue[string]
	DatabaseName                 plugin.TValue[string]
	Region                       plugin.TValue[string]
	CreatedAt                    plugin.TValue[*time.Time]
	UpdatedAt                    plugin.TValue[*time.Time]
	MagneticStoreWriteProperties plugin.TValue[any]
	RetentionProperties          plugin.TValue[any]
}

// createAwsTimestreamLiveanalyticsTable creates a new instance of this resource
func createAwsTimestreamLiveanalyticsTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsTimestreamLiveanalyticsTable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.timestream.liveanalytics.table", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsTimestreamLiveanalyticsTable) MqlName() string {
	return "aws.timestream.liveanalytics.table"
}

func (c *mqlAwsTimestreamLiveanalyticsTable) MqlID() string {
	return c.__id
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetDatabaseName() *plugin.TValue[string] {
	return &c.DatabaseName
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetUpdatedAt() *plugin.TValue[*time.Time] {
	return &c.UpdatedAt
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetMagneticStoreWriteProperties() *plugin.TValue[any] {
	return &c.MagneticStoreWriteProperties
}

func (c *mqlAwsTimestreamLiveanalyticsTable) GetRetentionProperties() *plugin.TValue[any] {
	return &c.RetentionProperties
}

// mqlAwsCodedeploy for the aws.codedeploy resource
type mqlAwsCodedeploy struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCodedeployInternal it will be used here
	Applications plugin.TValue[[]any]
}

// createAwsCodedeploy creates a new instance of this resource
func createAwsCodedeploy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodedeploy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codedeploy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodedeploy) MqlName() string {
	return "aws.codedeploy"
}

func (c *mqlAwsCodedeploy) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodedeploy) GetApplications() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Applications, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy", c.__id, "applications")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.applications()
	})
}

// mqlAwsCodedeployApplication for the aws.codedeploy.application resource
type mqlAwsCodedeployApplication struct {
	MqlRuntime *plugin.Runtime
	__id       string
	// optional: if you define mqlAwsCodedeployApplicationInternal it will be used here
	Arn              plugin.TValue[string]
	ApplicationId    plugin.TValue[string]
	ApplicationName  plugin.TValue[string]
	ComputePlatform  plugin.TValue[string]
	CreatedAt        plugin.TValue[*time.Time]
	LinkedToGitHub   plugin.TValue[bool]
	Tags             plugin.TValue[map[string]any]
	DeploymentGroups plugin.TValue[[]any]
	Deployments      plugin.TValue[[]any]
	Region           plugin.TValue[string]
}

// createAwsCodedeployApplication creates a new instance of this resource
func createAwsCodedeployApplication(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodedeployApplication{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codedeploy.application", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodedeployApplication) MqlName() string {
	return "aws.codedeploy.application"
}

func (c *mqlAwsCodedeployApplication) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodedeployApplication) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodedeployApplication) GetApplicationId() *plugin.TValue[string] {
	return &c.ApplicationId
}

func (c *mqlAwsCodedeployApplication) GetApplicationName() *plugin.TValue[string] {
	return &c.ApplicationName
}

func (c *mqlAwsCodedeployApplication) GetComputePlatform() *plugin.TValue[string] {
	return &c.ComputePlatform
}

func (c *mqlAwsCodedeployApplication) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsCodedeployApplication) GetLinkedToGitHub() *plugin.TValue[bool] {
	return &c.LinkedToGitHub
}

func (c *mqlAwsCodedeployApplication) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsCodedeployApplication) GetDeploymentGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.DeploymentGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.application", c.__id, "deploymentGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deploymentGroups()
	})
}

func (c *mqlAwsCodedeployApplication) GetDeployments() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Deployments, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.application", c.__id, "deployments")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployments()
	})
}

func (c *mqlAwsCodedeployApplication) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsCodedeployDeploymentGroup for the aws.codedeploy.deploymentGroup resource
type mqlAwsCodedeployDeploymentGroup struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsCodedeployDeploymentGroupInternal
	ApplicationName                  plugin.TValue[string]
	Arn                              plugin.TValue[string]
	DeploymentGroupId                plugin.TValue[string]
	DeploymentGroupName              plugin.TValue[string]
	ComputePlatform                  plugin.TValue[string]
	ServiceRoleArn                   plugin.TValue[string]
	TargetRevision                   plugin.TValue[any]
	Tags                             plugin.TValue[map[string]any]
	Region                           plugin.TValue[string]
	Deployments                      plugin.TValue[[]any]
	AutoScalingGroups                plugin.TValue[[]any]
	Ec2TagFilters                    plugin.TValue[[]any]
	OnPremisesInstanceTagFilters     plugin.TValue[[]any]
	LastSuccessfulDeployment         plugin.TValue[*mqlAwsCodedeployDeployment]
	LastAttemptedDeployment          plugin.TValue[*mqlAwsCodedeployDeployment]
	DeploymentStyle                  plugin.TValue[any]
	BlueGreenDeploymentConfiguration plugin.TValue[any]
	LoadBalancerInfo                 plugin.TValue[any]
}

// createAwsCodedeployDeploymentGroup creates a new instance of this resource
func createAwsCodedeployDeploymentGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodedeployDeploymentGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codedeploy.deploymentGroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodedeployDeploymentGroup) MqlName() string {
	return "aws.codedeploy.deploymentGroup"
}

func (c *mqlAwsCodedeployDeploymentGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodedeployDeploymentGroup) GetApplicationName() *plugin.TValue[string] {
	return &c.ApplicationName
}

func (c *mqlAwsCodedeployDeploymentGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodedeployDeploymentGroup) GetDeploymentGroupId() *plugin.TValue[string] {
	return &c.DeploymentGroupId
}

func (c *mqlAwsCodedeployDeploymentGroup) GetDeploymentGroupName() *plugin.TValue[string] {
	return &c.DeploymentGroupName
}

func (c *mqlAwsCodedeployDeploymentGroup) GetComputePlatform() *plugin.TValue[string] {
	return &c.ComputePlatform
}

func (c *mqlAwsCodedeployDeploymentGroup) GetServiceRoleArn() *plugin.TValue[string] {
	return &c.ServiceRoleArn
}

func (c *mqlAwsCodedeployDeploymentGroup) GetTargetRevision() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.TargetRevision, func() (any, error) {
		return c.targetRevision()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetTags() *plugin.TValue[map[string]any] {
	return plugin.GetOrCompute[map[string]any](&c.Tags, func() (map[string]any, error) {
		return c.tags()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodedeployDeploymentGroup) GetDeployments() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Deployments, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.deploymentGroup", c.__id, "deployments")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.deployments()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetAutoScalingGroups() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.AutoScalingGroups, func() ([]any, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.deploymentGroup", c.__id, "autoScalingGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]any), nil
			}
		}

		return c.autoScalingGroups()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetEc2TagFilters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.Ec2TagFilters, func() ([]any, error) {
		return c.ec2TagFilters()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetOnPremisesInstanceTagFilters() *plugin.TValue[[]any] {
	return plugin.GetOrCompute[[]any](&c.OnPremisesInstanceTagFilters, func() ([]any, error) {
		return c.onPremisesInstanceTagFilters()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetLastSuccessfulDeployment() *plugin.TValue[*mqlAwsCodedeployDeployment] {
	return plugin.GetOrCompute[*mqlAwsCodedeployDeployment](&c.LastSuccessfulDeployment, func() (*mqlAwsCodedeployDeployment, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.deploymentGroup", c.__id, "lastSuccessfulDeployment")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCodedeployDeployment), nil
			}
		}

		return c.lastSuccessfulDeployment()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetLastAttemptedDeployment() *plugin.TValue[*mqlAwsCodedeployDeployment] {
	return plugin.GetOrCompute[*mqlAwsCodedeployDeployment](&c.LastAttemptedDeployment, func() (*mqlAwsCodedeployDeployment, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codedeploy.deploymentGroup", c.__id, "lastAttemptedDeployment")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCodedeployDeployment), nil
			}
		}

		return c.lastAttemptedDeployment()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetDeploymentStyle() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.DeploymentStyle, func() (any, error) {
		return c.deploymentStyle()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetBlueGreenDeploymentConfiguration() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.BlueGreenDeploymentConfiguration, func() (any, error) {
		return c.blueGreenDeploymentConfiguration()
	})
}

func (c *mqlAwsCodedeployDeploymentGroup) GetLoadBalancerInfo() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.LoadBalancerInfo, func() (any, error) {
		return c.loadBalancerInfo()
	})
}

// mqlAwsCodedeployDeployment for the aws.codedeploy.deployment resource
type mqlAwsCodedeployDeployment struct {
	MqlRuntime *plugin.Runtime
	__id       string
	mqlAwsCodedeployDeploymentInternal
	ApplicationName               plugin.TValue[string]
	DeploymentId                  plugin.TValue[string]
	Arn                           plugin.TValue[string]
	Status                        plugin.TValue[string]
	DeploymentGroupName           plugin.TValue[string]
	DeploymentConfigName          plugin.TValue[string]
	CreatedAt                     plugin.TValue[*time.Time]
	CompleatedAt                  plugin.TValue[*time.Time]
	Description                   plugin.TValue[string]
	Creator                       plugin.TValue[string]
	IgnoreApplicationStopFailures plugin.TValue[bool]
	TargetInstances               plugin.TValue[any]
	Revision                      plugin.TValue[any]
	Region                        plugin.TValue[string]
	ErrorInformation              plugin.TValue[any]
	DeploymentOverview            plugin.TValue[any]
	IsRollback                    plugin.TValue[bool]
	RollbackInfo                  plugin.TValue[any]
}

// createAwsCodedeployDeployment creates a new instance of this resource
func createAwsCodedeployDeployment(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodedeployDeployment{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
		res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codedeploy.deployment", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodedeployDeployment) MqlName() string {
	return "aws.codedeploy.deployment"
}

func (c *mqlAwsCodedeployDeployment) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodedeployDeployment) GetApplicationName() *plugin.TValue[string] {
	return &c.ApplicationName
}

func (c *mqlAwsCodedeployDeployment) GetDeploymentId() *plugin.TValue[string] {
	return &c.DeploymentId
}

func (c *mqlAwsCodedeployDeployment) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodedeployDeployment) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCodedeployDeployment) GetDeploymentGroupName() *plugin.TValue[string] {
	return &c.DeploymentGroupName
}

func (c *mqlAwsCodedeployDeployment) GetDeploymentConfigName() *plugin.TValue[string] {
	return &c.DeploymentConfigName
}

func (c *mqlAwsCodedeployDeployment) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsCodedeployDeployment) GetCompleatedAt() *plugin.TValue[*time.Time] {
	return &c.CompleatedAt
}

func (c *mqlAwsCodedeployDeployment) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsCodedeployDeployment) GetCreator() *plugin.TValue[string] {
	return &c.Creator
}

func (c *mqlAwsCodedeployDeployment) GetIgnoreApplicationStopFailures() *plugin.TValue[bool] {
	return &c.IgnoreApplicationStopFailures
}

func (c *mqlAwsCodedeployDeployment) GetTargetInstances() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.TargetInstances, func() (any, error) {
		return c.targetInstances()
	})
}

func (c *mqlAwsCodedeployDeployment) GetRevision() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.Revision, func() (any, error) {
		return c.revision()
	})
}

func (c *mqlAwsCodedeployDeployment) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodedeployDeployment) GetErrorInformation() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.ErrorInformation, func() (any, error) {
		return c.errorInformation()
	})
}

func (c *mqlAwsCodedeployDeployment) GetDeploymentOverview() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.DeploymentOverview, func() (any, error) {
		return c.deploymentOverview()
	})
}

func (c *mqlAwsCodedeployDeployment) GetIsRollback() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsRollback, func() (bool, error) {
		return c.isRollback()
	})
}

func (c *mqlAwsCodedeployDeployment) GetRollbackInfo() *plugin.TValue[any] {
	return plugin.GetOrCompute[any](&c.RollbackInfo, func() (any, error) {
		return c.rollbackInfo()
	})
}
