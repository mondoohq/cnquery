// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by resources. DO NOT EDIT.

package resources

import (
	"errors"
	"time"

	"go.mondoo.com/cnquery/v9/llx"
	"go.mondoo.com/cnquery/v9/providers-sdk/v1/plugin"
	"go.mondoo.com/cnquery/v9/types"
)

var resourceFactories map[string]plugin.ResourceFactory

func init() {
	resourceFactories = map[string]plugin.ResourceFactory {
		"aws": {
			// to override args, implement: initAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAws,
		},
		"aws.account": {
			// to override args, implement: initAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccount,
		},
		"aws.organization": {
			// to override args, implement: initAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsOrganization,
		},
		"aws.vpc": {
			Init: initAwsVpc,
			Create: createAwsVpc,
		},
		"aws.vpc.routetable": {
			// to override args, implement: initAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcRoutetable,
		},
		"aws.vpc.subnet": {
			// to override args, implement: initAwsVpcSubnet(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcSubnet,
		},
		"aws.vpc.endpoint": {
			// to override args, implement: initAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcEndpoint,
		},
		"aws.vpc.flowlog": {
			// to override args, implement: initAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsVpcFlowlog,
		},
		"aws.accessAnalyzer": {
			// to override args, implement: initAwsAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccessAnalyzer,
		},
		"aws.accessanalyzer.analyzer": {
			// to override args, implement: initAwsAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAccessanalyzerAnalyzer,
		},
		"aws.efs": {
			// to override args, implement: initAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfs,
		},
		"aws.efs.filesystem": {
			// to override args, implement: initAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEfsFilesystem,
		},
		"aws.kms": {
			// to override args, implement: initAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsKms,
		},
		"aws.kms.key": {
			Init: initAwsKmsKey,
			Create: createAwsKmsKey,
		},
		"aws.iam": {
			// to override args, implement: initAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIam,
		},
		"aws.iam.usercredentialreportentry": {
			// to override args, implement: initAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamUsercredentialreportentry,
		},
		"aws.iam.user": {
			Init: initAwsIamUser,
			Create: createAwsIamUser,
		},
		"aws.iam.policy": {
			// to override args, implement: initAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicy,
		},
		"aws.iam.policyversion": {
			// to override args, implement: initAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamPolicyversion,
		},
		"aws.iam.role": {
			Init: initAwsIamRole,
			Create: createAwsIamRole,
		},
		"aws.iam.group": {
			Init: initAwsIamGroup,
			Create: createAwsIamGroup,
		},
		"aws.iam.virtualmfadevice": {
			// to override args, implement: initAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsIamVirtualmfadevice,
		},
		"aws.sagemaker": {
			// to override args, implement: initAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemaker,
		},
		"aws.sagemaker.notebookinstance": {
			Init: initAwsSagemakerNotebookinstance,
			Create: createAwsSagemakerNotebookinstance,
		},
		"aws.sagemaker.notebookinstance.details": {
			// to override args, implement: initAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerNotebookinstanceDetails,
		},
		"aws.sagemaker.endpoint": {
			// to override args, implement: initAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSagemakerEndpoint,
		},
		"aws.sns": {
			// to override args, implement: initAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSns,
		},
		"aws.sns.topic": {
			// to override args, implement: initAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsTopic,
		},
		"aws.sns.subscription": {
			// to override args, implement: initAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSnsSubscription,
		},
		"aws.es": {
			// to override args, implement: initAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEs,
		},
		"aws.es.domain": {
			Init: initAwsEsDomain,
			Create: createAwsEsDomain,
		},
		"aws.acm": {
			// to override args, implement: initAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAcm,
		},
		"aws.acm.certificate": {
			Init: initAwsAcmCertificate,
			Create: createAwsAcmCertificate,
		},
		"aws.autoscaling": {
			// to override args, implement: initAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscaling,
		},
		"aws.autoscaling.group": {
			// to override args, implement: initAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsAutoscalingGroup,
		},
		"aws.elb": {
			// to override args, implement: initAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElb,
		},
		"aws.elb.loadbalancer": {
			// to override args, implement: initAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElbLoadbalancer,
		},
		"aws.codebuild": {
			// to override args, implement: initAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCodebuild,
		},
		"aws.codebuild.project": {
			Init: initAwsCodebuildProject,
			Create: createAwsCodebuildProject,
		},
		"aws.guardduty": {
			// to override args, implement: initAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsGuardduty,
		},
		"aws.guardduty.detector": {
			Init: initAwsGuarddutyDetector,
			Create: createAwsGuarddutyDetector,
		},
		"aws.securityhub": {
			// to override args, implement: initAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhub,
		},
		"aws.securityhub.hub": {
			// to override args, implement: initAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecurityhubHub,
		},
		"aws.secretsmanager": {
			// to override args, implement: initAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanager,
		},
		"aws.secretsmanager.secret": {
			// to override args, implement: initAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSecretsmanagerSecret,
		},
		"aws.ecs": {
			// to override args, implement: initAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcs,
		},
		"aws.ecs.cluster": {
			Init: initAwsEcsCluster,
			Create: createAwsEcsCluster,
		},
		"aws.ecs.instance": {
			// to override args, implement: initAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcsInstance,
		},
		"aws.ecs.task": {
			Init: initAwsEcsTask,
			Create: createAwsEcsTask,
		},
		"aws.ecs.container": {
			Init: initAwsEcsContainer,
			Create: createAwsEcsContainer,
		},
		"aws.emr": {
			// to override args, implement: initAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmr,
		},
		"aws.emr.cluster": {
			// to override args, implement: initAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEmrCluster,
		},
		"aws.cloudwatch": {
			// to override args, implement: initAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatch,
		},
		"aws.cloudwatch.metricsalarm": {
			Init: initAwsCloudwatchMetricsalarm,
			Create: createAwsCloudwatchMetricsalarm,
		},
		"aws.cloudwatch.metric": {
			Init: initAwsCloudwatchMetric,
			Create: createAwsCloudwatchMetric,
		},
		"aws.cloudwatch.metricdimension": {
			// to override args, implement: initAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricdimension,
		},
		"aws.cloudwatch.metricstatistics": {
			Init: initAwsCloudwatchMetricstatistics,
			Create: createAwsCloudwatchMetricstatistics,
		},
		"aws.cloudwatch.metric.datapoint": {
			// to override args, implement: initAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchMetricDatapoint,
		},
		"aws.cloudwatch.loggroup": {
			Init: initAwsCloudwatchLoggroup,
			Create: createAwsCloudwatchLoggroup,
		},
		"aws.cloudwatch.loggroup.metricsfilter": {
			// to override args, implement: initAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudwatchLoggroupMetricsfilter,
		},
		"aws.cloudfront": {
			// to override args, implement: initAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfront,
		},
		"aws.cloudfront.distribution": {
			// to override args, implement: initAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistribution,
		},
		"aws.cloudfront.distribution.origin": {
			// to override args, implement: initAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontDistributionOrigin,
		},
		"aws.cloudfront.function": {
			// to override args, implement: initAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudfrontFunction,
		},
		"aws.cloudtrail": {
			// to override args, implement: initAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsCloudtrail,
		},
		"aws.cloudtrail.trail": {
			Init: initAwsCloudtrailTrail,
			Create: createAwsCloudtrailTrail,
		},
		"aws.s3control": {
			// to override args, implement: initAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3control,
		},
		"aws.s3": {
			// to override args, implement: initAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3,
		},
		"aws.s3.bucket": {
			Init: initAwsS3Bucket,
			Create: createAwsS3Bucket,
		},
		"aws.s3.bucket.grant": {
			// to override args, implement: initAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketGrant,
		},
		"aws.s3.bucket.corsrule": {
			// to override args, implement: initAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketCorsrule,
		},
		"aws.s3.bucket.policy": {
			// to override args, implement: initAwsS3BucketPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsS3BucketPolicy,
		},
		"aws.applicationAutoscaling": {
			// to override args, implement: initAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationAutoscaling,
		},
		"aws.applicationautoscaling.target": {
			// to override args, implement: initAwsApplicationautoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApplicationautoscalingTarget,
		},
		"aws.backup": {
			// to override args, implement: initAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackup,
		},
		"aws.backup.vault": {
			// to override args, implement: initAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVault,
		},
		"aws.backup.vaultRecoveryPoint": {
			// to override args, implement: initAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsBackupVaultRecoveryPoint,
		},
		"aws.dynamodb": {
			// to override args, implement: initAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodb,
		},
		"aws.dynamodb.limit": {
			// to override args, implement: initAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDynamodbLimit,
		},
		"aws.dynamodb.globaltable": {
			Init: initAwsDynamodbGlobaltable,
			Create: createAwsDynamodbGlobaltable,
		},
		"aws.dynamodb.table": {
			Init: initAwsDynamodbTable,
			Create: createAwsDynamodbTable,
		},
		"aws.rds": {
			// to override args, implement: initAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRds,
		},
		"aws.rds.dbcluster": {
			// to override args, implement: initAwsRdsDbcluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsDbcluster,
		},
		"aws.rds.snapshot": {
			// to override args, implement: initAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRdsSnapshot,
		},
		"aws.rds.dbinstance": {
			Init: initAwsRdsDbinstance,
			Create: createAwsRdsDbinstance,
		},
		"aws.elasticache": {
			// to override args, implement: initAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticache,
		},
		"aws.elasticache.cluster": {
			// to override args, implement: initAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsElasticacheCluster,
		},
		"aws.redshift": {
			// to override args, implement: initAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsRedshift,
		},
		"aws.redshift.cluster": {
			Init: initAwsRedshiftCluster,
			Create: createAwsRedshiftCluster,
		},
		"aws.ecr": {
			// to override args, implement: initAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcr,
		},
		"aws.ecr.repository": {
			// to override args, implement: initAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEcrRepository,
		},
		"aws.ecr.image": {
			Init: initAwsEcrImage,
			Create: createAwsEcrImage,
		},
		"aws.dms": {
			// to override args, implement: initAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsDms,
		},
		"aws.apigateway": {
			// to override args, implement: initAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigateway,
		},
		"aws.apigateway.restapi": {
			Init: initAwsApigatewayRestapi,
			Create: createAwsApigatewayRestapi,
		},
		"aws.apigateway.stage": {
			// to override args, implement: initAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsApigatewayStage,
		},
		"aws.lambda": {
			// to override args, implement: initAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsLambda,
		},
		"aws.lambda.function": {
			Init: initAwsLambdaFunction,
			Create: createAwsLambdaFunction,
		},
		"aws.ssm": {
			// to override args, implement: initAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsSsm,
		},
		"aws.ssm.instance": {
			Init: initAwsSsmInstance,
			Create: createAwsSsmInstance,
		},
		"aws.ec2": {
			// to override args, implement: initAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2,
		},
		"aws.ec2.networkacl": {
			// to override args, implement: initAwsEc2Networkacl(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Networkacl,
		},
		"aws.ec2.networkacl.entry": {
			// to override args, implement: initAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntry,
		},
		"aws.ec2.networkacl.entry.portrange": {
			// to override args, implement: initAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2NetworkaclEntryPortrange,
		},
		"aws.ec2.vpnconnection": {
			// to override args, implement: initAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vpnconnection,
		},
		"aws.ec2.vgwtelemetry": {
			// to override args, implement: initAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Vgwtelemetry,
		},
		"aws.ec2.internetgateway": {
			// to override args, implement: initAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2Internetgateway,
		},
		"aws.ec2.snapshot": {
			Init: initAwsEc2Snapshot,
			Create: createAwsEc2Snapshot,
		},
		"aws.ec2.volume": {
			Init: initAwsEc2Volume,
			Create: createAwsEc2Volume,
		},
		"aws.ec2.instance": {
			Init: initAwsEc2Instance,
			Create: createAwsEc2Instance,
		},
		"aws.ec2.keypair": {
			Init: initAwsEc2Keypair,
			Create: createAwsEc2Keypair,
		},
		"aws.ec2.image": {
			Init: initAwsEc2Image,
			Create: createAwsEc2Image,
		},
		"aws.ec2.instance.device": {
			// to override args, implement: initAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2InstanceDevice,
		},
		"aws.ec2.securitygroup": {
			Init: initAwsEc2Securitygroup,
			Create: createAwsEc2Securitygroup,
		},
		"aws.ec2.securitygroup.ippermission": {
			// to override args, implement: initAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEc2SecuritygroupIppermission,
		},
		"aws.config": {
			// to override args, implement: initAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfig,
		},
		"aws.config.rule": {
			// to override args, implement: initAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRule,
		},
		"aws.config.recorder": {
			// to override args, implement: initAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsConfigRecorder,
		},
		"aws.eks": {
			// to override args, implement: initAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEks,
		},
		"aws.eks.cluster": {
			// to override args, implement: initAwsEksCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (map[string]*llx.RawData, plugin.Resource, error)
			Create: createAwsEksCluster,
		},
	}
}

// NewResource is used by the runtime of this plugin to create new resources.
// Its arguments may be provided by users. This function is generally not
// used by initializing resources from recordings or from lists.
func NewResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	if f.Init != nil {
		cargs, res, err := f.Init(runtime, args)
		if err != nil {
			return res, err
		}

		if res != nil {
			id := name+"\x00"+res.MqlID()
			if x, ok := runtime.Resources.Get(id); ok {
				return x, nil
			}
			runtime.Resources.Set(id, res)
			return res, nil
		}

		args = cargs
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

// CreateResource is used by the runtime of this plugin to create resources.
// Its arguments must be complete and pre-processed. This method is used
// for initializing resources from recordings or from lists.
func CreateResource(runtime *plugin.Runtime, name string, args map[string]*llx.RawData) (plugin.Resource, error) {
	f, ok := resourceFactories[name]
	if !ok {
		return nil, errors.New("cannot find resource " + name + " in this provider")
	}

	res, err := f.Create(runtime, args)
	if err != nil {
		return nil, err
	}

	id := name+"\x00"+res.MqlID()
	if x, ok := runtime.Resources.Get(id); ok {
		return x, nil
	}

	runtime.Resources.Set(id, res)
	return res, nil
}

var getDataFields = map[string]func(r plugin.Resource) *plugin.DataRes{
	"aws.vpcs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetVpcs()).ToDataRes(types.Array(types.Resource("aws.vpc")))
	},
	"aws.regions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAws).GetRegions()).ToDataRes(types.Array(types.String))
	},
	"aws.account.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetId()).ToDataRes(types.String)
	},
	"aws.account.aliases": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetAliases()).ToDataRes(types.Array(types.String))
	},
	"aws.account.organization": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccount).GetOrganization()).ToDataRes(types.Resource("aws.organization"))
	},
	"aws.organization.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetArn()).ToDataRes(types.String)
	},
	"aws.organization.featureSet": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetFeatureSet()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountId()).ToDataRes(types.String)
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsOrganization).GetMasterAccountEmail()).ToDataRes(types.String)
	},
	"aws.vpc.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetCidrBlock()).ToDataRes(types.String)
	},
	"aws.vpc.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetState()).ToDataRes(types.String)
	},
	"aws.vpc.isDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetIsDefault()).ToDataRes(types.Bool)
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetInstanceTenancy()).ToDataRes(types.String)
	},
	"aws.vpc.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.vpc.endpoint")))
	},
	"aws.vpc.flowLogs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetFlowLogs()).ToDataRes(types.Array(types.Resource("aws.vpc.flowlog")))
	},
	"aws.vpc.routeTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetRouteTables()).ToDataRes(types.Array(types.Resource("aws.vpc.routetable")))
	},
	"aws.vpc.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetSubnets()).ToDataRes(types.Array(types.Resource("aws.vpc.subnet")))
	},
	"aws.vpc.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpc).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.vpc.routetable.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcRoutetable).GetRoutes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.vpc.subnet.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetArn()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetCidrs()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetMapPublicIpOnLaunch()).ToDataRes(types.Bool)
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcSubnet).GetDefaultForAvailabilityZone()).ToDataRes(types.Bool)
	},
	"aws.vpc.endpoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetType()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetServiceName()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetPolicyDocument()).ToDataRes(types.String)
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcEndpoint).GetSubnets()).ToDataRes(types.Array(types.String))
	},
	"aws.vpc.flowlog.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetId()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetVpc()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetRegion()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetStatus()).ToDataRes(types.String)
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsVpcFlowlog).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.accessAnalyzer.analyzers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessAnalyzer).GetAnalyzers()).ToDataRes(types.Array(types.Resource("aws.accessanalyzer.analyzer")))
	},
	"aws.accessanalyzer.analyzer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetArn()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetName()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetStatus()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetType()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetLastResourceAnalyzed()).ToDataRes(types.String)
	},
	"aws.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetLastResourceAnalyzedAt()).ToDataRes(types.Time)
	},
	"aws.accessanalyzer.analyzer.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAccessanalyzerAnalyzer).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.efs.filesystems": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfs).GetFilesystems()).ToDataRes(types.Array(types.Resource("aws.efs.filesystem")))
	},
	"aws.efs.filesystem.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetName()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetId()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetArn()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetBackupPolicy()).ToDataRes(types.Dict)
	},
	"aws.efs.filesystem.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetRegion()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEfsFilesystem).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.kms.keys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKms).GetKeys()).ToDataRes(types.Array(types.Resource("aws.kms.key")))
	},
	"aws.kms.key.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetId()).ToDataRes(types.String)
	},
	"aws.kms.key.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetArn()).ToDataRes(types.String)
	},
	"aws.kms.key.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetRegion()).ToDataRes(types.String)
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetKeyRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.kms.key.metadata": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsKmsKey).GetMetadata()).ToDataRes(types.Dict)
	},
	"aws.iam.users": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.roles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.credentialReport": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetCredentialReport()).ToDataRes(types.Array(types.Resource("aws.iam.usercredentialreportentry")))
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountPasswordPolicy()).ToDataRes(types.Dict)
	},
	"aws.iam.accountSummary": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetAccountSummary()).ToDataRes(types.Map(types.String, types.Int))
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetVirtualMfaDevices()).ToDataRes(types.Array(types.Resource("aws.iam.virtualmfadevice")))
	},
	"aws.iam.serverCertificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIam).GetServerCertificates()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetProperties()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey1LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedDate()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedRegion()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetAccessKey2LastUsedService()).ToDataRes(types.String)
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert1LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2Active()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetCert2LastRotated()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetMfaActive()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordEnabled()).ToDataRes(types.Bool)
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastChanged()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetPasswordNextRotation()).ToDataRes(types.Time)
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUsercredentialreportentry).GetUserCreationTime()).ToDataRes(types.Time)
	},
	"aws.iam.user.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.user.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetId()).ToDataRes(types.String)
	},
	"aws.iam.user.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetName()).ToDataRes(types.String)
	},
	"aws.iam.user.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPasswordLastUsed()).ToDataRes(types.Time)
	},
	"aws.iam.user.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.user.policies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetPolicies()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAttachedPolicies()).ToDataRes(types.Array(types.Resource("aws.iam.policy")))
	},
	"aws.iam.user.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamUser).GetAccessKeys()).ToDataRes(types.Array(types.Dict))
	},
	"aws.iam.policy.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.iam.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.iam.policy.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetIsAttachable()).ToDataRes(types.Bool)
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachmentCount()).ToDataRes(types.Int)
	},
	"aws.iam.policy.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetUpdateDate()).ToDataRes(types.Time)
	},
	"aws.iam.policy.scope": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetScope()).ToDataRes(types.String)
	},
	"aws.iam.policy.versions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetVersions()).ToDataRes(types.Array(types.Resource("aws.iam.policyversion")))
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetDefaultVersion()).ToDataRes(types.Resource("aws.iam.policyversion"))
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedUsers()).ToDataRes(types.Array(types.Resource("aws.iam.user")))
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedRoles()).ToDataRes(types.Array(types.Resource("aws.iam.role")))
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicy).GetAttachedGroups()).ToDataRes(types.Array(types.Resource("aws.iam.group")))
	},
	"aws.iam.policyversion.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetVersionId()).ToDataRes(types.String)
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetIsDefaultVersion()).ToDataRes(types.Bool)
	},
	"aws.iam.policyversion.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetDocument()).ToDataRes(types.Dict)
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamPolicyversion).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.role.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.role.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetId()).ToDataRes(types.String)
	},
	"aws.iam.role.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetName()).ToDataRes(types.String)
	},
	"aws.iam.role.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetDescription()).ToDataRes(types.String)
	},
	"aws.iam.role.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.iam.role.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamRole).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.iam.group.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetId()).ToDataRes(types.String)
	},
	"aws.iam.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetName()).ToDataRes(types.String)
	},
	"aws.iam.group.createDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetCreateDate()).ToDataRes(types.Time)
	},
	"aws.iam.group.usernames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamGroup).GetUsernames()).ToDataRes(types.Array(types.String))
	},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetSerialNumber()).ToDataRes(types.String)
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetEnableDate()).ToDataRes(types.Time)
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsIamVirtualmfadevice).GetUser()).ToDataRes(types.Resource("aws.iam.user"))
	},
	"aws.sagemaker.endpoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetEndpoints()).ToDataRes(types.Array(types.Resource("aws.sagemaker.endpoint")))
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemaker).GetNotebookInstances()).ToDataRes(types.Array(types.Resource("aws.sagemaker.notebookinstance")))
	},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetDetails()).ToDataRes(types.Resource("aws.sagemaker.notebookinstance.details"))
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerNotebookinstanceDetails).GetDirectInternetAccess()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetArn()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetName()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetConfig()).ToDataRes(types.Dict)
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetRegion()).ToDataRes(types.String)
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSagemakerEndpoint).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.topics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSns).GetTopics()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.sns.topic.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.topic.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetRegion()).ToDataRes(types.String)
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetSubscriptions()).ToDataRes(types.Array(types.Resource("aws.sns.subscription")))
	},
	"aws.sns.topic.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetAttributes()).ToDataRes(types.Dict)
	},
	"aws.sns.topic.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsTopic).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.sns.subscription.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetArn()).ToDataRes(types.String)
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSnsSubscription).GetProtocol()).ToDataRes(types.String)
	},
	"aws.es.domains": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEs).GetDomains()).ToDataRes(types.Array(types.Resource("aws.es.domain")))
	},
	"aws.es.domain.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetArn()).ToDataRes(types.String)
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEncryptionAtRestEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetNodeToNodeEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.es.domain.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetName()).ToDataRes(types.String)
	},
	"aws.es.domain.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.es.domain.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetRegion()).ToDataRes(types.String)
	},
	"aws.es.domain.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetElasticsearchVersion()).ToDataRes(types.String)
	},
	"aws.es.domain.domainId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainId()).ToDataRes(types.String)
	},
	"aws.es.domain.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEsDomain).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificates": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcm).GetCertificates()).ToDataRes(types.Array(types.Resource("aws.acm.certificate")))
	},
	"aws.acm.certificate.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetArn()).ToDataRes(types.String)
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotBefore()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetNotAfter()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetDomainName()).ToDataRes(types.String)
	},
	"aws.acm.certificate.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetStatus()).ToDataRes(types.String)
	},
	"aws.acm.certificate.subject": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetSubject()).ToDataRes(types.String)
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetCertificate()).ToDataRes(types.Resource("certificate"))
	},
	"aws.acm.certificate.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAcmCertificate).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.autoscaling.groups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscaling).GetGroups()).ToDataRes(types.Array(types.Resource("aws.autoscaling.group")))
	},
	"aws.autoscaling.group.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetArn()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetName()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetLoadBalancerNames()).ToDataRes(types.Array(types.String))
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetHealthCheckType()).ToDataRes(types.String)
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.autoscaling.group.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsAutoscalingGroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetClassicLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadBalancers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElb).GetLoadBalancers()).ToDataRes(types.Array(types.Resource("aws.elb.loadbalancer")))
	},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetArn()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetDnsName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetListenerDescriptions()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetName()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetScheme()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetVpcId()).ToDataRes(types.String)
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElbLoadbalancer).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.codebuild.projects": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuild).GetProjects()).ToDataRes(types.Array(types.Resource("aws.codebuild.project")))
	},
	"aws.codebuild.project.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetArn()).ToDataRes(types.String)
	},
	"aws.codebuild.project.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetDescription()).ToDataRes(types.String)
	},
	"aws.codebuild.project.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetName()).ToDataRes(types.String)
	},
	"aws.codebuild.project.environment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetEnvironment()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetRegion()).ToDataRes(types.String)
	},
	"aws.codebuild.project.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetSource()).ToDataRes(types.Dict)
	},
	"aws.codebuild.project.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCodebuildProject).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.guardduty.detectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuardduty).GetDetectors()).ToDataRes(types.Array(types.Resource("aws.guardduty.detector")))
	},
	"aws.guardduty.detector.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetId()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetRegion()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetStatus()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetFindingPublishingFrequency()).ToDataRes(types.String)
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsGuarddutyDetector).GetUnarchivedFindings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.securityhub.hubs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhub).GetHubs()).ToDataRes(types.Array(types.Resource("aws.securityhub.hub")))
	},
	"aws.securityhub.hub.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetArn()).ToDataRes(types.String)
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecurityhubHub).GetSubscribedAt()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secrets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanager).GetSecrets()).ToDataRes(types.Array(types.Resource("aws.secretsmanager.secret")))
	},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetArn()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetDescription()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastChangedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetLastRotatedDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetName()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetNextRotationDate()).ToDataRes(types.Time)
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetPrimaryRegion()).ToDataRes(types.String)
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetRotationEnabled()).ToDataRes(types.Bool)
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSecretsmanagerSecret).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetClusters()).ToDataRes(types.Array(types.Resource("aws.ecs.cluster")))
	},
	"aws.ecs.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcs).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRunningTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetPendingTasksCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetRegisteredContainerInstancesCount()).ToDataRes(types.Int)
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetConfiguration()).ToDataRes(types.Dict)
	},
	"aws.ecs.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetTasks()).ToDataRes(types.Array(types.Resource("aws.ecs.task")))
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsCluster).GetContainerInstances()).ToDataRes(types.Array(types.Resource("aws.ecs.instance")))
	},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetAgentConnected()).ToDataRes(types.Bool)
	},
	"aws.ecs.instance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetId()).ToDataRes(types.String)
	},
	"aws.ecs.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetCapacityProvider()).ToDataRes(types.String)
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetEc2Instance()).ToDataRes(types.Resource("aws.ec2.instance"))
	},
	"aws.ecs.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.task.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetConnectivity()).ToDataRes(types.Dict)
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.task.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ecs.task.containers": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsTask).GetContainers()).ToDataRes(types.Array(types.Resource("aws.ecs.container")))
	},
	"aws.ecs.container.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetName()).ToDataRes(types.String)
	},
	"aws.ecs.container.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ecs.container.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetImage()).ToDataRes(types.String)
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetClusterName()).ToDataRes(types.String)
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskDefinitionArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetLogDriver()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformFamily()).ToDataRes(types.String)
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.ecs.container.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetStatus()).ToDataRes(types.String)
	},
	"aws.ecs.container.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecs.container.command": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetCommand()).ToDataRes(types.Array(types.String))
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetTaskArn()).ToDataRes(types.String)
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetRuntimeId()).ToDataRes(types.String)
	},
	"aws.ecs.container.containerName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcsContainer).GetContainerName()).ToDataRes(types.String)
	},
	"aws.emr.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmr).GetClusters()).ToDataRes(types.Array(types.Resource("aws.emr.cluster")))
	},
	"aws.emr.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetName()).ToDataRes(types.String)
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetNormalizedInstanceHours()).ToDataRes(types.Int)
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetOutpostArn()).ToDataRes(types.String)
	},
	"aws.emr.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetMasterInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.emr.cluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetId()).ToDataRes(types.String)
	},
	"aws.emr.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEmrCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.cloudwatch.logGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetLogGroups()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup")))
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatch).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetMetricNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetState()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetStateReason()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetInsufficientDataActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetOkActions()).ToDataRes(types.Array(types.Resource("aws.sns.topic")))
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricsalarm).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetAlarms()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricsalarm")))
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetDimensions()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metricdimension")))
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetric).GetStatistics()).ToDataRes(types.Resource("aws.cloudwatch.metricstatistics"))
	},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricdimension).GetValue()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetNamespace()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetLabel()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricstatistics).GetDatapoints()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric.datapoint")))
	},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetTimestamp()).ToDataRes(types.Time)
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMaximum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetMinimum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetAverage()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetSum()).ToDataRes(types.Float)
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchMetricDatapoint).GetUnit()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetMetricsFilters()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.loggroup.metricsfilter")))
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetId()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterName()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetFilterPattern()).ToDataRes(types.String)
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudwatchLoggroupMetricsfilter).GetMetrics()).ToDataRes(types.Array(types.Resource("aws.cloudwatch.metric")))
	},
	"aws.cloudfront.distributions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetDistributions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution")))
	},
	"aws.cloudfront.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfront).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.cloudfront.function")))
	},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetOrigins()).ToDataRes(types.Array(types.Resource("aws.cloudfront.distribution.origin")))
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetDefaultCacheBehavior()).ToDataRes(types.Dict)
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetCacheBehaviors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetHttpVersion()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetIsIPV6Enabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistribution).GetPriceClass()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetDomainName()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetId()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionAttempts()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetConnectionTimeout()).ToDataRes(types.Int)
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetOriginPath()).ToDataRes(types.String)
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontDistributionOrigin).GetAccount()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetName()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStatus()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetLastModifiedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetStage()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetComment()).ToDataRes(types.String)
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudfrontFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrail).GetTrails()).ToDataRes(types.Array(types.Resource("aws.cloudtrail.trail")))
	},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetName()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetKmsKey()).ToDataRes(types.Resource("aws.kms.key"))
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsMultiRegionTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIsOrganizationTrail()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogFileValidationEnabled()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetIncludeGlobalServiceEvents()).ToDataRes(types.Bool)
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetS3bucket()).ToDataRes(types.Resource("aws.s3.bucket"))
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetSnsTopicARN()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetStatus()).ToDataRes(types.Dict)
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetLogGroup()).ToDataRes(types.Resource("aws.cloudwatch.loggroup"))
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetCloudWatchLogsRoleArn()).ToDataRes(types.String)
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetEventSelectors()).ToDataRes(types.Array(types.Dict))
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsCloudtrailTrail).GetRegion()).ToDataRes(types.String)
	},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3control).GetAccountPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.buckets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3).GetBuckets()).ToDataRes(types.Array(types.Resource("aws.s3.bucket")))
	},
	"aws.s3.bucket.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetArn()).ToDataRes(types.String)
	},
	"aws.s3.bucket.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPolicy()).ToDataRes(types.Resource("aws.s3.bucket.policy"))
	},
	"aws.s3.bucket.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.acl": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetAcl()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.grant")))
	},
	"aws.s3.bucket.owner": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetOwner()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.cors": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCors()).ToDataRes(types.Array(types.Resource("aws.s3.bucket.corsrule")))
	},
	"aws.s3.bucket.location": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLocation()).ToDataRes(types.String)
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetVersioning()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetLogging()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetStaticWebsiteHosting()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetDefaultLock()).ToDataRes(types.String)
	},
	"aws.s3.bucket.replication": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetReplication()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetEncryption()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetPublicAccessBlock()).ToDataRes(types.Dict)
	},
	"aws.s3.bucket.exists": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetExists()).ToDataRes(types.Bool)
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3Bucket).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.s3.bucket.grant.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetPermission()).ToDataRes(types.String)
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketGrant).GetGrantee()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedMethods()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetAllowedOrigins()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetExposeHeaders()).ToDataRes(types.Array(types.String))
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketCorsrule).GetMaxAgeSeconds()).ToDataRes(types.Int)
	},
	"aws.s3.bucket.policy.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetId()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetName()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetDocument()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetVersion()).ToDataRes(types.String)
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsS3BucketPolicy).GetStatements()).ToDataRes(types.Array(types.Dict))
	},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationAutoscaling).GetScalableTargets()).ToDataRes(types.Array(types.Resource("aws.applicationautoscaling.target")))
	},
	"aws.applicationautoscaling.target.namespace": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetNamespace()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetArn()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.scalableDimension": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetScalableDimension()).ToDataRes(types.String)
	},
	"aws.applicationautoscaling.target.minCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetMinCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationautoscaling.target.maxCapacity": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetMaxCapacity()).ToDataRes(types.Int)
	},
	"aws.applicationautoscaling.target.suspendedState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApplicationautoscalingTarget).GetSuspendedState()).ToDataRes(types.Dict)
	},
	"aws.backup.vaults": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackup).GetVaults()).ToDataRes(types.Array(types.Resource("aws.backup.vault")))
	},
	"aws.backup.vault.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vault.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetName()).ToDataRes(types.String)
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRecoveryPoints()).ToDataRes(types.Array(types.Resource("aws.backup.vaultRecoveryPoint")))
	},
	"aws.backup.vault.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetRegion()).ToDataRes(types.String)
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetCreatedAt()).ToDataRes(types.Time)
	},
	"aws.backup.vault.locked": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetLocked()).ToDataRes(types.Bool)
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVault).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetResourceType()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreatedBy()).ToDataRes(types.Dict)
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIamRoleArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetStatus()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCreationDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetCompletionDate()).ToDataRes(types.Time)
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetEncryptionKeyArn()).ToDataRes(types.String)
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsBackupVaultRecoveryPoint).GetIsEncrypted()).ToDataRes(types.Bool)
	},
	"aws.dynamodb.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetGlobalTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.globaltable")))
	},
	"aws.dynamodb.tables": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetTables()).ToDataRes(types.Array(types.Resource("aws.dynamodb.table")))
	},
	"aws.dynamodb.limits": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodb).GetLimits()).ToDataRes(types.Array(types.Resource("aws.dynamodb.limit")))
	},
	"aws.dynamodb.limit.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetAccountMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxRead()).ToDataRes(types.Int)
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbLimit).GetTableMaxWrite()).ToDataRes(types.Int)
	},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbGlobaltable).GetReplicaSettings()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetArn()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetName()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetRegion()).ToDataRes(types.String)
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetBackups()).ToDataRes(types.Array(types.Dict))
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetSseDescription()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetProvisionedThroughput()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetContinuousBackups()).ToDataRes(types.Dict)
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDynamodbTable).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetDbInstances()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.dbClusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRds).GetDbClusters()).ToDataRes(types.Array(types.Resource("aws.rds.dbcluster")))
	},
	"aws.rds.dbcluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetMembers()).ToDataRes(types.Array(types.Resource("aws.rds.dbinstance")))
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbcluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetId()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetAttributes()).ToDataRes(types.Array(types.Dict))
	},
	"aws.rds.snapshot.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetType()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetIsClusterSnapshot()).ToDataRes(types.Bool)
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsSnapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbinstance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetName()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetBackupRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.rds.snapshot")))
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageEncrypted()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageAllocated()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageIops()).ToDataRes(types.Int)
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStorageType()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnabledCloudwatchLogsExports()).ToDataRes(types.Array(types.String))
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDeletionProtection()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetMultiAZ()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetId()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEnhancedMonitoringResourceArn()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceClass()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetDbInstanceIdentifier()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngine()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetStatus()).ToDataRes(types.String)
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRdsDbinstance).GetCreatedTime()).ToDataRes(types.Time)
	},
	"aws.elasticache.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetClusters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticache).GetCacheClusters()).ToDataRes(types.Array(types.Resource("aws.elasticache.cluster")))
	},
	"aws.elasticache.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAtRestEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAuthTokenLastModifiedDate()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetAutoMinorVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterCreateTime()).ToDataRes(types.Time)
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterId()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheClusterStatus()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheNodes()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSecurityGroups()).ToDataRes(types.Array(types.String))
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetCacheSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetClientDownloadLandingPage()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngine()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetEngineVersion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetIpDiscovery()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetLogDeliveryConfigurations()).ToDataRes(types.Array(types.Dict))
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNetworkType()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNotificationConfiguration()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetNumCacheNodes()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetPreferredAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetSnapshotRetentionLimit()).ToDataRes(types.Int)
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionEnabled()).ToDataRes(types.Bool)
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsElasticacheCluster).GetTransitEncryptionMode()).ToDataRes(types.String)
	},
	"aws.redshift.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshift).GetClusters()).ToDataRes(types.Array(types.Resource("aws.redshift.cluster")))
	},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAllowVersionUpgrade()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAutomatedSnapshotRetentionPeriod()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterParameterGroupNames()).ToDataRes(types.Array(types.String))
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterRevisionNumber()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterStatus()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterSubnetGroupName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetClusterVersion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetCreatedAt()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetDbName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetEnhancedVpcRouting()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetMasterUsername()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetName()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNextMaintenanceWindowStartTime()).ToDataRes(types.Time)
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNodeType()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetNumberOfNodes()).ToDataRes(types.Int)
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetParameters()).ToDataRes(types.Array(types.Dict))
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPreferredMaintenanceWindow()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetPubliclyAccessible()).ToDataRes(types.Bool)
	},
	"aws.redshift.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsRedshiftCluster).GetVpcId()).ToDataRes(types.String)
	},
	"aws.ecr.privateRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPrivateRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetPublicRepositories()).ToDataRes(types.Array(types.Resource("aws.ecr.repository")))
	},
	"aws.ecr.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcr).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.repository.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetName()).ToDataRes(types.String)
	},
	"aws.ecr.repository.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetUri()).ToDataRes(types.String)
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.repository.public": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetPublic()).ToDataRes(types.Bool)
	},
	"aws.ecr.repository.images": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImages()).ToDataRes(types.Array(types.Resource("aws.ecr.image")))
	},
	"aws.ecr.repository.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrRepository).GetImageScanOnPush()).ToDataRes(types.Bool)
	},
	"aws.ecr.image.digest": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetDigest()).ToDataRes(types.String)
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetMediaType()).ToDataRes(types.String)
	},
	"aws.ecr.image.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetTags()).ToDataRes(types.Array(types.String))
	},
	"aws.ecr.image.registryId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegistryId()).ToDataRes(types.String)
	},
	"aws.ecr.image.repoName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRepoName()).ToDataRes(types.String)
	},
	"aws.ecr.image.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetRegion()).ToDataRes(types.String)
	},
	"aws.ecr.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetArn()).ToDataRes(types.String)
	},
	"aws.ecr.image.uri": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEcrImage).GetUri()).ToDataRes(types.String)
	},
	"aws.dms.replicationInstances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsDms).GetReplicationInstances()).ToDataRes(types.Array(types.Dict))
	},
	"aws.apigateway.restApis": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigateway).GetRestApis()).ToDataRes(types.Array(types.Resource("aws.apigateway.restapi")))
	},
	"aws.apigateway.restapi.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetId()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetCreatedDate()).ToDataRes(types.Time)
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetStages()).ToDataRes(types.Array(types.Resource("aws.apigateway.stage")))
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetRegion()).ToDataRes(types.String)
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayRestapi).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.apigateway.stage.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetArn()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetName()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetTracingEnabled()).ToDataRes(types.Bool)
	},
	"aws.apigateway.stage.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDescription()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetDeploymentId()).ToDataRes(types.String)
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsApigatewayStage).GetMethodSettings()).ToDataRes(types.Dict)
	},
	"aws.lambda.functions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambda).GetFunctions()).ToDataRes(types.Array(types.Resource("aws.lambda.function")))
	},
	"aws.lambda.function.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetName()).ToDataRes(types.String)
	},
	"aws.lambda.function.runtime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRuntime()).ToDataRes(types.String)
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetConcurrency()).ToDataRes(types.Int)
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetDlqTargetArn()).ToDataRes(types.String)
	},
	"aws.lambda.function.policy": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetPolicy()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.lambda.function.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetRegion()).ToDataRes(types.String)
	},
	"aws.lambda.function.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsLambdaFunction).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ssm.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsm).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ssm.instance")))
	},
	"aws.ssm.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPingStatus()).ToDataRes(types.String)
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetIpAddress()).ToDataRes(types.String)
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetPlatformName()).ToDataRes(types.String)
	},
	"aws.ssm.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ssm.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetArn()).ToDataRes(types.String)
	},
	"aws.ssm.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsSsmInstance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instances": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInstances()).ToDataRes(types.Array(types.Resource("aws.ec2.instance")))
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetEbsEncryptionByDefault()).ToDataRes(types.Map(types.String, types.Bool))
	},
	"aws.ec2.volumes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVolumes()).ToDataRes(types.Array(types.Resource("aws.ec2.volume")))
	},
	"aws.ec2.snapshots": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetSnapshots()).ToDataRes(types.Array(types.Resource("aws.ec2.snapshot")))
	},
	"aws.ec2.internetGateways": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetInternetGateways()).ToDataRes(types.Array(types.Resource("aws.ec2.internetgateway")))
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetVpnConnections()).ToDataRes(types.Array(types.Resource("aws.ec2.vpnconnection")))
	},
	"aws.ec2.networkAcls": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetNetworkAcls()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl")))
	},
	"aws.ec2.keypairs": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2).GetKeypairs()).ToDataRes(types.Array(types.Resource("aws.ec2.keypair")))
	},
	"aws.ec2.networkacl.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Networkacl).GetEntries()).ToDataRes(types.Array(types.Resource("aws.ec2.networkacl.entry")))
	},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetEgress()).ToDataRes(types.Bool)
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetRuleAction()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetPortRange()).ToDataRes(types.Resource("aws.ec2.networkacl.entry.portrange"))
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntry).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetFrom()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetTo()).ToDataRes(types.Int)
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2NetworkaclEntryPortrange).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vpnconnection).GetVgwTelemetry()).ToDataRes(types.Array(types.Resource("aws.ec2.vgwtelemetry")))
	},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetOutsideIpAddress()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Vgwtelemetry).GetStatusMessage()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Internetgateway).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.snapshot.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetCreateVolumePermission()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetStartTime()).ToDataRes(types.Time)
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Snapshot).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.volume.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.volume.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAttachments()).ToDataRes(types.Array(types.Dict))
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetEncrypted()).ToDataRes(types.Bool)
	},
	"aws.ec2.volume.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.volume.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetAvailabilityZone()).ToDataRes(types.String)
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetVolumeType()).ToDataRes(types.String)
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetCreateTime()).ToDataRes(types.Time)
	},
	"aws.ec2.volume.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Volume).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDetailedMonitoring()).ToDataRes(types.String)
	},
	"aws.ec2.instance.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSsm()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpTokens()).ToDataRes(types.String)
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetHttpEndpoint()).ToDataRes(types.String)
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPatchState()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetState()).ToDataRes(types.String)
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetDeviceMappings()).ToDataRes(types.Array(types.Resource("aws.ec2.instance.device")))
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetSecurityGroups()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup")))
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPlatformDetails()).ToDataRes(types.String)
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPublicDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceStatus()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateReason()).ToDataRes(types.Dict)
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionReason()).ToDataRes(types.String)
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetEbsOptimized()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetInstanceType()).ToDataRes(types.String)
	},
	"aws.ec2.instance.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.instance.image": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetImage()).ToDataRes(types.Resource("aws.ec2.image"))
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetLaunchTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateIp()).ToDataRes(types.String)
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetPrivateDnsName()).ToDataRes(types.String)
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetKeypair()).ToDataRes(types.Resource("aws.ec2.keypair"))
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetStateTransitionTime()).ToDataRes(types.Time)
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Instance).GetVpcArn()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetFingerprint()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.type": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetType()).ToDataRes(types.String)
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.keypair.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Keypair).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.image.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.image.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.image.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.image.architecture": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetArchitecture()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerId()).ToDataRes(types.String)
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Image).GetOwnerAlias()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeleteOnTermination()).ToDataRes(types.Bool)
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetStatus()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetVolumeId()).ToDataRes(types.String)
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2InstanceDevice).GetDeviceName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetArn()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetName()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetDescription()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetVpc()).ToDataRes(types.Resource("aws.vpc"))
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissions()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIpPermissionsEgress()).ToDataRes(types.Array(types.Resource("aws.ec2.securitygroup.ippermission")))
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetRegion()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2Securitygroup).GetIsAttachedToNetworkInterface()).ToDataRes(types.Bool)
	},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetId()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetFromPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetToPort()).ToDataRes(types.Int)
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpProtocol()).ToDataRes(types.String)
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpRanges()).ToDataRes(types.Array(types.String))
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEc2SecuritygroupIppermission).GetIpv6Ranges()).ToDataRes(types.Array(types.String))
	},
	"aws.config.recorders": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRecorders()).ToDataRes(types.Array(types.Resource("aws.config.recorder")))
	},
	"aws.config.rules": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfig).GetRules()).ToDataRes(types.Array(types.Resource("aws.config.rule")))
	},
	"aws.config.rule.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetArn()).ToDataRes(types.String)
	},
	"aws.config.rule.state": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetState()).ToDataRes(types.String)
	},
	"aws.config.rule.source": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRule).GetSource()).ToDataRes(types.Dict)
	},
	"aws.config.recorder.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetName()).ToDataRes(types.String)
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRoleArn()).ToDataRes(types.String)
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetAllSupported()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetIncludeGlobalResourceTypes()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.recording": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRecording()).ToDataRes(types.Bool)
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetLastStatus()).ToDataRes(types.String)
	},
	"aws.config.recorder.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsConfigRecorder).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.clusters": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEks).GetClusters()).ToDataRes(types.Array(types.Resource("aws.eks.cluster")))
	},
	"aws.eks.cluster.name": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetName()).ToDataRes(types.String)
	},
	"aws.eks.cluster.arn": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetArn()).ToDataRes(types.String)
	},
	"aws.eks.cluster.region": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetRegion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.tags": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetTags()).ToDataRes(types.Map(types.String, types.String))
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEndpoint()).ToDataRes(types.String)
	},
	"aws.eks.cluster.version": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetPlatformVersion()).ToDataRes(types.String)
	},
	"aws.eks.cluster.status": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetStatus()).ToDataRes(types.String)
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetEncryptionConfig()).ToDataRes(types.Array(types.Dict))
	},
	"aws.eks.cluster.logging": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetLogging()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetNetworkConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetResourcesVpcConfig()).ToDataRes(types.Dict)
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource) *plugin.DataRes {
		return (r.(*mqlAwsEksCluster).GetCreatedAt()).ToDataRes(types.Time)
	},
}

func GetData(resource plugin.Resource, field string, args map[string]*llx.RawData) *plugin.DataRes {
	f, ok := getDataFields[resource.MqlName()+"."+field]
	if !ok {
		return &plugin.DataRes{Error: "cannot find '" + field + "' in resource '" + resource.MqlName() + "'"}
	}

	return f(resource)
}

var setDataFields = map[string]func(r plugin.Resource, v *llx.RawData) bool {
	"aws.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAws).__id, ok = v.Value.(string)
			return
		},
	"aws.vpcs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Vpcs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.regions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAws).Regions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccount).__id, ok = v.Value.(string)
			return
		},
	"aws.account.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.account.aliases": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Aliases, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.account.organization": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccount).Organization, ok = plugin.RawToTValue[*mqlAwsOrganization](v.Value, v.Error)
		return
	},
	"aws.organization.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsOrganization).__id, ok = v.Value.(string)
			return
		},
	"aws.organization.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.featureSet": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).FeatureSet, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.organization.masterAccountEmail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsOrganization).MasterAccountEmail, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpc).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.cidrBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).CidrBlock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.isDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).IsDefault, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.instanceTenancy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).InstanceTenancy, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Endpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.flowLogs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).FlowLogs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routeTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).RouteTables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Subnets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpc).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcRoutetable).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.routetable.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.routetable.routes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcRoutetable).Routes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcSubnet).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.subnet.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.cidrs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).Cidrs, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.mapPublicIpOnLaunch": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).MapPublicIpOnLaunch, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.subnet.defaultForAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcSubnet).DefaultForAvailabilityZone, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.endpoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.serviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).ServiceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.policyDocument": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).PolicyDocument, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.endpoint.subnets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcEndpoint).Subnets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsVpcFlowlog).__id, ok = v.Value.(string)
			return
		},
	"aws.vpc.flowlog.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Vpc, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.vpc.flowlog.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsVpcFlowlog).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.accessAnalyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccessAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.accessAnalyzer.analyzers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessAnalyzer).Analyzers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAccessanalyzerAnalyzer).__id, ok = v.Value.(string)
			return
		},
	"aws.accessanalyzer.analyzer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.lastResourceAnalyzed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).LastResourceAnalyzed, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.lastResourceAnalyzedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).LastResourceAnalyzedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.accessanalyzer.analyzer.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAccessanalyzerAnalyzer).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.efs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfs).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystems": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfs).Filesystems, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEfsFilesystem).__id, ok = v.Value.(string)
			return
		},
	"aws.efs.filesystem.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.backupPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).BackupPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.efs.filesystem.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEfsFilesystem).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.kms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKms).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.keys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKms).Keys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.kms.key.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsKmsKey).__id, ok = v.Value.(string)
			return
		},
	"aws.kms.key.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.kms.key.keyRotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).KeyRotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.kms.key.metadata": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsKmsKey).Metadata, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIam).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.users": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Users, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.roles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Roles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.credentialReport": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).CredentialReport, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountPasswordPolicy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountPasswordPolicy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.accountSummary": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).AccountSummary, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualMfaDevices": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).VirtualMfaDevices, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.serverCertificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIam).ServerCertificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUsercredentialreportentry).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.usercredentialreportentry.properties": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Properties, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey1LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey1LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.accessKey2LastUsedService": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).AccessKey2LastUsedService, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert1LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert1LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2Active": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2Active, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.cert2LastRotated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).Cert2LastRotated, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.mfaActive": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).MfaActive, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastChanged": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastChanged, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.passwordNextRotation": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).PasswordNextRotation, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.iam.usercredentialreportentry.userCreationTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUsercredentialreportentry).UserCreationTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamUser).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.user.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.user.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.passwordLastUsed": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).PasswordLastUsed, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.user.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.policies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Policies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.attachedPolicies": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AttachedPolicies, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.user.accessKeys": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamUser).AccessKeys, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicy).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policy.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.isAttachable": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).IsAttachable, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachmentCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachmentCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.iam.policy.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.updateDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).UpdateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.policy.scope": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Scope, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policy.versions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).Versions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.defaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).DefaultVersion, ok = plugin.RawToTValue[*mqlAwsIamPolicyversion](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedUsers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedUsers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedRoles": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedRoles, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policy.attachedGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicy).AttachedGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamPolicyversion).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.policyversion.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.versionId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).VersionId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.isDefaultVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).IsDefaultVersion, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).Document, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.policyversion.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamPolicyversion).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.role.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamRole).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.role.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.role.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.role.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamRole).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.group.createDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).CreateDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.group.usernames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamGroup).Usernames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsIamVirtualmfadevice).__id, ok = v.Value.(string)
			return
		},
	"aws.iam.virtualmfadevice.serialNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).SerialNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.enableDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).EnableDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.iam.virtualmfadevice.user": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsIamVirtualmfadevice).User, ok = plugin.RawToTValue[*mqlAwsIamUser](v.Value, v.Error)
		return
	},
	"aws.sagemaker.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemaker).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).Endpoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemaker).NotebookInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstance).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Details, ok = plugin.RawToTValue[*mqlAwsSagemakerNotebookinstanceDetails](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerNotebookinstanceDetails).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.notebookinstance.details.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.sagemaker.notebookinstance.details.directInternetAccess": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerNotebookinstanceDetails).DirectInternetAccess, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSagemakerEndpoint).__id, ok = v.Value.(string)
			return
		},
	"aws.sagemaker.endpoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.config": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Config, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sagemaker.endpoint.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSagemakerEndpoint).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSns).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSns).Topics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsTopic).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.topic.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.topic.subscriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Subscriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Attributes, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.topic.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsTopic).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSnsSubscription).__id, ok = v.Value.(string)
			return
		},
	"aws.sns.subscription.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.sns.subscription.protocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSnsSubscription).Protocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEs).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domains": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEs).Domains, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.es.domain.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEsDomain).__id, ok = v.Value.(string)
			return
		},
	"aws.es.domain.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.encryptionAtRestEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).EncryptionAtRestEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.nodeToNodeEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).NodeToNodeEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.es.domain.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.es.domain.elasticsearchVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).ElasticsearchVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.es.domain.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEsDomain).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcm).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificates": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcm).Certificates, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAcmCertificate).__id, ok = v.Value.(string)
			return
		},
	"aws.acm.certificate.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notBefore": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotBefore, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.notAfter": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).NotAfter, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.subject": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Subject, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.certificate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Certificate, ok = plugin.RawToTValue[plugin.Resource](v.Value, v.Error)
		return
	},
	"aws.acm.certificate.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAcmCertificate).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscaling).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.groups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscaling).Groups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsAutoscalingGroup).__id, ok = v.Value.(string)
			return
		},
	"aws.autoscaling.group.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.loadBalancerNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).LoadBalancerNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.healthCheckType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).HealthCheckType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.autoscaling.group.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsAutoscalingGroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElb).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.classicLoadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).ClassicLoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadBalancers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElb).LoadBalancers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElbLoadbalancer).__id, ok = v.Value.(string)
			return
		},
	"aws.elb.loadbalancer.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.dnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).DnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.listenerDescriptions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).ListenerDescriptions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.scheme": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Scheme, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).Attributes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elb.loadbalancer.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElbLoadbalancer).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.codebuild.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuild).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.projects": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuild).Projects, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCodebuildProject).__id, ok = v.Value.(string)
			return
		},
	"aws.codebuild.project.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.environment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Environment, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Source, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.codebuild.project.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCodebuildProject).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuardduty).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.detectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuardduty).Detectors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsGuarddutyDetector).__id, ok = v.Value.(string)
			return
		},
	"aws.guardduty.detector.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.findingPublishingFrequency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).FindingPublishingFrequency, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.guardduty.detector.unarchivedFindings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsGuarddutyDetector).UnarchivedFindings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.securityhub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hubs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhub).Hubs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecurityhubHub).__id, ok = v.Value.(string)
			return
		},
	"aws.securityhub.hub.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.securityhub.hub.subscribedAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecurityhubHub).SubscribedAt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanager).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secrets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanager).Secrets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSecretsmanagerSecret).__id, ok = v.Value.(string)
			return
		},
	"aws.secretsmanager.secret.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastChangedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastChangedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.lastRotatedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).LastRotatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.nextRotationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).NextRotationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.primaryRegion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).PrimaryRegion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.rotationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).RotationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.secretsmanager.secret.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSecretsmanagerSecret).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcs).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcs).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.runningTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RunningTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.pendingTasksCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).PendingTasksCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.registeredContainerInstancesCount": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).RegisteredContainerInstancesCount, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.configuration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Configuration, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.tasks": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).Tasks, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.cluster.containerInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsCluster).ContainerInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.instance.agentConnected": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).AgentConnected, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.capacityProvider": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).CapacityProvider, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.ec2Instance": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Ec2Instance, ok = plugin.RawToTValue[*mqlAwsEc2Instance](v.Value, v.Error)
		return
	},
	"aws.ecs.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsTask).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.task.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.connectivity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Connectivity, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.task.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.task.containers": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsTask).Containers, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcsContainer).__id, ok = v.Value.(string)
			return
		},
	"aws.ecs.container.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Image, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.clusterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ClusterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskDefinitionArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskDefinitionArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.logDriver": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).LogDriver, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformFamily": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformFamily, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.command": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).Command, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecs.container.taskArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).TaskArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.runtimeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).RuntimeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecs.container.containerName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcsContainer).ContainerName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmr).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmr).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEmrCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.emr.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.normalizedInstanceHours": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).NormalizedInstanceHours, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.outpostArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).OutpostArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Status, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.masterInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).MasterInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.emr.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEmrCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatch).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.logGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).LogGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatch).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricsalarm).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricsalarm.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.metricNamespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).MetricNamespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.actions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Actions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).StateReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.insufficientDataActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).InsufficientDataActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.okActions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).OkActions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricsalarm.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricsalarm).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetric).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.alarms": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Alarms, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.dimensions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Dimensions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.statistics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetric).Statistics, ok = plugin.RawToTValue[*mqlAwsCloudwatchMetricstatistics](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricdimension).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricdimension.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricdimension.value": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricdimension).Value, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricstatistics).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metricstatistics.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.label": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Label, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metricstatistics.datapoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricstatistics).Datapoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchMetricDatapoint).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.metric.datapoint.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.timestamp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Timestamp, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.maximum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Maximum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.minimum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Minimum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.average": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Average, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.sum": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Sum, ok = plugin.RawToTValue[float64](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.metric.datapoint.unit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchMetricDatapoint).Unit, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroup).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsFilters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).MetricsFilters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudwatchLoggroupMetricsfilter).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudwatch.loggroup.metricsfilter.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.filterPattern": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).FilterPattern, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudwatch.loggroup.metricsfilter.metrics": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudwatchLoggroupMetricsfilter).Metrics, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfront).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distributions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Distributions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfront).Functions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontDistribution).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distribution.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Origins, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.defaultCacheBehavior": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).DefaultCacheBehavior, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.cacheBehaviors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).CacheBehaviors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.httpVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).HttpVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.isIPV6Enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).IsIPV6Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.enabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).Enabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.priceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistribution).PriceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontDistributionOrigin).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.distribution.origin.domainName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).DomainName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionAttempts": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionAttempts, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.connectionTimeout": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).ConnectionTimeout, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.originPath": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).OriginPath, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.distribution.origin.account": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontDistributionOrigin).Account, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudfrontFunction).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudfront.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.lastModifiedTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).LastModifiedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.stage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Stage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.comment": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Comment, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudfront.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudfrontFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudtrail).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudtrail.trails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrail).Trails, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsCloudtrailTrail).__id, ok = v.Value.(string)
			return
		},
	"aws.cloudtrail.trail.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.kmsKey": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).KmsKey, ok = plugin.RawToTValue[*mqlAwsKmsKey](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isMultiRegionTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsMultiRegionTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.isOrganizationTrail": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IsOrganizationTrail, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logFileValidationEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogFileValidationEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.includeGlobalServiceEvents": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).IncludeGlobalServiceEvents, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.s3bucket": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).S3bucket, ok = plugin.RawToTValue[*mqlAwsS3Bucket](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.snsTopicARN": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).SnsTopicARN, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Status, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.logGroup": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).LogGroup, ok = plugin.RawToTValue[*mqlAwsCloudwatchLoggroup](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.cloudWatchLogsRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).CloudWatchLogsRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.eventSelectors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).EventSelectors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.cloudtrail.trail.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsCloudtrailTrail).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3control.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3control).__id, ok = v.Value.(string)
			return
		},
	"aws.s3control.accountPublicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3control).AccountPublicAccessBlock, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.buckets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3).Buckets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3Bucket).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Policy, ok = plugin.RawToTValue[*mqlAwsS3BucketPolicy](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.acl": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Acl, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.owner": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Owner, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.cors": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Cors, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.location": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Location, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.versioning": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Versioning, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Logging, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.staticWebsiteHosting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).StaticWebsiteHosting, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.defaultLock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).DefaultLock, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.replication": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Replication, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.encryption": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Encryption, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.publicAccessBlock": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).PublicAccessBlock, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.exists": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).Exists, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3Bucket).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketGrant).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.grant.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.permission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Permission, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.grant.grantee": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketGrant).Grantee, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketCorsrule).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.corsrule.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedMethods": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedMethods, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.allowedOrigins": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).AllowedOrigins, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.exposeHeaders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).ExposeHeaders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.corsrule.maxAgeSeconds": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketCorsrule).MaxAgeSeconds, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsS3BucketPolicy).__id, ok = v.Value.(string)
			return
		},
	"aws.s3.bucket.policy.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.document": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Document, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.s3.bucket.policy.statements": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsS3BucketPolicy).Statements, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApplicationAutoscaling).__id, ok = v.Value.(string)
			return
		},
	"aws.applicationAutoscaling.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationAutoscaling.scalableTargets": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationAutoscaling).ScalableTargets, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApplicationautoscalingTarget).__id, ok = v.Value.(string)
			return
		},
	"aws.applicationautoscaling.target.namespace": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).Namespace, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.scalableDimension": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).ScalableDimension, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.minCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).MinCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.maxCapacity": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).MaxCapacity, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.applicationautoscaling.target.suspendedState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApplicationautoscalingTarget).SuspendedState, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackup).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vaults": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackup).Vaults, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vault.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackupVault).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vault.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.recoveryPoints": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).RecoveryPoints, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vault.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vault.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vault.locked": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).Locked, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.backup.vault.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVault).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsBackupVaultRecoveryPoint).__id, ok = v.Value.(string)
			return
		},
	"aws.backup.vaultRecoveryPoint.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.resourceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).ResourceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.createdBy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreatedBy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.iamRoleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IamRoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.creationDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CreationDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.completionDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).CompletionDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.encryptionKeyArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).EncryptionKeyArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.backup.vaultRecoveryPoint.isEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsBackupVaultRecoveryPoint).IsEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.dynamodb.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodb).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Backups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globalTables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).GlobalTables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.tables": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Tables, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limits": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodb).Limits, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbLimit).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.limit.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.accountMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).AccountMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxRead": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxRead, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.limit.tableMaxWrite": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbLimit).TableMaxWrite, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbGlobaltable).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.globaltable.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.globaltable.replicaSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbGlobaltable).ReplicaSettings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDynamodbTable).__id, ok = v.Value.(string)
			return
		},
	"aws.dynamodb.table.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.backups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Backups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.sseDescription": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).SseDescription, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.provisionedThroughput": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ProvisionedThroughput, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.continuousBackups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).ContinuousBackups, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.dynamodb.table.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDynamodbTable).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRds).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).DbInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbClusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRds).DbClusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsDbcluster).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbcluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.members": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Members, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbcluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbcluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsSnapshot).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.attributes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Attributes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.isClusterSnapshot": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).IsClusterSnapshot, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsSnapshot).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRdsDbinstance).__id, ok = v.Value.(string)
			return
		},
	"aws.rds.dbinstance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.backupRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).BackupRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageEncrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageEncrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageAllocated": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageAllocated, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageIops": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageIops, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.storageType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).StorageType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enabledCloudwatchLogsExports": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnabledCloudwatchLogsExports, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.deletionProtection": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DeletionProtection, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.multiAZ": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).MultiAZ, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.enhancedMonitoringResourceArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EnhancedMonitoringResourceArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceClass": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceClass, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.dbInstanceIdentifier": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).DbInstanceIdentifier, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.rds.dbinstance.createdTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRdsDbinstance).CreatedTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElasticache).__id, ok = v.Value.(string)
			return
		},
	"aws.elasticache.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cacheClusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticache).CacheClusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsElasticacheCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.elasticache.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.atRestEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AtRestEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.authTokenLastModifiedDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AuthTokenLastModifiedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.autoMinorVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).AutoMinorVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterCreateTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterCreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheClusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheNodes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSecurityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.cacheSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).CacheSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.clientDownloadLandingPage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).ClientDownloadLandingPage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engine": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Engine, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.engineVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).EngineVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.ipDiscovery": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).IpDiscovery, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.logDeliveryConfigurations": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).LogDeliveryConfigurations, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.networkType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NetworkType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.notificationConfiguration": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NotificationConfiguration, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.numCacheNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).NumCacheNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.preferredAvailabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).PreferredAvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.snapshotRetentionLimit": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).SnapshotRetentionLimit, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.elasticache.cluster.transitEncryptionMode": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsElasticacheCluster).TransitEncryptionMode, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRedshift).__id, ok = v.Value.(string)
			return
		},
	"aws.redshift.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshift).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsRedshiftCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.redshift.cluster.allowVersionUpgrade": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AllowVersionUpgrade, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.automatedSnapshotRetentionPeriod": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AutomatedSnapshotRetentionPeriod, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterParameterGroupNames": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterParameterGroupNames, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterRevisionNumber": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterRevisionNumber, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterSubnetGroupName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterSubnetGroupName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.clusterVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).ClusterVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).CreatedAt, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.dbName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).DbName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.enhancedVpcRouting": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).EnhancedVpcRouting, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Logging, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.masterUsername": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).MasterUsername, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nextMaintenanceWindowStartTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NextMaintenanceWindowStartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.nodeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NodeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.numberOfNodes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).NumberOfNodes, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.parameters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Parameters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.preferredMaintenanceWindow": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PreferredMaintenanceWindow, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.publiclyAccessible": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).PubliclyAccessible, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.redshift.cluster.vpcId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsRedshiftCluster).VpcId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcr).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.privateRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PrivateRepositories, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.publicRepositories": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).PublicRepositories, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcr).Images, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcrRepository).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.repository.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.public": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Public, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.images": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Images, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.repository.imageScanOnPush": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrRepository).ImageScanOnPush, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ecr.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEcrImage).__id, ok = v.Value.(string)
			return
		},
	"aws.ecr.image.digest": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Digest, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.mediaType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).MediaType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Tags, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ecr.image.registryId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RegistryId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.repoName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).RepoName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ecr.image.uri": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEcrImage).Uri, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.dms.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsDms).__id, ok = v.Value.(string)
			return
		},
	"aws.dms.replicationInstances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsDms).ReplicationInstances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigateway).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.restApis": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigateway).RestApis, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigatewayRestapi).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.restapi.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.createdDate": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).CreatedDate, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.stages": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Stages, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.restapi.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayRestapi).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsApigatewayStage).__id, ok = v.Value.(string)
			return
		},
	"aws.apigateway.stage.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.tracingEnabled": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).TracingEnabled, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.deploymentId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).DeploymentId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.apigateway.stage.methodSettings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsApigatewayStage).MethodSettings, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsLambda).__id, ok = v.Value.(string)
			return
		},
	"aws.lambda.functions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambda).Functions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsLambdaFunction).__id, ok = v.Value.(string)
			return
		},
	"aws.lambda.function.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.runtime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Runtime, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.concurrency": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Concurrency, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.lambda.function.dlqTargetArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).DlqTargetArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.policy": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Policy, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.vpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).VpcConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.lambda.function.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.lambda.function.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsLambdaFunction).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ssm.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSsm).__id, ok = v.Value.(string)
			return
		},
	"aws.ssm.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsm).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsSsmInstance).__id, ok = v.Value.(string)
			return
		},
	"aws.ssm.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.pingStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PingStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.ipAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).IpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.platformName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).PlatformName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ssm.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsSsmInstance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instances": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Instances, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.ebsEncryptionByDefault": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).EbsEncryptionByDefault, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volumes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Volumes, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshots": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Snapshots, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.internetGateways": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).InternetGateways, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnConnections": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).VpnConnections, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkAcls": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).NetworkAcls, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.keypairs": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2).Keypairs, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Networkacl).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entries": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Networkacl).Entries, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2NetworkaclEntry).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.entry.egress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Egress, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.ruleAction": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).RuleAction, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portRange": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).PortRange, ok = plugin.RawToTValue[*mqlAwsEc2NetworkaclEntryPortrange](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntry).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2NetworkaclEntryPortrange).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.networkacl.entry.portrange.from": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).From, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.to": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).To, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.networkacl.entry.portrange.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2NetworkaclEntryPortrange).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Vpnconnection).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.vpnconnection.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vpnconnection.vgwTelemetry": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vpnconnection).VgwTelemetry, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Vgwtelemetry).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.vgwtelemetry.outsideIpAddress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).OutsideIpAddress, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.vgwtelemetry.statusMessage": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Vgwtelemetry).StatusMessage, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Internetgateway).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.internetgateway.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.internetgateway.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Internetgateway).Attachments, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Snapshot).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.snapshot.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.createVolumePermission": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).CreateVolumePermission, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.startTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).StartTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.snapshot.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Snapshot).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Volume).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.volume.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.attachments": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Attachments, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.encrypted": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Encrypted, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.availabilityZone": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).AvailabilityZone, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.volumeType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).VolumeType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.createTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).CreateTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.volume.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Volume).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Instance).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.instance.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.detailedMonitoring": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DetailedMonitoring, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ssm": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Ssm, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpTokens": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpTokens, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.httpEndpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).HttpEndpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.patchState": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PatchState, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.deviceMappings": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).DeviceMappings, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.securityGroups": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).SecurityGroups, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.platformDetails": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PlatformDetails, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.publicDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PublicDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceStatus, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateReason, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionReason": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionReason, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.ebsOptimized": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).EbsOptimized, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.instanceType": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).InstanceType, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.image": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Image, ok = plugin.RawToTValue[*mqlAwsEc2Image](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.launchTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).LaunchTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateIp": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateIp, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.privateDnsName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).PrivateDnsName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.keypair": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).Keypair, ok = plugin.RawToTValue[*mqlAwsEc2Keypair](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.stateTransitionTime": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).StateTransitionTime, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.vpcArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Instance).VpcArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Keypair).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.keypair.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.fingerprint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Fingerprint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.type": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Type, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.keypair.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Keypair).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Image).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.image.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.architecture": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).Architecture, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.image.ownerAlias": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Image).OwnerAlias, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2InstanceDevice).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.instance.device.deleteOnTermination": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeleteOnTermination, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.volumeId": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).VolumeId, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.instance.device.deviceName": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2InstanceDevice).DeviceName, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2Securitygroup).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securitygroup.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.description": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Description, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.vpc": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Vpc, ok = plugin.RawToTValue[*mqlAwsVpc](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissions": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissions, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ipPermissionsEgress": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IpPermissionsEgress, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.isAttachedToNetworkInterface": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2Securitygroup).IsAttachedToNetworkInterface, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEc2SecuritygroupIppermission).__id, ok = v.Value.(string)
			return
		},
	"aws.ec2.securitygroup.ippermission.id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Id, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.fromPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).FromPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.toPort": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).ToPort, ok = plugin.RawToTValue[int64](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipProtocol": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpProtocol, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipRanges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).IpRanges, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.ec2.securitygroup.ippermission.ipv6Ranges": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEc2SecuritygroupIppermission).Ipv6Ranges, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfig).__id, ok = v.Value.(string)
			return
		},
	"aws.config.recorders": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Recorders, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.rules": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfig).Rules, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.config.rule.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfigRule).__id, ok = v.Value.(string)
			return
		},
	"aws.config.rule.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.state": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).State, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.rule.source": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRule).Source, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.config.recorder.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsConfigRecorder).__id, ok = v.Value.(string)
			return
		},
	"aws.config.recorder.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.roleArn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).RoleArn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.allSupported": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).AllSupported, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.includeGlobalResourceTypes": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).IncludeGlobalResourceTypes, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.recording": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Recording, ok = plugin.RawToTValue[bool](v.Value, v.Error)
		return
	},
	"aws.config.recorder.lastStatus": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).LastStatus, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.config.recorder.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsConfigRecorder).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEks).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.clusters": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEks).Clusters, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.__id": func(r plugin.Resource, v *llx.RawData) (ok bool) {
			r.(*mqlAwsEksCluster).__id, ok = v.Value.(string)
			return
		},
	"aws.eks.cluster.name": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Name, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.arn": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Arn, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.region": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Region, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.tags": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Tags, ok = plugin.RawToTValue[map[string]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.endpoint": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Endpoint, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.version": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Version, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.platformVersion": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).PlatformVersion, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.status": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Status, ok = plugin.RawToTValue[string](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.encryptionConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).EncryptionConfig, ok = plugin.RawToTValue[[]interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.logging": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).Logging, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.networkConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).NetworkConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.resourcesVpcConfig": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).ResourcesVpcConfig, ok = plugin.RawToTValue[interface{}](v.Value, v.Error)
		return
	},
	"aws.eks.cluster.createdAt": func(r plugin.Resource, v *llx.RawData) (ok bool) {
		r.(*mqlAwsEksCluster).CreatedAt, ok = plugin.RawToTValue[*time.Time](v.Value, v.Error)
		return
	},
}

func SetData(resource plugin.Resource, field string, val *llx.RawData) error {
	f, ok := setDataFields[resource.MqlName() + "." + field]
	if !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', field not found")
	}

	if ok := f(resource, val); !ok {
		return errors.New("[aws] cannot set '"+field+"' in resource '"+resource.MqlName()+"', type does not match")
	}
	return nil
}

func SetAllData(resource plugin.Resource, args map[string]*llx.RawData) error {
	var err error
	for k, v := range args {
		if err = SetData(resource, k, v); err != nil {
			return err
		}
	}
	return nil
}

// mqlAws for the aws resource
type mqlAws struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsInternal it will be used here
	Vpcs plugin.TValue[[]interface{}]
	Regions plugin.TValue[[]interface{}]
}

// createAws creates a new instance of this resource
func createAws(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAws{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAws) MqlName() string {
	return "aws"
}

func (c *mqlAws) MqlID() string {
	return c.__id
}

func (c *mqlAws) GetVpcs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vpcs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws", c.__id, "vpcs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vpcs()
	})
}

func (c *mqlAws) GetRegions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Regions, func() ([]interface{}, error) {
		return c.regions()
	})
}

// mqlAwsAccount for the aws.account resource
type mqlAwsAccount struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccountInternal it will be used here
	Id plugin.TValue[string]
	Aliases plugin.TValue[[]interface{}]
	Organization plugin.TValue[*mqlAwsOrganization]
}

// createAwsAccount creates a new instance of this resource
func createAwsAccount(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccount{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.account", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccount) MqlName() string {
	return "aws.account"
}

func (c *mqlAwsAccount) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccount) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsAccount) GetAliases() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Aliases, func() ([]interface{}, error) {
		return c.aliases()
	})
}

func (c *mqlAwsAccount) GetOrganization() *plugin.TValue[*mqlAwsOrganization] {
	return plugin.GetOrCompute[*mqlAwsOrganization](&c.Organization, func() (*mqlAwsOrganization, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.account", c.__id, "organization")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsOrganization), nil
			}
		}

		return c.organization()
	})
}

// mqlAwsOrganization for the aws.organization resource
type mqlAwsOrganization struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsOrganizationInternal it will be used here
	Arn plugin.TValue[string]
	FeatureSet plugin.TValue[string]
	MasterAccountId plugin.TValue[string]
	MasterAccountEmail plugin.TValue[string]
}

// createAwsOrganization creates a new instance of this resource
func createAwsOrganization(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsOrganization{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.organization", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsOrganization) MqlName() string {
	return "aws.organization"
}

func (c *mqlAwsOrganization) MqlID() string {
	return c.__id
}

func (c *mqlAwsOrganization) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsOrganization) GetFeatureSet() *plugin.TValue[string] {
	return &c.FeatureSet
}

func (c *mqlAwsOrganization) GetMasterAccountId() *plugin.TValue[string] {
	return &c.MasterAccountId
}

func (c *mqlAwsOrganization) GetMasterAccountEmail() *plugin.TValue[string] {
	return &c.MasterAccountEmail
}

// mqlAwsVpc for the aws.vpc resource
type mqlAwsVpc struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	CidrBlock plugin.TValue[string]
	State plugin.TValue[string]
	IsDefault plugin.TValue[bool]
	InstanceTenancy plugin.TValue[string]
	Region plugin.TValue[string]
	Endpoints plugin.TValue[[]interface{}]
	FlowLogs plugin.TValue[[]interface{}]
	RouteTables plugin.TValue[[]interface{}]
	Subnets plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpc creates a new instance of this resource
func createAwsVpc(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpc{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpc) MqlName() string {
	return "aws.vpc"
}

func (c *mqlAwsVpc) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpc) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpc) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpc) GetCidrBlock() *plugin.TValue[string] {
	return &c.CidrBlock
}

func (c *mqlAwsVpc) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsVpc) GetIsDefault() *plugin.TValue[bool] {
	return &c.IsDefault
}

func (c *mqlAwsVpc) GetInstanceTenancy() *plugin.TValue[string] {
	return &c.InstanceTenancy
}

func (c *mqlAwsVpc) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpc) GetEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Endpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsVpc) GetFlowLogs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.FlowLogs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "flowLogs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.flowLogs()
	})
}

func (c *mqlAwsVpc) GetRouteTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RouteTables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "routeTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.routeTables()
	})
}

func (c *mqlAwsVpc) GetSubnets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subnets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.vpc", c.__id, "subnets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subnets()
	})
}

func (c *mqlAwsVpc) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsVpcRoutetable for the aws.vpc.routetable resource
type mqlAwsVpcRoutetable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcRoutetableInternal it will be used here
	Id plugin.TValue[string]
	Routes plugin.TValue[[]interface{}]
}

// createAwsVpcRoutetable creates a new instance of this resource
func createAwsVpcRoutetable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcRoutetable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.routetable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcRoutetable) MqlName() string {
	return "aws.vpc.routetable"
}

func (c *mqlAwsVpcRoutetable) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcRoutetable) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcRoutetable) GetRoutes() *plugin.TValue[[]interface{}] {
	return &c.Routes
}

// mqlAwsVpcSubnet for the aws.vpc.subnet resource
type mqlAwsVpcSubnet struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcSubnetInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Cidrs plugin.TValue[string]
	MapPublicIpOnLaunch plugin.TValue[bool]
	AvailabilityZone plugin.TValue[string]
	DefaultForAvailabilityZone plugin.TValue[bool]
}

// createAwsVpcSubnet creates a new instance of this resource
func createAwsVpcSubnet(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcSubnet{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.subnet", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcSubnet) MqlName() string {
	return "aws.vpc.subnet"
}

func (c *mqlAwsVpcSubnet) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcSubnet) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsVpcSubnet) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcSubnet) GetCidrs() *plugin.TValue[string] {
	return &c.Cidrs
}

func (c *mqlAwsVpcSubnet) GetMapPublicIpOnLaunch() *plugin.TValue[bool] {
	return &c.MapPublicIpOnLaunch
}

func (c *mqlAwsVpcSubnet) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsVpcSubnet) GetDefaultForAvailabilityZone() *plugin.TValue[bool] {
	return &c.DefaultForAvailabilityZone
}

// mqlAwsVpcEndpoint for the aws.vpc.endpoint resource
type mqlAwsVpcEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcEndpointInternal it will be used here
	Id plugin.TValue[string]
	Type plugin.TValue[string]
	Vpc plugin.TValue[string]
	Region plugin.TValue[string]
	ServiceName plugin.TValue[string]
	PolicyDocument plugin.TValue[string]
	Subnets plugin.TValue[[]interface{}]
}

// createAwsVpcEndpoint creates a new instance of this resource
func createAwsVpcEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcEndpoint) MqlName() string {
	return "aws.vpc.endpoint"
}

func (c *mqlAwsVpcEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcEndpoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcEndpoint) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsVpcEndpoint) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcEndpoint) GetServiceName() *plugin.TValue[string] {
	return &c.ServiceName
}

func (c *mqlAwsVpcEndpoint) GetPolicyDocument() *plugin.TValue[string] {
	return &c.PolicyDocument
}

func (c *mqlAwsVpcEndpoint) GetSubnets() *plugin.TValue[[]interface{}] {
	return &c.Subnets
}

// mqlAwsVpcFlowlog for the aws.vpc.flowlog resource
type mqlAwsVpcFlowlog struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsVpcFlowlogInternal it will be used here
	Id plugin.TValue[string]
	Vpc plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsVpcFlowlog creates a new instance of this resource
func createAwsVpcFlowlog(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsVpcFlowlog{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.vpc.flowlog", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsVpcFlowlog) MqlName() string {
	return "aws.vpc.flowlog"
}

func (c *mqlAwsVpcFlowlog) MqlID() string {
	return c.__id
}

func (c *mqlAwsVpcFlowlog) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsVpcFlowlog) GetVpc() *plugin.TValue[string] {
	return &c.Vpc
}

func (c *mqlAwsVpcFlowlog) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsVpcFlowlog) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsVpcFlowlog) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsAccessAnalyzer for the aws.accessAnalyzer resource
type mqlAwsAccessAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccessAnalyzerInternal it will be used here
	Analyzers plugin.TValue[[]interface{}]
}

// createAwsAccessAnalyzer creates a new instance of this resource
func createAwsAccessAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccessAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.accessAnalyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccessAnalyzer) MqlName() string {
	return "aws.accessAnalyzer"
}

func (c *mqlAwsAccessAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccessAnalyzer) GetAnalyzers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Analyzers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.accessAnalyzer", c.__id, "analyzers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.analyzers()
	})
}

// mqlAwsAccessanalyzerAnalyzer for the aws.accessanalyzer.analyzer resource
type mqlAwsAccessanalyzerAnalyzer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAccessanalyzerAnalyzerInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Type plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	LastResourceAnalyzed plugin.TValue[string]
	LastResourceAnalyzedAt plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsAccessanalyzerAnalyzer creates a new instance of this resource
func createAwsAccessanalyzerAnalyzer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAccessanalyzerAnalyzer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.accessanalyzer.analyzer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAccessanalyzerAnalyzer) MqlName() string {
	return "aws.accessanalyzer.analyzer"
}

func (c *mqlAwsAccessanalyzerAnalyzer) MqlID() string {
	return c.__id
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetLastResourceAnalyzed() *plugin.TValue[string] {
	return &c.LastResourceAnalyzed
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetLastResourceAnalyzedAt() *plugin.TValue[*time.Time] {
	return &c.LastResourceAnalyzedAt
}

func (c *mqlAwsAccessanalyzerAnalyzer) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsEfs for the aws.efs resource
type mqlAwsEfs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEfsInternal it will be used here
	Filesystems plugin.TValue[[]interface{}]
}

// createAwsEfs creates a new instance of this resource
func createAwsEfs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	// to override __id implement: id() (string, error)

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfs) MqlName() string {
	return "aws.efs"
}

func (c *mqlAwsEfs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfs) GetFilesystems() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Filesystems, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs", c.__id, "filesystems")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.filesystems()
	})
}

// mqlAwsEfsFilesystem for the aws.efs.filesystem resource
type mqlAwsEfsFilesystem struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEfsFilesystemInternal it will be used here
	Name plugin.TValue[string]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	BackupPolicy plugin.TValue[interface{}]
	Region plugin.TValue[string]
	AvailabilityZone plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsEfsFilesystem creates a new instance of this resource
func createAwsEfsFilesystem(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEfsFilesystem{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.efs.filesystem", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEfsFilesystem) MqlName() string {
	return "aws.efs.filesystem"
}

func (c *mqlAwsEfsFilesystem) MqlID() string {
	return c.__id
}

func (c *mqlAwsEfsFilesystem) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEfsFilesystem) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEfsFilesystem) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEfsFilesystem) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEfsFilesystem) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.efs.filesystem", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsEfsFilesystem) GetBackupPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.BackupPolicy, func() (interface{}, error) {
		return c.backupPolicy()
	})
}

func (c *mqlAwsEfsFilesystem) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEfsFilesystem) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEfsFilesystem) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEfsFilesystem) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

// mqlAwsKms for the aws.kms resource
type mqlAwsKms struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsInternal it will be used here
	Keys plugin.TValue[[]interface{}]
}

// createAwsKms creates a new instance of this resource
func createAwsKms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKms) MqlName() string {
	return "aws.kms"
}

func (c *mqlAwsKms) MqlID() string {
	return c.__id
}

func (c *mqlAwsKms) GetKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Keys, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.kms", c.__id, "keys")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.keys()
	})
}

// mqlAwsKmsKey for the aws.kms.key resource
type mqlAwsKmsKey struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsKmsKeyInternal it will be used here
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	KeyRotationEnabled plugin.TValue[bool]
	Metadata plugin.TValue[interface{}]
}

// createAwsKmsKey creates a new instance of this resource
func createAwsKmsKey(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsKmsKey{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.kms.key", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsKmsKey) MqlName() string {
	return "aws.kms.key"
}

func (c *mqlAwsKmsKey) MqlID() string {
	return c.__id
}

func (c *mqlAwsKmsKey) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsKmsKey) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsKmsKey) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsKmsKey) GetKeyRotationEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.KeyRotationEnabled, func() (bool, error) {
		return c.keyRotationEnabled()
	})
}

func (c *mqlAwsKmsKey) GetMetadata() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Metadata, func() (interface{}, error) {
		return c.metadata()
	})
}

// mqlAwsIam for the aws.iam resource
type mqlAwsIam struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamInternal it will be used here
	Users plugin.TValue[[]interface{}]
	Roles plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	CredentialReport plugin.TValue[[]interface{}]
	AccountPasswordPolicy plugin.TValue[interface{}]
	AccountSummary plugin.TValue[map[string]interface{}]
	VirtualMfaDevices plugin.TValue[[]interface{}]
	ServerCertificates plugin.TValue[[]interface{}]
}

// createAwsIam creates a new instance of this resource
func createAwsIam(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIam{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIam) MqlName() string {
	return "aws.iam"
}

func (c *mqlAwsIam) MqlID() string {
	return c.__id
}

func (c *mqlAwsIam) GetUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Users, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "users")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.users()
	})
}

func (c *mqlAwsIam) GetRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Roles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "roles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.roles()
	})
}

func (c *mqlAwsIam) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

func (c *mqlAwsIam) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "policies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.policies()
	})
}

func (c *mqlAwsIam) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIam) GetCredentialReport() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CredentialReport, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "credentialReport")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.credentialReport()
	})
}

func (c *mqlAwsIam) GetAccountPasswordPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.AccountPasswordPolicy, func() (interface{}, error) {
		return c.accountPasswordPolicy()
	})
}

func (c *mqlAwsIam) GetAccountSummary() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.AccountSummary, func() (map[string]interface{}, error) {
		return c.accountSummary()
	})
}

func (c *mqlAwsIam) GetVirtualMfaDevices() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.VirtualMfaDevices, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam", c.__id, "virtualMfaDevices")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.virtualMfaDevices()
	})
}

func (c *mqlAwsIam) GetServerCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ServerCertificates, func() ([]interface{}, error) {
		return c.serverCertificates()
	})
}

// mqlAwsIamUsercredentialreportentry for the aws.iam.usercredentialreportentry resource
type mqlAwsIamUsercredentialreportentry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUsercredentialreportentryInternal it will be used here
	Properties plugin.TValue[map[string]interface{}]
	Arn plugin.TValue[string]
	AccessKey1Active plugin.TValue[bool]
	AccessKey1LastRotated plugin.TValue[*time.Time]
	AccessKey1LastUsedDate plugin.TValue[*time.Time]
	AccessKey1LastUsedRegion plugin.TValue[string]
	AccessKey1LastUsedService plugin.TValue[string]
	AccessKey2Active plugin.TValue[bool]
	AccessKey2LastRotated plugin.TValue[*time.Time]
	AccessKey2LastUsedDate plugin.TValue[*time.Time]
	AccessKey2LastUsedRegion plugin.TValue[string]
	AccessKey2LastUsedService plugin.TValue[string]
	Cert1Active plugin.TValue[bool]
	Cert1LastRotated plugin.TValue[*time.Time]
	Cert2Active plugin.TValue[bool]
	Cert2LastRotated plugin.TValue[*time.Time]
	MfaActive plugin.TValue[bool]
	PasswordEnabled plugin.TValue[bool]
	PasswordLastChanged plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	PasswordNextRotation plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
	UserCreationTime plugin.TValue[*time.Time]
}

// createAwsIamUsercredentialreportentry creates a new instance of this resource
func createAwsIamUsercredentialreportentry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUsercredentialreportentry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.usercredentialreportentry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUsercredentialreportentry) MqlName() string {
	return "aws.iam.usercredentialreportentry"
}

func (c *mqlAwsIamUsercredentialreportentry) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUsercredentialreportentry) GetProperties() *plugin.TValue[map[string]interface{}] {
	return &c.Properties
}

func (c *mqlAwsIamUsercredentialreportentry) GetArn() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Arn, func() (string, error) {
		return c.arn()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey1Active, func() (bool, error) {
		return c.accessKey1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastRotated, func() (*time.Time, error) {
		return c.accessKey1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey1LastUsedDate, func() (*time.Time, error) {
		return c.accessKey1LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedRegion, func() (string, error) {
		return c.accessKey1LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey1LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey1LastUsedService, func() (string, error) {
		return c.accessKey1LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.AccessKey2Active, func() (bool, error) {
		return c.accessKey2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastRotated, func() (*time.Time, error) {
		return c.accessKey2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.AccessKey2LastUsedDate, func() (*time.Time, error) {
		return c.accessKey2LastUsedDate()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedRegion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedRegion, func() (string, error) {
		return c.accessKey2LastUsedRegion()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetAccessKey2LastUsedService() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.AccessKey2LastUsedService, func() (string, error) {
		return c.accessKey2LastUsedService()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert1Active, func() (bool, error) {
		return c.cert1Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert1LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert1LastRotated, func() (*time.Time, error) {
		return c.cert1LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2Active() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Cert2Active, func() (bool, error) {
		return c.cert2Active()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetCert2LastRotated() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.Cert2LastRotated, func() (*time.Time, error) {
		return c.cert2LastRotated()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetMfaActive() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.MfaActive, func() (bool, error) {
		return c.mfaActive()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordEnabled() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.PasswordEnabled, func() (bool, error) {
		return c.passwordEnabled()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastChanged() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastChanged, func() (*time.Time, error) {
		return c.passwordLastChanged()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordLastUsed, func() (*time.Time, error) {
		return c.passwordLastUsed()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetPasswordNextRotation() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.PasswordNextRotation, func() (*time.Time, error) {
		return c.passwordNextRotation()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return plugin.GetOrCompute[*mqlAwsIamUser](&c.User, func() (*mqlAwsIamUser, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.usercredentialreportentry", c.__id, "user")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamUser), nil
			}
		}

		return c.user()
	})
}

func (c *mqlAwsIamUsercredentialreportentry) GetUserCreationTime() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UserCreationTime, func() (*time.Time, error) {
		return c.userCreationTime()
	})
}

// mqlAwsIamUser for the aws.iam.user resource
type mqlAwsIamUser struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamUserInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	PasswordLastUsed plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	Policies plugin.TValue[[]interface{}]
	AttachedPolicies plugin.TValue[[]interface{}]
	Groups plugin.TValue[[]interface{}]
	AccessKeys plugin.TValue[[]interface{}]
}

// createAwsIamUser creates a new instance of this resource
func createAwsIamUser(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamUser{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.user", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamUser) MqlName() string {
	return "aws.iam.user"
}

func (c *mqlAwsIamUser) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamUser) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamUser) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamUser) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamUser) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamUser) GetPasswordLastUsed() *plugin.TValue[*time.Time] {
	return &c.PasswordLastUsed
}

func (c *mqlAwsIamUser) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamUser) GetPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Policies, func() ([]interface{}, error) {
		return c.policies()
	})
}

func (c *mqlAwsIamUser) GetAttachedPolicies() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedPolicies, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.user", c.__id, "attachedPolicies")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedPolicies()
	})
}

func (c *mqlAwsIamUser) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		return c.groups()
	})
}

func (c *mqlAwsIamUser) GetAccessKeys() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AccessKeys, func() ([]interface{}, error) {
		return c.accessKeys()
	})
}

// mqlAwsIamPolicy for the aws.iam.policy resource
type mqlAwsIamPolicy struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamPolicyInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	IsAttachable plugin.TValue[bool]
	AttachmentCount plugin.TValue[int64]
	CreateDate plugin.TValue[*time.Time]
	UpdateDate plugin.TValue[*time.Time]
	Scope plugin.TValue[string]
	Versions plugin.TValue[[]interface{}]
	DefaultVersion plugin.TValue[*mqlAwsIamPolicyversion]
	AttachedUsers plugin.TValue[[]interface{}]
	AttachedRoles plugin.TValue[[]interface{}]
	AttachedGroups plugin.TValue[[]interface{}]
}

// createAwsIamPolicy creates a new instance of this resource
func createAwsIamPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicy) MqlName() string {
	return "aws.iam.policy"
}

func (c *mqlAwsIamPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicy) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicy) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamPolicy) GetName() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Name, func() (string, error) {
		return c.name()
	})
}

func (c *mqlAwsIamPolicy) GetDescription() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Description, func() (string, error) {
		return c.description()
	})
}

func (c *mqlAwsIamPolicy) GetIsAttachable() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachable, func() (bool, error) {
		return c.isAttachable()
	})
}

func (c *mqlAwsIamPolicy) GetAttachmentCount() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.AttachmentCount, func() (int64, error) {
		return c.attachmentCount()
	})
}

func (c *mqlAwsIamPolicy) GetCreateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.CreateDate, func() (*time.Time, error) {
		return c.createDate()
	})
}

func (c *mqlAwsIamPolicy) GetUpdateDate() *plugin.TValue[*time.Time] {
	return plugin.GetOrCompute[*time.Time](&c.UpdateDate, func() (*time.Time, error) {
		return c.updateDate()
	})
}

func (c *mqlAwsIamPolicy) GetScope() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Scope, func() (string, error) {
		return c.scope()
	})
}

func (c *mqlAwsIamPolicy) GetVersions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Versions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "versions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.versions()
	})
}

func (c *mqlAwsIamPolicy) GetDefaultVersion() *plugin.TValue[*mqlAwsIamPolicyversion] {
	return plugin.GetOrCompute[*mqlAwsIamPolicyversion](&c.DefaultVersion, func() (*mqlAwsIamPolicyversion, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "defaultVersion")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsIamPolicyversion), nil
			}
		}

		return c.defaultVersion()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedUsers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedUsers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedUsers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedUsers()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedRoles() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedRoles, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedRoles")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedRoles()
	})
}

func (c *mqlAwsIamPolicy) GetAttachedGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.AttachedGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.iam.policy", c.__id, "attachedGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.attachedGroups()
	})
}

// mqlAwsIamPolicyversion for the aws.iam.policyversion resource
type mqlAwsIamPolicyversion struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamPolicyversionInternal it will be used here
	Arn plugin.TValue[string]
	VersionId plugin.TValue[string]
	IsDefaultVersion plugin.TValue[bool]
	Document plugin.TValue[interface{}]
	CreateDate plugin.TValue[*time.Time]
}

// createAwsIamPolicyversion creates a new instance of this resource
func createAwsIamPolicyversion(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamPolicyversion{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.policyversion", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamPolicyversion) MqlName() string {
	return "aws.iam.policyversion"
}

func (c *mqlAwsIamPolicyversion) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamPolicyversion) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamPolicyversion) GetVersionId() *plugin.TValue[string] {
	return &c.VersionId
}

func (c *mqlAwsIamPolicyversion) GetIsDefaultVersion() *plugin.TValue[bool] {
	return &c.IsDefaultVersion
}

func (c *mqlAwsIamPolicyversion) GetDocument() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Document, func() (interface{}, error) {
		return c.document()
	})
}

func (c *mqlAwsIamPolicyversion) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

// mqlAwsIamRole for the aws.iam.role resource
type mqlAwsIamRole struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamRoleInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	CreateDate plugin.TValue[*time.Time]
}

// createAwsIamRole creates a new instance of this resource
func createAwsIamRole(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamRole{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.role", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamRole) MqlName() string {
	return "aws.iam.role"
}

func (c *mqlAwsIamRole) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamRole) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamRole) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamRole) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamRole) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsIamRole) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsIamRole) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

// mqlAwsIamGroup for the aws.iam.group resource
type mqlAwsIamGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamGroupInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreateDate plugin.TValue[*time.Time]
	Usernames plugin.TValue[[]interface{}]
}

// createAwsIamGroup creates a new instance of this resource
func createAwsIamGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamGroup) MqlName() string {
	return "aws.iam.group"
}

func (c *mqlAwsIamGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsIamGroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsIamGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsIamGroup) GetCreateDate() *plugin.TValue[*time.Time] {
	return &c.CreateDate
}

func (c *mqlAwsIamGroup) GetUsernames() *plugin.TValue[[]interface{}] {
	return &c.Usernames
}

// mqlAwsIamVirtualmfadevice for the aws.iam.virtualmfadevice resource
type mqlAwsIamVirtualmfadevice struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsIamVirtualmfadeviceInternal it will be used here
	SerialNumber plugin.TValue[string]
	EnableDate plugin.TValue[*time.Time]
	User plugin.TValue[*mqlAwsIamUser]
}

// createAwsIamVirtualmfadevice creates a new instance of this resource
func createAwsIamVirtualmfadevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsIamVirtualmfadevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.iam.virtualmfadevice", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsIamVirtualmfadevice) MqlName() string {
	return "aws.iam.virtualmfadevice"
}

func (c *mqlAwsIamVirtualmfadevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsIamVirtualmfadevice) GetSerialNumber() *plugin.TValue[string] {
	return &c.SerialNumber
}

func (c *mqlAwsIamVirtualmfadevice) GetEnableDate() *plugin.TValue[*time.Time] {
	return &c.EnableDate
}

func (c *mqlAwsIamVirtualmfadevice) GetUser() *plugin.TValue[*mqlAwsIamUser] {
	return &c.User
}

// mqlAwsSagemaker for the aws.sagemaker resource
type mqlAwsSagemaker struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerInternal it will be used here
	Endpoints plugin.TValue[[]interface{}]
	NotebookInstances plugin.TValue[[]interface{}]
}

// createAwsSagemaker creates a new instance of this resource
func createAwsSagemaker(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemaker{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemaker) MqlName() string {
	return "aws.sagemaker"
}

func (c *mqlAwsSagemaker) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemaker) GetEndpoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Endpoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "endpoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.endpoints()
	})
}

func (c *mqlAwsSagemaker) GetNotebookInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NotebookInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker", c.__id, "notebookInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.notebookInstances()
	})
}

// mqlAwsSagemakerNotebookinstance for the aws.sagemaker.notebookinstance resource
type mqlAwsSagemakerNotebookinstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerNotebookinstanceInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Details plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerNotebookinstance creates a new instance of this resource
func createAwsSagemakerNotebookinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstance) MqlName() string {
	return "aws.sagemaker.notebookinstance"
}

func (c *mqlAwsSagemakerNotebookinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerNotebookinstance) GetDetails() *plugin.TValue[*mqlAwsSagemakerNotebookinstanceDetails] {
	return plugin.GetOrCompute[*mqlAwsSagemakerNotebookinstanceDetails](&c.Details, func() (*mqlAwsSagemakerNotebookinstanceDetails, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance", c.__id, "details")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsSagemakerNotebookinstanceDetails), nil
			}
		}

		return c.details()
	})
}

func (c *mqlAwsSagemakerNotebookinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerNotebookinstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSagemakerNotebookinstanceDetails for the aws.sagemaker.notebookinstance.details resource
type mqlAwsSagemakerNotebookinstanceDetails struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerNotebookinstanceDetailsInternal it will be used here
	Arn plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	DirectInternetAccess plugin.TValue[string]
}

// createAwsSagemakerNotebookinstanceDetails creates a new instance of this resource
func createAwsSagemakerNotebookinstanceDetails(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerNotebookinstanceDetails{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.notebookinstance.details", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlName() string {
	return "aws.sagemaker.notebookinstance.details"
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sagemaker.notebookinstance.details", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsSagemakerNotebookinstanceDetails) GetDirectInternetAccess() *plugin.TValue[string] {
	return &c.DirectInternetAccess
}

// mqlAwsSagemakerEndpoint for the aws.sagemaker.endpoint resource
type mqlAwsSagemakerEndpoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSagemakerEndpointInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Config plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSagemakerEndpoint creates a new instance of this resource
func createAwsSagemakerEndpoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSagemakerEndpoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sagemaker.endpoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSagemakerEndpoint) MqlName() string {
	return "aws.sagemaker.endpoint"
}

func (c *mqlAwsSagemakerEndpoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsSagemakerEndpoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSagemakerEndpoint) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSagemakerEndpoint) GetConfig() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Config, func() (interface{}, error) {
		return c.config()
	})
}

func (c *mqlAwsSagemakerEndpoint) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSagemakerEndpoint) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSns for the aws.sns resource
type mqlAwsSns struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsInternal it will be used here
	Topics plugin.TValue[[]interface{}]
}

// createAwsSns creates a new instance of this resource
func createAwsSns(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSns{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSns) MqlName() string {
	return "aws.sns"
}

func (c *mqlAwsSns) MqlID() string {
	return c.__id
}

func (c *mqlAwsSns) GetTopics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Topics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns", c.__id, "topics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.topics()
	})
}

// mqlAwsSnsTopic for the aws.sns.topic resource
type mqlAwsSnsTopic struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsTopicInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Subscriptions plugin.TValue[[]interface{}]
	Attributes plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSnsTopic creates a new instance of this resource
func createAwsSnsTopic(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsTopic{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.topic", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsTopic) MqlName() string {
	return "aws.sns.topic"
}

func (c *mqlAwsSnsTopic) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsTopic) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsTopic) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSnsTopic) GetSubscriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Subscriptions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.sns.topic", c.__id, "subscriptions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.subscriptions()
	})
}

func (c *mqlAwsSnsTopic) GetAttributes() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Attributes, func() (interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsSnsTopic) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsSnsSubscription for the aws.sns.subscription resource
type mqlAwsSnsSubscription struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSnsSubscriptionInternal it will be used here
	Arn plugin.TValue[string]
	Protocol plugin.TValue[string]
}

// createAwsSnsSubscription creates a new instance of this resource
func createAwsSnsSubscription(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSnsSubscription{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.sns.subscription", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSnsSubscription) MqlName() string {
	return "aws.sns.subscription"
}

func (c *mqlAwsSnsSubscription) MqlID() string {
	return c.__id
}

func (c *mqlAwsSnsSubscription) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSnsSubscription) GetProtocol() *plugin.TValue[string] {
	return &c.Protocol
}

// mqlAwsEs for the aws.es resource
type mqlAwsEs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsInternal it will be used here
	Domains plugin.TValue[[]interface{}]
}

// createAwsEs creates a new instance of this resource
func createAwsEs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEs) MqlName() string {
	return "aws.es"
}

func (c *mqlAwsEs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEs) GetDomains() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Domains, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.es", c.__id, "domains")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.domains()
	})
}

// mqlAwsEsDomain for the aws.es.domain resource
type mqlAwsEsDomain struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEsDomainInternal it will be used here
	Arn plugin.TValue[string]
	EncryptionAtRestEnabled plugin.TValue[bool]
	NodeToNodeEncryptionEnabled plugin.TValue[bool]
	Name plugin.TValue[string]
	Endpoint plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	ElasticsearchVersion plugin.TValue[string]
	DomainId plugin.TValue[string]
	DomainName plugin.TValue[string]
}

// createAwsEsDomain creates a new instance of this resource
func createAwsEsDomain(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEsDomain{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.es.domain", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEsDomain) MqlName() string {
	return "aws.es.domain"
}

func (c *mqlAwsEsDomain) MqlID() string {
	return c.__id
}

func (c *mqlAwsEsDomain) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEsDomain) GetEncryptionAtRestEnabled() *plugin.TValue[bool] {
	return &c.EncryptionAtRestEnabled
}

func (c *mqlAwsEsDomain) GetNodeToNodeEncryptionEnabled() *plugin.TValue[bool] {
	return &c.NodeToNodeEncryptionEnabled
}

func (c *mqlAwsEsDomain) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEsDomain) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEsDomain) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEsDomain) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEsDomain) GetElasticsearchVersion() *plugin.TValue[string] {
	return &c.ElasticsearchVersion
}

func (c *mqlAwsEsDomain) GetDomainId() *plugin.TValue[string] {
	return &c.DomainId
}

func (c *mqlAwsEsDomain) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

// mqlAwsAcm for the aws.acm resource
type mqlAwsAcm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmInternal it will be used here
	Certificates plugin.TValue[[]interface{}]
}

// createAwsAcm creates a new instance of this resource
func createAwsAcm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcm) MqlName() string {
	return "aws.acm"
}

func (c *mqlAwsAcm) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcm) GetCertificates() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Certificates, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm", c.__id, "certificates")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.certificates()
	})
}

// mqlAwsAcmCertificate for the aws.acm.certificate resource
type mqlAwsAcmCertificate struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAcmCertificateInternal it will be used here
	Arn plugin.TValue[string]
	NotBefore plugin.TValue[*time.Time]
	NotAfter plugin.TValue[*time.Time]
	CreatedAt plugin.TValue[*time.Time]
	DomainName plugin.TValue[string]
	Status plugin.TValue[string]
	Subject plugin.TValue[string]
	Certificate plugin.TValue[plugin.Resource]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsAcmCertificate creates a new instance of this resource
func createAwsAcmCertificate(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAcmCertificate{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.acm.certificate", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAcmCertificate) MqlName() string {
	return "aws.acm.certificate"
}

func (c *mqlAwsAcmCertificate) MqlID() string {
	return c.__id
}

func (c *mqlAwsAcmCertificate) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAcmCertificate) GetNotBefore() *plugin.TValue[*time.Time] {
	return &c.NotBefore
}

func (c *mqlAwsAcmCertificate) GetNotAfter() *plugin.TValue[*time.Time] {
	return &c.NotAfter
}

func (c *mqlAwsAcmCertificate) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsAcmCertificate) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsAcmCertificate) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsAcmCertificate) GetSubject() *plugin.TValue[string] {
	return &c.Subject
}

func (c *mqlAwsAcmCertificate) GetCertificate() *plugin.TValue[plugin.Resource] {
	return plugin.GetOrCompute[plugin.Resource](&c.Certificate, func() (plugin.Resource, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.acm.certificate", c.__id, "certificate")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(plugin.Resource), nil
			}
		}

		return c.certificate()
	})
}

func (c *mqlAwsAcmCertificate) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsAutoscaling for the aws.autoscaling resource
type mqlAwsAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAutoscalingInternal it will be used here
	Groups plugin.TValue[[]interface{}]
}

// createAwsAutoscaling creates a new instance of this resource
func createAwsAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscaling) MqlName() string {
	return "aws.autoscaling"
}

func (c *mqlAwsAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscaling) GetGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Groups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.autoscaling", c.__id, "groups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.groups()
	})
}

// mqlAwsAutoscalingGroup for the aws.autoscaling.group resource
type mqlAwsAutoscalingGroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsAutoscalingGroupInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	LoadBalancerNames plugin.TValue[[]interface{}]
	HealthCheckType plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
}

// createAwsAutoscalingGroup creates a new instance of this resource
func createAwsAutoscalingGroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsAutoscalingGroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.autoscaling.group", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsAutoscalingGroup) MqlName() string {
	return "aws.autoscaling.group"
}

func (c *mqlAwsAutoscalingGroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsAutoscalingGroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsAutoscalingGroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsAutoscalingGroup) GetLoadBalancerNames() *plugin.TValue[[]interface{}] {
	return &c.LoadBalancerNames
}

func (c *mqlAwsAutoscalingGroup) GetHealthCheckType() *plugin.TValue[string] {
	return &c.HealthCheckType
}

func (c *mqlAwsAutoscalingGroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsAutoscalingGroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsElb for the aws.elb resource
type mqlAwsElb struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbInternal it will be used here
	ClassicLoadBalancers plugin.TValue[[]interface{}]
	LoadBalancers plugin.TValue[[]interface{}]
}

// createAwsElb creates a new instance of this resource
func createAwsElb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElb) MqlName() string {
	return "aws.elb"
}

func (c *mqlAwsElb) MqlID() string {
	return c.__id
}

func (c *mqlAwsElb) GetClassicLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ClassicLoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "classicLoadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.classicLoadBalancers()
	})
}

func (c *mqlAwsElb) GetLoadBalancers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LoadBalancers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elb", c.__id, "loadBalancers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.loadBalancers()
	})
}

// mqlAwsElbLoadbalancer for the aws.elb.loadbalancer resource
type mqlAwsElbLoadbalancer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElbLoadbalancerInternal it will be used here
	Arn plugin.TValue[string]
	DnsName plugin.TValue[string]
	ListenerDescriptions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
	Scheme plugin.TValue[string]
	Attributes plugin.TValue[[]interface{}]
	VpcId plugin.TValue[string]
	CreatedTime plugin.TValue[*time.Time]
}

// createAwsElbLoadbalancer creates a new instance of this resource
func createAwsElbLoadbalancer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElbLoadbalancer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elb.loadbalancer", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElbLoadbalancer) MqlName() string {
	return "aws.elb.loadbalancer"
}

func (c *mqlAwsElbLoadbalancer) MqlID() string {
	return c.__id
}

func (c *mqlAwsElbLoadbalancer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElbLoadbalancer) GetDnsName() *plugin.TValue[string] {
	return &c.DnsName
}

func (c *mqlAwsElbLoadbalancer) GetListenerDescriptions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ListenerDescriptions, func() ([]interface{}, error) {
		return c.listenerDescriptions()
	})
}

func (c *mqlAwsElbLoadbalancer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsElbLoadbalancer) GetScheme() *plugin.TValue[string] {
	return &c.Scheme
}

func (c *mqlAwsElbLoadbalancer) GetAttributes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Attributes, func() ([]interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsElbLoadbalancer) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

func (c *mqlAwsElbLoadbalancer) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

// mqlAwsCodebuild for the aws.codebuild resource
type mqlAwsCodebuild struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildInternal it will be used here
	Projects plugin.TValue[[]interface{}]
}

// createAwsCodebuild creates a new instance of this resource
func createAwsCodebuild(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuild{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuild) MqlName() string {
	return "aws.codebuild"
}

func (c *mqlAwsCodebuild) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuild) GetProjects() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Projects, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.codebuild", c.__id, "projects")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.projects()
	})
}

// mqlAwsCodebuildProject for the aws.codebuild.project resource
type mqlAwsCodebuildProject struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCodebuildProjectInternal it will be used here
	Arn plugin.TValue[string]
	Description plugin.TValue[string]
	Name plugin.TValue[string]
	Environment plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Source plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsCodebuildProject creates a new instance of this resource
func createAwsCodebuildProject(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCodebuildProject{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.codebuild.project", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCodebuildProject) MqlName() string {
	return "aws.codebuild.project"
}

func (c *mqlAwsCodebuildProject) MqlID() string {
	return c.__id
}

func (c *mqlAwsCodebuildProject) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCodebuildProject) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsCodebuildProject) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCodebuildProject) GetEnvironment() *plugin.TValue[interface{}] {
	return &c.Environment
}

func (c *mqlAwsCodebuildProject) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCodebuildProject) GetSource() *plugin.TValue[interface{}] {
	return &c.Source
}

func (c *mqlAwsCodebuildProject) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsGuardduty for the aws.guardduty resource
type mqlAwsGuardduty struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyInternal it will be used here
	Detectors plugin.TValue[[]interface{}]
}

// createAwsGuardduty creates a new instance of this resource
func createAwsGuardduty(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuardduty{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuardduty) MqlName() string {
	return "aws.guardduty"
}

func (c *mqlAwsGuardduty) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuardduty) GetDetectors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Detectors, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.guardduty", c.__id, "detectors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.detectors()
	})
}

// mqlAwsGuarddutyDetector for the aws.guardduty.detector resource
type mqlAwsGuarddutyDetector struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsGuarddutyDetectorInternal it will be used here
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Status plugin.TValue[string]
	FindingPublishingFrequency plugin.TValue[string]
	UnarchivedFindings plugin.TValue[[]interface{}]
}

// createAwsGuarddutyDetector creates a new instance of this resource
func createAwsGuarddutyDetector(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsGuarddutyDetector{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.guardduty.detector", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsGuarddutyDetector) MqlName() string {
	return "aws.guardduty.detector"
}

func (c *mqlAwsGuarddutyDetector) MqlID() string {
	return c.__id
}

func (c *mqlAwsGuarddutyDetector) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsGuarddutyDetector) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsGuarddutyDetector) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsGuarddutyDetector) GetFindingPublishingFrequency() *plugin.TValue[string] {
	return &c.FindingPublishingFrequency
}

func (c *mqlAwsGuarddutyDetector) GetUnarchivedFindings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.UnarchivedFindings, func() ([]interface{}, error) {
		return c.unarchivedFindings()
	})
}

// mqlAwsSecurityhub for the aws.securityhub resource
type mqlAwsSecurityhub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubInternal it will be used here
	Hubs plugin.TValue[[]interface{}]
}

// createAwsSecurityhub creates a new instance of this resource
func createAwsSecurityhub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhub) MqlName() string {
	return "aws.securityhub"
}

func (c *mqlAwsSecurityhub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhub) GetHubs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Hubs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.securityhub", c.__id, "hubs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.hubs()
	})
}

// mqlAwsSecurityhubHub for the aws.securityhub.hub resource
type mqlAwsSecurityhubHub struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecurityhubHubInternal it will be used here
	Arn plugin.TValue[string]
	SubscribedAt plugin.TValue[string]
}

// createAwsSecurityhubHub creates a new instance of this resource
func createAwsSecurityhubHub(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecurityhubHub{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.securityhub.hub", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecurityhubHub) MqlName() string {
	return "aws.securityhub.hub"
}

func (c *mqlAwsSecurityhubHub) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecurityhubHub) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecurityhubHub) GetSubscribedAt() *plugin.TValue[string] {
	return &c.SubscribedAt
}

// mqlAwsSecretsmanager for the aws.secretsmanager resource
type mqlAwsSecretsmanager struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerInternal it will be used here
	Secrets plugin.TValue[[]interface{}]
}

// createAwsSecretsmanager creates a new instance of this resource
func createAwsSecretsmanager(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanager{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanager) MqlName() string {
	return "aws.secretsmanager"
}

func (c *mqlAwsSecretsmanager) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanager) GetSecrets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Secrets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.secretsmanager", c.__id, "secrets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.secrets()
	})
}

// mqlAwsSecretsmanagerSecret for the aws.secretsmanager.secret resource
type mqlAwsSecretsmanagerSecret struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSecretsmanagerSecretInternal it will be used here
	Arn plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	Description plugin.TValue[string]
	LastChangedDate plugin.TValue[*time.Time]
	LastRotatedDate plugin.TValue[*time.Time]
	Name plugin.TValue[string]
	NextRotationDate plugin.TValue[*time.Time]
	PrimaryRegion plugin.TValue[string]
	RotationEnabled plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSecretsmanagerSecret creates a new instance of this resource
func createAwsSecretsmanagerSecret(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSecretsmanagerSecret{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.secretsmanager.secret", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSecretsmanagerSecret) MqlName() string {
	return "aws.secretsmanager.secret"
}

func (c *mqlAwsSecretsmanagerSecret) MqlID() string {
	return c.__id
}

func (c *mqlAwsSecretsmanagerSecret) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSecretsmanagerSecret) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsSecretsmanagerSecret) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsSecretsmanagerSecret) GetLastChangedDate() *plugin.TValue[*time.Time] {
	return &c.LastChangedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetLastRotatedDate() *plugin.TValue[*time.Time] {
	return &c.LastRotatedDate
}

func (c *mqlAwsSecretsmanagerSecret) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsSecretsmanagerSecret) GetNextRotationDate() *plugin.TValue[*time.Time] {
	return &c.NextRotationDate
}

func (c *mqlAwsSecretsmanagerSecret) GetPrimaryRegion() *plugin.TValue[string] {
	return &c.PrimaryRegion
}

func (c *mqlAwsSecretsmanagerSecret) GetRotationEnabled() *plugin.TValue[bool] {
	return &c.RotationEnabled
}

func (c *mqlAwsSecretsmanagerSecret) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsEcs for the aws.ecs resource
type mqlAwsEcs struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	Containers plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
}

// createAwsEcs creates a new instance of this resource
func createAwsEcs(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcs{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcs) MqlName() string {
	return "aws.ecs"
}

func (c *mqlAwsEcs) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcs) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

func (c *mqlAwsEcs) GetContainers() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Containers, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containers")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containers()
	})
}

func (c *mqlAwsEcs) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

// mqlAwsEcsCluster for the aws.ecs.cluster resource
type mqlAwsEcsCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	RunningTasksCount plugin.TValue[int64]
	PendingTasksCount plugin.TValue[int64]
	RegisteredContainerInstancesCount plugin.TValue[int64]
	Configuration plugin.TValue[interface{}]
	Status plugin.TValue[string]
	Tasks plugin.TValue[[]interface{}]
	ContainerInstances plugin.TValue[[]interface{}]
}

// createAwsEcsCluster creates a new instance of this resource
func createAwsEcsCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsCluster) MqlName() string {
	return "aws.ecs.cluster"
}

func (c *mqlAwsEcsCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsCluster) GetRunningTasksCount() *plugin.TValue[int64] {
	return &c.RunningTasksCount
}

func (c *mqlAwsEcsCluster) GetPendingTasksCount() *plugin.TValue[int64] {
	return &c.PendingTasksCount
}

func (c *mqlAwsEcsCluster) GetRegisteredContainerInstancesCount() *plugin.TValue[int64] {
	return &c.RegisteredContainerInstancesCount
}

func (c *mqlAwsEcsCluster) GetConfiguration() *plugin.TValue[interface{}] {
	return &c.Configuration
}

func (c *mqlAwsEcsCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsCluster) GetTasks() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tasks, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "tasks")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tasks()
	})
}

func (c *mqlAwsEcsCluster) GetContainerInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ContainerInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.cluster", c.__id, "containerInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.containerInstances()
	})
}

// mqlAwsEcsInstance for the aws.ecs.instance resource
type mqlAwsEcsInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsInstanceInternal it will be used here
	AgentConnected plugin.TValue[bool]
	Id plugin.TValue[string]
	Arn plugin.TValue[string]
	CapacityProvider plugin.TValue[string]
	Ec2Instance plugin.TValue[*mqlAwsEc2Instance]
	Region plugin.TValue[string]
}

// createAwsEcsInstance creates a new instance of this resource
func createAwsEcsInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsInstance) MqlName() string {
	return "aws.ecs.instance"
}

func (c *mqlAwsEcsInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsInstance) GetAgentConnected() *plugin.TValue[bool] {
	return &c.AgentConnected
}

func (c *mqlAwsEcsInstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEcsInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsInstance) GetCapacityProvider() *plugin.TValue[string] {
	return &c.CapacityProvider
}

func (c *mqlAwsEcsInstance) GetEc2Instance() *plugin.TValue[*mqlAwsEc2Instance] {
	return plugin.GetOrCompute[*mqlAwsEc2Instance](&c.Ec2Instance, func() (*mqlAwsEc2Instance, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecs.instance", c.__id, "ec2Instance")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Instance), nil
			}
		}

		return c.ec2Instance()
	})
}

func (c *mqlAwsEcsInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEcsTask for the aws.ecs.task resource
type mqlAwsEcsTask struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsTaskInternal it will be used here
	Arn plugin.TValue[string]
	ClusterName plugin.TValue[string]
	Connectivity plugin.TValue[interface{}]
	LastStatus plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Containers plugin.TValue[[]interface{}]
}

// createAwsEcsTask creates a new instance of this resource
func createAwsEcsTask(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsTask{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.task", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsTask) MqlName() string {
	return "aws.ecs.task"
}

func (c *mqlAwsEcsTask) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsTask) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsTask) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsTask) GetConnectivity() *plugin.TValue[interface{}] {
	return &c.Connectivity
}

func (c *mqlAwsEcsTask) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsEcsTask) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsTask) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsTask) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcsTask) GetContainers() *plugin.TValue[[]interface{}] {
	return &c.Containers
}

// mqlAwsEcsContainer for the aws.ecs.container resource
type mqlAwsEcsContainer struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcsContainerInternal it will be used here
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	PublicIp plugin.TValue[string]
	Image plugin.TValue[string]
	ClusterName plugin.TValue[string]
	TaskDefinitionArn plugin.TValue[string]
	LogDriver plugin.TValue[string]
	PlatformFamily plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Status plugin.TValue[string]
	Region plugin.TValue[string]
	Command plugin.TValue[[]interface{}]
	TaskArn plugin.TValue[string]
	RuntimeId plugin.TValue[string]
	ContainerName plugin.TValue[string]
}

// createAwsEcsContainer creates a new instance of this resource
func createAwsEcsContainer(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcsContainer{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecs.container", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcsContainer) MqlName() string {
	return "aws.ecs.container"
}

func (c *mqlAwsEcsContainer) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcsContainer) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcsContainer) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcsContainer) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEcsContainer) GetImage() *plugin.TValue[string] {
	return &c.Image
}

func (c *mqlAwsEcsContainer) GetClusterName() *plugin.TValue[string] {
	return &c.ClusterName
}

func (c *mqlAwsEcsContainer) GetTaskDefinitionArn() *plugin.TValue[string] {
	return &c.TaskDefinitionArn
}

func (c *mqlAwsEcsContainer) GetLogDriver() *plugin.TValue[string] {
	return &c.LogDriver
}

func (c *mqlAwsEcsContainer) GetPlatformFamily() *plugin.TValue[string] {
	return &c.PlatformFamily
}

func (c *mqlAwsEcsContainer) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEcsContainer) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEcsContainer) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcsContainer) GetCommand() *plugin.TValue[[]interface{}] {
	return &c.Command
}

func (c *mqlAwsEcsContainer) GetTaskArn() *plugin.TValue[string] {
	return &c.TaskArn
}

func (c *mqlAwsEcsContainer) GetRuntimeId() *plugin.TValue[string] {
	return &c.RuntimeId
}

func (c *mqlAwsEcsContainer) GetContainerName() *plugin.TValue[string] {
	return &c.ContainerName
}

// mqlAwsEmr for the aws.emr resource
type mqlAwsEmr struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsEmr creates a new instance of this resource
func createAwsEmr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmr) MqlName() string {
	return "aws.emr"
}

func (c *mqlAwsEmr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmr) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.emr", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEmrCluster for the aws.emr.cluster resource
type mqlAwsEmrCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEmrClusterInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	NormalizedInstanceHours plugin.TValue[int64]
	OutpostArn plugin.TValue[string]
	Status plugin.TValue[interface{}]
	MasterInstances plugin.TValue[[]interface{}]
	Id plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsEmrCluster creates a new instance of this resource
func createAwsEmrCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEmrCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.emr.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEmrCluster) MqlName() string {
	return "aws.emr.cluster"
}

func (c *mqlAwsEmrCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEmrCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEmrCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEmrCluster) GetNormalizedInstanceHours() *plugin.TValue[int64] {
	return &c.NormalizedInstanceHours
}

func (c *mqlAwsEmrCluster) GetOutpostArn() *plugin.TValue[string] {
	return &c.OutpostArn
}

func (c *mqlAwsEmrCluster) GetStatus() *plugin.TValue[interface{}] {
	return &c.Status
}

func (c *mqlAwsEmrCluster) GetMasterInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MasterInstances, func() ([]interface{}, error) {
		return c.masterInstances()
	})
}

func (c *mqlAwsEmrCluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEmrCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsCloudwatch for the aws.cloudwatch resource
type mqlAwsCloudwatch struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchInternal it will be used here
	LogGroups plugin.TValue[[]interface{}]
	Alarms plugin.TValue[[]interface{}]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatch creates a new instance of this resource
func createAwsCloudwatch(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatch{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatch) MqlName() string {
	return "aws.cloudwatch"
}

func (c *mqlAwsCloudwatch) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatch) GetLogGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.LogGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "logGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.logGroups()
	})
}

func (c *mqlAwsCloudwatch) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatch) GetMetrics() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Metrics, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch", c.__id, "metrics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metrics()
	})
}

// mqlAwsCloudwatchMetricsalarm for the aws.cloudwatch.metricsalarm resource
type mqlAwsCloudwatchMetricsalarm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricsalarmInternal it will be used here
	Arn plugin.TValue[string]
	MetricName plugin.TValue[string]
	MetricNamespace plugin.TValue[string]
	Region plugin.TValue[string]
	Actions plugin.TValue[[]interface{}]
	State plugin.TValue[string]
	StateReason plugin.TValue[string]
	InsufficientDataActions plugin.TValue[[]interface{}]
	OkActions plugin.TValue[[]interface{}]
	Name plugin.TValue[string]
}

// createAwsCloudwatchMetricsalarm creates a new instance of this resource
func createAwsCloudwatchMetricsalarm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricsalarm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricsalarm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlName() string {
	return "aws.cloudwatch.metricsalarm"
}

func (c *mqlAwsCloudwatchMetricsalarm) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricsalarm) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricName() *plugin.TValue[string] {
	return &c.MetricName
}

func (c *mqlAwsCloudwatchMetricsalarm) GetMetricNamespace() *plugin.TValue[string] {
	return &c.MetricNamespace
}

func (c *mqlAwsCloudwatchMetricsalarm) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricsalarm) GetActions() *plugin.TValue[[]interface{}] {
	return &c.Actions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsCloudwatchMetricsalarm) GetStateReason() *plugin.TValue[string] {
	return &c.StateReason
}

func (c *mqlAwsCloudwatchMetricsalarm) GetInsufficientDataActions() *plugin.TValue[[]interface{}] {
	return &c.InsufficientDataActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetOkActions() *plugin.TValue[[]interface{}] {
	return &c.OkActions
}

func (c *mqlAwsCloudwatchMetricsalarm) GetName() *plugin.TValue[string] {
	return &c.Name
}

// mqlAwsCloudwatchMetric for the aws.cloudwatch.metric resource
type mqlAwsCloudwatchMetric struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricInternal it will be used here
	Name plugin.TValue[string]
	Namespace plugin.TValue[string]
	Region plugin.TValue[string]
	Alarms plugin.TValue[[]interface{}]
	Dimensions plugin.TValue[[]interface{}]
	Statistics plugin.TValue[*mqlAwsCloudwatchMetricstatistics]
}

// createAwsCloudwatchMetric creates a new instance of this resource
func createAwsCloudwatchMetric(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetric{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetric) MqlName() string {
	return "aws.cloudwatch.metric"
}

func (c *mqlAwsCloudwatchMetric) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetric) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetric) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetric) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetric) GetAlarms() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Alarms, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "alarms")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.alarms()
	})
}

func (c *mqlAwsCloudwatchMetric) GetDimensions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Dimensions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "dimensions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dimensions()
	})
}

func (c *mqlAwsCloudwatchMetric) GetStatistics() *plugin.TValue[*mqlAwsCloudwatchMetricstatistics] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchMetricstatistics](&c.Statistics, func() (*mqlAwsCloudwatchMetricstatistics, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.metric", c.__id, "statistics")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchMetricstatistics), nil
			}
		}

		return c.statistics()
	})
}

// mqlAwsCloudwatchMetricdimension for the aws.cloudwatch.metricdimension resource
type mqlAwsCloudwatchMetricdimension struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricdimensionInternal it will be used here
	Name plugin.TValue[string]
	Value plugin.TValue[string]
}

// createAwsCloudwatchMetricdimension creates a new instance of this resource
func createAwsCloudwatchMetricdimension(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricdimension{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricdimension", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricdimension) MqlName() string {
	return "aws.cloudwatch.metricdimension"
}

func (c *mqlAwsCloudwatchMetricdimension) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricdimension) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricdimension) GetValue() *plugin.TValue[string] {
	return &c.Value
}

// mqlAwsCloudwatchMetricstatistics for the aws.cloudwatch.metricstatistics resource
type mqlAwsCloudwatchMetricstatistics struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricstatisticsInternal it will be used here
	Namespace plugin.TValue[string]
	Name plugin.TValue[string]
	Region plugin.TValue[string]
	Label plugin.TValue[string]
	Datapoints plugin.TValue[[]interface{}]
}

// createAwsCloudwatchMetricstatistics creates a new instance of this resource
func createAwsCloudwatchMetricstatistics(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricstatistics{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metricstatistics", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlName() string {
	return "aws.cloudwatch.metricstatistics"
}

func (c *mqlAwsCloudwatchMetricstatistics) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricstatistics) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsCloudwatchMetricstatistics) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchMetricstatistics) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsCloudwatchMetricstatistics) GetLabel() *plugin.TValue[string] {
	return &c.Label
}

func (c *mqlAwsCloudwatchMetricstatistics) GetDatapoints() *plugin.TValue[[]interface{}] {
	return &c.Datapoints
}

// mqlAwsCloudwatchMetricDatapoint for the aws.cloudwatch.metric.datapoint resource
type mqlAwsCloudwatchMetricDatapoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchMetricDatapointInternal it will be used here
	Id plugin.TValue[string]
	Timestamp plugin.TValue[*time.Time]
	Maximum plugin.TValue[float64]
	Minimum plugin.TValue[float64]
	Average plugin.TValue[float64]
	Sum plugin.TValue[float64]
	Unit plugin.TValue[string]
}

// createAwsCloudwatchMetricDatapoint creates a new instance of this resource
func createAwsCloudwatchMetricDatapoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchMetricDatapoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.metric.datapoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlName() string {
	return "aws.cloudwatch.metric.datapoint"
}

func (c *mqlAwsCloudwatchMetricDatapoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetTimestamp() *plugin.TValue[*time.Time] {
	return &c.Timestamp
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMaximum() *plugin.TValue[float64] {
	return &c.Maximum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetMinimum() *plugin.TValue[float64] {
	return &c.Minimum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetAverage() *plugin.TValue[float64] {
	return &c.Average
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetSum() *plugin.TValue[float64] {
	return &c.Sum
}

func (c *mqlAwsCloudwatchMetricDatapoint) GetUnit() *plugin.TValue[string] {
	return &c.Unit
}

// mqlAwsCloudwatchLoggroup for the aws.cloudwatch.loggroup resource
type mqlAwsCloudwatchLoggroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	MetricsFilters plugin.TValue[[]interface{}]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	Region plugin.TValue[string]
}

// createAwsCloudwatchLoggroup creates a new instance of this resource
func createAwsCloudwatchLoggroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroup) MqlName() string {
	return "aws.cloudwatch.loggroup"
}

func (c *mqlAwsCloudwatchLoggroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudwatchLoggroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudwatchLoggroup) GetMetricsFilters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.MetricsFilters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "metricsFilters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.metricsFilters()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudwatch.loggroup", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudwatchLoggroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsCloudwatchLoggroupMetricsfilter for the aws.cloudwatch.loggroup.metricsfilter resource
type mqlAwsCloudwatchLoggroupMetricsfilter struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudwatchLoggroupMetricsfilterInternal it will be used here
	Id plugin.TValue[string]
	FilterName plugin.TValue[string]
	FilterPattern plugin.TValue[string]
	Metrics plugin.TValue[[]interface{}]
}

// createAwsCloudwatchLoggroupMetricsfilter creates a new instance of this resource
func createAwsCloudwatchLoggroupMetricsfilter(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudwatchLoggroupMetricsfilter{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudwatch.loggroup.metricsfilter", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlName() string {
	return "aws.cloudwatch.loggroup.metricsfilter"
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterName() *plugin.TValue[string] {
	return &c.FilterName
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetFilterPattern() *plugin.TValue[string] {
	return &c.FilterPattern
}

func (c *mqlAwsCloudwatchLoggroupMetricsfilter) GetMetrics() *plugin.TValue[[]interface{}] {
	return &c.Metrics
}

// mqlAwsCloudfront for the aws.cloudfront resource
type mqlAwsCloudfront struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontInternal it will be used here
	Distributions plugin.TValue[[]interface{}]
	Functions plugin.TValue[[]interface{}]
}

// createAwsCloudfront creates a new instance of this resource
func createAwsCloudfront(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfront{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfront) MqlName() string {
	return "aws.cloudfront"
}

func (c *mqlAwsCloudfront) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfront) GetDistributions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Distributions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "distributions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.distributions()
	})
}

func (c *mqlAwsCloudfront) GetFunctions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Functions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudfront", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsCloudfrontDistribution for the aws.cloudfront.distribution resource
type mqlAwsCloudfrontDistribution struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontDistributionInternal it will be used here
	Arn plugin.TValue[string]
	Status plugin.TValue[string]
	DomainName plugin.TValue[string]
	Origins plugin.TValue[[]interface{}]
	DefaultCacheBehavior plugin.TValue[interface{}]
	CacheBehaviors plugin.TValue[[]interface{}]
	HttpVersion plugin.TValue[string]
	IsIPV6Enabled plugin.TValue[bool]
	Enabled plugin.TValue[bool]
	PriceClass plugin.TValue[string]
}

// createAwsCloudfrontDistribution creates a new instance of this resource
func createAwsCloudfrontDistribution(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistribution{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistribution) MqlName() string {
	return "aws.cloudfront.distribution"
}

func (c *mqlAwsCloudfrontDistribution) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistribution) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontDistribution) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontDistribution) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistribution) GetOrigins() *plugin.TValue[[]interface{}] {
	return &c.Origins
}

func (c *mqlAwsCloudfrontDistribution) GetDefaultCacheBehavior() *plugin.TValue[interface{}] {
	return &c.DefaultCacheBehavior
}

func (c *mqlAwsCloudfrontDistribution) GetCacheBehaviors() *plugin.TValue[[]interface{}] {
	return &c.CacheBehaviors
}

func (c *mqlAwsCloudfrontDistribution) GetHttpVersion() *plugin.TValue[string] {
	return &c.HttpVersion
}

func (c *mqlAwsCloudfrontDistribution) GetIsIPV6Enabled() *plugin.TValue[bool] {
	return &c.IsIPV6Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetEnabled() *plugin.TValue[bool] {
	return &c.Enabled
}

func (c *mqlAwsCloudfrontDistribution) GetPriceClass() *plugin.TValue[string] {
	return &c.PriceClass
}

// mqlAwsCloudfrontDistributionOrigin for the aws.cloudfront.distribution.origin resource
type mqlAwsCloudfrontDistributionOrigin struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontDistributionOriginInternal it will be used here
	DomainName plugin.TValue[string]
	Id plugin.TValue[string]
	ConnectionAttempts plugin.TValue[int64]
	ConnectionTimeout plugin.TValue[int64]
	OriginPath plugin.TValue[string]
	Account plugin.TValue[string]
}

// createAwsCloudfrontDistributionOrigin creates a new instance of this resource
func createAwsCloudfrontDistributionOrigin(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontDistributionOrigin{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.distribution.origin", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlName() string {
	return "aws.cloudfront.distribution.origin"
}

func (c *mqlAwsCloudfrontDistributionOrigin) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetDomainName() *plugin.TValue[string] {
	return &c.DomainName
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionAttempts() *plugin.TValue[int64] {
	return &c.ConnectionAttempts
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetConnectionTimeout() *plugin.TValue[int64] {
	return &c.ConnectionTimeout
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetOriginPath() *plugin.TValue[string] {
	return &c.OriginPath
}

func (c *mqlAwsCloudfrontDistributionOrigin) GetAccount() *plugin.TValue[string] {
	return &c.Account
}

// mqlAwsCloudfrontFunction for the aws.cloudfront.function resource
type mqlAwsCloudfrontFunction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudfrontFunctionInternal it will be used here
	Name plugin.TValue[string]
	Status plugin.TValue[string]
	Arn plugin.TValue[string]
	LastModifiedTime plugin.TValue[*time.Time]
	CreatedTime plugin.TValue[*time.Time]
	Stage plugin.TValue[string]
	Comment plugin.TValue[string]
	Runtime plugin.TValue[string]
}

// createAwsCloudfrontFunction creates a new instance of this resource
func createAwsCloudfrontFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudfrontFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudfront.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudfrontFunction) MqlName() string {
	return "aws.cloudfront.function"
}

func (c *mqlAwsCloudfrontFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudfrontFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudfrontFunction) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsCloudfrontFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudfrontFunction) GetLastModifiedTime() *plugin.TValue[*time.Time] {
	return &c.LastModifiedTime
}

func (c *mqlAwsCloudfrontFunction) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

func (c *mqlAwsCloudfrontFunction) GetStage() *plugin.TValue[string] {
	return &c.Stage
}

func (c *mqlAwsCloudfrontFunction) GetComment() *plugin.TValue[string] {
	return &c.Comment
}

func (c *mqlAwsCloudfrontFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

// mqlAwsCloudtrail for the aws.cloudtrail resource
type mqlAwsCloudtrail struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudtrailInternal it will be used here
	Trails plugin.TValue[[]interface{}]
}

// createAwsCloudtrail creates a new instance of this resource
func createAwsCloudtrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrail) MqlName() string {
	return "aws.cloudtrail"
}

func (c *mqlAwsCloudtrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrail) GetTrails() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Trails, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail", c.__id, "trails")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.trails()
	})
}

// mqlAwsCloudtrailTrail for the aws.cloudtrail.trail resource
type mqlAwsCloudtrailTrail struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsCloudtrailTrailInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	KmsKey plugin.TValue[*mqlAwsKmsKey]
	IsMultiRegionTrail plugin.TValue[bool]
	IsOrganizationTrail plugin.TValue[bool]
	LogFileValidationEnabled plugin.TValue[bool]
	IncludeGlobalServiceEvents plugin.TValue[bool]
	S3bucket plugin.TValue[*mqlAwsS3Bucket]
	SnsTopicARN plugin.TValue[string]
	Status plugin.TValue[interface{}]
	LogGroup plugin.TValue[*mqlAwsCloudwatchLoggroup]
	CloudWatchLogsRoleArn plugin.TValue[string]
	EventSelectors plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
}

// createAwsCloudtrailTrail creates a new instance of this resource
func createAwsCloudtrailTrail(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsCloudtrailTrail{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.cloudtrail.trail", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsCloudtrailTrail) MqlName() string {
	return "aws.cloudtrail.trail"
}

func (c *mqlAwsCloudtrailTrail) MqlID() string {
	return c.__id
}

func (c *mqlAwsCloudtrailTrail) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsCloudtrailTrail) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsCloudtrailTrail) GetKmsKey() *plugin.TValue[*mqlAwsKmsKey] {
	return plugin.GetOrCompute[*mqlAwsKmsKey](&c.KmsKey, func() (*mqlAwsKmsKey, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "kmsKey")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsKmsKey), nil
			}
		}

		return c.kmsKey()
	})
}

func (c *mqlAwsCloudtrailTrail) GetIsMultiRegionTrail() *plugin.TValue[bool] {
	return &c.IsMultiRegionTrail
}

func (c *mqlAwsCloudtrailTrail) GetIsOrganizationTrail() *plugin.TValue[bool] {
	return &c.IsOrganizationTrail
}

func (c *mqlAwsCloudtrailTrail) GetLogFileValidationEnabled() *plugin.TValue[bool] {
	return &c.LogFileValidationEnabled
}

func (c *mqlAwsCloudtrailTrail) GetIncludeGlobalServiceEvents() *plugin.TValue[bool] {
	return &c.IncludeGlobalServiceEvents
}

func (c *mqlAwsCloudtrailTrail) GetS3bucket() *plugin.TValue[*mqlAwsS3Bucket] {
	return plugin.GetOrCompute[*mqlAwsS3Bucket](&c.S3bucket, func() (*mqlAwsS3Bucket, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "s3bucket")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3Bucket), nil
			}
		}

		return c.s3bucket()
	})
}

func (c *mqlAwsCloudtrailTrail) GetSnsTopicARN() *plugin.TValue[string] {
	return &c.SnsTopicARN
}

func (c *mqlAwsCloudtrailTrail) GetStatus() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Status, func() (interface{}, error) {
		return c.status()
	})
}

func (c *mqlAwsCloudtrailTrail) GetLogGroup() *plugin.TValue[*mqlAwsCloudwatchLoggroup] {
	return plugin.GetOrCompute[*mqlAwsCloudwatchLoggroup](&c.LogGroup, func() (*mqlAwsCloudwatchLoggroup, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.cloudtrail.trail", c.__id, "logGroup")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsCloudwatchLoggroup), nil
			}
		}

		return c.logGroup()
	})
}

func (c *mqlAwsCloudtrailTrail) GetCloudWatchLogsRoleArn() *plugin.TValue[string] {
	return &c.CloudWatchLogsRoleArn
}

func (c *mqlAwsCloudtrailTrail) GetEventSelectors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.EventSelectors, func() ([]interface{}, error) {
		return c.eventSelectors()
	})
}

func (c *mqlAwsCloudtrailTrail) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsS3control for the aws.s3control resource
type mqlAwsS3control struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3controlInternal it will be used here
	AccountPublicAccessBlock plugin.TValue[interface{}]
}

// createAwsS3control creates a new instance of this resource
func createAwsS3control(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3control{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3control", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3control) MqlName() string {
	return "aws.s3control"
}

func (c *mqlAwsS3control) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3control) GetAccountPublicAccessBlock() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.AccountPublicAccessBlock, func() (interface{}, error) {
		return c.accountPublicAccessBlock()
	})
}

// mqlAwsS3 for the aws.s3 resource
type mqlAwsS3 struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3Internal it will be used here
	Buckets plugin.TValue[[]interface{}]
}

// createAwsS3 creates a new instance of this resource
func createAwsS3(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3) MqlName() string {
	return "aws.s3"
}

func (c *mqlAwsS3) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3) GetBuckets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Buckets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3", c.__id, "buckets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.buckets()
	})
}

// mqlAwsS3Bucket for the aws.s3.bucket resource
type mqlAwsS3Bucket struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Policy plugin.TValue[*mqlAwsS3BucketPolicy]
	Tags plugin.TValue[map[string]interface{}]
	Acl plugin.TValue[[]interface{}]
	Owner plugin.TValue[map[string]interface{}]
	Public plugin.TValue[bool]
	Cors plugin.TValue[[]interface{}]
	Location plugin.TValue[string]
	Versioning plugin.TValue[map[string]interface{}]
	Logging plugin.TValue[map[string]interface{}]
	StaticWebsiteHosting plugin.TValue[map[string]interface{}]
	DefaultLock plugin.TValue[string]
	Replication plugin.TValue[interface{}]
	Encryption plugin.TValue[interface{}]
	PublicAccessBlock plugin.TValue[interface{}]
	Exists plugin.TValue[bool]
	CreatedTime plugin.TValue[*time.Time]
}

// createAwsS3Bucket creates a new instance of this resource
func createAwsS3Bucket(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3Bucket{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3Bucket) MqlName() string {
	return "aws.s3.bucket"
}

func (c *mqlAwsS3Bucket) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3Bucket) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsS3Bucket) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3Bucket) GetPolicy() *plugin.TValue[*mqlAwsS3BucketPolicy] {
	return plugin.GetOrCompute[*mqlAwsS3BucketPolicy](&c.Policy, func() (*mqlAwsS3BucketPolicy, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "policy")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsS3BucketPolicy), nil
			}
		}

		return c.policy()
	})
}

func (c *mqlAwsS3Bucket) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

func (c *mqlAwsS3Bucket) GetAcl() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Acl, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "acl")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.acl()
	})
}

func (c *mqlAwsS3Bucket) GetOwner() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Owner, func() (map[string]interface{}, error) {
		return c.owner()
	})
}

func (c *mqlAwsS3Bucket) GetPublic() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.Public, func() (bool, error) {
		return c.public()
	})
}

func (c *mqlAwsS3Bucket) GetCors() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Cors, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.s3.bucket", c.__id, "cors")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.cors()
	})
}

func (c *mqlAwsS3Bucket) GetLocation() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Location, func() (string, error) {
		return c.location()
	})
}

func (c *mqlAwsS3Bucket) GetVersioning() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Versioning, func() (map[string]interface{}, error) {
		return c.versioning()
	})
}

func (c *mqlAwsS3Bucket) GetLogging() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Logging, func() (map[string]interface{}, error) {
		return c.logging()
	})
}

func (c *mqlAwsS3Bucket) GetStaticWebsiteHosting() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.StaticWebsiteHosting, func() (map[string]interface{}, error) {
		return c.staticWebsiteHosting()
	})
}

func (c *mqlAwsS3Bucket) GetDefaultLock() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.DefaultLock, func() (string, error) {
		return c.defaultLock()
	})
}

func (c *mqlAwsS3Bucket) GetReplication() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Replication, func() (interface{}, error) {
		return c.replication()
	})
}

func (c *mqlAwsS3Bucket) GetEncryption() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Encryption, func() (interface{}, error) {
		return c.encryption()
	})
}

func (c *mqlAwsS3Bucket) GetPublicAccessBlock() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.PublicAccessBlock, func() (interface{}, error) {
		return c.publicAccessBlock()
	})
}

func (c *mqlAwsS3Bucket) GetExists() *plugin.TValue[bool] {
	return &c.Exists
}

func (c *mqlAwsS3Bucket) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

// mqlAwsS3BucketGrant for the aws.s3.bucket.grant resource
type mqlAwsS3BucketGrant struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketGrantInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Permission plugin.TValue[string]
	Grantee plugin.TValue[map[string]interface{}]
}

// createAwsS3BucketGrant creates a new instance of this resource
func createAwsS3BucketGrant(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketGrant{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.grant", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketGrant) MqlName() string {
	return "aws.s3.bucket.grant"
}

func (c *mqlAwsS3BucketGrant) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketGrant) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketGrant) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketGrant) GetPermission() *plugin.TValue[string] {
	return &c.Permission
}

func (c *mqlAwsS3BucketGrant) GetGrantee() *plugin.TValue[map[string]interface{}] {
	return &c.Grantee
}

// mqlAwsS3BucketCorsrule for the aws.s3.bucket.corsrule resource
type mqlAwsS3BucketCorsrule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketCorsruleInternal it will be used here
	Name plugin.TValue[string]
	AllowedHeaders plugin.TValue[[]interface{}]
	AllowedMethods plugin.TValue[[]interface{}]
	AllowedOrigins plugin.TValue[[]interface{}]
	ExposeHeaders plugin.TValue[[]interface{}]
	MaxAgeSeconds plugin.TValue[int64]
}

// createAwsS3BucketCorsrule creates a new instance of this resource
func createAwsS3BucketCorsrule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketCorsrule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.corsrule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketCorsrule) MqlName() string {
	return "aws.s3.bucket.corsrule"
}

func (c *mqlAwsS3BucketCorsrule) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketCorsrule) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedHeaders() *plugin.TValue[[]interface{}] {
	return &c.AllowedHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedMethods() *plugin.TValue[[]interface{}] {
	return &c.AllowedMethods
}

func (c *mqlAwsS3BucketCorsrule) GetAllowedOrigins() *plugin.TValue[[]interface{}] {
	return &c.AllowedOrigins
}

func (c *mqlAwsS3BucketCorsrule) GetExposeHeaders() *plugin.TValue[[]interface{}] {
	return &c.ExposeHeaders
}

func (c *mqlAwsS3BucketCorsrule) GetMaxAgeSeconds() *plugin.TValue[int64] {
	return &c.MaxAgeSeconds
}

// mqlAwsS3BucketPolicy for the aws.s3.bucket.policy resource
type mqlAwsS3BucketPolicy struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsS3BucketPolicyInternal it will be used here
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Document plugin.TValue[string]
	Version plugin.TValue[string]
	Statements plugin.TValue[[]interface{}]
}

// createAwsS3BucketPolicy creates a new instance of this resource
func createAwsS3BucketPolicy(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsS3BucketPolicy{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.s3.bucket.policy", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsS3BucketPolicy) MqlName() string {
	return "aws.s3.bucket.policy"
}

func (c *mqlAwsS3BucketPolicy) MqlID() string {
	return c.__id
}

func (c *mqlAwsS3BucketPolicy) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsS3BucketPolicy) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsS3BucketPolicy) GetDocument() *plugin.TValue[string] {
	return &c.Document
}

func (c *mqlAwsS3BucketPolicy) GetVersion() *plugin.TValue[string] {
	return plugin.GetOrCompute[string](&c.Version, func() (string, error) {
		return c.version()
	})
}

func (c *mqlAwsS3BucketPolicy) GetStatements() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Statements, func() ([]interface{}, error) {
		return c.statements()
	})
}

// mqlAwsApplicationAutoscaling for the aws.applicationAutoscaling resource
type mqlAwsApplicationAutoscaling struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApplicationAutoscalingInternal it will be used here
	Namespace plugin.TValue[string]
	ScalableTargets plugin.TValue[[]interface{}]
}

// createAwsApplicationAutoscaling creates a new instance of this resource
func createAwsApplicationAutoscaling(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationAutoscaling{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationAutoscaling", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationAutoscaling) MqlName() string {
	return "aws.applicationAutoscaling"
}

func (c *mqlAwsApplicationAutoscaling) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationAutoscaling) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationAutoscaling) GetScalableTargets() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ScalableTargets, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.applicationAutoscaling", c.__id, "scalableTargets")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.scalableTargets()
	})
}

// mqlAwsApplicationautoscalingTarget for the aws.applicationautoscaling.target resource
type mqlAwsApplicationautoscalingTarget struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApplicationautoscalingTargetInternal it will be used here
	Namespace plugin.TValue[string]
	Arn plugin.TValue[string]
	ScalableDimension plugin.TValue[string]
	MinCapacity plugin.TValue[int64]
	MaxCapacity plugin.TValue[int64]
	SuspendedState plugin.TValue[interface{}]
}

// createAwsApplicationautoscalingTarget creates a new instance of this resource
func createAwsApplicationautoscalingTarget(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApplicationautoscalingTarget{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.applicationautoscaling.target", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApplicationautoscalingTarget) MqlName() string {
	return "aws.applicationautoscaling.target"
}

func (c *mqlAwsApplicationautoscalingTarget) MqlID() string {
	return c.__id
}

func (c *mqlAwsApplicationautoscalingTarget) GetNamespace() *plugin.TValue[string] {
	return &c.Namespace
}

func (c *mqlAwsApplicationautoscalingTarget) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApplicationautoscalingTarget) GetScalableDimension() *plugin.TValue[string] {
	return &c.ScalableDimension
}

func (c *mqlAwsApplicationautoscalingTarget) GetMinCapacity() *plugin.TValue[int64] {
	return &c.MinCapacity
}

func (c *mqlAwsApplicationautoscalingTarget) GetMaxCapacity() *plugin.TValue[int64] {
	return &c.MaxCapacity
}

func (c *mqlAwsApplicationautoscalingTarget) GetSuspendedState() *plugin.TValue[interface{}] {
	return &c.SuspendedState
}

// mqlAwsBackup for the aws.backup resource
type mqlAwsBackup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupInternal it will be used here
	Vaults plugin.TValue[[]interface{}]
}

// createAwsBackup creates a new instance of this resource
func createAwsBackup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackup) MqlName() string {
	return "aws.backup"
}

func (c *mqlAwsBackup) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackup) GetVaults() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Vaults, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup", c.__id, "vaults")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vaults()
	})
}

// mqlAwsBackupVault for the aws.backup.vault resource
type mqlAwsBackupVault struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupVaultInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	RecoveryPoints plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	CreatedAt plugin.TValue[*time.Time]
	Locked plugin.TValue[bool]
	EncryptionKeyArn plugin.TValue[string]
}

// createAwsBackupVault creates a new instance of this resource
func createAwsBackupVault(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVault{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vault", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVault) MqlName() string {
	return "aws.backup.vault"
}

func (c *mqlAwsBackupVault) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVault) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVault) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsBackupVault) GetRecoveryPoints() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RecoveryPoints, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.backup.vault", c.__id, "recoveryPoints")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.recoveryPoints()
	})
}

func (c *mqlAwsBackupVault) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsBackupVault) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}

func (c *mqlAwsBackupVault) GetLocked() *plugin.TValue[bool] {
	return &c.Locked
}

func (c *mqlAwsBackupVault) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

// mqlAwsBackupVaultRecoveryPoint for the aws.backup.vaultRecoveryPoint resource
type mqlAwsBackupVaultRecoveryPoint struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsBackupVaultRecoveryPointInternal it will be used here
	Arn plugin.TValue[string]
	ResourceType plugin.TValue[string]
	CreatedBy plugin.TValue[interface{}]
	IamRoleArn plugin.TValue[string]
	Status plugin.TValue[string]
	CreationDate plugin.TValue[*time.Time]
	CompletionDate plugin.TValue[*time.Time]
	EncryptionKeyArn plugin.TValue[string]
	IsEncrypted plugin.TValue[bool]
}

// createAwsBackupVaultRecoveryPoint creates a new instance of this resource
func createAwsBackupVaultRecoveryPoint(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsBackupVaultRecoveryPoint{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.backup.vaultRecoveryPoint", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlName() string {
	return "aws.backup.vaultRecoveryPoint"
}

func (c *mqlAwsBackupVaultRecoveryPoint) MqlID() string {
	return c.__id
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetResourceType() *plugin.TValue[string] {
	return &c.ResourceType
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreatedBy() *plugin.TValue[interface{}] {
	return &c.CreatedBy
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIamRoleArn() *plugin.TValue[string] {
	return &c.IamRoleArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCreationDate() *plugin.TValue[*time.Time] {
	return &c.CreationDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetCompletionDate() *plugin.TValue[*time.Time] {
	return &c.CompletionDate
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetEncryptionKeyArn() *plugin.TValue[string] {
	return &c.EncryptionKeyArn
}

func (c *mqlAwsBackupVaultRecoveryPoint) GetIsEncrypted() *plugin.TValue[bool] {
	return &c.IsEncrypted
}

// mqlAwsDynamodb for the aws.dynamodb resource
type mqlAwsDynamodb struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbInternal it will be used here
	Backups plugin.TValue[[]interface{}]
	GlobalTables plugin.TValue[[]interface{}]
	Tables plugin.TValue[[]interface{}]
	Limits plugin.TValue[[]interface{}]
}

// createAwsDynamodb creates a new instance of this resource
func createAwsDynamodb(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodb{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodb) MqlName() string {
	return "aws.dynamodb"
}

func (c *mqlAwsDynamodb) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodb) GetBackups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Backups, func() ([]interface{}, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodb) GetGlobalTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.GlobalTables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "globalTables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.globalTables()
	})
}

func (c *mqlAwsDynamodb) GetTables() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Tables, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "tables")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.tables()
	})
}

func (c *mqlAwsDynamodb) GetLimits() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Limits, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.dynamodb", c.__id, "limits")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.limits()
	})
}

// mqlAwsDynamodbLimit for the aws.dynamodb.limit resource
type mqlAwsDynamodbLimit struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbLimitInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	AccountMaxRead plugin.TValue[int64]
	AccountMaxWrite plugin.TValue[int64]
	TableMaxRead plugin.TValue[int64]
	TableMaxWrite plugin.TValue[int64]
}

// createAwsDynamodbLimit creates a new instance of this resource
func createAwsDynamodbLimit(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbLimit{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.limit", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbLimit) MqlName() string {
	return "aws.dynamodb.limit"
}

func (c *mqlAwsDynamodbLimit) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbLimit) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbLimit) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxRead() *plugin.TValue[int64] {
	return &c.AccountMaxRead
}

func (c *mqlAwsDynamodbLimit) GetAccountMaxWrite() *plugin.TValue[int64] {
	return &c.AccountMaxWrite
}

func (c *mqlAwsDynamodbLimit) GetTableMaxRead() *plugin.TValue[int64] {
	return &c.TableMaxRead
}

func (c *mqlAwsDynamodbLimit) GetTableMaxWrite() *plugin.TValue[int64] {
	return &c.TableMaxWrite
}

// mqlAwsDynamodbGlobaltable for the aws.dynamodb.globaltable resource
type mqlAwsDynamodbGlobaltable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbGlobaltableInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	ReplicaSettings plugin.TValue[[]interface{}]
}

// createAwsDynamodbGlobaltable creates a new instance of this resource
func createAwsDynamodbGlobaltable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbGlobaltable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.globaltable", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbGlobaltable) MqlName() string {
	return "aws.dynamodb.globaltable"
}

func (c *mqlAwsDynamodbGlobaltable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbGlobaltable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbGlobaltable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbGlobaltable) GetReplicaSettings() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ReplicaSettings, func() ([]interface{}, error) {
		return c.replicaSettings()
	})
}

// mqlAwsDynamodbTable for the aws.dynamodb.table resource
type mqlAwsDynamodbTable struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDynamodbTableInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Region plugin.TValue[string]
	Backups plugin.TValue[[]interface{}]
	SseDescription plugin.TValue[interface{}]
	ProvisionedThroughput plugin.TValue[interface{}]
	ContinuousBackups plugin.TValue[interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsDynamodbTable creates a new instance of this resource
func createAwsDynamodbTable(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDynamodbTable{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dynamodb.table", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDynamodbTable) MqlName() string {
	return "aws.dynamodb.table"
}

func (c *mqlAwsDynamodbTable) MqlID() string {
	return c.__id
}

func (c *mqlAwsDynamodbTable) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsDynamodbTable) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsDynamodbTable) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsDynamodbTable) GetBackups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Backups, func() ([]interface{}, error) {
		return c.backups()
	})
}

func (c *mqlAwsDynamodbTable) GetSseDescription() *plugin.TValue[interface{}] {
	return &c.SseDescription
}

func (c *mqlAwsDynamodbTable) GetProvisionedThroughput() *plugin.TValue[interface{}] {
	return &c.ProvisionedThroughput
}

func (c *mqlAwsDynamodbTable) GetContinuousBackups() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.ContinuousBackups, func() (interface{}, error) {
		return c.continuousBackups()
	})
}

func (c *mqlAwsDynamodbTable) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsRds for the aws.rds resource
type mqlAwsRds struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsInternal it will be used here
	DbInstances plugin.TValue[[]interface{}]
	DbClusters plugin.TValue[[]interface{}]
}

// createAwsRds creates a new instance of this resource
func createAwsRds(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRds{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRds) MqlName() string {
	return "aws.rds"
}

func (c *mqlAwsRds) MqlID() string {
	return c.__id
}

func (c *mqlAwsRds) GetDbInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DbInstances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "dbInstances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dbInstances()
	})
}

func (c *mqlAwsRds) GetDbClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.DbClusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds", c.__id, "dbClusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.dbClusters()
	})
}

// mqlAwsRdsDbcluster for the aws.rds.dbcluster resource
type mqlAwsRdsDbcluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsDbclusterInternal it will be used here
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Id plugin.TValue[string]
	Members plugin.TValue[[]interface{}]
	Snapshots plugin.TValue[[]interface{}]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsRdsDbcluster creates a new instance of this resource
func createAwsRdsDbcluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbcluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbcluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbcluster) MqlName() string {
	return "aws.rds.dbcluster"
}

func (c *mqlAwsRdsDbcluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbcluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbcluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbcluster) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbcluster) GetMembers() *plugin.TValue[[]interface{}] {
	return &c.Members
}

func (c *mqlAwsRdsDbcluster) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbcluster", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbcluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsRdsSnapshot for the aws.rds.snapshot resource
type mqlAwsRdsSnapshot struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsSnapshotInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attributes plugin.TValue[[]interface{}]
	Type plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	Region plugin.TValue[string]
	IsClusterSnapshot plugin.TValue[bool]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsRdsSnapshot creates a new instance of this resource
func createAwsRdsSnapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsSnapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsSnapshot) MqlName() string {
	return "aws.rds.snapshot"
}

func (c *mqlAwsRdsSnapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsSnapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsSnapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsSnapshot) GetAttributes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Attributes, func() ([]interface{}, error) {
		return c.attributes()
	})
}

func (c *mqlAwsRdsSnapshot) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsRdsSnapshot) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRdsSnapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsSnapshot) GetIsClusterSnapshot() *plugin.TValue[bool] {
	return &c.IsClusterSnapshot
}

func (c *mqlAwsRdsSnapshot) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsRdsDbinstance for the aws.rds.dbinstance resource
type mqlAwsRdsDbinstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRdsDbinstanceInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	BackupRetentionPeriod plugin.TValue[int64]
	Snapshots plugin.TValue[[]interface{}]
	StorageEncrypted plugin.TValue[bool]
	StorageAllocated plugin.TValue[int64]
	StorageIops plugin.TValue[int64]
	StorageType plugin.TValue[string]
	Region plugin.TValue[string]
	AvailabilityZone plugin.TValue[string]
	PubliclyAccessible plugin.TValue[bool]
	EnabledCloudwatchLogsExports plugin.TValue[[]interface{}]
	DeletionProtection plugin.TValue[bool]
	MultiAZ plugin.TValue[bool]
	Id plugin.TValue[string]
	EnhancedMonitoringResourceArn plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	DbInstanceClass plugin.TValue[string]
	DbInstanceIdentifier plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	Status plugin.TValue[string]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	CreatedTime plugin.TValue[*time.Time]
}

// createAwsRdsDbinstance creates a new instance of this resource
func createAwsRdsDbinstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRdsDbinstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.rds.dbinstance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRdsDbinstance) MqlName() string {
	return "aws.rds.dbinstance"
}

func (c *mqlAwsRdsDbinstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsRdsDbinstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRdsDbinstance) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRdsDbinstance) GetBackupRetentionPeriod() *plugin.TValue[int64] {
	return &c.BackupRetentionPeriod
}

func (c *mqlAwsRdsDbinstance) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.rds.dbinstance", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsRdsDbinstance) GetStorageEncrypted() *plugin.TValue[bool] {
	return &c.StorageEncrypted
}

func (c *mqlAwsRdsDbinstance) GetStorageAllocated() *plugin.TValue[int64] {
	return &c.StorageAllocated
}

func (c *mqlAwsRdsDbinstance) GetStorageIops() *plugin.TValue[int64] {
	return &c.StorageIops
}

func (c *mqlAwsRdsDbinstance) GetStorageType() *plugin.TValue[string] {
	return &c.StorageType
}

func (c *mqlAwsRdsDbinstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRdsDbinstance) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRdsDbinstance) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRdsDbinstance) GetEnabledCloudwatchLogsExports() *plugin.TValue[[]interface{}] {
	return &c.EnabledCloudwatchLogsExports
}

func (c *mqlAwsRdsDbinstance) GetDeletionProtection() *plugin.TValue[bool] {
	return &c.DeletionProtection
}

func (c *mqlAwsRdsDbinstance) GetMultiAZ() *plugin.TValue[bool] {
	return &c.MultiAZ
}

func (c *mqlAwsRdsDbinstance) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsRdsDbinstance) GetEnhancedMonitoringResourceArn() *plugin.TValue[string] {
	return &c.EnhancedMonitoringResourceArn
}

func (c *mqlAwsRdsDbinstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceClass() *plugin.TValue[string] {
	return &c.DbInstanceClass
}

func (c *mqlAwsRdsDbinstance) GetDbInstanceIdentifier() *plugin.TValue[string] {
	return &c.DbInstanceIdentifier
}

func (c *mqlAwsRdsDbinstance) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsRdsDbinstance) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsRdsDbinstance) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.SecurityGroups
}

func (c *mqlAwsRdsDbinstance) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsRdsDbinstance) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsRdsDbinstance) GetCreatedTime() *plugin.TValue[*time.Time] {
	return &c.CreatedTime
}

// mqlAwsElasticache for the aws.elasticache resource
type mqlAwsElasticache struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElasticacheInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
	CacheClusters plugin.TValue[[]interface{}]
}

// createAwsElasticache creates a new instance of this resource
func createAwsElasticache(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticache{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticache) MqlName() string {
	return "aws.elasticache"
}

func (c *mqlAwsElasticache) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticache) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		return c.clusters()
	})
}

func (c *mqlAwsElasticache) GetCacheClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CacheClusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.elasticache", c.__id, "cacheClusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.cacheClusters()
	})
}

// mqlAwsElasticacheCluster for the aws.elasticache.cluster resource
type mqlAwsElasticacheCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsElasticacheClusterInternal it will be used here
	Arn plugin.TValue[string]
	AtRestEncryptionEnabled plugin.TValue[bool]
	AuthTokenEnabled plugin.TValue[bool]
	AuthTokenLastModifiedDate plugin.TValue[*time.Time]
	AutoMinorVersionUpgrade plugin.TValue[bool]
	CacheClusterCreateTime plugin.TValue[*time.Time]
	CacheClusterId plugin.TValue[string]
	CacheClusterStatus plugin.TValue[string]
	CacheNodeType plugin.TValue[string]
	CacheNodes plugin.TValue[[]interface{}]
	CacheSecurityGroups plugin.TValue[[]interface{}]
	CacheSubnetGroupName plugin.TValue[string]
	ClientDownloadLandingPage plugin.TValue[string]
	NodeType plugin.TValue[string]
	Engine plugin.TValue[string]
	EngineVersion plugin.TValue[string]
	IpDiscovery plugin.TValue[string]
	LogDeliveryConfigurations plugin.TValue[[]interface{}]
	NetworkType plugin.TValue[string]
	NotificationConfiguration plugin.TValue[string]
	NumCacheNodes plugin.TValue[int64]
	PreferredAvailabilityZone plugin.TValue[string]
	Region plugin.TValue[string]
	SecurityGroups plugin.TValue[[]interface{}]
	SnapshotRetentionLimit plugin.TValue[int64]
	TransitEncryptionEnabled plugin.TValue[bool]
	TransitEncryptionMode plugin.TValue[string]
}

// createAwsElasticacheCluster creates a new instance of this resource
func createAwsElasticacheCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsElasticacheCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.elasticache.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsElasticacheCluster) MqlName() string {
	return "aws.elasticache.cluster"
}

func (c *mqlAwsElasticacheCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsElasticacheCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsElasticacheCluster) GetAtRestEncryptionEnabled() *plugin.TValue[bool] {
	return &c.AtRestEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenEnabled() *plugin.TValue[bool] {
	return &c.AuthTokenEnabled
}

func (c *mqlAwsElasticacheCluster) GetAuthTokenLastModifiedDate() *plugin.TValue[*time.Time] {
	return &c.AuthTokenLastModifiedDate
}

func (c *mqlAwsElasticacheCluster) GetAutoMinorVersionUpgrade() *plugin.TValue[bool] {
	return &c.AutoMinorVersionUpgrade
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterCreateTime() *plugin.TValue[*time.Time] {
	return &c.CacheClusterCreateTime
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterId() *plugin.TValue[string] {
	return &c.CacheClusterId
}

func (c *mqlAwsElasticacheCluster) GetCacheClusterStatus() *plugin.TValue[string] {
	return &c.CacheClusterStatus
}

func (c *mqlAwsElasticacheCluster) GetCacheNodeType() *plugin.TValue[string] {
	return &c.CacheNodeType
}

func (c *mqlAwsElasticacheCluster) GetCacheNodes() *plugin.TValue[[]interface{}] {
	return &c.CacheNodes
}

func (c *mqlAwsElasticacheCluster) GetCacheSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.CacheSecurityGroups
}

func (c *mqlAwsElasticacheCluster) GetCacheSubnetGroupName() *plugin.TValue[string] {
	return &c.CacheSubnetGroupName
}

func (c *mqlAwsElasticacheCluster) GetClientDownloadLandingPage() *plugin.TValue[string] {
	return &c.ClientDownloadLandingPage
}

func (c *mqlAwsElasticacheCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsElasticacheCluster) GetEngine() *plugin.TValue[string] {
	return &c.Engine
}

func (c *mqlAwsElasticacheCluster) GetEngineVersion() *plugin.TValue[string] {
	return &c.EngineVersion
}

func (c *mqlAwsElasticacheCluster) GetIpDiscovery() *plugin.TValue[string] {
	return &c.IpDiscovery
}

func (c *mqlAwsElasticacheCluster) GetLogDeliveryConfigurations() *plugin.TValue[[]interface{}] {
	return &c.LogDeliveryConfigurations
}

func (c *mqlAwsElasticacheCluster) GetNetworkType() *plugin.TValue[string] {
	return &c.NetworkType
}

func (c *mqlAwsElasticacheCluster) GetNotificationConfiguration() *plugin.TValue[string] {
	return &c.NotificationConfiguration
}

func (c *mqlAwsElasticacheCluster) GetNumCacheNodes() *plugin.TValue[int64] {
	return &c.NumCacheNodes
}

func (c *mqlAwsElasticacheCluster) GetPreferredAvailabilityZone() *plugin.TValue[string] {
	return &c.PreferredAvailabilityZone
}

func (c *mqlAwsElasticacheCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsElasticacheCluster) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.SecurityGroups
}

func (c *mqlAwsElasticacheCluster) GetSnapshotRetentionLimit() *plugin.TValue[int64] {
	return &c.SnapshotRetentionLimit
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionEnabled() *plugin.TValue[bool] {
	return &c.TransitEncryptionEnabled
}

func (c *mqlAwsElasticacheCluster) GetTransitEncryptionMode() *plugin.TValue[string] {
	return &c.TransitEncryptionMode
}

// mqlAwsRedshift for the aws.redshift resource
type mqlAwsRedshift struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRedshiftInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsRedshift creates a new instance of this resource
func createAwsRedshift(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshift{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshift) MqlName() string {
	return "aws.redshift"
}

func (c *mqlAwsRedshift) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshift) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.redshift", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsRedshiftCluster for the aws.redshift.cluster resource
type mqlAwsRedshiftCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsRedshiftClusterInternal it will be used here
	AllowVersionUpgrade plugin.TValue[bool]
	Arn plugin.TValue[string]
	AutomatedSnapshotRetentionPeriod plugin.TValue[int64]
	AvailabilityZone plugin.TValue[string]
	ClusterParameterGroupNames plugin.TValue[[]interface{}]
	ClusterRevisionNumber plugin.TValue[string]
	ClusterStatus plugin.TValue[string]
	ClusterSubnetGroupName plugin.TValue[string]
	ClusterVersion plugin.TValue[string]
	CreatedAt plugin.TValue[string]
	DbName plugin.TValue[string]
	Encrypted plugin.TValue[bool]
	EnhancedVpcRouting plugin.TValue[bool]
	Logging plugin.TValue[interface{}]
	MasterUsername plugin.TValue[string]
	Name plugin.TValue[string]
	NextMaintenanceWindowStartTime plugin.TValue[*time.Time]
	NodeType plugin.TValue[string]
	NumberOfNodes plugin.TValue[int64]
	Parameters plugin.TValue[[]interface{}]
	PreferredMaintenanceWindow plugin.TValue[string]
	PubliclyAccessible plugin.TValue[bool]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	VpcId plugin.TValue[string]
}

// createAwsRedshiftCluster creates a new instance of this resource
func createAwsRedshiftCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsRedshiftCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.redshift.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsRedshiftCluster) MqlName() string {
	return "aws.redshift.cluster"
}

func (c *mqlAwsRedshiftCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsRedshiftCluster) GetAllowVersionUpgrade() *plugin.TValue[bool] {
	return &c.AllowVersionUpgrade
}

func (c *mqlAwsRedshiftCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsRedshiftCluster) GetAutomatedSnapshotRetentionPeriod() *plugin.TValue[int64] {
	return &c.AutomatedSnapshotRetentionPeriod
}

func (c *mqlAwsRedshiftCluster) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsRedshiftCluster) GetClusterParameterGroupNames() *plugin.TValue[[]interface{}] {
	return &c.ClusterParameterGroupNames
}

func (c *mqlAwsRedshiftCluster) GetClusterRevisionNumber() *plugin.TValue[string] {
	return &c.ClusterRevisionNumber
}

func (c *mqlAwsRedshiftCluster) GetClusterStatus() *plugin.TValue[string] {
	return &c.ClusterStatus
}

func (c *mqlAwsRedshiftCluster) GetClusterSubnetGroupName() *plugin.TValue[string] {
	return &c.ClusterSubnetGroupName
}

func (c *mqlAwsRedshiftCluster) GetClusterVersion() *plugin.TValue[string] {
	return &c.ClusterVersion
}

func (c *mqlAwsRedshiftCluster) GetCreatedAt() *plugin.TValue[string] {
	return &c.CreatedAt
}

func (c *mqlAwsRedshiftCluster) GetDbName() *plugin.TValue[string] {
	return &c.DbName
}

func (c *mqlAwsRedshiftCluster) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsRedshiftCluster) GetEnhancedVpcRouting() *plugin.TValue[bool] {
	return &c.EnhancedVpcRouting
}

func (c *mqlAwsRedshiftCluster) GetLogging() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Logging, func() (interface{}, error) {
		return c.logging()
	})
}

func (c *mqlAwsRedshiftCluster) GetMasterUsername() *plugin.TValue[string] {
	return &c.MasterUsername
}

func (c *mqlAwsRedshiftCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsRedshiftCluster) GetNextMaintenanceWindowStartTime() *plugin.TValue[*time.Time] {
	return &c.NextMaintenanceWindowStartTime
}

func (c *mqlAwsRedshiftCluster) GetNodeType() *plugin.TValue[string] {
	return &c.NodeType
}

func (c *mqlAwsRedshiftCluster) GetNumberOfNodes() *plugin.TValue[int64] {
	return &c.NumberOfNodes
}

func (c *mqlAwsRedshiftCluster) GetParameters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Parameters, func() ([]interface{}, error) {
		return c.parameters()
	})
}

func (c *mqlAwsRedshiftCluster) GetPreferredMaintenanceWindow() *plugin.TValue[string] {
	return &c.PreferredMaintenanceWindow
}

func (c *mqlAwsRedshiftCluster) GetPubliclyAccessible() *plugin.TValue[bool] {
	return &c.PubliclyAccessible
}

func (c *mqlAwsRedshiftCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsRedshiftCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsRedshiftCluster) GetVpcId() *plugin.TValue[string] {
	return &c.VpcId
}

// mqlAwsEcr for the aws.ecr resource
type mqlAwsEcr struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrInternal it will be used here
	PrivateRepositories plugin.TValue[[]interface{}]
	PublicRepositories plugin.TValue[[]interface{}]
	Images plugin.TValue[[]interface{}]
}

// createAwsEcr creates a new instance of this resource
func createAwsEcr(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcr{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcr) MqlName() string {
	return "aws.ecr"
}

func (c *mqlAwsEcr) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcr) GetPrivateRepositories() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PrivateRepositories, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "privateRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.privateRepositories()
	})
}

func (c *mqlAwsEcr) GetPublicRepositories() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.PublicRepositories, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "publicRepositories")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.publicRepositories()
	})
}

func (c *mqlAwsEcr) GetImages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Images, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.images()
	})
}

// mqlAwsEcrRepository for the aws.ecr.repository resource
type mqlAwsEcrRepository struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrRepositoryInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Uri plugin.TValue[string]
	RegistryId plugin.TValue[string]
	Public plugin.TValue[bool]
	Images plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	ImageScanOnPush plugin.TValue[bool]
}

// createAwsEcrRepository creates a new instance of this resource
func createAwsEcrRepository(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrRepository{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.repository", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrRepository) MqlName() string {
	return "aws.ecr.repository"
}

func (c *mqlAwsEcrRepository) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrRepository) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrRepository) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEcrRepository) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

func (c *mqlAwsEcrRepository) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrRepository) GetPublic() *plugin.TValue[bool] {
	return &c.Public
}

func (c *mqlAwsEcrRepository) GetImages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Images, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ecr.repository", c.__id, "images")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.images()
	})
}

func (c *mqlAwsEcrRepository) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrRepository) GetImageScanOnPush() *plugin.TValue[bool] {
	return &c.ImageScanOnPush
}

// mqlAwsEcrImage for the aws.ecr.image resource
type mqlAwsEcrImage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEcrImageInternal it will be used here
	Digest plugin.TValue[string]
	MediaType plugin.TValue[string]
	Tags plugin.TValue[[]interface{}]
	RegistryId plugin.TValue[string]
	RepoName plugin.TValue[string]
	Region plugin.TValue[string]
	Arn plugin.TValue[string]
	Uri plugin.TValue[string]
}

// createAwsEcrImage creates a new instance of this resource
func createAwsEcrImage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEcrImage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ecr.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEcrImage) MqlName() string {
	return "aws.ecr.image"
}

func (c *mqlAwsEcrImage) MqlID() string {
	return c.__id
}

func (c *mqlAwsEcrImage) GetDigest() *plugin.TValue[string] {
	return &c.Digest
}

func (c *mqlAwsEcrImage) GetMediaType() *plugin.TValue[string] {
	return &c.MediaType
}

func (c *mqlAwsEcrImage) GetTags() *plugin.TValue[[]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEcrImage) GetRegistryId() *plugin.TValue[string] {
	return &c.RegistryId
}

func (c *mqlAwsEcrImage) GetRepoName() *plugin.TValue[string] {
	return &c.RepoName
}

func (c *mqlAwsEcrImage) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEcrImage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEcrImage) GetUri() *plugin.TValue[string] {
	return &c.Uri
}

// mqlAwsDms for the aws.dms resource
type mqlAwsDms struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsDmsInternal it will be used here
	ReplicationInstances plugin.TValue[[]interface{}]
}

// createAwsDms creates a new instance of this resource
func createAwsDms(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsDms{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.dms", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsDms) MqlName() string {
	return "aws.dms"
}

func (c *mqlAwsDms) MqlID() string {
	return c.__id
}

func (c *mqlAwsDms) GetReplicationInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.ReplicationInstances, func() ([]interface{}, error) {
		return c.replicationInstances()
	})
}

// mqlAwsApigateway for the aws.apigateway resource
type mqlAwsApigateway struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayInternal it will be used here
	RestApis plugin.TValue[[]interface{}]
}

// createAwsApigateway creates a new instance of this resource
func createAwsApigateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigateway) MqlName() string {
	return "aws.apigateway"
}

func (c *mqlAwsApigateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigateway) GetRestApis() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.RestApis, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway", c.__id, "restApis")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.restApis()
	})
}

// mqlAwsApigatewayRestapi for the aws.apigateway.restapi resource
type mqlAwsApigatewayRestapi struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayRestapiInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	CreatedDate plugin.TValue[*time.Time]
	Description plugin.TValue[string]
	Stages plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsApigatewayRestapi creates a new instance of this resource
func createAwsApigatewayRestapi(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayRestapi{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.restapi", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayRestapi) MqlName() string {
	return "aws.apigateway.restapi"
}

func (c *mqlAwsApigatewayRestapi) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayRestapi) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayRestapi) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsApigatewayRestapi) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayRestapi) GetCreatedDate() *plugin.TValue[*time.Time] {
	return &c.CreatedDate
}

func (c *mqlAwsApigatewayRestapi) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayRestapi) GetStages() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Stages, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.apigateway.restapi", c.__id, "stages")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.stages()
	})
}

func (c *mqlAwsApigatewayRestapi) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsApigatewayRestapi) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsApigatewayStage for the aws.apigateway.stage resource
type mqlAwsApigatewayStage struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsApigatewayStageInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	TracingEnabled plugin.TValue[bool]
	Description plugin.TValue[string]
	DeploymentId plugin.TValue[string]
	MethodSettings plugin.TValue[interface{}]
}

// createAwsApigatewayStage creates a new instance of this resource
func createAwsApigatewayStage(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsApigatewayStage{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.apigateway.stage", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsApigatewayStage) MqlName() string {
	return "aws.apigateway.stage"
}

func (c *mqlAwsApigatewayStage) MqlID() string {
	return c.__id
}

func (c *mqlAwsApigatewayStage) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsApigatewayStage) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsApigatewayStage) GetTracingEnabled() *plugin.TValue[bool] {
	return &c.TracingEnabled
}

func (c *mqlAwsApigatewayStage) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsApigatewayStage) GetDeploymentId() *plugin.TValue[string] {
	return &c.DeploymentId
}

func (c *mqlAwsApigatewayStage) GetMethodSettings() *plugin.TValue[interface{}] {
	return &c.MethodSettings
}

// mqlAwsLambda for the aws.lambda resource
type mqlAwsLambda struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsLambdaInternal it will be used here
	Functions plugin.TValue[[]interface{}]
}

// createAwsLambda creates a new instance of this resource
func createAwsLambda(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambda{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambda) MqlName() string {
	return "aws.lambda"
}

func (c *mqlAwsLambda) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambda) GetFunctions() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Functions, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.lambda", c.__id, "functions")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.functions()
	})
}

// mqlAwsLambdaFunction for the aws.lambda.function resource
type mqlAwsLambdaFunction struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsLambdaFunctionInternal it will be used here
	Arn plugin.TValue[string]
	Name plugin.TValue[string]
	Runtime plugin.TValue[string]
	Concurrency plugin.TValue[int64]
	DlqTargetArn plugin.TValue[string]
	Policy plugin.TValue[interface{}]
	VpcConfig plugin.TValue[interface{}]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsLambdaFunction creates a new instance of this resource
func createAwsLambdaFunction(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsLambdaFunction{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.lambda.function", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsLambdaFunction) MqlName() string {
	return "aws.lambda.function"
}

func (c *mqlAwsLambdaFunction) MqlID() string {
	return c.__id
}

func (c *mqlAwsLambdaFunction) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsLambdaFunction) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsLambdaFunction) GetRuntime() *plugin.TValue[string] {
	return &c.Runtime
}

func (c *mqlAwsLambdaFunction) GetConcurrency() *plugin.TValue[int64] {
	return plugin.GetOrCompute[int64](&c.Concurrency, func() (int64, error) {
		return c.concurrency()
	})
}

func (c *mqlAwsLambdaFunction) GetDlqTargetArn() *plugin.TValue[string] {
	return &c.DlqTargetArn
}

func (c *mqlAwsLambdaFunction) GetPolicy() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Policy, func() (interface{}, error) {
		return c.policy()
	})
}

func (c *mqlAwsLambdaFunction) GetVpcConfig() *plugin.TValue[interface{}] {
	return &c.VpcConfig
}

func (c *mqlAwsLambdaFunction) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsLambdaFunction) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

// mqlAwsSsm for the aws.ssm resource
type mqlAwsSsm struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSsmInternal it will be used here
	Instances plugin.TValue[[]interface{}]
}

// createAwsSsm creates a new instance of this resource
func createAwsSsm(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsm{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsm) MqlName() string {
	return "aws.ssm"
}

func (c *mqlAwsSsm) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsm) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ssm", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

// mqlAwsSsmInstance for the aws.ssm.instance resource
type mqlAwsSsmInstance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsSsmInstanceInternal it will be used here
	InstanceId plugin.TValue[string]
	PingStatus plugin.TValue[string]
	IpAddress plugin.TValue[string]
	PlatformName plugin.TValue[string]
	Region plugin.TValue[string]
	Arn plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
}

// createAwsSsmInstance creates a new instance of this resource
func createAwsSsmInstance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsSsmInstance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ssm.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsSsmInstance) MqlName() string {
	return "aws.ssm.instance"
}

func (c *mqlAwsSsmInstance) MqlID() string {
	return c.__id
}

func (c *mqlAwsSsmInstance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsSsmInstance) GetPingStatus() *plugin.TValue[string] {
	return &c.PingStatus
}

func (c *mqlAwsSsmInstance) GetIpAddress() *plugin.TValue[string] {
	return &c.IpAddress
}

func (c *mqlAwsSsmInstance) GetPlatformName() *plugin.TValue[string] {
	return &c.PlatformName
}

func (c *mqlAwsSsmInstance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsSsmInstance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsSsmInstance) GetTags() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.Tags, func() (map[string]interface{}, error) {
		return c.tags()
	})
}

// mqlAwsEc2 for the aws.ec2 resource
type mqlAwsEc2 struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2Internal it will be used here
	SecurityGroups plugin.TValue[[]interface{}]
	Instances plugin.TValue[[]interface{}]
	EbsEncryptionByDefault plugin.TValue[map[string]interface{}]
	Volumes plugin.TValue[[]interface{}]
	Snapshots plugin.TValue[[]interface{}]
	InternetGateways plugin.TValue[[]interface{}]
	VpnConnections plugin.TValue[[]interface{}]
	NetworkAcls plugin.TValue[[]interface{}]
	Keypairs plugin.TValue[[]interface{}]
}

// createAwsEc2 creates a new instance of this resource
func createAwsEc2(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2) MqlName() string {
	return "aws.ec2"
}

func (c *mqlAwsEc2) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.SecurityGroups, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "securityGroups")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.securityGroups()
	})
}

func (c *mqlAwsEc2) GetInstances() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Instances, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "instances")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.instances()
	})
}

func (c *mqlAwsEc2) GetEbsEncryptionByDefault() *plugin.TValue[map[string]interface{}] {
	return plugin.GetOrCompute[map[string]interface{}](&c.EbsEncryptionByDefault, func() (map[string]interface{}, error) {
		return c.ebsEncryptionByDefault()
	})
}

func (c *mqlAwsEc2) GetVolumes() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Volumes, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "volumes")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.volumes()
	})
}

func (c *mqlAwsEc2) GetSnapshots() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Snapshots, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "snapshots")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.snapshots()
	})
}

func (c *mqlAwsEc2) GetInternetGateways() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.InternetGateways, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "internetGateways")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.internetGateways()
	})
}

func (c *mqlAwsEc2) GetVpnConnections() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.VpnConnections, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "vpnConnections")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.vpnConnections()
	})
}

func (c *mqlAwsEc2) GetNetworkAcls() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.NetworkAcls, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "networkAcls")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.networkAcls()
	})
}

func (c *mqlAwsEc2) GetKeypairs() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Keypairs, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2", c.__id, "keypairs")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.keypairs()
	})
}

// mqlAwsEc2Networkacl for the aws.ec2.networkacl resource
type mqlAwsEc2Networkacl struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	Entries plugin.TValue[[]interface{}]
}

// createAwsEc2Networkacl creates a new instance of this resource
func createAwsEc2Networkacl(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Networkacl{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Networkacl) MqlName() string {
	return "aws.ec2.networkacl"
}

func (c *mqlAwsEc2Networkacl) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Networkacl) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Networkacl) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Networkacl) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Networkacl) GetEntries() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Entries, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl", c.__id, "entries")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.entries()
	})
}

// mqlAwsEc2NetworkaclEntry for the aws.ec2.networkacl.entry resource
type mqlAwsEc2NetworkaclEntry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclEntryInternal it will be used here
	Egress plugin.TValue[bool]
	RuleAction plugin.TValue[string]
	PortRange plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange]
	Id plugin.TValue[string]
}

// createAwsEc2NetworkaclEntry creates a new instance of this resource
func createAwsEc2NetworkaclEntry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntry) MqlName() string {
	return "aws.ec2.networkacl.entry"
}

func (c *mqlAwsEc2NetworkaclEntry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntry) GetEgress() *plugin.TValue[bool] {
	return &c.Egress
}

func (c *mqlAwsEc2NetworkaclEntry) GetRuleAction() *plugin.TValue[string] {
	return &c.RuleAction
}

func (c *mqlAwsEc2NetworkaclEntry) GetPortRange() *plugin.TValue[*mqlAwsEc2NetworkaclEntryPortrange] {
	return plugin.GetOrCompute[*mqlAwsEc2NetworkaclEntryPortrange](&c.PortRange, func() (*mqlAwsEc2NetworkaclEntryPortrange, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.networkacl.entry", c.__id, "portRange")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2NetworkaclEntryPortrange), nil
			}
		}

		return c.portRange()
	})
}

func (c *mqlAwsEc2NetworkaclEntry) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2NetworkaclEntryPortrange for the aws.ec2.networkacl.entry.portrange resource
type mqlAwsEc2NetworkaclEntryPortrange struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2NetworkaclEntryPortrangeInternal it will be used here
	From plugin.TValue[int64]
	To plugin.TValue[int64]
	Id plugin.TValue[string]
}

// createAwsEc2NetworkaclEntryPortrange creates a new instance of this resource
func createAwsEc2NetworkaclEntryPortrange(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2NetworkaclEntryPortrange{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.networkacl.entry.portrange", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlName() string {
	return "aws.ec2.networkacl.entry.portrange"
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetFrom() *plugin.TValue[int64] {
	return &c.From
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetTo() *plugin.TValue[int64] {
	return &c.To
}

func (c *mqlAwsEc2NetworkaclEntryPortrange) GetId() *plugin.TValue[string] {
	return &c.Id
}

// mqlAwsEc2Vpnconnection for the aws.ec2.vpnconnection resource
type mqlAwsEc2Vpnconnection struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VpnconnectionInternal it will be used here
	Arn plugin.TValue[string]
	VgwTelemetry plugin.TValue[[]interface{}]
}

// createAwsEc2Vpnconnection creates a new instance of this resource
func createAwsEc2Vpnconnection(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vpnconnection{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vpnconnection", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vpnconnection) MqlName() string {
	return "aws.ec2.vpnconnection"
}

func (c *mqlAwsEc2Vpnconnection) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vpnconnection) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Vpnconnection) GetVgwTelemetry() *plugin.TValue[[]interface{}] {
	return &c.VgwTelemetry
}

// mqlAwsEc2Vgwtelemetry for the aws.ec2.vgwtelemetry resource
type mqlAwsEc2Vgwtelemetry struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VgwtelemetryInternal it will be used here
	OutsideIpAddress plugin.TValue[string]
	Status plugin.TValue[string]
	StatusMessage plugin.TValue[string]
}

// createAwsEc2Vgwtelemetry creates a new instance of this resource
func createAwsEc2Vgwtelemetry(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Vgwtelemetry{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.vgwtelemetry", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Vgwtelemetry) MqlName() string {
	return "aws.ec2.vgwtelemetry"
}

func (c *mqlAwsEc2Vgwtelemetry) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Vgwtelemetry) GetOutsideIpAddress() *plugin.TValue[string] {
	return &c.OutsideIpAddress
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2Vgwtelemetry) GetStatusMessage() *plugin.TValue[string] {
	return &c.StatusMessage
}

// mqlAwsEc2Internetgateway for the aws.ec2.internetgateway resource
type mqlAwsEc2Internetgateway struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2InternetgatewayInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attachments plugin.TValue[[]interface{}]
}

// createAwsEc2Internetgateway creates a new instance of this resource
func createAwsEc2Internetgateway(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Internetgateway{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.internetgateway", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Internetgateway) MqlName() string {
	return "aws.ec2.internetgateway"
}

func (c *mqlAwsEc2Internetgateway) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Internetgateway) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Internetgateway) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Internetgateway) GetAttachments() *plugin.TValue[[]interface{}] {
	return &c.Attachments
}

// mqlAwsEc2Snapshot for the aws.ec2.snapshot resource
type mqlAwsEc2Snapshot struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2SnapshotInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Region plugin.TValue[string]
	CreateVolumePermission plugin.TValue[[]interface{}]
	VolumeId plugin.TValue[string]
	StartTime plugin.TValue[*time.Time]
	Tags plugin.TValue[map[string]interface{}]
	State plugin.TValue[string]
}

// createAwsEc2Snapshot creates a new instance of this resource
func createAwsEc2Snapshot(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Snapshot{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.snapshot", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Snapshot) MqlName() string {
	return "aws.ec2.snapshot"
}

func (c *mqlAwsEc2Snapshot) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Snapshot) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Snapshot) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Snapshot) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Snapshot) GetCreateVolumePermission() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.CreateVolumePermission, func() ([]interface{}, error) {
		return c.createVolumePermission()
	})
}

func (c *mqlAwsEc2Snapshot) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2Snapshot) GetStartTime() *plugin.TValue[*time.Time] {
	return &c.StartTime
}

func (c *mqlAwsEc2Snapshot) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Snapshot) GetState() *plugin.TValue[string] {
	return &c.State
}

// mqlAwsEc2Volume for the aws.ec2.volume resource
type mqlAwsEc2Volume struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2VolumeInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Attachments plugin.TValue[[]interface{}]
	Encrypted plugin.TValue[bool]
	State plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	AvailabilityZone plugin.TValue[string]
	VolumeType plugin.TValue[string]
	CreateTime plugin.TValue[*time.Time]
	Region plugin.TValue[string]
}

// createAwsEc2Volume creates a new instance of this resource
func createAwsEc2Volume(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Volume{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.volume", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Volume) MqlName() string {
	return "aws.ec2.volume"
}

func (c *mqlAwsEc2Volume) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Volume) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Volume) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Volume) GetAttachments() *plugin.TValue[[]interface{}] {
	return &c.Attachments
}

func (c *mqlAwsEc2Volume) GetEncrypted() *plugin.TValue[bool] {
	return &c.Encrypted
}

func (c *mqlAwsEc2Volume) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Volume) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Volume) GetAvailabilityZone() *plugin.TValue[string] {
	return &c.AvailabilityZone
}

func (c *mqlAwsEc2Volume) GetVolumeType() *plugin.TValue[string] {
	return &c.VolumeType
}

func (c *mqlAwsEc2Volume) GetCreateTime() *plugin.TValue[*time.Time] {
	return &c.CreateTime
}

func (c *mqlAwsEc2Volume) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEc2Instance for the aws.ec2.instance resource
type mqlAwsEc2Instance struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2InstanceInternal it will be used here
	Arn plugin.TValue[string]
	InstanceId plugin.TValue[string]
	DetailedMonitoring plugin.TValue[string]
	Region plugin.TValue[string]
	PublicIp plugin.TValue[string]
	Ssm plugin.TValue[interface{}]
	Vpc plugin.TValue[*mqlAwsVpc]
	HttpTokens plugin.TValue[string]
	HttpEndpoint plugin.TValue[string]
	PatchState plugin.TValue[interface{}]
	State plugin.TValue[string]
	DeviceMappings plugin.TValue[[]interface{}]
	SecurityGroups plugin.TValue[[]interface{}]
	PlatformDetails plugin.TValue[string]
	PublicDnsName plugin.TValue[string]
	InstanceStatus plugin.TValue[interface{}]
	StateReason plugin.TValue[interface{}]
	StateTransitionReason plugin.TValue[string]
	EbsOptimized plugin.TValue[bool]
	InstanceType plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Image plugin.TValue[*mqlAwsEc2Image]
	LaunchTime plugin.TValue[*time.Time]
	PrivateIp plugin.TValue[string]
	PrivateDnsName plugin.TValue[string]
	Keypair plugin.TValue[*mqlAwsEc2Keypair]
	StateTransitionTime plugin.TValue[*time.Time]
	VpcArn plugin.TValue[string]
}

// createAwsEc2Instance creates a new instance of this resource
func createAwsEc2Instance(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Instance{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Instance) MqlName() string {
	return "aws.ec2.instance"
}

func (c *mqlAwsEc2Instance) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Instance) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Instance) GetInstanceId() *plugin.TValue[string] {
	return &c.InstanceId
}

func (c *mqlAwsEc2Instance) GetDetailedMonitoring() *plugin.TValue[string] {
	return &c.DetailedMonitoring
}

func (c *mqlAwsEc2Instance) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Instance) GetPublicIp() *plugin.TValue[string] {
	return &c.PublicIp
}

func (c *mqlAwsEc2Instance) GetSsm() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.Ssm, func() (interface{}, error) {
		return c.ssm()
	})
}

func (c *mqlAwsEc2Instance) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return plugin.GetOrCompute[*mqlAwsVpc](&c.Vpc, func() (*mqlAwsVpc, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "vpc")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsVpc), nil
			}
		}

		return c.vpc()
	})
}

func (c *mqlAwsEc2Instance) GetHttpTokens() *plugin.TValue[string] {
	return &c.HttpTokens
}

func (c *mqlAwsEc2Instance) GetHttpEndpoint() *plugin.TValue[string] {
	return &c.HttpEndpoint
}

func (c *mqlAwsEc2Instance) GetPatchState() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.PatchState, func() (interface{}, error) {
		return c.patchState()
	})
}

func (c *mqlAwsEc2Instance) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsEc2Instance) GetDeviceMappings() *plugin.TValue[[]interface{}] {
	return &c.DeviceMappings
}

func (c *mqlAwsEc2Instance) GetSecurityGroups() *plugin.TValue[[]interface{}] {
	return &c.SecurityGroups
}

func (c *mqlAwsEc2Instance) GetPlatformDetails() *plugin.TValue[string] {
	return &c.PlatformDetails
}

func (c *mqlAwsEc2Instance) GetPublicDnsName() *plugin.TValue[string] {
	return &c.PublicDnsName
}

func (c *mqlAwsEc2Instance) GetInstanceStatus() *plugin.TValue[interface{}] {
	return plugin.GetOrCompute[interface{}](&c.InstanceStatus, func() (interface{}, error) {
		return c.instanceStatus()
	})
}

func (c *mqlAwsEc2Instance) GetStateReason() *plugin.TValue[interface{}] {
	return &c.StateReason
}

func (c *mqlAwsEc2Instance) GetStateTransitionReason() *plugin.TValue[string] {
	return &c.StateTransitionReason
}

func (c *mqlAwsEc2Instance) GetEbsOptimized() *plugin.TValue[bool] {
	return &c.EbsOptimized
}

func (c *mqlAwsEc2Instance) GetInstanceType() *plugin.TValue[string] {
	return &c.InstanceType
}

func (c *mqlAwsEc2Instance) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Instance) GetImage() *plugin.TValue[*mqlAwsEc2Image] {
	return &c.Image
}

func (c *mqlAwsEc2Instance) GetLaunchTime() *plugin.TValue[*time.Time] {
	return &c.LaunchTime
}

func (c *mqlAwsEc2Instance) GetPrivateIp() *plugin.TValue[string] {
	return &c.PrivateIp
}

func (c *mqlAwsEc2Instance) GetPrivateDnsName() *plugin.TValue[string] {
	return &c.PrivateDnsName
}

func (c *mqlAwsEc2Instance) GetKeypair() *plugin.TValue[*mqlAwsEc2Keypair] {
	return plugin.GetOrCompute[*mqlAwsEc2Keypair](&c.Keypair, func() (*mqlAwsEc2Keypair, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.ec2.instance", c.__id, "keypair")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.(*mqlAwsEc2Keypair), nil
			}
		}

		return c.keypair()
	})
}

func (c *mqlAwsEc2Instance) GetStateTransitionTime() *plugin.TValue[*time.Time] {
	return &c.StateTransitionTime
}

func (c *mqlAwsEc2Instance) GetVpcArn() *plugin.TValue[string] {
	return &c.VpcArn
}

// mqlAwsEc2Keypair for the aws.ec2.keypair resource
type mqlAwsEc2Keypair struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2KeypairInternal it will be used here
	Arn plugin.TValue[string]
	Fingerprint plugin.TValue[string]
	Name plugin.TValue[string]
	Type plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Region plugin.TValue[string]
}

// createAwsEc2Keypair creates a new instance of this resource
func createAwsEc2Keypair(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Keypair{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.keypair", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Keypair) MqlName() string {
	return "aws.ec2.keypair"
}

func (c *mqlAwsEc2Keypair) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Keypair) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Keypair) GetFingerprint() *plugin.TValue[string] {
	return &c.Fingerprint
}

func (c *mqlAwsEc2Keypair) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Keypair) GetType() *plugin.TValue[string] {
	return &c.Type
}

func (c *mqlAwsEc2Keypair) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Keypair) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEc2Image for the aws.ec2.image resource
type mqlAwsEc2Image struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2ImageInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Architecture plugin.TValue[string]
	OwnerId plugin.TValue[string]
	OwnerAlias plugin.TValue[string]
}

// createAwsEc2Image creates a new instance of this resource
func createAwsEc2Image(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Image{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.image", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Image) MqlName() string {
	return "aws.ec2.image"
}

func (c *mqlAwsEc2Image) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Image) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Image) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Image) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Image) GetArchitecture() *plugin.TValue[string] {
	return &c.Architecture
}

func (c *mqlAwsEc2Image) GetOwnerId() *plugin.TValue[string] {
	return &c.OwnerId
}

func (c *mqlAwsEc2Image) GetOwnerAlias() *plugin.TValue[string] {
	return &c.OwnerAlias
}

// mqlAwsEc2InstanceDevice for the aws.ec2.instance.device resource
type mqlAwsEc2InstanceDevice struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2InstanceDeviceInternal it will be used here
	DeleteOnTermination plugin.TValue[bool]
	Status plugin.TValue[string]
	VolumeId plugin.TValue[string]
	DeviceName plugin.TValue[string]
}

// createAwsEc2InstanceDevice creates a new instance of this resource
func createAwsEc2InstanceDevice(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2InstanceDevice{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.instance.device", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2InstanceDevice) MqlName() string {
	return "aws.ec2.instance.device"
}

func (c *mqlAwsEc2InstanceDevice) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2InstanceDevice) GetDeleteOnTermination() *plugin.TValue[bool] {
	return &c.DeleteOnTermination
}

func (c *mqlAwsEc2InstanceDevice) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEc2InstanceDevice) GetVolumeId() *plugin.TValue[string] {
	return &c.VolumeId
}

func (c *mqlAwsEc2InstanceDevice) GetDeviceName() *plugin.TValue[string] {
	return &c.DeviceName
}

// mqlAwsEc2Securitygroup for the aws.ec2.securitygroup resource
type mqlAwsEc2Securitygroup struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2SecuritygroupInternal it will be used here
	Arn plugin.TValue[string]
	Id plugin.TValue[string]
	Name plugin.TValue[string]
	Description plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Vpc plugin.TValue[*mqlAwsVpc]
	IpPermissions plugin.TValue[[]interface{}]
	IpPermissionsEgress plugin.TValue[[]interface{}]
	Region plugin.TValue[string]
	IsAttachedToNetworkInterface plugin.TValue[bool]
}

// createAwsEc2Securitygroup creates a new instance of this resource
func createAwsEc2Securitygroup(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2Securitygroup{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2Securitygroup) MqlName() string {
	return "aws.ec2.securitygroup"
}

func (c *mqlAwsEc2Securitygroup) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2Securitygroup) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEc2Securitygroup) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2Securitygroup) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEc2Securitygroup) GetDescription() *plugin.TValue[string] {
	return &c.Description
}

func (c *mqlAwsEc2Securitygroup) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEc2Securitygroup) GetVpc() *plugin.TValue[*mqlAwsVpc] {
	return &c.Vpc
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissions() *plugin.TValue[[]interface{}] {
	return &c.IpPermissions
}

func (c *mqlAwsEc2Securitygroup) GetIpPermissionsEgress() *plugin.TValue[[]interface{}] {
	return &c.IpPermissionsEgress
}

func (c *mqlAwsEc2Securitygroup) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEc2Securitygroup) GetIsAttachedToNetworkInterface() *plugin.TValue[bool] {
	return plugin.GetOrCompute[bool](&c.IsAttachedToNetworkInterface, func() (bool, error) {
		return c.isAttachedToNetworkInterface()
	})
}

// mqlAwsEc2SecuritygroupIppermission for the aws.ec2.securitygroup.ippermission resource
type mqlAwsEc2SecuritygroupIppermission struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEc2SecuritygroupIppermissionInternal it will be used here
	Id plugin.TValue[string]
	FromPort plugin.TValue[int64]
	ToPort plugin.TValue[int64]
	IpProtocol plugin.TValue[string]
	IpRanges plugin.TValue[[]interface{}]
	Ipv6Ranges plugin.TValue[[]interface{}]
}

// createAwsEc2SecuritygroupIppermission creates a new instance of this resource
func createAwsEc2SecuritygroupIppermission(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEc2SecuritygroupIppermission{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.ec2.securitygroup.ippermission", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlName() string {
	return "aws.ec2.securitygroup.ippermission"
}

func (c *mqlAwsEc2SecuritygroupIppermission) MqlID() string {
	return c.__id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetId() *plugin.TValue[string] {
	return &c.Id
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetFromPort() *plugin.TValue[int64] {
	return &c.FromPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetToPort() *plugin.TValue[int64] {
	return &c.ToPort
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpProtocol() *plugin.TValue[string] {
	return &c.IpProtocol
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpRanges() *plugin.TValue[[]interface{}] {
	return &c.IpRanges
}

func (c *mqlAwsEc2SecuritygroupIppermission) GetIpv6Ranges() *plugin.TValue[[]interface{}] {
	return &c.Ipv6Ranges
}

// mqlAwsConfig for the aws.config resource
type mqlAwsConfig struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigInternal it will be used here
	Recorders plugin.TValue[[]interface{}]
	Rules plugin.TValue[[]interface{}]
}

// createAwsConfig creates a new instance of this resource
func createAwsConfig(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfig{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfig) MqlName() string {
	return "aws.config"
}

func (c *mqlAwsConfig) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfig) GetRecorders() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Recorders, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "recorders")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.recorders()
	})
}

func (c *mqlAwsConfig) GetRules() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Rules, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.config", c.__id, "rules")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.rules()
	})
}

// mqlAwsConfigRule for the aws.config.rule resource
type mqlAwsConfigRule struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigRuleInternal it will be used here
	Arn plugin.TValue[string]
	State plugin.TValue[string]
	Source plugin.TValue[interface{}]
}

// createAwsConfigRule creates a new instance of this resource
func createAwsConfigRule(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRule{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.rule", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRule) MqlName() string {
	return "aws.config.rule"
}

func (c *mqlAwsConfigRule) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRule) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsConfigRule) GetState() *plugin.TValue[string] {
	return &c.State
}

func (c *mqlAwsConfigRule) GetSource() *plugin.TValue[interface{}] {
	return &c.Source
}

// mqlAwsConfigRecorder for the aws.config.recorder resource
type mqlAwsConfigRecorder struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsConfigRecorderInternal it will be used here
	Name plugin.TValue[string]
	RoleArn plugin.TValue[string]
	AllSupported plugin.TValue[bool]
	IncludeGlobalResourceTypes plugin.TValue[bool]
	Recording plugin.TValue[bool]
	LastStatus plugin.TValue[string]
	Region plugin.TValue[string]
}

// createAwsConfigRecorder creates a new instance of this resource
func createAwsConfigRecorder(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsConfigRecorder{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.config.recorder", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsConfigRecorder) MqlName() string {
	return "aws.config.recorder"
}

func (c *mqlAwsConfigRecorder) MqlID() string {
	return c.__id
}

func (c *mqlAwsConfigRecorder) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsConfigRecorder) GetRoleArn() *plugin.TValue[string] {
	return &c.RoleArn
}

func (c *mqlAwsConfigRecorder) GetAllSupported() *plugin.TValue[bool] {
	return &c.AllSupported
}

func (c *mqlAwsConfigRecorder) GetIncludeGlobalResourceTypes() *plugin.TValue[bool] {
	return &c.IncludeGlobalResourceTypes
}

func (c *mqlAwsConfigRecorder) GetRecording() *plugin.TValue[bool] {
	return &c.Recording
}

func (c *mqlAwsConfigRecorder) GetLastStatus() *plugin.TValue[string] {
	return &c.LastStatus
}

func (c *mqlAwsConfigRecorder) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

// mqlAwsEks for the aws.eks resource
type mqlAwsEks struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEksInternal it will be used here
	Clusters plugin.TValue[[]interface{}]
}

// createAwsEks creates a new instance of this resource
func createAwsEks(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEks{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEks) MqlName() string {
	return "aws.eks"
}

func (c *mqlAwsEks) MqlID() string {
	return c.__id
}

func (c *mqlAwsEks) GetClusters() *plugin.TValue[[]interface{}] {
	return plugin.GetOrCompute[[]interface{}](&c.Clusters, func() ([]interface{}, error) {
		if c.MqlRuntime.HasRecording {
			d, err := c.MqlRuntime.FieldResourceFromRecording("aws.eks", c.__id, "clusters")
			if err != nil {
				return nil, err
			}
			if d != nil {
				return d.Value.([]interface{}), nil
			}
		}

		return c.clusters()
	})
}

// mqlAwsEksCluster for the aws.eks.cluster resource
type mqlAwsEksCluster struct {
	MqlRuntime *plugin.Runtime
	__id string
	// optional: if you define mqlAwsEksClusterInternal it will be used here
	Name plugin.TValue[string]
	Arn plugin.TValue[string]
	Region plugin.TValue[string]
	Tags plugin.TValue[map[string]interface{}]
	Endpoint plugin.TValue[string]
	Version plugin.TValue[string]
	PlatformVersion plugin.TValue[string]
	Status plugin.TValue[string]
	EncryptionConfig plugin.TValue[[]interface{}]
	Logging plugin.TValue[interface{}]
	NetworkConfig plugin.TValue[interface{}]
	ResourcesVpcConfig plugin.TValue[interface{}]
	CreatedAt plugin.TValue[*time.Time]
}

// createAwsEksCluster creates a new instance of this resource
func createAwsEksCluster(runtime *plugin.Runtime, args map[string]*llx.RawData) (plugin.Resource, error) {
	res := &mqlAwsEksCluster{
		MqlRuntime: runtime,
	}

	err := SetAllData(res, args)
	if err != nil {
		return res, err
	}

	if res.__id == "" {
	res.__id, err = res.id()
		if err != nil {
			return nil, err
		}
	}

	if runtime.HasRecording {
		args, err = runtime.ResourceFromRecording("aws.eks.cluster", res.__id)
		if err != nil || args == nil {
			return res, err
		}
		return res, SetAllData(res, args)
	}

	return res, nil
}

func (c *mqlAwsEksCluster) MqlName() string {
	return "aws.eks.cluster"
}

func (c *mqlAwsEksCluster) MqlID() string {
	return c.__id
}

func (c *mqlAwsEksCluster) GetName() *plugin.TValue[string] {
	return &c.Name
}

func (c *mqlAwsEksCluster) GetArn() *plugin.TValue[string] {
	return &c.Arn
}

func (c *mqlAwsEksCluster) GetRegion() *plugin.TValue[string] {
	return &c.Region
}

func (c *mqlAwsEksCluster) GetTags() *plugin.TValue[map[string]interface{}] {
	return &c.Tags
}

func (c *mqlAwsEksCluster) GetEndpoint() *plugin.TValue[string] {
	return &c.Endpoint
}

func (c *mqlAwsEksCluster) GetVersion() *plugin.TValue[string] {
	return &c.Version
}

func (c *mqlAwsEksCluster) GetPlatformVersion() *plugin.TValue[string] {
	return &c.PlatformVersion
}

func (c *mqlAwsEksCluster) GetStatus() *plugin.TValue[string] {
	return &c.Status
}

func (c *mqlAwsEksCluster) GetEncryptionConfig() *plugin.TValue[[]interface{}] {
	return &c.EncryptionConfig
}

func (c *mqlAwsEksCluster) GetLogging() *plugin.TValue[interface{}] {
	return &c.Logging
}

func (c *mqlAwsEksCluster) GetNetworkConfig() *plugin.TValue[interface{}] {
	return &c.NetworkConfig
}

func (c *mqlAwsEksCluster) GetResourcesVpcConfig() *plugin.TValue[interface{}] {
	return &c.ResourcesVpcConfig
}

func (c *mqlAwsEksCluster) GetCreatedAt() *plugin.TValue[*time.Time] {
	return &c.CreatedAt
}
